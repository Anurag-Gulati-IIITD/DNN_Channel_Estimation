# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.h" 1
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 1
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3
# 88 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
             
# 97 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
             
# 13 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3

# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 14 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 275 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
# 565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_directx.h" 1 3
# 566 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 2 3




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3
}



#pragma pack(pop)
# 276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 534 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
extern "C" {




void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);


}
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 2 3




#pragma pack(push,_CRT_PACKING)
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef unsigned long long size_t;
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long ssize_t;






typedef size_t rsize_t;
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long intptr_t;
# 75 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef unsigned long long uintptr_t;
# 88 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long ptrdiff_t;
# 106 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;
# 138 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
typedef __time64_t time_t;
# 422 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)


extern "C" {
# 26 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
# 26 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 3
typedef off32_t off_t;
# 81 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 103 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ typedef long long fpos_t;
# 139 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);
extern
  __attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_printf(const char * __restrict__ , ... ) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vprintf (const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
# 386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__((__format__ (ms_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) fprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
  __attribute__((__format__ (ms_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) printf(const char * __restrict__ _Format,...);
  __attribute__((__format__ (ms_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) sprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,...) ;

  __attribute__((__format__ (ms_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) vfprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,va_list _ArgList);
  __attribute__((__format__ (ms_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) vprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__((__format__ (ms_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) vsprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,va_list _Args) ;

  __attribute__((__format__ (ms_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) scanf(const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...) ;






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


  __attribute__((__format__ (ms_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __ms_vscanf(const char * __restrict__ Format, va_list argp);
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);

  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int vfscanf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
  {
    return __ms_vfscanf (__stream, __format, __local_argv);
  }

  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int vsscanf (const char * __restrict__ __source, const char * __restrict__ __format, __builtin_va_list __local_argv)
  {
    return __ms_vsscanf( __source, __format, __local_argv );
  }
  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int vscanf(const char *__format, __builtin_va_list __local_argv)
  {
    return __ms_vscanf (__format, __local_argv);
  }


#pragma GCC diagnostic pop





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _filbuf(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flsbuf(int _Ch,FILE *_File);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __attribute__((__cdecl__)) clearerr(FILE *_File);
  int __attribute__((__cdecl__)) fclose(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fcloseall(void);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fdopen(int _FileHandle,const char *_Mode);

  int __attribute__((__cdecl__)) feof(FILE *_File);
  int __attribute__((__cdecl__)) ferror(FILE *_File);
  int __attribute__((__cdecl__)) fflush(FILE *_File);
  int __attribute__((__cdecl__)) fgetc(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fgetchar(void);
  int __attribute__((__cdecl__)) fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  int __attribute__((__cdecl__)) fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  char *__attribute__((__cdecl__)) fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fileno(FILE *_File);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _tempnam(const char *_DirName,const char *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flushall(void);
  FILE *__attribute__((__cdecl__)) fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) ;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__ mode);
  int __attribute__((__cdecl__)) fputc(int _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fputchar(int _Ch);
  int __attribute__((__cdecl__)) fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __attribute__((__cdecl__)) fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__attribute__((__cdecl__)) freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) ;
  int __attribute__((__cdecl__)) fsetpos(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fsetpos64(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fseek(FILE *_File,long _Offset,int _Origin);



  int fseeko64(FILE* stream, _off64_t offset, int whence);
  int fseeko(FILE* stream, _off_t offset, int whence);
# 502 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  long __attribute__((__cdecl__)) ftell(FILE *_File);

  _off_t ftello(FILE * stream);
  _off64_t ftello64(FILE * stream);
# 514 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ int __attribute__((__cdecl__)) _fseeki64(FILE *_File,long long _Offset,int _Origin);
  __extension__ long long __attribute__((__cdecl__)) _ftelli64(FILE *_File);
  size_t __attribute__((__cdecl__)) fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) getc(FILE *_File);
  int __attribute__((__cdecl__)) getchar(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getmaxstdio(void);
  char *__attribute__((__cdecl__)) gets(char *_Buffer) ;
  int __attribute__((__cdecl__)) _getw(FILE *_File);


  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pclose(FILE *_File);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _popen(const char *_Command,const char *_Mode);




  int __attribute__((__cdecl__)) putc(int _Ch,FILE *_File);
  int __attribute__((__cdecl__)) putchar(int _Ch);
  int __attribute__((__cdecl__)) puts(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putw(int _Word,FILE *_File);


  int __attribute__((__cdecl__)) remove(const char *_Filename);
  int __attribute__((__cdecl__)) rename(const char *_OldFilename,const char *_NewFilename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _unlink(const char *_Filename);

  int __attribute__((__cdecl__)) unlink(const char *_Filename) ;


  void __attribute__((__cdecl__)) rewind(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _rmtmp(void);
  void __attribute__((__cdecl__)) setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmaxstdio(int _Max);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_output_format(unsigned int _Format);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _get_output_format(void);
  int __attribute__((__cdecl__)) setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf(const char * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) ;
  FILE *__attribute__((__cdecl__)) tmpfile(void) ;
  char *__attribute__((__cdecl__)) tmpnam(char *_Buffer);
  int __attribute__((__cdecl__)) ungetc(int _Ch,FILE *_File);

  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) ;






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


       
       


  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __ms_vsnprintf(char * __restrict__ d,size_t n,const char * __restrict__ format,va_list arg)
    ;

  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int vsnprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, va_list __local_argv)
  {
    return __ms_vsnprintf (__stream, __n, __format, __local_argv);
  }

  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __ms_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);


inline __attribute__((__cdecl__))
__attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
int snprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __ms_vsnprintf (__stream, __n, __format, __local_argv);
  __builtin_va_end( __local_argv );
  return __retval;
}


       
       

#pragma GCC diagnostic pop



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_printf_count_output(int _Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _get_printf_count_output(void);




                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);

                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);
# 768 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  int __attribute__((__cdecl__)) fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) wscanf(const wchar_t * __restrict__ _Format,...) ;

  int __attribute__((__cdecl__)) __ms_vwscanf (const wchar_t * __restrict__ , va_list);
  int __attribute__((__cdecl__)) __ms_vfwscanf (FILE * __restrict__ ,const wchar_t * __restrict__ ,va_list);
  int __attribute__((__cdecl__)) __ms_vswscanf (const wchar_t * __restrict__ ,const wchar_t * __restrict__ ,va_list);

  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vfwscanf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
  {
    return __ms_vfwscanf (__stream, __format, __local_argv);
  }

  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vswscanf (const wchar_t * __restrict__ __source, const wchar_t * __restrict__ __format, __builtin_va_list __local_argv)
  {
    return __ms_vswscanf( __source, __format, __local_argv );
  }
  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (1)))
  int vwscanf(const wchar_t *__format, __builtin_va_list __local_argv)
  {
    return __ms_vwscanf (__format, __local_argv);
  }



  int __attribute__((__cdecl__)) fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) wprintf(const wchar_t * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
# 811 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) ;




       
       


  int __attribute__((__cdecl__)) __ms_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
  int __attribute__((__cdecl__)) __ms_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
  inline __attribute__((__cdecl__))
  int snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...)
  {
    int r;
    va_list argp;
    __builtin_va_start (argp, format);
    r = _vsnwprintf (s, n, format, argp);
    __builtin_va_end (argp);
    return r;
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) vsnwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, va_list arg)
  {
    return _vsnwprintf(s,n,format,arg);
  }
       
       



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 1 3
# 21 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



extern "C++" {

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vswprintf (wchar_t *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{



  return _vswprintf( __stream, __format, __local_argv );

}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int swprintf (wchar_t *__stream, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

}
# 868 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
# 877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t *__restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
# 927 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _lock_file(FILE *_File);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _unlock_file(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fclose_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fflush_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftell_nolock(FILE *_File);
  __extension__ __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseeki64_nolock(FILE *_File,long long _Offset,int _Origin);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _ftelli64_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ungetc_nolock(int _Ch,FILE *_File);





  char *__attribute__((__cdecl__)) tempnam(const char *_Directory,const char *_FilePrefix) ;
  int __attribute__((__cdecl__)) fcloseall(void) ;
  FILE *__attribute__((__cdecl__)) fdopen(int _FileHandle,const char *_Format) ;
  int __attribute__((__cdecl__)) fgetchar(void) ;
  int __attribute__((__cdecl__)) fileno(FILE *_File) ;
  int __attribute__((__cdecl__)) flushall(void) ;
  int __attribute__((__cdecl__)) fputchar(int _Ch) ;
  int __attribute__((__cdecl__)) getw(FILE *_File) ;
  int __attribute__((__cdecl__)) putw(int _Ch,FILE *_File) ;
  int __attribute__((__cdecl__)) rmtmp(void) ;
# 969 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
# 983 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
# 992 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);





  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
# 1022 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);



}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 2 3
# 23 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) clearerr_s(FILE *_File);
  int __attribute__((__cdecl__)) fprintf_s(FILE *_File,const char *_Format,...);
  size_t __attribute__((__cdecl__)) fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) printf_s(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_s_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) sscanf_s(const char *_Src,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s(const char *_Src,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) vfprintf_s(FILE *_File,const char *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vprintf_s(const char *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__((dllimport)) int __attribute__((__cdecl__)) vsprintf_s(char *_DstBuf,size_t _Size,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsprintf_s(char (&_DstBuf)[__size], const char* _Format, va_list _ArgList) { return vsprintf_s(_DstBuf,__size,_Format,_ArgList); } }

  __attribute__((dllimport)) int __attribute__((__cdecl__)) sprintf_s(char *_DstBuf,size_t _DstSize,const char *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) sprintf_s(char (&_DstBuf)[__size], const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vsprintf_s(_DstBuf,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p(FILE *_File,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p(FILE *_File,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p(const char *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_l(char *_DstBuf,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_l(char *_DstBuf,const char *_Format,_locale_t,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_s_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) fopen_s(FILE **_File,const char *_Filename,const char *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) freopen_s(FILE** _File, const char *_Filename, const char *_Mode, FILE *_Stream);

  __attribute__ ((__dllimport__)) char* __attribute__((__cdecl__)) gets_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline char* __attribute__((__cdecl__)) get_s(char (&_DstBuf)[__size]) { return get_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) tmpnam_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) tmpnam_s(char (&_DstBuf)[__size]) { return tmpnam_s(_DstBuf,__size); } }




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline wchar_t* __attribute__((__cdecl__)) _getws_s(wchar_t (&_DstBuf)[__size]) { return _getws_s(_DstBuf,__size); } }

  int __attribute__((__cdecl__)) fwprintf_s(FILE *_File,const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) wprintf_s(const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) vfwprintf_s(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf_s(const wchar_t *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vswprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vswprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, va_list _ArgList) { return vswprintf_s(_Dst,__size,_Format,_ArgList); } }

  int __attribute__((__cdecl__)) swprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) swprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vswprintf_s(_Dst,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, va_list _ArgList) { return _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_s_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_s_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) swscanf_s(const wchar_t *_Src,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t (&_DstBuf)[__size]) { return _wtmpnam_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE *_File,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,va_list _Args);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format,_locale_t _Locale,...);



  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);


}
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
# 2 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 1
# 79 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 1 3
# 196 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  typedef long long unsigned int size_t;
  typedef long long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 495 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/os_defines.h" 1 3
# 496 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cpu_defines.h" 1 3
# 499 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 1 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_defines.h" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 2 3

namespace std
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
       
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx
{

# 54 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 2 3

namespace std
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std
{

# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 182 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 314 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 926 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1753 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1774 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<short unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };



  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1893 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };





  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;


  template<template<typename...> class _Default,
    template<typename...> class _Op, typename... _Args>
    using __detected_or_t_ =
      __detected_or_t<_Default<_Args...>, _Op, _Args...>;
# 2590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename _Tp>
    inline
    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };


}
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 2 3

namespace std
{

# 74 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 159 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
namespace std
{

# 174 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 2 3





namespace std
{

# 76 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, const _U1&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, const _U2&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<const _U1&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<const _U2&, _T2>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _MoveConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, _U1&&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, _U2&&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyMoveConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<_U1&&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<_U2&&, _T2>>>::value;
  }
# 146 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }







      template<typename _U1 = _T1, typename _U2=_T2, typename
                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 210 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
      template<typename _U1, typename _U2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
         _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _U1, _T2>()),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                           _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _T1, _U2>()),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
           _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__is_nothrow_swappable<_T1>::value
               && __is_nothrow_swappable<_T2>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 422 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 441 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3

}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3







namespace std
{

# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 230 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/debug/assertions.h" 1 3
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 1 3
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ptr_traits.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ptr_traits.h" 3
namespace std
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = typename _Tp::template rebind<_Up>;

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t_<__get_first_arg_t, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind
   = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
      static_assert(!is_same<rebind<element_type>, __undefined>::value,
   "pointer type defines rebind<U> or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 2 3

namespace std
{

# 96 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 160 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 290 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }




  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 441 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 476 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 609 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 679 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx
{

# 747 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 847 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std
{

# 999 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/debug/debug.h" 1 3
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/predefined_ops.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}
# 72 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

namespace std
{

# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1039 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 1 3
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3

#pragma GCC visibility push(default)


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 2 3

extern "C++" {

namespace std
{
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 129 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 160 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 113 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 140 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }



    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Tp,
    bool __with_nested = !__is_base_of(nested_exception, _Tp)>
    struct _Throw_with_nested_impl
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }
    };

  template<typename _Tp>
    struct _Throw_with_nested_impl<_Tp, false>
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw static_cast<_Up&&>(__t); }
    };

  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>
    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp, false>
    : _Throw_with_nested_impl<_Tp, false>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&, false>
    : _Throw_with_nested_helper<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&&, false>
    : _Throw_with_nested_helper<_Tp>
    { };



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));
    }

  template<typename _Tp, bool = __is_polymorphic(_Tp)>
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow(const _Tp& __t)
      {
 if (auto __tp =
            dynamic_cast<const nested_exception*>(std::__addressof(__t)))
   __tp->rethrow_nested();
      }
    };

  template<typename _Tp>
    struct _Rethrow_if_nested_impl<_Tp, false>
    {
      static void _S_rethrow(const _Tp&) { }
    };


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
    }


}

}



#pragma GCC visibility pop
# 172 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 2 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));



inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 2 3






namespace __gnu_cxx
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 2 3


namespace std
{
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 1 3
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3
       
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3



namespace std
{

# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 2 3






namespace std
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      typedef true_type is_always_equal;

    };
# 96 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 1 3
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
namespace std
{


  struct __allocator_traits_base
  {
    template<typename _Alloc, typename _Up>
      using __rebind = typename _Alloc::template rebind<_Up>::other;

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __diff_type = typename _Tp::difference_type;
    template<typename _Tp>
      using __size_type = typename _Tp::size_type;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,
         __allocator_traits_base::__rebind,
         _Alloc, _Up>;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;







      using const_pointer
 = __detected_or_t<__ptr_rebind<pointer, const value_type>,
     __c_pointer, _Alloc>;







      using void_pointer
 = __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;







      using const_void_pointer
 = __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,
     _Alloc>;







      using difference_type
 = __detected_or_t<typename pointer_traits<pointer>::difference_type,
     __diff_type, _Alloc>;







      using size_type
 = __detected_or_t<typename make_unsigned<difference_type>::type,
     __size_type, _Alloc>;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,
   "allocator defines rebind or is like Alloc<T, Args>");

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 279 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 294 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 306 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 346 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 414 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 428 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 440 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3
  };


}
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 2 3

namespace std
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 90 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
namespace std
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 677 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/initializer_list" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/initializer_list" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 2 3


namespace std
{

# 88 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  constexpr inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 105 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {






    private:
      template<typename _Up>
 using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
      template<typename _CvTp>
 using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
    public:
      typedef __iter<_Tp> iterator;
      typedef __iter<const _Tp> const_iterator;
      typedef __ptr_to<_Tp> _Elt_pointer;
      typedef __ptr_to<_Elt_pointer> _Map_pointer;


      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Deque_iterator _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() noexcept
      : _M_cur(), _M_first(), _M_last(), _M_node() { }

      _Deque_iterator(const iterator& __x) noexcept
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const noexcept
      { return *_M_cur; }

      pointer
      operator->() const noexcept
      { return _M_cur; }

      _Self&
      operator++() noexcept
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n) noexcept
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n) noexcept
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const noexcept
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node) noexcept
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    noexcept
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
# 457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;





      typedef typename _Alloc_traits::pointer _Ptr;
      typedef typename _Alloc_traits::const_pointer _Ptr_const;


      typedef typename _Alloc_traits::template rebind<_Ptr>::other
 _Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

    public:
      typedef _Alloc allocator_type;
      typedef typename _Alloc_traits::size_type size_type;

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x, false_type)
      : _M_impl(__x._M_move_impl())
      { }

      _Deque_base(_Deque_base&& __x, true_type)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x)
      : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})
      { }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   {
     if (__x._M_impl._M_map)
       {
  _M_initialize_map(0);
  this->_M_impl._M_swap_data(__x._M_impl);
       }
   }
 else
   {
     _M_initialize_map(__n);
   }
      }


      ~_Deque_base() noexcept;

    protected:
      typedef typename iterator::_Map_pointer _Map_pointer;




      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Map_pointer _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a) noexcept
 : _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 _Deque_impl(_Deque_impl&&) = default;

 _Deque_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 void _M_swap_data(_Deque_impl& __x) noexcept
 {
   using std::swap;
   swap(this->_M_start, __x._M_start);
   swap(this->_M_finish, __x._M_finish);
   swap(this->_M_map, __x._M_map);
   swap(this->_M_map_size, __x._M_map_size);
 }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const noexcept
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) noexcept
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;


    private:
      _Deque_impl
      _M_move_impl()
      {
 if (!_M_impl._M_map)
   return std::move(_M_impl);


 _Tp_alloc_type __alloc{_M_get_Tp_allocator()};

 _Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};

 _Deque_base __empty{__alloc};
 __empty._M_initialize_map(0);

 _Deque_impl __ret{std::move(_M_get_Tp_allocator())};
 _M_impl._M_swap_data(__ret);
 _M_impl._M_swap_data(__empty._M_impl);
 return __ret;
      }

    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() noexcept
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 677 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Map_pointer __nstart = (this->_M_impl._M_map
          + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = _Map_pointer();
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 828 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



     

      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Alloc_traits _Alloc_traits;
      typedef typename _Base::_Map_pointer _Map_pointer;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:






      deque() : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 903 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_default_initialize(); }
# 916 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 943 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
       __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(deque&& __x)
      : _Base(std::move(__x)) { }


      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }


      deque(deque&& __x, const allocator_type& __a)
      : _Base(std::move(__x), __a, __x.size())
      {
 if (__x.get_allocator() != __a)
   {
     std::__uninitialized_move_a(__x.begin(), __x.end(),
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
     __x.clear();
   }
      }
# 992 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 1040 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 1050 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 1062 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
 using __always_equal = typename _Alloc_traits::is_always_equal;
 _M_move_assign1(std::move(__x), __always_equal{});
 return *this;
      }
# 1081 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 1099 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 1116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 1143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }






      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const noexcept
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 1282 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_default_append(__new_size - __len);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 const size_type __len = size();
 if (__new_size > __len)
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }






      bool
      empty() const noexcept
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      reference
      operator[](size_type __n) noexcept
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1408 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1426 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1483 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                              __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args);
# 1516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      pop_front() noexcept
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     _Alloc_traits::destroy(this->_M_impl,
                            this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1570 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      pop_back() noexcept
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     _Alloc_traits::destroy(this->_M_impl,
                            this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1594 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 1607 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1633 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1646 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1662 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }
# 1696 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1742 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }
# 1766 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
# 1783 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      swap(deque& __x) noexcept
      {
 _M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1839 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1861 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);



      void
      _M_default_initialize();
# 1877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
# 1941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
        void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
        void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1960 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
        iterator
        _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();




      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 2111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);





      void
      _M_move_assign1(deque&& __x, true_type) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 __x.clear();
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }




      void
      _M_move_assign1(deque&& __x, false_type)
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign();
 _M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
      }



      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {

 deque __newobj(std::forward<_Args>(__args)...);

 clear();
 _M_deallocate_node(*begin()._M_node);
 _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 this->_M_impl._M_map = nullptr;
 this->_M_impl._M_map_size = 0;

 this->_M_impl._M_swap_data(__newobj._M_impl);
      }


      void
      _M_move_assign2(deque&& __x, true_type)
      {

 auto __alloc = __x._M_get_Tp_allocator();


 _M_replace_map(std::move(__x));

 _M_get_Tp_allocator() = std::move(__alloc);
      }



      void
      _M_move_assign2(deque&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   {


     _M_replace_map(std::move(__x), __x.get_allocator());
   }
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }

    };
# 2218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 2236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3



namespace std
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 319 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3

}
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/deque.tcc" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/deque.tcc" 3
namespace std
{



  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
        _M_get_Tp_allocator());
          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
      this->_M_impl._M_finish._M_cur,
      _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {


    _M_replace_map(__x, __x.get_allocator());
    std::__alloc_on_copy(_M_get_Tp_allocator(),
           __x._M_get_Tp_allocator());
    return *this;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __len = size();
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);
      }



  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     emplace_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     emplace_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position._M_const_cast(),
          std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
 return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_default_a(this->_M_impl._M_finish,
          __new_finish,
          _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
 = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
 return false;

      const difference_type __back_capacity
 = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
 return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)

       emplace_back(*__first);



          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur,
                std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::move_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }



}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 3





# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 1 3
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
namespace std
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 213 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 278 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 291 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 337 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 375 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 401 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 425 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 437 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 449 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 488 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 505 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 693 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 725 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 764 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      { return *(this->_M_impl._M_start + __n); }
# 794 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 822 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 840 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      { return *(end() - 1); }





      const_reference
      back() const noexcept
      { return *(end() - 1); }
# 887 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      _Tp*



      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }


      const _Tp*



      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 949 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 969 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 984 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1014 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      { return this->insert(__position, __l.begin(), __l.end()); }
# 1051 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1093 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1172 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1243 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1361 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }



      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const
 { return __ptr; }

      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }






    };
# 1507 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1524 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
namespace std
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std
{

# 540 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 677 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 773 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                          ,
     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x) noexcept
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
# 989 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>
      void
      emplace_back(_Args&&... __args)
      { push_back(bool(__args...)); }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 2 3

namespace std
{

# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 108 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 1263 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 2 3

namespace std
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 2 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/vector.tcc" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/vector.tcc" 3
namespace std
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   const auto __pos = begin() + (__position - cbegin());
   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__pos, std::move(__x_copy));
     }
   else
     _M_insert_aux(__pos, __x);



 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + (__position - cbegin()),
   std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;



   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = pointer();

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 try
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = pointer();

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 catch(...)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     throw;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    __new_finish =
      std::__uninitialized_default_n_a(__new_finish, __n,
           _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 2 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
namespace std
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
   __gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
 __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_less_val());
    }
# 183 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 263 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_less_iter());
 }
    }
# 296 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 351 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 377 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 412 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 439 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 466 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last),
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 494 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last),
          __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 517 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 530 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
namespace std
{

# 104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 1 3
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std
{

# 107 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 2 3
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uses_allocator.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uses_allocator.h" 3
namespace std
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 2 3


namespace std
{

# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     
     

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);


      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      _Sequence c;

    public:
# 146 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      explicit
      queue(const _Sequence& __c)
      : c(__c) { }

      explicit
      queue(_Sequence&& __c = _Sequence())
      : c(std::move(__c)) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 queue(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const _Sequence& __c, const _Alloc& __a)
 : c(__c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(_Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const queue& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
 ;
 return c.front();
      }





      const_reference
      front() const
      {
 ;
 return c.front();
      }





      reference
      back()
      {
 ;
 return c.back();
      }





      const_reference
      back() const
      {
 ;
 return c.back();
      }
# 241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 267 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 c.pop_front();
      }


      void
      swap(queue& __q)
      noexcept(__is_nothrow_swappable<_Tp>::value)
      {
 using std::swap;
 swap(c, __q.c);
      }

    };
# 296 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 314 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline void
    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<queue<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };
# 395 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     
     
     



      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:
# 437 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      explicit
      priority_queue(const _Compare& __x,
       const _Sequence& __s)
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      explicit
      priority_queue(const _Compare& __x = _Compare(),
       _Sequence&& __s = _Sequence())
      : c(std::move(__s)), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 priority_queue(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Alloc& __a)
 : c(__x, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Sequence& __c,
         const _Alloc& __a)
 : c(__x, __c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
 : c(__x, std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const priority_queue& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(priority_queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }
# 503 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x,
         const _Sequence& __s)
 : c(__s), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }

      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         _Sequence&& __s = _Sequence())
 : c(std::move(__s)), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
 ;
 return c.front();
      }
# 557 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }


      void
      push(value_type&& __x)
      {
 c.push_back(std::move(__x));
 std::push_heap(c.begin(), c.end(), comp);
      }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 {
   c.emplace_back(std::forward<_Args>(__args)...);
   std::push_heap(c.begin(), c.end(), comp);
 }
# 592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }


      void
      swap(priority_queue& __pq)
      noexcept(__is_nothrow_swappable<_Tp>::value
               && __is_nothrow_swappable<_Compare>::value)
      {
 using std::swap;
 swap(c, __pq.c);
 swap(comp, __pq.comp);
      }

    };




  template<typename _Tp, typename _Sequence, typename _Compare>
    inline void
    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
  priority_queue<_Tp, _Sequence, _Compare>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Sequence, typename _Compare,
    typename _Alloc>
    struct uses_allocator<priority_queue<_Tp, _Sequence, _Compare>, _Alloc>
    : public uses_allocator<_Sequence, _Alloc>::type { };



}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 3




namespace std
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 1 3
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
       
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3
# 25 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned long _fsize_t;




  struct _wfinddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };

  struct _wfinddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };
# 178 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pctype;
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__wctype;
# 207 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pwctype;
# 231 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  int __attribute__((__cdecl__)) iswalpha(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalpha_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswupper(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswupper_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswlower(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswxdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswxdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswspace(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswspace_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswpunct(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswpunct_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswalnum(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalnum_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswprint(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswprint_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswgraph(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswgraph_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswcntrl(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcntrl_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswascii(wint_t _C);
  int __attribute__((__cdecl__)) isleadbyte(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isleadbyte_l(int _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towupper(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towupper_l(wint_t _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towlower(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswctype(wint_t _C,wctype_t _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsymf(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsymf_l(wint_t _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsym(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsym_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) is_wctype(wint_t _C,wctype_t _Type);


  int __attribute__((__cdecl__)) iswblank(wint_t _C);







  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetcwd(wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetdcwd(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  wchar_t *__attribute__((__cdecl__)) _wgetdcwd_nolock(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wmkdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrmdir(const wchar_t *_Path);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _waccess(const wchar_t *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchmod(const wchar_t *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcreat(const wchar_t *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32(const wchar_t *_Filename,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32(intptr_t _FindHandle,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wunlink(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrename(const wchar_t *_OldFilename,const wchar_t *_NewFilename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wmktemp(wchar_t *_TemplateName) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32i64(const wchar_t *_Filename,struct _wfinddata32i64_t *_FindData);
  intptr_t __attribute__((__cdecl__)) _wfindfirst64i32(const wchar_t *_Filename,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst64(const wchar_t *_Filename,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32i64(intptr_t _FindHandle,struct _wfinddata32i64_t *_FindData);
  int __attribute__((__cdecl__)) _wfindnext64i32(intptr_t _FindHandle,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext64(intptr_t _FindHandle,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsopen_s(int *_FileHandle,const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wopen(const wchar_t *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsopen(const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,...) ;




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wsetlocale(int _Category,const wchar_t *_Locale);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecl(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecle(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclp(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclpe(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecv(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecve(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvp(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvpe(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
# 338 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);
# 378 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned short _ino_t;

  typedef unsigned short ino_t;





  typedef unsigned int _dev_t;

  typedef unsigned int dev_t;




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_stat64.h" 1 3
# 19 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_stat64.h" 3
  struct _stat32 {
    _dev_t st_dev;
   _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };


  struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
  };


  struct _stat32i64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };

  struct _stat64i32 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };

  struct _stat64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };
# 394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32(const wchar_t *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32i64(const wchar_t *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _wstat64i32(const wchar_t *_Name,struct _stat64i32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat64(const wchar_t *_Name,struct _stat64 *_Stat);
# 412 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *_cgetws(wchar_t *_Buffer) ;
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwch(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwche(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _putwch(wchar_t _WCh);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwch(wint_t _WCh);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cputws(const wchar_t *_String);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  wint_t __attribute__((__cdecl__)) _putwch_nolock(wchar_t _WCh);
  wint_t __attribute__((__cdecl__)) _getwch_nolock(void);
  wint_t __attribute__((__cdecl__)) _getwche_nolock(void);
  wint_t __attribute__((__cdecl__)) _ungetwch_nolock(wint_t _WCh);
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);

  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;




  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);
  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;





  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);



  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) ;
# 951 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s(wchar_t *, size_t, const time_t *);
# 963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef int mbstate_t;
  typedef wchar_t _Wint_t;

  wint_t __attribute__((__cdecl__)) btowc(int);
  size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__ _Ch,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__ _Dest,const char ** __restrict__ _PSrc,size_t _Count,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__ _Dest,wchar_t _Source,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__ _Dest,const wchar_t ** __restrict__ _PSource,size_t _Count,mbstate_t * __restrict__ _State) ;
  int __attribute__((__cdecl__)) wctob(wint_t _WCh);


  wchar_t *__attribute__((__cdecl__)) wmemset(wchar_t *s, wchar_t c, size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemchr(const wchar_t *s, wchar_t c, size_t n);
  int __attribute__((__cdecl__)) wmemcmp(const wchar_t *s1, const wchar_t *s2,size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemcpy(wchar_t * __restrict__ s1,const wchar_t * __restrict__ s2,size_t n) ;
  wchar_t * __attribute__((__cdecl__)) wmempcpy (wchar_t *_Dst, const wchar_t *_Src, size_t _Size);
  wchar_t *__attribute__((__cdecl__)) wmemmove(wchar_t *s1, const wchar_t *s2, size_t n) ;
  int __attribute__((__cdecl__)) fwide(FILE *stream,int mode);
  int __attribute__((__cdecl__)) mbsinit(const mbstate_t *ps);
  __extension__ long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);
  __extension__ unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);


  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount) ;
# 1066 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 2 3
# 23 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
extern "C" {




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _waccess_s (const wchar_t *_Filename,int _AccessMode);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wmktemp_s (wchar_t *_TemplateName,size_t _SizeInWords);




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _cgetws_s (wchar_t *_Buffer,size_t _SizeInWords,size_t *_SizeRead);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s (const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s (const wchar_t *_Format,va_list _ArgList);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itow_s(int _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _itow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ltow_s(long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ltow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ultow_s(unsigned long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ultow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t* _ReturnSize, wchar_t (&_DstBuf)[__size], const wchar_t* _VarName) { return _wgetenv_s(_ReturnSize, _DstBuf, __size, _VarName); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);





  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t (&_PathResult)[__size], const wchar_t* _Drive, const wchar_t* _Dir, const wchar_t* _Filename, const wchar_t* _Ext) { return _wmakepath_s(_PathResult,__size,_Drive,_Dir,_Filename,_Ext); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t* _Filename, const wchar_t* _EnvVar, wchar_t (&_ResultPath)[__size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, __size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }






  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscat_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscpy_s(_Dest,__size,_Source); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val, size_t _Count,_locale_t _Locale);

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) wcsnlen_s(const wchar_t * _src, size_t _count) {
    return _src ? wcsnlen(_src, _count) : 0;
  }




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);
# 165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t *_Retval,wchar_t *_Dst,size_t _SizeInWords,const char **_PSrc,size_t _N,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dst)[__size], const char** _PSrc, size_t _N, mbstate_t _State) { return mbsrtowcs_s(_Retval, _Dst, __size, _PSrc, _N, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,wchar_t _Ch,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t* _Retval, char (&_Dst)[__size], wchar_t _Ch, mbstate_t _State) { return wcrtomb_s(_Retval, _Dst, __size, _Ch, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,const wchar_t **_Src,size_t _Size,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t _Retval, char (&_Dst)[__size], const wchar_t** _Src, size_t _Size, mbstate_t _State) { return wcsrtombs_s(_Retval, _Dst, __size, _Src, _Size, _State); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemcpy_s (wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemmove_s(wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);



}
# 1072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1074 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 2 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 2 3
# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
namespace std
{

# 90 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 2 3

namespace std
{

# 74 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace __gnu_cxx
{

# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std
{

# 226 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((wint_t)(0xFFFF)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 1 3 4
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 1 3 4
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 13 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4
extern "C" {




  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);


}
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 427 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 2 3 4
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 421 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace std
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 1 3
# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
  struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
  };
# 79 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
  int __attribute__((__cdecl__)) _configthreadlocale(int _Flag);
  char *__attribute__((__cdecl__)) setlocale(int _Category,const char *_Locale);
  __attribute__ ((__dllimport__)) struct lconv *__attribute__((__cdecl__)) localeconv(void);
  _locale_t __attribute__((__cdecl__)) _get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) _create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) _free_locale(_locale_t _Locale);
  _locale_t __attribute__((__cdecl__)) __get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) __create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) __free_locale(_locale_t _Locale);







}


#pragma pack(pop)
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 2 3
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 2 3



namespace std
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
extern "C" {
# 72 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  extern const unsigned char __newclmap[];
  extern const unsigned char __newcumap[];
  extern pthreadlocinfo __ptlocinfo;
  extern pthreadmbcinfo __ptmbcinfo;
  extern int __globallocalestatus;
  extern int __locale_changed;
  extern struct threadlocaleinfostruct __initiallocinfo;
  extern _locale_tstruct __initiallocalestructinfo;
  pthreadlocinfo __attribute__((__cdecl__)) __updatetlocinfo(void);
  pthreadmbcinfo __attribute__((__cdecl__)) __updatetmbcinfo(void);
# 100 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype(int _C,int _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype_l(int _C,int _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalpha(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalpha_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) islower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _islower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isxdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isxdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isspace(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isspace_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ispunct(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ispunct_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalnum(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalnum_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isprint(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isprint_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isgraph(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isgraph_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) iscntrl(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iscntrl_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __isascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __toascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsymf(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsym(int _C);


int __attribute__((__cdecl__)) isblank(int _C);
# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  extern int * __imp___mb_cur_max;
# 276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
}
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 2 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 2 3

namespace std
{

# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 1 3
# 30 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 3
extern "C" {
# 239 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 3
}
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/types.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/types.h" 3
__extension__
typedef long long _pid_t;




typedef _pid_t pid_t;





typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef unsigned int useconds_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};





__extension__
typedef unsigned long long _sigset_t;
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 1 3
# 16 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
extern "C" {
# 31 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthread(void (__attribute__((__cdecl__)) *_StartAddress) (void *),unsigned _StackSize,void *_ArgList);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthread(void) __attribute__ ((__noreturn__));
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthreadex(void *_Security,unsigned _StackSize,unsigned ( *_StartAddress) (void *),void *_ArgList,unsigned _InitFlag,unsigned *_ThrdAddr);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthreadex(unsigned _Retval) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));






       

  void __attribute__((__cdecl__)) __attribute__((noreturn)) abort(void);
       



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _cexit(void);
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _c_exit(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getpid(void);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _cwait(int *_TermStat,intptr_t _ProcHandle,int _Action);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execl(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execle(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlp(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlpe(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execv(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execve(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvp(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvpe(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnl(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnle(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlp(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlpe(int _Mode,const char *_Filename,const char *_ArgList,...);
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  int __attribute__((__cdecl__)) system(const char *_Command);
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  void __attribute__((__cdecl__)) __security_init_cookie(void);




  void __attribute__((__cdecl__)) __security_check_cookie(uintptr_t _StackCookie);
  __attribute__((noreturn)) void __attribute__((__cdecl__)) __report_gsfailure(uintptr_t _StackCookie);

  extern uintptr_t __security_cookie;

  intptr_t __attribute__((__cdecl__)) _loaddll(char *_Filename);
  int __attribute__((__cdecl__)) _unloaddll(intptr_t _Handle);
  int (__attribute__((__cdecl__)) *__attribute__((__cdecl__)) _getdllprocaddr(intptr_t _Handle,char *_ProcedureName,intptr_t _Ordinal))(void);
# 154 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  intptr_t __attribute__((__cdecl__)) cwait(int *_TermStat,intptr_t _ProcHandle,int _Action) ;

  int __attribute__((__cdecl__)) execl(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execle(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlp(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlpe(const char *_Filename,const char *_ArgList,...) ;






  intptr_t __attribute__((__cdecl__)) spawnl(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnle(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlp(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlpe(int,const char *_Filename,const char *_ArgList,...) ;


  int __attribute__((__cdecl__)) getpid(void) ;






  int __attribute__((__cdecl__)) execv(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execve(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  int __attribute__((__cdecl__)) execvp(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execvpe(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;






  intptr_t __attribute__((__cdecl__)) spawnv(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnve(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvp(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvpe(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;



}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/syslimits.h" 1 3 4






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/limits.h" 1 3 4
# 169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 2 3 4
# 8 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/syslimits.h" 2 3 4
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 2 3 4
# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_signal.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 2 3


extern "C" {




  typedef int sig_atomic_t;
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
  typedef void (*__p_sig_fn_t)(int);
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
  extern void **__attribute__((__cdecl__)) __pxcptinfoptrs(void);


  __p_sig_fn_t __attribute__((__cdecl__)) signal(int _SigNum,__p_sig_fn_t _Func);
  int __attribute__((__cdecl__)) raise(int _SigNum);


}
# 69 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 53 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
  struct __timeb32 {
    __time32_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct __timeb64 {
    __time64_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime64(struct __timeb64 *_Time);



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime(struct __timeb64 *);
# 102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
  void __attribute__((__cdecl__)) ftime (struct timeb *);
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 2 3


extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime_s(struct __timeb32 *_Time);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime64_s(struct __timeb64 *_Time);







}
# 125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 2 3
# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_compat.h" 1 3
# 73 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3


extern "C" {
# 160 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
void * pthread_timechange_handler_np(void * dummy);
int pthread_delay_np (const struct timespec *interval);
int pthread_num_processors_np(void);
int pthread_set_num_processors_np(int n);
# 180 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
typedef long pthread_once_t;
typedef unsigned pthread_mutexattr_t;
typedef unsigned pthread_key_t;
typedef void *pthread_barrierattr_t;
typedef int pthread_condattr_t;
typedef int pthread_rwlockattr_t;
# 196 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
typedef uintptr_t pthread_t;

typedef struct _pthread_cleanup _pthread_cleanup;
struct _pthread_cleanup
{
    void (*func)(void *);
    void *arg;
    _pthread_cleanup *next;
};
# 239 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
struct sched_param {
  int sched_priority;
};

int sched_yield(void);
int sched_get_priority_min(int pol);
int sched_get_priority_max(int pol);
int sched_getscheduler(pid_t pid);
int sched_setscheduler(pid_t pid, int pol, const struct sched_param *param);



typedef struct pthread_attr_t pthread_attr_t;
struct pthread_attr_t
{
    unsigned p_state;
    void *stack;
    size_t s_size;
    struct sched_param param;
};

int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
int pthread_getschedparam(pthread_t thread, int *pol, struct sched_param *param);
int pthread_setschedparam(pthread_t thread, int pol, const struct sched_param *param);
int pthread_attr_setschedpolicy (pthread_attr_t *attr, int pol);
int pthread_attr_getschedpolicy (pthread_attr_t *attr, int *pol);


typedef void *pthread_spinlock_t;
typedef void *pthread_mutex_t;
typedef void *pthread_cond_t;
typedef void *pthread_rwlock_t;
typedef void *pthread_barrier_t;
# 291 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
extern void (**_pthread_key_dest)(void *);
int pthread_key_create(pthread_key_t *key, void (* dest)(void *));
int pthread_key_delete(pthread_key_t key);
void * pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *value);

pthread_t pthread_self(void);
int pthread_once(pthread_once_t *o, void (*func)(void));
void pthread_testcancel(void);
int pthread_equal(pthread_t t1, pthread_t t2);
void pthread_tls_init(void);
void _pthread_cleanup_dest(pthread_t t);
int pthread_get_concurrency(int *val);
int pthread_set_concurrency(int val);
void pthread_exit(void *res);
void _pthread_invoke_cancel(void);
int pthread_cancel(pthread_t t);
int pthread_kill(pthread_t t, int sig);
unsigned _pthread_get_state(const pthread_attr_t *attr, unsigned flag);
int _pthread_set_state(pthread_attr_t *attr, unsigned flag, unsigned val);
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
int pthread_create_wrapper(void *args);
int pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(* func)(void *), void *arg);
int pthread_join(pthread_t t, void **res);
int pthread_detach(pthread_t t);
int pthread_setname_np(pthread_t thread, const char *name);
int pthread_getname_np(pthread_t thread, char *name, size_t len);


int pthread_rwlock_init(pthread_rwlock_t *rwlock_, const pthread_rwlockattr_t *attr);
int pthread_rwlock_wrlock(pthread_rwlock_t *l);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *ts);
int pthread_rwlock_rdlock(pthread_rwlock_t *l);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *l, const struct timespec *ts);
int pthread_rwlock_unlock(pthread_rwlock_t *l);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *l);
int pthread_rwlock_trywrlock(pthread_rwlock_t *l);
int pthread_rwlock_destroy (pthread_rwlock_t *l);

int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *a);
int pthread_cond_destroy(pthread_cond_t *cv);
int pthread_cond_signal (pthread_cond_t *cv);
int pthread_cond_broadcast (pthread_cond_t *cv);
int pthread_cond_wait (pthread_cond_t *cv, pthread_mutex_t *external_mutex);
int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);
int pthread_cond_timedwait_relative_np(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);

int pthread_mutex_lock(pthread_mutex_t *m);
int pthread_mutex_timedlock(pthread_mutex_t *m, const struct timespec *ts);
int pthread_mutex_unlock(pthread_mutex_t *m);
int pthread_mutex_trylock(pthread_mutex_t *m);
int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a);
int pthread_mutex_destroy(pthread_mutex_t *m);

int pthread_barrier_destroy(pthread_barrier_t *b);
int pthread_barrier_init(pthread_barrier_t *b, const void *attr, unsigned int count);
int pthread_barrier_wait(pthread_barrier_t *b);

int pthread_spin_init(pthread_spinlock_t *l, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *l);

int pthread_spin_lock(pthread_spinlock_t *l);
int pthread_spin_trylock(pthread_spinlock_t *l);
int pthread_spin_unlock(pthread_spinlock_t *l);

int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_setdetachstate(pthread_attr_t *a, int flag);
int pthread_attr_getdetachstate(const pthread_attr_t *a, int *flag);
int pthread_attr_setinheritsched(pthread_attr_t *a, int flag);
int pthread_attr_getinheritsched(const pthread_attr_t *a, int *flag);
int pthread_attr_setscope(pthread_attr_t *a, int flag);
int pthread_attr_getscope(const pthread_attr_t *a, int *flag);
int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stack);
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack);
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size);

int pthread_mutexattr_init(pthread_mutexattr_t *a);
int pthread_mutexattr_destroy(pthread_mutexattr_t *a);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setpshared(pthread_mutexattr_t * a, int type);
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *a, int * prio);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *a, int prio);
int pthread_getconcurrency(void);
int pthread_setconcurrency(int new_level);

int pthread_condattr_destroy(pthread_condattr_t *a);
int pthread_condattr_init(pthread_condattr_t *a);
int pthread_condattr_getpshared(const pthread_condattr_t *a, int *s);
int pthread_condattr_setpshared(pthread_condattr_t *a, int s);


typedef int clockid_t;



int pthread_condattr_getclock (const pthread_condattr_t *attr,
       clockid_t *clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr,
       clockid_t clock_id);
int __pthread_clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);

int pthread_barrierattr_init(void **attr);
int pthread_barrierattr_destroy(void **attr);
int pthread_barrierattr_setpshared(void **attr, int s);
int pthread_barrierattr_getpshared(void **attr, int *s);


struct _pthread_cleanup ** pthread_getclean (void);
void * pthread_gethandle (pthread_t t);
void * pthread_getevent ();

unsigned long long _pthread_rel_time_in_ms(const struct timespec *ts);
unsigned long long _pthread_time_in_ms(void);
unsigned long long _pthread_time_in_ms_from_timespec(const struct timespec *ts);
int _pthread_tryjoin (pthread_t t, void **res);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *a);
int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *a, int *s);
int pthread_rwlockattr_init(pthread_rwlockattr_t *a);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int s);
# 428 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_unistd.h" 1 3
# 429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 689 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
}
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 2 3
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3



































# 298 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}



static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;

      __r = pthread_mutexattr_init (&__attr);
      if (!__r)
 __r = pthread_mutexattr_settype (&__attr,
         2);
      if (!__r)
 __r = pthread_mutex_init (__mutex, &__attr);
      if (!__r)
 __r = pthread_mutexattr_destroy (&__attr);
      return __r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
# 149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/atomic_word.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 3







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 3
       
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 2 3

namespace std
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 2 3







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
namespace std
{



namespace __cxx11 {
# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;



      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }

 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 258 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 410 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 426 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 476 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 544 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }




      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {

  _M_destroy(_M_allocated_capacity);
  _M_data(_M_local_data());
  _M_set_length(0);
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 599 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (!__str._M_is_local()
     && (_Alloc_traits::_S_propagate_on_move_assign()
       || _Alloc_traits::_S_always_equal()))
   {
     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {
      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
     assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 813 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 826 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 875 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 904 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 921 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 942 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1026 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1084 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1150 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1217 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1233 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1249 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1266 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1279 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1315 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1413 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1436 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1459 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1478 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1502 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1520 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1544 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 this->_M_erase(_M_check(__pos, "basic_string::erase"),
         _M_limit(__pos, __n));
 return *this;
      }
# 1560 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1579 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1667 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1692 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1716 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1734 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1754 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 1776 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1797 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 1822 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 1854 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 1956 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 1976 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2009 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 2022 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2054 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2067 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2084 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 2097 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2114 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2128 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2209 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2222 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2255 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2286 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2303 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2318 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2335 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2366 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2382 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2401 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2433 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2459 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2501 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
}
# 4927 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 5048 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 5095 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 5133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 5171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 5209 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 5247 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 5285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 5305 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 5323 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 5346 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 5363 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 75 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 25 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
  typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



  typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;

       


  typedef struct {
    long double x;
  } _LONGDOUBLE;

       

#pragma pack(4)
  typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 140 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
# 156 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);




  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;
# 180 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___argc;







  extern char *** __imp___argv;







  extern wchar_t *** __imp___wargv;
# 208 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char *** __imp__environ;
# 217 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern wchar_t *** __imp__wenviron;
# 226 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char ** __imp__pgmptr;
# 235 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern wchar_t ** __imp__wpgmptr;



  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);




  extern int * __imp__fmode;



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);





  extern unsigned int * __imp__osplatform;
# 265 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__osver;
# 274 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winver;
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winmajor;
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winminor;




  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }
# 334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);


  __extension__ long long __attribute__((__cdecl__)) _abs64(long long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long long __attribute__((__cdecl__)) _abs64(long long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));


  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);

  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 404 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);






  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);




  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);


       
       


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);
       
       

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);
# 533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);





       
       


  __extension__ unsigned long long __attribute__((__cdecl__)) _rotl64(unsigned long long _Val,int _Shift);
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long Value,int Shift);
       
       
       
       


  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);
       
       
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);
# 610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 634 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);
# 689 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 30 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 31 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 2 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 2 3




extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_Dest, char (&__drive)[__drive_size], char (&__dir)[__dir_size], char (&__name)[__name_size], char (&__ext)[__ext_size]) { return _splitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) qsort_s(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(void *,const void *,const void *),void *_Context);





}
# 695 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
       
       
# 97 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
       
       




void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 206 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
}


#pragma pack(pop)
# 696 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 76 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 2 3
# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 201 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

}
# 215 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 247 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 96 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*_errno())) { (*_errno()) = 0; }
 ~_Save_errno() { if ((*_errno()) == 0) (*_errno()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*_errno()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 5403 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 2 3

namespace std
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}







namespace std
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };






  inline namespace literals
  {
  inline namespace string_literals
  {

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


  }
  }




}
# 53 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 1 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3
       
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3



namespace std
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 2 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 2 3


namespace std
{

# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    class __shim;

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;
  };
# 482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 640 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 667 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 681 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 731 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 760 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 774 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 787 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3

namespace std
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 2 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 2 3

namespace std
{




  enum class errc
    {




      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,

      broken_pipe = 32,






      device_or_resource_busy = 16,
      directory_not_empty = 41,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 38,
      function_not_supported = 40,


      illegal_byte_sequence = 42,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,






      no_child_process = 10,


      no_lock_available = 39,




      no_space_on_device = 28,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,



      not_enough_memory = 12,

      not_supported = 129,




      operation_not_permitted = 1,



      operation_would_block = 140,


      permission_denied = 13,


      read_only_file_system = 30,
      resource_deadlock_would_occur = 36,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,




      timed_out = 138,

      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31


 ,
      value_too_large = 132


   };


}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 3




namespace std
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 2 3

namespace std
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };

  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}





namespace std
{




  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };


}
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3


namespace std
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc e) noexcept
  { return error_code(static_cast<int>(e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc e) noexcept
  { return error_condition(static_cast<int>(e), iostream_category()); }
# 228 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  public:
# 255 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 487 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 504 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 645 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 662 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 688 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 739 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 751 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 762 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 773 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 792 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 808 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 829 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 846 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 860 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 2 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
# 50 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 1 3
# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 166 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 3
  typedef wchar_t wctrans_t;
  wint_t __attribute__((__cdecl__)) towctrans(wint_t,wctrans_t);
  wctrans_t __attribute__((__cdecl__)) wctrans(const char *);
  wctype_t __attribute__((__cdecl__)) wctype(const char *);


}


#pragma pack(pop)
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 2 3
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_base.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_base.h" 3
namespace std
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);

    static const mask blank = 1 << 10;

  };


}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3




namespace std
{

# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3

namespace std
{

# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1156 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_inline.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_inline.h" 3
namespace std
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3

namespace std
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1947 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2505 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3

namespace std
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 2 3



namespace std
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 2 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 2 3


namespace std
{

# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      flush();
# 357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      pos_type
      tellp();
# 368 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }



}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 639 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 2 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3




namespace std
{

# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      int_type
      get();
# 315 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      int_type
      peek();
# 485 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      unget();
# 555 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      int
      sync();
# 570 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      pos_type
      tellg();
# 585 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 922 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    {
      __is >> __x;
      return __is;
    }



}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 935 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 2 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 2 3

namespace std
{

# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 81 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3






#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }





    bool before(const type_info& __arg) const noexcept;
    bool operator==(const type_info& __arg) const noexcept;
# 136 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 82 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3




namespace std
{

namespace __cxx11 {
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 189 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 242 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* __str = __from._M_string.data();
   if (__from.eback())
     {
     _M_goff[0] = __from.eback() - __str;
     _M_goff[1] = __from.gptr() - __str;
     _M_goff[2] = __from.egptr() - __str;
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 343 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 366 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 402 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 420 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 471 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 615 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 654 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 689 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 705 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 756 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3

namespace std
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 814 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 2 3
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 1 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
       
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3

#pragma GCC visibility push(default)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cxxabi_tweaks.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cxxabi_tweaks.h" 3
namespace __cxxabiv1
{
  extern "C"
  {
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cxxabi_tweaks.h" 3
  __extension__ typedef int __guard __attribute__((mode (__DI__)));


  typedef void __cxa_vec_ctor_return_type;


  typedef void __cxa_cdtor_return_type;


  }
}
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 2 3







namespace __cxxabiv1
{
  extern "C"
  {


  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);


  void*
  __cxa_vec_new(size_t __element_count, size_t __element_size,
  size_t __padding_size, __cxa_cdtor_type __constructor,
  __cxa_cdtor_type __destructor);

  void*
  __cxa_vec_new2(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*));

  void*
  __cxa_vec_new3(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*, size_t));


  __cxa_vec_ctor_return_type
  __cxa_vec_ctor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor);

  __cxa_vec_ctor_return_type
  __cxa_vec_cctor(void* __dest_array, void* __src_array,
    size_t __element_count, size_t __element_size,
    __cxa_cdtor_return_type (*__constructor) (void*, void*),
    __cxa_cdtor_type __destructor);


  void
  __cxa_vec_dtor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_cleanup(void* __array_address, size_t __element_count, size_t __s,
      __cxa_cdtor_type __destructor) noexcept;


  void
  __cxa_vec_delete(void* __array_address, size_t __element_size,
     size_t __padding_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_delete2(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*));

  void
  __cxa_vec_delete3(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*, size_t));

  int
  __cxa_guard_acquire(__guard*);

  void
  __cxa_guard_release(__guard*) noexcept;

  void
  __cxa_guard_abort(__guard*) noexcept;


  int
  __cxa_atexit(void (*)(void*), void*, void*) noexcept;

  int
  __cxa_finalize(void*);


  int
  __cxa_thread_atexit(void (*)(void*), void*, void *) noexcept;


  void
  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));

  void
  __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));


  void
  __cxa_bad_cast() __attribute__((__noreturn__));

  void
  __cxa_bad_typeid() __attribute__((__noreturn__));

  void
  __cxa_throw_bad_array_new_length() __attribute__((__noreturn__));
# 197 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  char*
  __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   size_t* __length, int* __status);


  }
}






namespace __cxxabiv1
{

  class __fundamental_type_info : public std::type_info
  {
  public:
    explicit
    __fundamental_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__fundamental_type_info();
  };


  class __array_type_info : public std::type_info
  {
  public:
    explicit
    __array_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__array_type_info();
  };


  class __function_type_info : public std::type_info
  {
  public:
    explicit
    __function_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__function_type_info();

  protected:

    virtual bool
    __is_function_p() const;
  };


  class __enum_type_info : public std::type_info
  {
  public:
    explicit
    __enum_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__enum_type_info();
  };


  class __pbase_type_info : public std::type_info
  {
  public:
    unsigned int __flags;
    const std::type_info* __pointee;

    explicit
    __pbase_type_info(const char* __n, int __quals,
        const std::type_info* __type)
    : std::type_info(__n), __flags(__quals), __pointee(__type)
    { }

    virtual
    ~__pbase_type_info();


    enum __masks
      {
 __const_mask = 0x1,
 __volatile_mask = 0x2,
 __restrict_mask = 0x4,
 __incomplete_mask = 0x8,
 __incomplete_class_mask = 0x10,
 __transaction_safe_mask = 0x20
      };

  protected:
    __pbase_type_info(const __pbase_type_info&);

    __pbase_type_info&
    operator=(const __pbase_type_info&);


    virtual bool
    __do_catch(const std::type_info* __thr_type, void** __thr_obj,
        unsigned int __outer) const;

    inline virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  inline bool __pbase_type_info::
  __pointer_catch (const __pbase_type_info *thrown_type,
     void **thr_obj,
     unsigned outer) const
  {
    return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);
  }


  class __pointer_type_info : public __pbase_type_info
  {
  public:
    explicit
    __pointer_type_info(const char* __n, int __quals,
   const std::type_info* __type)
    : __pbase_type_info (__n, __quals, __type) { }


    virtual
    ~__pointer_type_info();

  protected:

    virtual bool
    __is_pointer_p() const;

    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  class __class_type_info;


  class __pointer_to_member_type_info : public __pbase_type_info
  {
  public:
    __class_type_info* __context;

    explicit
    __pointer_to_member_type_info(const char* __n, int __quals,
      const std::type_info* __type,
      __class_type_info* __klass)
    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }

    virtual
    ~__pointer_to_member_type_info();

  protected:
    __pointer_to_member_type_info(const __pointer_to_member_type_info&);

    __pointer_to_member_type_info&
    operator=(const __pointer_to_member_type_info&);


    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __base_class_type_info
  {
  public:
    const __class_type_info* __base_type;

    long long __offset_flags;




    enum __offset_flags_masks
      {
 __virtual_mask = 0x1,
 __public_mask = 0x2,
 __hwm_bit = 2,
 __offset_shift = 8
      };


    bool
    __is_virtual_p() const
    { return __offset_flags & __virtual_mask; }

    bool
    __is_public_p() const
    { return __offset_flags & __public_mask; }

    ptrdiff_t
    __offset() const
    {



      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
    }
  };


  class __class_type_info : public std::type_info
  {
  public:
    explicit
    __class_type_info (const char *__n) : type_info(__n) { }

    virtual
    ~__class_type_info ();






    enum __sub_kind
      {

 __unknown = 0,



 __not_contained,


 __contained_ambig,


 __contained_virtual_mask = __base_class_type_info::__virtual_mask,


 __contained_public_mask = __base_class_type_info::__public_mask,


 __contained_mask = 1 << __base_class_type_info::__hwm_bit,

 __contained_private = __contained_mask,
 __contained_public = __contained_mask | __contained_public_mask
      };

    struct __upcast_result;
    struct __dyncast_result;

  protected:

    virtual bool
    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;

    virtual bool
    __do_catch(const type_info* __thr_type, void** __thr_obj,
        unsigned __outer) const;

  public:


    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;







    inline __sub_kind
    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
        const __class_type_info* __src_type,
        const void* __src_ptr) const;
# 479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;





    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
  };


  class __si_class_type_info : public __class_type_info
  {
  public:
    const __class_type_info* __base_type;

    explicit
    __si_class_type_info(const char *__n, const __class_type_info *__base)
    : __class_type_info(__n), __base_type(__base) { }

    virtual
    ~__si_class_type_info();

  protected:
    __si_class_type_info(const __si_class_type_info&);

    __si_class_type_info&
    operator=(const __si_class_type_info&);


    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __sub_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info*__dst, const void*__obj,
  __upcast_result& __restrict __result) const;
  };


  class __vmi_class_type_info : public __class_type_info
  {
  public:
    unsigned int __flags;
    unsigned int __base_count;




    __base_class_type_info __base_info[1];

    explicit
    __vmi_class_type_info(const char* __n, int ___flags)
    : __class_type_info(__n), __flags(___flags), __base_count(0) { }

    virtual
    ~__vmi_class_type_info();


    enum __flags_masks
      {
 __non_diamond_repeat_mask = 0x1,
 __diamond_shaped_mask = 0x2,
 __flags_unknown_mask = 0x10
      };

  protected:

    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;
  };


  struct __cxa_exception;
  struct __cxa_refcounted_exception;
  struct __cxa_dependent_exception;
  struct __cxa_eh_globals;

  extern "C"
  {
# 592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  void*
  __dynamic_cast(const void* __src_ptr,
   const __class_type_info* __src_type,
   const __class_type_info* __dst_type,
   ptrdiff_t __src2dst);
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  __cxa_eh_globals*
  __cxa_get_globals() noexcept __attribute__ ((__const__));

  __cxa_eh_globals*
  __cxa_get_globals_fast() noexcept __attribute__ ((__const__));


  void*
  __cxa_allocate_exception(size_t) noexcept;


  void
  __cxa_free_exception(void*) noexcept;


  void
  __cxa_throw(void*, std::type_info*, void ( *) (void *))
  __attribute__((__noreturn__));


  void*
  __cxa_get_exception_ptr(void*) noexcept __attribute__ ((__pure__));

  void*
  __cxa_begin_catch(void*) noexcept;

  void
  __cxa_end_catch();

  void
  __cxa_rethrow() __attribute__((__noreturn__));



  std::type_info*
  __cxa_current_exception_type() noexcept __attribute__ ((__pure__));




  __cxa_dependent_exception*
  __cxa_allocate_dependent_exception() noexcept;


  void
  __cxa_free_dependent_exception(__cxa_dependent_exception*) noexcept;

  }



  class __foreign_exception
  {
    virtual ~__foreign_exception() throw();
    virtual void __pure_dummy() = 0;
  };

}
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
namespace abi = __cxxabiv1;

namespace __gnu_cxx
{
# 700 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  class recursive_init_error: public std::exception
  {
  public:
    recursive_init_error() throw() { }
    virtual ~recursive_init_error() throw ();
  };
}


#pragma GCC visibility pop
# 92 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 93 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2



# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h"
namespace hls {

template<typename __STREAM_T__>
class stream
{
  protected:
    std::string _name;
    std::deque<__STREAM_T__> _data;





  public:


    stream() {
        static unsigned _counter = 1;
        std::stringstream ss;

        char* _demangle_name = abi::__cxa_demangle(typeid(*this).name(), 0, 0, 0);
        if (_demangle_name) {
            _name = _demangle_name;
            free(_demangle_name);
        }
        else {
            _name = "hls_stream";
        }




        ss << _counter++;
        _name += "." + ss.str();
    }

    stream(const std::string name) {


        _name = name;
    }


  private:
    stream(const stream< __STREAM_T__ >& chn):
        _name(chn._name), _data(chn._data) {
    }

    stream& operator = (const stream< __STREAM_T__ >& chn) {
        _name = chn._name;
        _data = chn._data;
        return *this;
    }

  public:

    void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:


    virtual ~stream() {
        if (!_data.empty())
        {
            std::cout << "WARNING: Hls::stream '"
                      << _name
                      << "' contains leftover data,"
                      << " which may result in RTL simulation hanging."
                      << std::endl;
        }
    }


    bool empty() {



        return _data.empty();
    }

    bool full() const { return false; }


    void read(__STREAM_T__& head) {
        head = read();
    }
# 202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h"
    __STREAM_T__ read() {
        __STREAM_T__ elem;




        if (_data.empty()) {
            std::cout << "WARNING: Hls::stream '"
                      << _name
                      << "' is read while empty,"
                      << " which may result in RTL simulation hanging."
                      << std::endl;
            elem = __STREAM_T__();
        } else {
            elem = _data.front();
            _data.pop_front();
        }
        return elem;
    }



    void write(const __STREAM_T__& tail) {



        _data.push_back(tail);



    }


    bool read_nb(__STREAM_T__& head) {



        bool is_empty = _data.empty();
        if (is_empty) {
            head = __STREAM_T__();
        } else {
            __STREAM_T__ elem(_data.front());
            _data.pop_front();
            head = elem;
        }
        return !is_empty;
    }


    bool write_nb(const __STREAM_T__& tail) {
        bool is_full = full();
        write(tail);
        return !is_full;
    }


    size_t size() {
        return _data.size();
    }
};

}
# 3 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3





# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
       
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3





# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
# 168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
# 243 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);
# 270 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  struct _complex {
    double x;
    double y;
  };


  double __attribute__((__cdecl__)) _cabs(struct _complex _ComplexA);
  double __attribute__((__cdecl__)) _hypot(double _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _jn(int _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _yn(int _X,double _Y);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _chgsign (double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _copysign (double _Number,double _Sign);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _logb (double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _nextafter (double, double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _scalb (double, long);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclass (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnan (double);






__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) jn (int, double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) yn (int, double) ;

__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) chgsign (double);
# 327 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) fpclass (double);
# 372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
# 520 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
# 607 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
# 664 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1030 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
# 1087 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1098 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1181 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);



   extern long double __attribute__((__cdecl__)) _chgsignl (long double);
# 1576 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
}




#pragma pack(pop)
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 2 3
# 77 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
extern "C++"
{
namespace std
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 435 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 559 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
namespace std
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 956 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3

}
# 1072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
namespace std
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 1797 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
}
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 2 3





namespace std
{

# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 121 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      constexpr complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }



      constexpr complex(const complex&) = default;



      template<typename _Up>
        constexpr complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      real() const { return _M_real; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      imag() const { return _M_imag; }
# 172 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);



      complex& operator=(const complex&) = default;



      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      constexpr complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }



  template<typename _Tp>
    constexpr _Tp
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    constexpr _Tp
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }
# 570 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 606 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 636 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    {
      ;
      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));
    }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 770 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 862 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 934 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),
        __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(float __r = 0.0f, float __i = 0.0f)

      : _M_value{ __r, __i } { }







      explicit constexpr complex(const complex<double>&);
      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      imag() const { return __imag__ _M_value; }
# 1097 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(double __r = 0.0, double __i = 0.0)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      imag() const { return __imag__ _M_value; }
# 1248 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(long double __r = 0.0L,
     long double __i = 0.0L)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      constexpr complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      imag() const { return __imag__ _M_value; }
# 1400 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline constexpr
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}



namespace std
{



  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);

  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);

  template<typename _Tp> _Tp fabs(const std::complex<_Tp>&);

  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_acos(const std::complex<_Tp>& __z)
    {
      const std::complex<_Tp> __t = std::asin(__z);
      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;
      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());
    }


  inline __complex__ float
  __complex_acos(__complex__ float __z)
  { return __builtin_cacosf(__z); }

  inline __complex__ double
  __complex_acos(__complex__ double __z)
  { return __builtin_cacos(__z); }

  inline __complex__ long double
  __complex_acos(const __complex__ long double& __z)
  { return __builtin_cacosl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acos(const std::complex<_Tp>& __z)
    { return __complex_acos(__z.__rep()); }
# 1621 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_asin(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t(-__z.imag(), __z.real());
      __t = std::asinh(__t);
      return std::complex<_Tp>(__t.imag(), -__t.real());
    }


  inline __complex__ float
  __complex_asin(__complex__ float __z)
  { return __builtin_casinf(__z); }

  inline __complex__ double
  __complex_asin(__complex__ double __z)
  { return __builtin_casin(__z); }

  inline __complex__ long double
  __complex_asin(const __complex__ long double& __z)
  { return __builtin_casinl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asin(const std::complex<_Tp>& __z)
    { return __complex_asin(__z.__rep()); }
# 1657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atan(const std::complex<_Tp>& __z)
    {
      const _Tp __r2 = __z.real() * __z.real();
      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();

      _Tp __num = __z.imag() + _Tp(1.0);
      _Tp __den = __z.imag() - _Tp(1.0);

      __num = __r2 + __num * __num;
      __den = __r2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),
          _Tp(0.25) * log(__num / __den));
    }


  inline __complex__ float
  __complex_atan(__complex__ float __z)
  { return __builtin_catanf(__z); }

  inline __complex__ double
  __complex_atan(__complex__ double __z)
  { return __builtin_catan(__z); }

  inline __complex__ long double
  __complex_atan(const __complex__ long double& __z)
  { return __builtin_catanl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atan(const std::complex<_Tp>& __z)
    { return __complex_atan(__z.__rep()); }
# 1701 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_acosh(const std::complex<_Tp>& __z)
    {

      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
     + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
    }


  inline __complex__ float
  __complex_acosh(__complex__ float __z)
  { return __builtin_cacoshf(__z); }

  inline __complex__ double
  __complex_acosh(__complex__ double __z)
  { return __builtin_cacosh(__z); }

  inline __complex__ long double
  __complex_acosh(const __complex__ long double& __z)
  { return __builtin_cacoshl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acosh(const std::complex<_Tp>& __z)
    { return __complex_acosh(__z.__rep()); }
# 1737 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_asinh(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t((__z.real() - __z.imag())
       * (__z.real() + __z.imag()) + _Tp(1.0),
       _Tp(2.0) * __z.real() * __z.imag());
      __t = std::sqrt(__t);

      return std::log(__t + __z);
    }


  inline __complex__ float
  __complex_asinh(__complex__ float __z)
  { return __builtin_casinhf(__z); }

  inline __complex__ double
  __complex_asinh(__complex__ double __z)
  { return __builtin_casinh(__z); }

  inline __complex__ long double
  __complex_asinh(const __complex__ long double& __z)
  { return __builtin_casinhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asinh(const std::complex<_Tp>& __z)
    { return __complex_asinh(__z.__rep()); }
# 1776 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atanh(const std::complex<_Tp>& __z)
    {
      const _Tp __i2 = __z.imag() * __z.imag();
      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();

      _Tp __num = _Tp(1.0) + __z.real();
      _Tp __den = _Tp(1.0) - __z.real();

      __num = __i2 + __num * __num;
      __den = __i2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),
          _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));
    }


  inline __complex__ float
  __complex_atanh(__complex__ float __z)
  { return __builtin_catanhf(__z); }

  inline __complex__ double
  __complex_atanh(__complex__ double __z)
  { return __builtin_catanh(__z); }

  inline __complex__ long double
  __complex_atanh(const __complex__ long double& __z)
  { return __builtin_catanhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atanh(const std::complex<_Tp>& __z)
    { return __complex_atanh(__z.__rep()); }
# 1820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline _Tp



    fabs(const std::complex<_Tp>& __z)
    { return std::abs(__z); }


  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    arg(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;

      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)
                        : __type();



    }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    imag(_Tp)
    { return _Tp(); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    norm(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __type(__x) * __type(__x);
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    real(_Tp __x)
    { return __x; }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const _Up& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const _Tp& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), std::complex<__type>(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x),
        std::complex<__type>(__y));
    }



  template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);

  template<typename _Tp>
    std::complex<_Tp>
    __complex_proj(const std::complex<_Tp>& __z)
    {
      const _Tp __den = (__z.real() * __z.real()
    + __z.imag() * __z.imag() + _Tp(1.0));

      return std::complex<_Tp>((_Tp(2.0) * __z.real()) / __den,
          (_Tp(2.0) * __z.imag()) / __den);
    }


  inline __complex__ float
  __complex_proj(__complex__ float __z)
  { return __builtin_cprojf(__z); }

  inline __complex__ double
  __complex_proj(__complex__ double __z)
  { return __builtin_cproj(__z); }

  inline __complex__ long double
  __complex_proj(const __complex__ long double& __z)
  { return __builtin_cprojl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    proj(const std::complex<_Tp>& __z)
    { return __complex_proj(__z.__rep()); }
# 1925 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    proj(_Tp __x)
    { return __x; }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    conj(_Tp __x)
    { return __x; }



inline namespace literals {
inline namespace complex_literals {



  constexpr std::complex<float>
  operator""if(long double __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<float>
  operator""if(unsigned long long __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<double>
  operator""i(long double __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<double>
  operator""i(unsigned long long __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<long double>
  operator""il(long double __num)
  { return std::complex<long double>{0.0L, __num}; }

  constexpr std::complex<long double>
  operator""il(unsigned long long __num)
  { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }

}
}




}
# 4 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 1
# 54 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 1
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h" 1
# 100 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"

# 100 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 122 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 233 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
# 17 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 18 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 2 3




# 21 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
extern "C" {
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 77 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 78 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 157 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"

# 157 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 574 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}
# 602 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
class half;






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
# 610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 630 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
template <int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64>
class ap_private;

template <int _AP_W, bool _AP_S>
struct ssdm_int_sim {

  ap_private<_AP_W, _AP_S> V;
  ssdm_int_sim() {}
};


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 1
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S>
struct _private_range_ref;
template <int _AP_W, bool _AP_S>
struct _private_bit_ref;
# 90 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 1
# 31 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 1 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 3
       
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 3







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 2 3



# 53 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 3
namespace std
{

  using ::max_align_t;
}
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 1
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2
# 186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 1
# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"

# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int8_t xint8;
typedef int16_t xint16;
typedef int32_t xint32;
typedef int64_t xint64;
typedef uint8_t xuint8;
typedef uint16_t xuint16;
typedef uint32_t xuint32;
typedef uint64_t xuint64;


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdbool.h" 1 3 4
# 126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 2
# 143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h" 1
# 27 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 28 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h" 2
# 198 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
typedef unsigned long long int mp_limb_t;
typedef long long int mp_limb_signed_t;







typedef unsigned long long int mp_bitcnt_t;







typedef struct
{
  int _mp_alloc;

  int _mp_size;


  mp_limb_t *_mp_d;
} __mpz_struct;



typedef __mpz_struct mpz_t[1];

typedef mp_limb_t * mp_ptr;
typedef const mp_limb_t * mp_srcptr;


typedef long long int mp_size_t;
typedef long int mp_exp_t;






typedef struct
{
  __mpz_struct _mp_num;
  __mpz_struct _mp_den;
} __mpq_struct;

typedef __mpq_struct mpq_t[1];

typedef struct
{
  int _mp_prec;



  int _mp_size;


  mp_exp_t _mp_exp;
  mp_limb_t *_mp_d;
} __mpf_struct;

typedef __mpf_struct mpf_t[1];


typedef enum
{
  GMP_RAND_ALG_DEFAULT = 0,
  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
} gmp_randalg_t;


typedef struct
{
  mpz_t _mp_seed;
  gmp_randalg_t _mp_alg;
  union {
    void *_mp_lc;
  } _mp_algdata;
} __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];



typedef const __mpz_struct *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef const __mpf_struct *mpf_srcptr;
typedef __mpf_struct *mpf_ptr;
typedef const __mpq_struct *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
# 532 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern "C" {
using std::FILE;



 void __gmp_set_memory_functions (void *(*) (size_t), void *(*) (void *, size_t, size_t), void (*) (void *, size_t))

                                      throw ();


 void __gmp_get_memory_functions (void *(**) (size_t), void *(**) (void *, size_t, size_t), void (**) (void *, size_t))

                                                                   throw ();


 extern const int __gmp_bits_per_limb;


 extern int __gmp_errno;


 extern const char * const __gmp_version;


 extern const char * const __mpir_version;





 void __gmp_randinit_default (gmp_randstate_t);


 void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t)

                          ;


 int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);


 void __gmp_randinit_mt (gmp_randstate_t);


 void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);


 void __gmp_randseed (gmp_randstate_t, mpz_srcptr);


 void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);


 void __gmp_randclear (gmp_randstate_t);


 unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);


 unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);





 int __gmp_asprintf (char **, const char *, ...);



 int __gmp_fprintf (FILE *, const char *, ...);
# 615 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 int __gmp_printf (const char *, ...);


 int __gmp_snprintf (char *, size_t, const char *, ...);


 int __gmp_sprintf (char *, const char *, ...);
# 653 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 int __gmp_fscanf (FILE *, const char *, ...);



 int __gmp_scanf (const char *, ...);


 int __gmp_sscanf (const char *, const char *, ...);
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 void *__gmpz_realloc (mpz_ptr, mp_size_t);




 void __gmpz_abs (mpz_ptr, mpz_srcptr);




 void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);


 void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, unsigned long);


 unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_clear (mpz_ptr);


 void __gmpz_clears (mpz_ptr, ...);


 void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_cmp (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmp_si (mpz_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpz_com (mpz_ptr, mpz_srcptr);


 void __gmpz_combit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));


 void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);


 int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_dump (mpz_srcptr);


 void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);


 void __gmpz_fac_ui (mpz_ptr, unsigned long int);


 void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_fib_ui (mpz_ptr, unsigned long int);


 void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_fits_sint_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_slong_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_sshort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 int __gmpz_fits_uint_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ulong_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ushort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));


 double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);


 long int __gmpz_get_si (mpz_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpz_get_str (char *, int, mpz_srcptr);



 unsigned long int __gmpz_get_ui (mpz_srcptr) throw () __attribute__ ((__pure__));




 mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) throw () __attribute__ ((__pure__));



 mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);


 void __gmpz_init (mpz_ptr);


 void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);


 void __gmpz_inits (mpz_ptr, ...);


 void __gmpz_init_set (mpz_ptr, mpz_srcptr);


 void __gmpz_init_set_d (mpz_ptr, double);


 void __gmpz_init_set_si (mpz_ptr, signed long int);


 int __gmpz_init_set_str (mpz_ptr, const char *, int);


 void __gmpz_init_set_ui (mpz_ptr, unsigned long int);



 size_t __gmpz_inp_raw (mpz_ptr, FILE *);




 size_t __gmpz_inp_str (mpz_ptr, FILE *, int);



 int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));


 int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));


 void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);




 void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);


 void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);





 void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);



 void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);



 void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);




 void __gmpz_neg (mpz_ptr, mpz_srcptr);



 void __gmpz_nextprime (mpz_ptr, mpz_srcptr);


 void __gmpz_next_likely_prime (mpz_ptr, mpz_srcptr,gmp_randstate_t);



 size_t __gmpz_out_raw (FILE *, mpz_srcptr);




 size_t __gmpz_out_str (FILE *, int, mpz_srcptr);



 int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));



 int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));




 mp_bitcnt_t __gmpz_popcount (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);


 int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));


 int __gmpz_probable_prime_p (mpz_srcptr,gmp_randstate_t, int,unsigned long);


 int __gmpz_likely_prime_p (mpz_srcptr,gmp_randstate_t, unsigned long);


 void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);


 unsigned long int __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_nthroot (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rootrem (mpz_ptr,mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));



 void __gmpz_set (mpz_ptr, mpz_srcptr);


 void __gmpz_set_d (mpz_ptr, double);


 void __gmpz_set_f (mpz_ptr, mpf_srcptr);



 void __gmpz_set_q (mpz_ptr, mpq_srcptr);




 void __gmpz_set_si (mpz_ptr, signed long int);


 int __gmpz_set_str (mpz_ptr, const char *, int);



 void __gmpz_set_ui (mpz_ptr, unsigned long int);


 void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);



 size_t __gmpz_size (mpz_srcptr) throw () __attribute__ ((__pure__));



 size_t __gmpz_sizeinbase (mpz_srcptr, int) throw () __attribute__ ((__pure__));


 void __gmpz_sqrt (mpz_ptr, mpz_srcptr);


 void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);



 void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);



 void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);


 void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_swap (mpz_ptr, mpz_ptr) throw ();


 unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);



 void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);






 void __gmpq_abs (mpq_ptr, mpq_srcptr);



 void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_canonicalize (mpq_ptr);


 void __gmpq_clear (mpq_ptr);


 void __gmpq_clears (mpq_ptr, ...);


 int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


 int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));


 int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));


 void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);


 int __gmpq_equal (mpq_srcptr, mpq_srcptr) throw () __attribute__ ((__pure__));


 void __gmpq_get_num (mpz_ptr, mpq_srcptr);


 void __gmpq_get_den (mpz_ptr, mpq_srcptr);


 double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));


 char *__gmpq_get_str (char *, int, mpq_srcptr);


 void __gmpq_init (mpq_ptr);


 void __gmpq_inits (mpq_ptr, ...);



 size_t __gmpq_inp_str (mpq_ptr, FILE *, int);



 void __gmpq_inv (mpq_ptr, mpq_srcptr);


 void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);



 void __gmpq_neg (mpq_ptr, mpq_srcptr);




 size_t __gmpq_out_str (FILE *, int, mpq_srcptr);



 void __gmpq_set (mpq_ptr, mpq_srcptr);


 void __gmpq_set_d (mpq_ptr, double);


 void __gmpq_set_den (mpq_ptr, mpz_srcptr);


 void __gmpq_set_f (mpq_ptr, mpf_srcptr);


 void __gmpq_set_num (mpq_ptr, mpz_srcptr);


 void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);


 int __gmpq_set_str (mpq_ptr, const char *, int);


 void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);


 void __gmpq_set_z (mpq_ptr, mpz_srcptr);


 void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_swap (mpq_ptr, mpq_ptr) throw ();





 void __gmpf_abs (mpf_ptr, mpf_srcptr);


 void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);

 void __gmpf_ceil (mpf_ptr, mpf_srcptr);


 void __gmpf_clear (mpf_ptr);


 void __gmpf_clears (mpf_ptr, ...);


 int __gmpf_cmp (mpf_srcptr, mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));


 int __gmpf_cmp_si (mpf_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_dump (mpf_srcptr);


 int __gmpf_eq (mpf_srcptr, mpf_srcptr, unsigned long int) __attribute__ ((__pure__));


 int __gmpf_fits_sint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_slong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_sshort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_uint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ulong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ushort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_floor (mpf_ptr, mpf_srcptr);


 double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));


 double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);


 mp_bitcnt_t __gmpf_get_default_prec (void) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) throw () __attribute__ ((__pure__));


 long __gmpf_get_si (mpf_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);


 unsigned long __gmpf_get_ui (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_init (mpf_ptr);


 void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);


 void __gmpf_inits (mpf_ptr, ...);


 void __gmpf_init_set (mpf_ptr, mpf_srcptr);


 void __gmpf_init_set_d (mpf_ptr, double);


 void __gmpf_init_set_si (mpf_ptr, signed long int);


 int __gmpf_init_set_str (mpf_ptr, const char *, int);


 void __gmpf_init_set_ui (mpf_ptr, unsigned long int);



 size_t __gmpf_inp_str (mpf_ptr, FILE *, int);



 int __gmpf_integer_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_neg (mpf_ptr, mpf_srcptr);



 size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);



 void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);


 void __gmpf_rrandomb (mpf_ptr, gmp_randstate_t, mp_size_t, mp_exp_t);


 void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_set (mpf_ptr, mpf_srcptr);


 void __gmpf_set_d (mpf_ptr, double);


 void __gmpf_set_default_prec (mp_bitcnt_t) throw ();


 void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);


 void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) throw ();


 void __gmpf_set_q (mpf_ptr, mpq_srcptr);


 void __gmpf_set_si (mpf_ptr, signed long int);


 int __gmpf_set_str (mpf_ptr, const char *, int);


 void __gmpf_set_ui (mpf_ptr, unsigned long int);


 void __gmpf_set_z (mpf_ptr, mpz_srcptr);


 size_t __gmpf_size (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_sqrt (mpf_ptr, mpf_srcptr);


 void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);


 void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_swap (mpf_ptr, mpf_ptr) throw ();


 void __gmpf_trunc (mpf_ptr, mpf_srcptr);


 void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
# 1516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_bdivmod (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, unsigned long int);


 mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);


 int __gmpn_mulmod_2expp1 (mp_ptr, mp_srcptr, mp_srcptr,int,unsigned long, mp_ptr);


 void __gmpn_mulmod_2expm1 (mp_ptr, mp_ptr, mp_ptr,unsigned long, mp_ptr);



 int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));






 mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);





 mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);


 void __gmpn_invert (mp_ptr xp, mp_srcptr ap, mp_size_t n);


 mp_limb_t __gmpn_sb_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dip)
                                               ;


 mp_limb_t __gmpn_dc_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dip, mp_ptr tp)
                                     ;


 void __gmpn_dc_bdiv_q_n (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr scratch)
                                                 ;


 mp_limb_t __gmpn_inv_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_srcptr dip)
                                        ;


 mp_limb_t __gmpn_dc_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_limb_t dinv)
                                 ;


 mp_limb_t __gmpn_dc_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_inv_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_srcptr dinv)
                                 ;


 mp_limb_t __gmpn_inv_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                    ;


 mp_limb_t __gmpn_sb_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_sb_bdiv_q (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_dc_bdiv_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                                               ;


 mp_limb_t __gmpn_sb_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_sb_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_tdiv_q (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_divexact (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_redc_1 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);


 mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_neg_n (mp_ptr, mp_srcptr, mp_size_t);



 void __gmpn_com_n (mp_ptr, mp_srcptr, mp_size_t);


 int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);



 mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));


 void __gmpn_random (mp_ptr, mp_size_t);


 void __gmpn_random2 (mp_ptr, mp_size_t);


 void __gmpn_urandomb (mp_ptr, gmp_randstate_t, unsigned long);


 void __gmpn_urandomm (mp_ptr, gmp_randstate_t, mp_srcptr, mp_size_t);


 void __gmpn_randomb (mp_ptr, gmp_randstate_t, mp_size_t);


 void __gmpn_rrandom (mp_ptr, gmp_randstate_t, mp_size_t);


 mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);


 mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_zero (mp_ptr, mp_size_t);
# 1799 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
}
# 1823 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_uint_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ulong_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

unsigned long
__gmpz_get_ui (mpz_srcptr __gmp_z) throw ()
{
  mp_ptr __gmp_p = __gmp_z->_mp_d;
  mp_size_t __gmp_n = __gmp_z->_mp_size;
  mp_limb_t __gmp_l = __gmp_p[0];






  return (unsigned long)(__gmp_n != 0 ? __gmp_l : 0);
# 1879 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) throw ()
{
  mp_limb_t __gmp_result = 0;
  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
    __gmp_result = __gmp_z->_mp_d[__gmp_n];
  return __gmp_result;
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;

  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_bitcnt_t
__gmpz_popcount (mpz_srcptr __gmp_u) throw ()
{
  mp_size_t __gmp_usize;
  mp_bitcnt_t __gmp_result;

  __gmp_usize = __gmp_u->_mp_size;
  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

void
__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
}




extern __inline__ __attribute__((__gnu_inline__))

size_t
__gmpz_size (mpz_srcptr __gmp_z) throw ()
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}






extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
}
# 2220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) throw ()
{
  int __gmp_result;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}



}
# 2328 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 std::ostream& operator<< (std::ostream &, mpz_srcptr);
 std::ostream& operator<< (std::ostream &, mpq_srcptr);
 std::ostream& operator<< (std::ostream &, mpf_srcptr);
 std::istream& operator>> (std::istream &, mpz_ptr);
 std::istream& operator>> (std::istream &, mpq_ptr);
 std::istream& operator>> (std::istream &, mpf_ptr);
# 2348 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
typedef __mpz_struct MP_INT;
typedef __mpq_struct MP_RAT;
# 2358 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
enum
{
  GMP_ERROR_NONE = 0,
  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
  GMP_ERROR_DIVISION_BY_ZERO = 2,
  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
  GMP_ERROR_INVALID_ARGUMENT = 8
};
# 144 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 2




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h" 1
# 73 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef void mpfr_void;
typedef int mpfr_int;
typedef unsigned int mpfr_uint;
typedef long mpfr_long;
typedef unsigned long mpfr_ulong;
typedef size_t mpfr_size_t;
# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef enum {
  MPFR_RNDN=0,
  MPFR_RNDZ,
  MPFR_RNDU,
  MPFR_RNDD,
  MPFR_RNDA,
  MPFR_RNDF,
  MPFR_RNDNA=-1
} mpfr_rnd_t;
# 130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef long mpfr_prec_t;
typedef unsigned long mpfr_uprec_t;
# 143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef int mpfr_sign_t;


typedef mp_exp_t mpfr_exp_t;






typedef struct {
  mpfr_prec_t _mpfr_prec;
  mpfr_sign_t _mpfr_sign;
  mpfr_exp_t _mpfr_exp;
  mp_limb_t *_mpfr_d;
} __mpfr_struct;
# 179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef __mpfr_struct mpfr_t[1];
typedef __mpfr_struct *mpfr_ptr;
typedef const __mpfr_struct *mpfr_srcptr;
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef enum {
  MPFR_NAN_KIND = 0,
  MPFR_INF_KIND = 1, MPFR_ZERO_KIND = 2, MPFR_REGULAR_KIND = 3
} mpfr_kind_t;
# 241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
extern "C" {


 const char * mpfr_get_version (void);
 const char * mpfr_get_patches (void);
 int mpfr_buildopt_tls_p (void);
 int mpfr_buildopt_decimal_p (void);

 mpfr_exp_t mpfr_get_emin (void);
 int mpfr_set_emin (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emin_min (void);
 mpfr_exp_t mpfr_get_emin_max (void);
 mpfr_exp_t mpfr_get_emax (void);
 int mpfr_set_emax (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emax_min (void);
 mpfr_exp_t mpfr_get_emax_max (void);

 void mpfr_set_default_rounding_mode (mpfr_rnd_t);
 mpfr_rnd_t mpfr_get_default_rounding_mode (void);
 const char *
   mpfr_print_rnd_mode (mpfr_rnd_t);

 void mpfr_clear_flags (void);
 void mpfr_clear_underflow (void);
 void mpfr_clear_overflow (void);
 void mpfr_clear_nanflag (void);
 void mpfr_clear_inexflag (void);
 void mpfr_clear_erangeflag (void);

 void mpfr_set_underflow (void);
 void mpfr_set_overflow (void);
 void mpfr_set_nanflag (void);
 void mpfr_set_inexflag (void);
 void mpfr_set_erangeflag (void);

 int mpfr_underflow_p (void);
 int mpfr_overflow_p (void);
 int mpfr_nanflag_p (void);
 int mpfr_inexflag_p (void);
 int mpfr_erangeflag_p (void);

 int
  mpfr_check_range (mpfr_ptr, int, mpfr_rnd_t);

 void mpfr_init2 (mpfr_ptr, mpfr_prec_t);
 void mpfr_init (mpfr_ptr);
 void mpfr_clear (mpfr_ptr);

 void
  mpfr_inits2 (mpfr_prec_t, mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_inits (mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_clears (mpfr_ptr, ...) __attribute__ ((sentinel));

 int
  mpfr_prec_round (mpfr_ptr, mpfr_prec_t, mpfr_rnd_t);
 int
  mpfr_can_round (mpfr_srcptr, mpfr_exp_t, mpfr_rnd_t, mpfr_rnd_t, mpfr_prec_t)
                                            ;
 mpfr_prec_t mpfr_min_prec (mpfr_srcptr);

 mpfr_exp_t mpfr_get_exp (mpfr_srcptr);
 int mpfr_set_exp (mpfr_ptr, mpfr_exp_t);
 mpfr_prec_t mpfr_get_prec (mpfr_srcptr);
 void mpfr_set_prec (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_prec_raw (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_default_prec (mpfr_prec_t);
 mpfr_prec_t mpfr_get_default_prec (void);

 int mpfr_set_d (mpfr_ptr, double, mpfr_rnd_t);
 int mpfr_set_flt (mpfr_ptr, float, mpfr_rnd_t);




 int
  mpfr_set_ld (mpfr_ptr, long double, mpfr_rnd_t);
 int
  mpfr_set_z (mpfr_ptr, mpz_srcptr, mpfr_rnd_t);
 int
  mpfr_set_z_2exp (mpfr_ptr, mpz_srcptr, mpfr_exp_t, mpfr_rnd_t);
 void mpfr_set_nan (mpfr_ptr);
 void mpfr_set_inf (mpfr_ptr, int);
 void mpfr_set_zero (mpfr_ptr, int);
 int
  mpfr_set_f (mpfr_ptr, mpf_srcptr, mpfr_rnd_t);
 int
  mpfr_get_f (mpf_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_set_si (mpfr_ptr, long, mpfr_rnd_t);
 int
  mpfr_set_ui (mpfr_ptr, unsigned long, mpfr_rnd_t);
 int
  mpfr_set_si_2exp (mpfr_ptr, long, mpfr_exp_t, mpfr_rnd_t);
 int
  mpfr_set_ui_2exp (mpfr_ptr,unsigned long,mpfr_exp_t,mpfr_rnd_t);
 int
  mpfr_set_q (mpfr_ptr, mpq_srcptr, mpfr_rnd_t);
 int
  mpfr_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t);
 int
  mpfr_init_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t)
                                              ;
 int
  mpfr_set4 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t, int);
 int
  mpfr_abs (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int
  mpfr_set (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_neg (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_signbit (mpfr_srcptr);
 int
  mpfr_setsign (mpfr_ptr, mpfr_srcptr, int, mpfr_rnd_t);
 int
  mpfr_copysign (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
# 364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
 int __gmpfr_set_sj (mpfr_t, intmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_sj_2exp (mpfr_t, intmax_t, intmax_t, mpfr_rnd_t);
 int __gmpfr_set_uj (mpfr_t, uintmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_uj_2exp (mpfr_t, uintmax_t, intmax_t, mpfr_rnd_t);
 intmax_t __gmpfr_mpfr_get_sj (mpfr_srcptr, mpfr_rnd_t);
 uintmax_t __gmpfr_mpfr_get_uj (mpfr_srcptr, mpfr_rnd_t);


 mpfr_exp_t mpfr_get_z_2exp (mpz_ptr, mpfr_srcptr);
 float mpfr_get_flt (mpfr_srcptr, mpfr_rnd_t);
 double mpfr_get_d (mpfr_srcptr, mpfr_rnd_t);




 long double mpfr_get_ld (mpfr_srcptr, mpfr_rnd_t)
                                                                  ;
 double mpfr_get_d1 (mpfr_srcptr);
 double mpfr_get_d_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                 ;
 long double mpfr_get_ld_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 long mpfr_get_si (mpfr_srcptr, mpfr_rnd_t);
 unsigned long mpfr_get_ui (mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 char*mpfr_get_str (char*, mpfr_exp_t*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_get_z (mpz_ptr z, mpfr_srcptr f, mpfr_rnd_t)
                                                         ;

 void mpfr_free_str (char *);

 int mpfr_urandom (mpfr_ptr, gmp_randstate_t, mpfr_rnd_t)
                                                           ;
 int mpfr_urandomb (mpfr_ptr, gmp_randstate_t);

 void mpfr_nextabove (mpfr_ptr);
 void mpfr_nextbelow (mpfr_ptr);
 void mpfr_nexttoward (mpfr_ptr, mpfr_srcptr);




 size_t __gmpfr_inp_str (mpfr_ptr, FILE*, int, mpfr_rnd_t)
                                                              ;
 size_t __gmpfr_out_str (FILE*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                           ;

 int __gmpfr_fprintf (FILE*, const char*, ...)
                                                    ;

 int mpfr_printf (const char*, ...);
 int mpfr_asprintf (char**, const char*, ...)
                                                     ;
 int mpfr_sprintf (char*, const char*, ...)
                                                    ;
 int mpfr_snprintf (char*, size_t, const char*, ...)
                                                                        ;
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
 int mpfr_pow (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_ui (mpfr_ptr, mpfr_srcptr, unsigned long int, mpfr_rnd_t)
                                                                             ;
 int mpfr_ui_pow_ui (mpfr_ptr, unsigned long int, unsigned long int, mpfr_rnd_t)
                                                                            ;
 int mpfr_ui_pow (mpfr_ptr, unsigned long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_pow_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;

 int mpfr_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                        ;
 int mpfr_sqrt_ui (mpfr_ptr, unsigned long, mpfr_rnd_t)
                                                           ;
 int mpfr_rec_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                            ;

 int mpfr_add (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_mul (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_div (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;

 int mpfr_add_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_sub_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_sub (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_div_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_div (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_sub (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_div_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_div (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_sub_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_sub (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_div_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_div (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_sqr (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_const_pi (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_log2 (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_euler (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_catalan (mpfr_ptr, mpfr_rnd_t);

 int mpfr_agm (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_log (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_log1p (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;

 int mpfr_exp (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_expm1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_eint (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_li2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);

 int mpfr_cmp (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp3 (mpfr_srcptr, mpfr_srcptr, int);
 int mpfr_cmp_d (mpfr_srcptr, double);
 int mpfr_cmp_ld (mpfr_srcptr, long double);
 int mpfr_cmpabs (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp_ui (mpfr_srcptr, unsigned long);
 int mpfr_cmp_si (mpfr_srcptr, long);
 int mpfr_cmp_ui_2exp (mpfr_srcptr, unsigned long, mpfr_exp_t)
                                                               ;
 int mpfr_cmp_si_2exp (mpfr_srcptr, long, mpfr_exp_t)
                                                               ;
 void mpfr_reldiff (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_eq (mpfr_srcptr, mpfr_srcptr, unsigned long)
                                                        ;
 int mpfr_sgn (mpfr_srcptr);

 int mpfr_mul_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_div_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_mul_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_div_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_mul_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;
 int mpfr_div_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;

 int mpfr_rint (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_round (mpfr_ptr, mpfr_srcptr);
 int mpfr_trunc (mpfr_ptr, mpfr_srcptr);
 int mpfr_ceil (mpfr_ptr, mpfr_srcptr);
 int mpfr_floor (mpfr_ptr, mpfr_srcptr);
 int mpfr_rint_round (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_trunc (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_ceil (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                             ;
 int mpfr_rint_floor (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_frac (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_modf (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_remquo (mpfr_ptr, long*, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_remainder (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;
 int mpfr_fmod (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;

 int mpfr_fits_ulong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_slong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_ushort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sshort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uintmax_p (mpfr_srcptr,mpfr_rnd_t);
 int mpfr_fits_intmax_p (mpfr_srcptr, mpfr_rnd_t);

 void mpfr_extract (mpz_ptr, mpfr_srcptr, unsigned int)
                                                              ;
 void mpfr_swap (mpfr_ptr, mpfr_ptr);
 void mpfr_dump (mpfr_srcptr);

 int mpfr_nan_p (mpfr_srcptr);
 int mpfr_inf_p (mpfr_srcptr);
 int mpfr_number_p (mpfr_srcptr);
 int mpfr_integer_p (mpfr_srcptr);
 int mpfr_zero_p (mpfr_srcptr);
 int mpfr_regular_p (mpfr_srcptr);

 int mpfr_greater_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_greaterequal_p (mpfr_srcptr, mpfr_srcptr)
                                                                   ;
 int mpfr_less_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessequal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessgreater_p (mpfr_srcptr,mpfr_srcptr);
 int mpfr_equal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_unordered_p (mpfr_srcptr, mpfr_srcptr);

 int mpfr_atanh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_acosh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asinh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cosh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_tanh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh_cosh (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;

 int mpfr_sech (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csch (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_coth (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_acos (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asin (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin_cos (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;
 int mpfr_cos (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_tan (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan2 (mpfr_ptr,mpfr_srcptr,mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_sec (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cot (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_hypot (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                      ;
 int mpfr_erf (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_erfc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cbrt (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_root (mpfr_ptr,mpfr_srcptr,unsigned long,mpfr_rnd_t);
 int mpfr_gamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lngamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lgamma (mpfr_ptr,int*,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_digamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta_ui (mpfr_ptr,unsigned long,mpfr_rnd_t);
 int mpfr_fac_ui (mpfr_ptr, unsigned long int, mpfr_rnd_t)
                                                          ;
 int mpfr_j0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_j1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_jn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;
 int mpfr_y0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_y1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_yn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;

 int mpfr_ai (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

 int mpfr_min (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_max (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_dim (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_mul_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_z (mpfr_srcptr, mpz_srcptr);

 int mpfr_mul_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_q (mpfr_srcptr, mpq_srcptr);

 int mpfr_cmp_f (mpfr_srcptr, mpf_srcptr);

 int mpfr_fma (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_fms (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sum (mpfr_ptr, mpfr_ptr *const, unsigned long, mpfr_rnd_t)
                                                                      ;

 void mpfr_free_cache (void);

 int mpfr_subnormalize (mpfr_ptr, int, mpfr_rnd_t)
                                                                 ;

 int mpfr_strtofr (mpfr_ptr, const char *, char **, int, mpfr_rnd_t)
                                                                          ;

 size_t mpfr_custom_get_size (mpfr_prec_t);
 void mpfr_custom_init (void *, mpfr_prec_t);
 void * mpfr_custom_get_significand (mpfr_srcptr);
 mpfr_exp_t mpfr_custom_get_exp (mpfr_srcptr);
 void mpfr_custom_move (mpfr_ptr, void *);
 void mpfr_custom_init_set (mpfr_ptr, int, mpfr_exp_t, mpfr_prec_t, void *)
                                                                              ;
 int mpfr_custom_get_kind (mpfr_srcptr);


}
# 149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 2



typedef long xip_fpo_prec_t;


typedef int xip_fpo_sign_t;


typedef long xip_fpo_exp_t;


typedef struct {
  xip_fpo_prec_t _xip_fpo_exp_prec;
  xip_fpo_prec_t _xip_fpo_mant_prec;
  xip_fpo_sign_t _xip_fpo_sign;
  xip_fpo_exp_t _xip_fpo_exp;
  mp_limb_t *_xip_fpo_d;
} __xip_fpo_struct;


typedef struct {
  xip_fpo_prec_t _xip_fpo_i_prec;
  xip_fpo_prec_t _xip_fpo_frac_prec;
  xint64 _xip_fpo_i;
  xint64 _xip_fpo_frac;
} __xip_fpo_fix_struct;


typedef __xip_fpo_struct xip_fpo_t[1];
typedef __xip_fpo_fix_struct xip_fpo_fix_t[1];


typedef __xip_fpo_struct *xip_fpo_ptr;
typedef const __xip_fpo_struct *xip_fpo_srcptr;
typedef __xip_fpo_fix_struct *xip_fpo_fix_ptr;
typedef const __xip_fpo_fix_struct *xip_fpo_fix_srcptr;
# 197 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int xip_fpo_exc_t;


extern "C" {


typedef struct xil_fpo_accum_state xil_fpo_accum_state;


 const char * xip_fpo_get_version (void);


 void xip_fpo_init2 (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_init2 (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_clear (xip_fpo_ptr);
 void xip_fpo_fix_clear (xip_fpo_fix_ptr);
 void xip_fpo_clears (xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_clears (xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_set_prec (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_set_prec (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 xip_fpo_prec_t xip_fpo_get_prec_mant (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_get_prec_exp (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_frac (xip_fpo_fix_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_int (xip_fpo_fix_ptr);


 xip_fpo_exc_t xip_fpo_set (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set (xip_fpo_fix_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui (xip_fpo_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_fix_set_ui (xip_fpo_fix_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_set_si (xip_fpo_ptr, long);
 xip_fpo_exc_t xip_fpo_fix_set_si (xip_fpo_fix_ptr, long);
 xip_fpo_exc_t xip_fpo_set_uj (xip_fpo_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_uj (xip_fpo_fix_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_set_sj (xip_fpo_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_sj (xip_fpo_fix_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_set_flt (xip_fpo_ptr, float);
 xip_fpo_exc_t xip_fpo_fix_set_flt (xip_fpo_fix_ptr, float);
 xip_fpo_exc_t xip_fpo_set_d (xip_fpo_ptr, double);
 xip_fpo_exc_t xip_fpo_fix_set_d (xip_fpo_fix_ptr, double);
 xip_fpo_exc_t xip_fpo_set_z (xip_fpo_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_z (xip_fpo_fix_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_set_q (xip_fpo_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_q (xip_fpo_fix_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_set_f (xip_fpo_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_f (xip_fpo_fix_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_set_fr (xip_fpo_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_fr (xip_fpo_fix_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui_2exp (xip_fpo_ptr, unsigned long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_si_2exp (xip_fpo_ptr, long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_uj_2exp (xip_fpo_ptr, uintmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_sj_2exp (xip_fpo_ptr, intmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_str (xip_fpo_ptr, const char *, int);
 xip_fpo_exc_t xip_fpo_fix_set_str (xip_fpo_fix_ptr, const char *, int);
 void xip_fpo_set_nan (xip_fpo_ptr);
 void xip_fpo_set_inf (xip_fpo_ptr, int);
 void xip_fpo_set_zero (xip_fpo_ptr, int);


 unsigned long xip_fpo_get_ui (xip_fpo_srcptr);
 unsigned long xip_fpo_fix_get_ui (xip_fpo_fix_srcptr);
 long xip_fpo_get_si (xip_fpo_srcptr);
 long xip_fpo_fix_get_si (xip_fpo_fix_srcptr);
 uintmax_t xip_fpo_get_uj (xip_fpo_srcptr);
 uintmax_t xip_fpo_fix_get_uj (xip_fpo_fix_srcptr);
 intmax_t xip_fpo_get_sj (xip_fpo_srcptr);
 intmax_t xip_fpo_fix_get_sj (xip_fpo_fix_srcptr);
 float xip_fpo_get_flt (xip_fpo_srcptr);
 float xip_fpo_fix_get_flt (xip_fpo_fix_srcptr);
 double xip_fpo_get_d (xip_fpo_srcptr);
 double xip_fpo_fix_get_d (xip_fpo_fix_srcptr);
 double xip_fpo_get_d_2exp (long *, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_get_z (mpz_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_z (mpz_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_f (mpf_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_f (mpf_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_fr (mpfr_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_fr (mpfr_ptr, xip_fpo_fix_srcptr);
 char * xip_fpo_get_str (char *, xip_fpo_exp_t *, int, int, xip_fpo_srcptr);
 char * xip_fpo_fix_get_str (char *, int, xip_fpo_fix_srcptr);
 void xip_fpo_free_str (char *);
 void xip_fpo_fix_free_str (char *);
 int xip_fpo_sizeinbase (xip_fpo_srcptr, int);
 int xip_fpo_fix_sizeinbase (xip_fpo_fix_srcptr, int);


 xip_fpo_exc_t xip_fpo_add (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_add_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_add_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_sub (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sub_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_sub_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_mul (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_mul_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_mul_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_fma (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fma_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fma_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_fms (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fms_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fms_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_div (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_div_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_div_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_rec (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_rec_flt (float *, float);
 xip_fpo_exc_t xip_fpo_rec_d (double *, double);
 xip_fpo_exc_t xip_fpo_abs (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_abs_flt (float *, float);
 xip_fpo_exc_t xip_fpo_abs_d (double *, double);
 xip_fpo_exc_t xip_fpo_log (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_log_flt (float *, float);
 xip_fpo_exc_t xip_fpo_log_d (double *, double);
 int xip_fpo_exp_array (xip_fpo_t * , xip_fpo_t * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_flt_array (float * , float * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_d_array (double * , double * , xip_fpo_exc_t *, unsigned long long);
 xip_fpo_exc_t xip_fpo_exp (xip_fpo_ptr , xip_fpo_srcptr );
 xip_fpo_exc_t xip_fpo_exp_flt (float * , float );
 xip_fpo_exc_t xip_fpo_exp_d (double * , double );
 struct xil_fpo_accum_state * xip_fpo_accum_create_state (int , int , int , int , int);
 void xip_fpo_accum_reset_state (struct xil_fpo_accum_state *);
 void xip_fpo_accum_destroy_state (struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample (xip_fpo_t, xip_fpo_t, bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_flt (float *, float , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_d (double *, double , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_sqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_sqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_recsqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_recsqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_recsqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_unordered (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_unordered_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_unordered_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_equal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_equal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_equal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_less (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_less_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_less_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_lessequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_lessequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_lessequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greater (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greater_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greater_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greaterequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greaterequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greaterequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_notequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_notequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_notequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_condcode (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_condcode_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_condcode_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_flttofix (xip_fpo_fix_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttofix_int_flt (int *, float);
 xip_fpo_exc_t xip_fpo_flttofix_int_d (int *, double);
 xip_fpo_exc_t xip_fpo_fixtoflt (xip_fpo_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_fixtoflt_flt_int (float *, int);
 xip_fpo_exc_t xip_fpo_fixtoflt_d_int (double *, int);
 xip_fpo_exc_t xip_fpo_flttoflt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_d (float *, double);
 xip_fpo_exc_t xip_fpo_flttoflt_d_flt (double *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_d_d (double *, double);


}
# 187 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h" 1
# 188 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h" 1
# 189 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2





inline float xil_fpo_add_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_add_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_add_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_add_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_sub_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_sub_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_sub_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_sub_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_mul_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_mul_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_mul_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_mul_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_div_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_div_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_div_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_div_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_rec_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_rec_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_rec_d(double a)
{
  double res_d = 0.0;


  xip_fpo_rec_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_sqrt_flt(float a)
{

  float res_flt = 0.0f;


  xip_fpo_sqrt_flt(&res_flt, a);

  return res_flt;
}

inline double xil_fpo_sqrt_d(double a)
{
  double res_d = 0.0;


  xip_fpo_sqrt_d(&res_d, a);

  return res_d;
}





inline float xil_fpo_recsqrt_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_recsqrt_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_recsqrt_d(double a)
{
  double res_d = 0.0;


  xip_fpo_recsqrt_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_abs_flt(float a)
{
  float res_flt = 0.0f;

  xip_fpo_abs_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_abs_d(double a)
{
  double res_d = 0.0;

  xip_fpo_abs_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_log_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_log_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_log_d(double a)
{
  double res_d = 0.0;


  xip_fpo_log_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_exp_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_exp_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_exp_d(double a)
{
  double res_d = 0.0;


  xip_fpo_exp_d(&res_d, a);
  return res_d;
}





inline int xil_fpo_unordered_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_unordered_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_unordered_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_unordered_d(&res_int, a, b);
  return res_int;
}






inline int xil_fpo_equal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_equal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_equal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_equal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_less_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_less_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_less_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_less_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_lessequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_lessequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_lessequal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_lessequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greater_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_greater_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greater_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_greater_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greaterequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_greaterequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greaterequal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_greaterequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_notequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_notequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_notequal_d(double a, double b)
{
  int res_int = 0;

  xip_fpo_notequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_condcode_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_condcode_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_condcode_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_condcode_d(&res_int, a, b);
  return res_int;
}




inline int xil_fpo_flttofix_int_flt(float a)
{
  int res_int = 0;


  xip_fpo_flttofix_int_flt(&res_int, a);
  return res_int;
}

inline int xil_fpo_flttofix_int_d(double a)
{
  int res_int = 0;


  xip_fpo_flttofix_int_d(&res_int, a);
  return res_int;
}

inline float xil_fpo_fixtoflt_flt_int(int a)
{
  float res_flt = 0.0f;


  xip_fpo_fixtoflt_flt_int(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_fixtoflt_d_int(int a)
{
  double res_d = 0.0;


  xip_fpo_fixtoflt_d_int(&res_d, a);
  return res_d;
}

inline float xil_fpo_flttoflt_flt_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_flttoflt_flt_flt(&res_flt, a);
  return res_flt;
}

inline float xil_fpo_flttoflt_flt_d(double a)
{
  float res_flt = 0.0f;


  xip_fpo_flttoflt_flt_d(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_flttoflt_d_flt(float a)
{
  double res_d = 0.0;


  xip_fpo_flttoflt_d_flt(&res_d, a);
  return res_d;
}

inline double xil_fpo_flttoflt_d_d(double a)
{
  double res_d = 0.0;


  xip_fpo_flttoflt_d_d(&res_d, a);
  return res_d;
}
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h" 1
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 129 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
# 69 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 1 3
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3

# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
namespace std
{
  namespace rel_ops
  {
 
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 2 3
# 78 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
namespace std
{



  template<typename _Tp>
    struct tuple_size;



  template<typename _Tp>
    struct tuple_size<const _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;


  template<typename>
    struct __is_tuple_like_impl : false_type
    { };




  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



}
# 130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 210 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
namespace std
{

# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 552 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 581 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
namespace std
{

# 83 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 1 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
       
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
# 158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 314 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1569 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 2 3

namespace std
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 260 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 344 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }


}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3




namespace std
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
# 598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 697 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 731 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 794 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 822 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 891 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 924 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 990 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1020 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1175 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1466 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1646 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1732 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1746 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1781 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1797 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2018 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2209 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2242 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2275 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2569 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2821 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2865 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2900 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2949 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2981 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3049 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3081 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3131 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3204 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3247 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3271 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3296 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3317 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3397 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3425 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3537 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3661 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3688 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3716 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







# 3761 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
# 3782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3806 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3837 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 3909 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3934 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 3959 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 3982 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4022 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4061 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4129 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4233 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4265 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4328 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 4364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4404 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4437 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4512 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4545 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4619 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4695 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4725 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4786 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4836 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 4900 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 4934 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5002 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5051 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5121 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5291 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5369 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5419 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5497 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5536 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5561 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 2 3
# 211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 2 3
# 214 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 1 3
# 21 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
extern "C" {
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;
       

  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);
       
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);







  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;
# 187 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 2 3
# 23 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char *_Dst, rsize_t _SizeInBytes, const char *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcpy_s(char (&_Dest)[__size], const char * _Source) { return strcpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncpy_s(char (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return strncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncpy_s_l(char (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _strncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } };
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char *_Dst, rsize_t _SizeInBytes, const char * _Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcat_s(char (&_Dest)[__size], const char * _Source) { return strcat_s(_Dest,__size,_Source); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
# 82 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
}
# 191 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 2 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 2 3
# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
namespace std
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
# 216 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 1 3
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
       
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
namespace std
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(__is_nothrow_swappable<_Tp>::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 2 3


namespace std
{







  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };

  template<typename... _Elements>
    class tuple;



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements)),
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };






  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 2 3




namespace std
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*) noexcept;


  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };

  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct _Unwrap
    {
      using type = _Tp&&;


      static constexpr _Tp&&
      _S_fwd(_Tp& __t) noexcept { return static_cast<_Tp&&>(__t); }
    };

  template<typename _Tp, typename _Up>
    struct _Unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;


      static _Up&
      _S_fwd(const _Tp& __t) noexcept { __t.get(); }
    };



  template<typename _Tp>
    inline typename _Unwrap<_Tp>::type
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return _Unwrap<_Tp>::_S_fwd(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    noexcept(noexcept(std::forward<_Fn>(__f)(std::forward<_Args>(__args)...)))
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept(
   (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...)))
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept(
   ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...)))
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memobj_ref, _MemFun&& __f, _Tp&& __t)
    noexcept(noexcept(__invfwd<_Tp>(__t).*__f))
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memobj_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept((*std::forward<_Tp>(__t)).*__f))
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    inline typename result_of<_Callable&&(_Args&&...)>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    {
      using __result_of = result_of<_Callable&&(_Args&&...)>;
      using __type = typename __result_of::type;
      using __tag = typename __result_of::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }
# 281 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp, typename = __void_t<>> struct __has_argument_type : false_type { }; template<typename _Tp> struct __has_argument_type<_Tp, __void_t<typename _Tp::argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_first_argument_type : false_type { }; template<typename _Tp> struct __has_first_argument_type<_Tp, __void_t<typename _Tp::first_argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_second_argument_type : false_type { }; template<typename _Tp> struct __has_second_argument_type<_Tp, __void_t<typename _Tp::second_argument_type>> : true_type { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }



  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 578 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };




  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 654 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 669 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 680 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };

 





  namespace placeholders
  {
 




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
 
  }

 






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



 template<std::size_t __i, typename _Tuple>
   using _Safe_tuple_element_t
     = typename enable_if<(__i < tuple_size<_Tuple>::value),
     tuple_element<__i, _Tuple>>::type::type;
# 770 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(std::get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   using __type
     = __tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>;
   return std::forward<__type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static constexpr const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static constexpr _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static constexpr type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor&>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename _Tp, typename... _Up>
        explicit
        _Bind_simple(_Tp&& __f, _Up&&... __args)
        : _M_bound(std::forward<_Tp>(__f), std::forward<_Up>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:
      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
 }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      template<typename _Func,
        typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 1888 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function(const function& __x);
# 1897 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
# 1920 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 1937 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 1955 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 1969 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 1997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 2023 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 2051 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 2064 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      _Res operator()(_ArgTypes... __args) const;
# 2077 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      const type_info& target_type() const noexcept;
# 2088 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor> _Functor* target() noexcept;


      template<typename _Functor> const _Functor* target() const noexcept;


    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
# 2200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 2218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 2236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}
# 224 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
 
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
class half;



 namespace detail
 {
# 311 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<bool,typename T,typename> struct conditional { typedef T type; };
  template<typename T,typename F> struct conditional<false,T,F> { typedef F type; };


  template<bool> struct bool_type {};
  typedef bool_type<true> true_type;
  typedef bool_type<false> false_type;


  template<typename> struct is_float : false_type {};
  template<typename T> struct is_float<const T> : is_float<T> {};
  template<typename T> struct is_float<volatile T> : is_float<T> {};
  template<typename T> struct is_float<const volatile T> : is_float<T> {};
  template<> struct is_float<float> : true_type {};
  template<> struct is_float<double> : true_type {};
  template<> struct is_float<long double> : true_type {};




  typedef std::uint_least16_t uint16;


  typedef std::uint_least32_t uint32;


  typedef std::int_fast32_t int17;
# 350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  struct binary_t {};


  constexpr binary_t binary = binary_t();



  struct expr
  {


   explicit constexpr expr(float f) : value_(f) {}



   constexpr operator float() const { return value_; }

  private:

   float value_;
  };





  template<typename T,typename,typename=void,typename=void> struct enable {};
  template<typename T> struct enable<T,half,void,void> { typedef T type; };
  template<typename T> struct enable<T,float,void,void> { typedef T type; };
  template<typename T> struct enable<T,double,void,void> { typedef T type; };
  template<typename T> struct enable<T,long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long,void,void> { typedef T type; };
  template<typename T> struct enable<T,int,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned int,void,void> { typedef T type; };
  template<typename T> struct enable<T,short,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned short,void,void> { typedef T type; };
  template<typename T> struct enable<T,char,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned char,void,void> { typedef T type; };
  template<typename T> struct enable<T,expr,void,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,void> { typedef T type; };
  template<typename T> struct enable<T,half,long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long,void> { typedef T type; };
  template<typename T> struct enable<T,half,int,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned int,void> { typedef T type; };
  template<typename T> struct enable<T,half,short,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned short,void> { typedef T type; };
  template<typename T> struct enable<T,half,char,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned char,void> { typedef T type; };
  template<typename T> struct enable<T,float,half,void> { typedef float type; };
  template<typename T> struct enable<T,half,float,void> { typedef float type; };
  template<typename T> struct enable<T,double,half,void> { typedef double type; };
  template<typename T> struct enable<T,half,double,void> { typedef double type; };
  template<typename T> struct enable<T,half,expr,void> { typedef T type; };
  template<typename T> struct enable<T,expr,half,void> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,half> { typedef T type; };
  template<typename T> struct enable<T,half,half,expr> { typedef T type; };
  template<typename T> struct enable<T,half,expr,half> { typedef T type; };
  template<typename T> struct enable<T,half,expr,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,half,half> { typedef T type; };
  template<typename T> struct enable<T,expr,half,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,half> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,expr> { typedef T type; };






  template<typename T,typename U> struct result : enable<expr,T,U> {};
  template<> struct result<half,half> { typedef half type; };
# 434 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T> bool builtin_isinf(T arg)
  {

   return std::isinf(arg);





  }






  template<typename T> bool builtin_isnan(T arg)
  {

   return std::isnan(arg);





  }






  template<typename T> bool builtin_signbit(T arg)
  {

   return std::signbit(arg);



  }
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<std::float_round_style R> uint16 float2half_impl(float value, true_type)
  {

   static_assert(std::numeric_limits<float>::is_iec559, "float to half conversion needs IEEE 754 conformant 'float' type");
   static_assert(sizeof(uint32)==sizeof(float), "float to half conversion needs unsigned integer type of exactly the size of a 'float'");

   static const uint16 base_table[512] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
    0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
    0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
    0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
    0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };
   static const unsigned char shift_table[512] = {
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };
   uint32 bits;
   std::memcpy(&bits, &value, sizeof(float));
   uint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);
   if(R == std::round_to_nearest)
    hbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)

     & (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)

    ;
   else if(R == std::round_toward_zero)
    hbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];
   else if(R == std::round_toward_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&
     ((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));
   else if(R == std::round_toward_neg_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&
     ((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half_impl(float value, false_type)
  {
   uint16 hbits = builtin_signbit(value) << 15;
   if(value == 0.0f)
    return hbits;
   if(builtin_isnan(value))
    return hbits | 0x7FFF;
   if(builtin_isinf(value))
    return hbits | 0x7C00;
   int exp;
   std::frexp(value, &exp);
   if(exp > 16)
   {
    if(R == std::round_toward_zero)
     return hbits | 0x7BFF;
    else if(R == std::round_toward_infinity)
     return hbits | 0x7C00 - (hbits>>15);
    else if(R == std::round_toward_neg_infinity)
     return hbits | 0x7BFF + (hbits>>15);
    return hbits | 0x7C00;
   }
   if(exp < -13)
    value = std::ldexp(value, 24);
   else
   {
    value = std::ldexp(value, 11-exp);
    hbits |= ((exp+14)<<10);
   }
   int ival = static_cast<int>(value);
   hbits |= static_cast<uint16>(std::abs(ival)&0x3FF);
   if(R == std::round_to_nearest)
   {
    float diff = std::abs(value-static_cast<float>(ival));

     hbits += (diff>0.5f) | ((diff==0.5f)&hbits);



   }
   else if(R == std::round_toward_infinity)
    hbits += value > static_cast<float>(ival);
   else if(R == std::round_toward_neg_infinity)
    hbits += value < static_cast<float>(ival);
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half(float value)
  {
   return float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)
  {
   if(S)
    value = -value;
   uint16 bits = S << 15;
   if(value > 65504)
   {
    if(R == std::round_toward_infinity)
     bits |= 0x7C00 - S;
    else if(R == std::round_toward_neg_infinity)
     bits |= 0x7BFF + S;
    else
     bits |= 0x7BFF + (R!=std::round_toward_zero);
   }
   else if(value)
   {
    unsigned int m = value, exp = 25;
    for(; m<0x400; m<<=1,--exp) ;
    for(; m>0x7FF; m>>=1,++exp) ;
    bits |= (exp<<10) | (m&0x3FF);
    if(exp > 25)
    {
     if(R == std::round_to_nearest)
      bits += (value>>(exp-26)) & 1

       & (((((1<<(exp-26))-1)&value)!=0)|bits)

      ;
     else if(R == std::round_toward_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & !S;
     else if(R == std::round_toward_neg_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & S;
    }
   }
   return bits;
  }






  template<std::float_round_style R,typename T> uint16 int2half(T value)
  {
   return (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);
  }





  inline float half2float_impl(uint16 value, true_type)
  {

   static_assert(std::numeric_limits<float>::is_iec559, "half to float conversion needs IEEE 754 conformant 'float' type");
   static_assert(sizeof(uint32)==sizeof(float), "half to float conversion needs unsigned integer type of exactly the size of a 'float'");

   static const uint32 mantissa_table[2048] = {
    0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
    0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
    0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
    0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
    0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
    0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
    0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
    0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
    0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
    0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
    0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
    0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
    0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
    0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
    0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
    0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
    0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
    0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
    0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
    0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
    0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
    0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
    0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
    0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
    0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
    0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
    0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
    0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
    0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
    0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
    0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
    0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
    0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
    0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
    0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
    0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
    0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
    0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
    0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
    0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
    0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
    0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
    0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
    0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
    0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
    0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
    0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
    0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
    0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
    0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
    0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
    0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
    0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
    0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
    0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
    0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
    0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
    0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
    0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
    0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
    0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
    0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
    0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
    0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
    0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
    0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
    0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
    0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
    0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
    0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
    0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
    0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
    0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
    0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
    0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
    0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
    0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
    0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
    0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
    0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
    0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
    0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
    0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
    0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
    0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
    0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
    0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
    0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
    0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
    0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
    0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
    0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
    0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
    0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
    0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
    0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
    0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
    0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
    0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
    0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
    0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
    0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
    0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
    0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
    0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
    0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
    0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
    0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
    0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
    0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
    0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
    0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
    0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
    0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
    0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
    0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
    0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
    0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
    0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
    0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
    0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
    0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
    0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
    0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
    0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
    0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
    0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
    0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
   static const uint32 exponent_table[64] = {
    0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
    0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
    0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
    0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
   static const unsigned short offset_table[64] = {
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
   uint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];


   float out;
   std::memcpy(&out, &bits, sizeof(float));
   return out;
  }




  inline float half2float_impl(uint16 value, false_type)
  {
   float out;
   int abs = value & 0x7FFF;
   if(abs > 0x7C00)
    out = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;
   else if(abs == 0x7C00)
    out = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();
   else if(abs > 0x3FF)
    out = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);
   else
    out = std::ldexp(static_cast<float>(abs), -24);
   return (value&0x8000) ? -out : out;
  }




  inline float half2float(uint16 value)
  {
   return half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   if(e >= 0x7C00)
    return (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
   if(e < 0x3800)
   {
    if(R == std::round_toward_infinity)
     return T(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     return -T(value>0x8000);
    return T();
   }
   int17 m = (value&0x3FF) | 0x400;
   e >>= 10;
   if(e < 25)
   {
    if(R == std::round_indeterminate || R == std::round_toward_zero)
     m >>= 25 - e;
    else
    {
     if(R == std::round_to_nearest)
      m += (1<<(24-e)) - (~(m>>(25-e))&E);
     else if(R == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(25-e))-1U);
     else if(R == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(25-e))-1U);
     m >>= 25 - e;
    }
   }
   else
    m <<= e - 25;


   return static_cast<T>((value&0x8000) ? -m : m);
  }






  template<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,1,T>(value); }





  template<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }






  template<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   uint16 result = value;
   if(e < 0x3C00)
   {
    result &= 0x8000;
    if(R == std::round_to_nearest)
     result |= 0x3C00U & -(e>=(0x3800+E));
    else if(R == std::round_toward_infinity)
     result |= 0x3C00U & -(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     result |= 0x3C00U & -(value>0x8000);
   }
   else if(e < 0x6400)
   {
    e = 25 - (e>>10);
    unsigned int mask = (1<<e) - 1;
    if(R == std::round_to_nearest)
     result += (1<<(e-1)) - (~(result>>e)&E);
    else if(R == std::round_toward_infinity)
     result += mask & ((value>>15)-1);
    else if(R == std::round_toward_neg_infinity)
     result += mask & -(value>>15);
    result &= ~mask;
   }
   return result;
  }





  template<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,1>(value); }




  inline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }


  struct functions;
  template<typename> struct unary_specialized;
  template<typename,typename> struct binary_specialized;
  template<typename,typename,std::float_round_style> struct half_caster;
 }
# 979 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
 class half
 {
  friend struct detail::functions;
  friend struct detail::unary_specialized<half>;
  friend struct detail::binary_specialized<half,half>;
  template<typename,typename,std::float_round_style> friend struct detail::half_caster;
  friend struct std::numeric_limits<half>;

  friend struct std::hash<half>;


 public:



  constexpr half() : data_() {}




  half(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }



  half(float rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }


  template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
  half(const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& rhs) {
   std::cout << "WARNING: explicit method ap_fixed::to_half() should be used to convert ap_fixed to half." << std::endl;
   *this = rhs.to_half();
  }



  operator float() const {



            return xip_fpo_half_get_flt();

        }





  half& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }





  template<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this = *this + rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this = *this - rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this = *this * rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this = *this / rhs; }
# 1097 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  half& operator++() { return *this += 1.0f; }



  half& operator--() { return *this -= 1.0f; }



  half operator++(int) { half out(*this); ++*this; return out; }



  half operator--(int) { half out(*this); --*this; return out; }



        detail::uint16 get_bits() { return data_; }



        void set_bits(detail::uint16 bits) { data_ = bits; }





        xip_fpo_exc_t xip_fpo_get_data(xip_fpo_ptr op) const {
            int exc = 0;
            op->_xip_fpo_sign = ((data_ & 0x8000) ? -1 : 1);
            op->_xip_fpo_exp = ((data_ & 0x7C00) >> 10) - 14;
            *(op->_xip_fpo_d) = ((mp_limb_t)(data_ & 0x3FF) + (mp_limb_t)(0x400)) << (8*sizeof(*(op->_xip_fpo_d)) - 11);
            if ((data_ & 0x7C00) == 0) {
                exc |= 0x1;
                xip_fpo_set_zero(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) == 0x7C00) {
                exc |= 0x2;
                xip_fpo_set_inf(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) > 0x7C00) {
                exc |= 0x4;
                xip_fpo_set_nan(op);
            }
            return exc;
        }


        float xip_fpo_half_get_flt() const {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_exc_t exc = xip_fpo_get_data(op);
            float res;
            if (exc & 0x1) {
                res = (op->_xip_fpo_sign > 0 ? 0.0f : -0.0f);
            } else if (exc & 0x2) {
                res = (op->_xip_fpo_sign > 0 ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity());
            } else if (exc & 0x4) {
                res = std::numeric_limits<float>::quiet_NaN();
            } else {
                res = xip_fpo_get_flt(op);
            }
            xip_fpo_clear(op);
            return res;
        }



        void xip_fpo_set_data(xip_fpo_ptr op) {
            mpfr_t fr;
            (fr)->_mpfr_prec = (op)->_xip_fpo_mant_prec; (fr)->_mpfr_sign = (op)->_xip_fpo_sign; (fr)->_mpfr_exp = (op)->_xip_fpo_exp; (fr)->_mpfr_d = (op)->_xip_fpo_d;;
            data_ = 0;
            data_ |= (op->_xip_fpo_sign == 1 ? 0 : 1) << 15;
            if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1)))) {
                data_ &= 0x8000;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3)))) {
                data_ |= 0x7C00;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2)))) {
                data_ |= 0x7E00;
            } else {
                data_ |= (op->_xip_fpo_exp + 14) << 10;
                data_ |= (*(op->_xip_fpo_d) << 1) >> (8*sizeof(*(op->_xip_fpo_d)) - 10);
            }
        }


        void xip_fpo_half_set_flt(float rhs) {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_set_flt(op, rhs);
            xip_fpo_set_data(op);
            xip_fpo_clear(op);
        }


        private:

  static const std::float_round_style round_style = (std::float_round_style)(1);



  constexpr half(detail::binary_t, detail::uint16 bits) : data_(bits) {}


  detail::uint16 data_;
 };



    template<typename F>
    half math_function_1arg(F f, half x) {
        half res;
        xip_fpo_t rop, xop;
        xip_fpo_inits2(5, 11, rop, xop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        f(rop, xop);
        res.xip_fpo_set_data(rop);
        xip_fpo_clears(rop, xop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    half binary_operator(F f, half x, half y) {
        half res;
        xip_fpo_t op, xop, yop;
        xip_fpo_inits2(5, 11, op, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(op, xop, yop);
        res.xip_fpo_set_data(op);
        xip_fpo_clears(op, xop, yop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    bool binary_operator_compare(F f, half x, half y) {
        int res;
        xip_fpo_t xop, yop;
        xip_fpo_inits2(5, 11, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(&res, xop, yop);
        xip_fpo_clears(xop, yop, (xip_fpo_ptr)0);
        return res;
    }
# 1248 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
 namespace literal
 {





  inline half operator "" _h(long double value) { return half(static_cast<float>(value)); }
 }



 namespace detail
 {

  struct functions
  {
# 1273 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half plus(T1 x, T2 y) { return binary_operator(xip_fpo_add, x, y); }
   static float plus(float x, half y) { return xil_fpo_add_flt(x,y); }
   static float plus(half x, float y) { return xil_fpo_add_flt(x,y); }
   static double plus(double x, half y) { return xil_fpo_add_d(x,y); }
   static double plus(half x, double y) { return xil_fpo_add_d(x,y); }
# 1289 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half minus(T1 x, T2 y) { return binary_operator(xip_fpo_sub, x, y); }
   static float minus(float x, half y) { return xil_fpo_sub_flt(x,y); }
   static float minus(half x, float y) { return xil_fpo_sub_flt(x,y); }
   static double minus(double x, half y) { return xil_fpo_sub_d(x,y); }
   static double minus(half x, double y) { return xil_fpo_sub_d(x,y); }
# 1305 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half multiplies(T1 x, T2 y) { return binary_operator(xip_fpo_mul, x, y); }
   static float multiplies(float x, half y) { return xil_fpo_mul_flt(x,y); }
   static float multiplies(half x, float y) { return xil_fpo_mul_flt(x,y); }
   static double multiplies(double x, half y) { return xil_fpo_mul_d(x,y); }
   static double multiplies(half x, double y) { return xil_fpo_mul_d(x,y); }
# 1321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half divides(T1 x, T2 y) { return binary_operator(xip_fpo_div, x, y); }
   static float divides(float x, half y) { return xil_fpo_div_flt(x,y); }
   static float divides(half x, float y) { return xil_fpo_div_flt(x,y); }
   static double divides(double x, half y) { return xil_fpo_div_d(x,y); }
   static double divides(half x, double y) { return xil_fpo_div_d(x,y); }






   template<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }





   template<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)
   {
    float f;
    if(in >> f)
     arg = f;
    return in;
   }





   static expr fmod(float x, float y) { return expr(std::fmod(x, y)); }





   static expr remainder(float x, float y)
   {

    return expr(std::remainder(x, y));
# 1381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }






   static expr remquo(float x, float y, int *quo)
   {

    return expr(std::remquo(x, y, quo));
# 1428 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }





   static expr fdim(float x, float y)
   {

    return expr(std::fdim(x, y));



   }

                        static expr maxmag(float x, float y)
                        {
    if (fabs(y)>fabs(x)) return expr(y);
    else return expr(x);
                        }

                        static expr minmag(float x, float y)
                        {
    if (fabs(y)<fabs(x)) return expr(y);
    else return expr(x);
                        }






   static expr fma(float x, float y, float z)
   {



    return expr(x*y+z);

   }



   static half nanh(const char*) { return half(binary, 0x7FFF); }




   static expr exp(float arg) { return expr(std::exp(arg)); }




   static expr expm1(float arg)
   {

    return expr(std::expm1(arg));



   }




   static expr exp2(float arg)
   {

    return expr(std::exp2(arg));



   }




   static expr log(float arg) { return expr(std::log(arg)); }




   static expr log10(float arg) { return expr(std::log10(arg)); }




   static expr log1p(float arg)
   {

    return expr(std::log1p(arg));



   }




   static expr log2(float arg)
   {

    return expr(std::log2(arg));



   }

                        static expr logb(float arg)
                        {

                                return expr(std::logb(arg));



                        }




   static expr sqrt(float arg) { return expr(std::sqrt(arg)); }




   static expr cbrt(float arg)
   {

    return expr(std::cbrt(arg));






   }





   static expr hypot(float x, float y)
   {

    return expr(std::hypot(x, y));




   }





   static expr pow(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr powr(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr pown(float base, int exp) { return expr(std::pow(base, exp)); }
   static expr rootn(float base, int exp) { return expr(std::pow(base, float(float(1)/float(exp)))); }




   static expr sin(float arg) { return expr(std::sin(arg)); }




   static expr cos(float arg) { return expr(std::cos(arg)); }




   static expr tan(float arg) { return expr(std::tan(arg)); }




   static expr asin(float arg) { return expr(std::asin(arg)); }




   static expr acos(float arg) { return expr(std::acos(arg)); }




   static expr atan(float arg) { return expr(std::atan(arg)); }





   static expr atan2(float x, float y) { return expr(std::atan2(x, y)); }




   static expr sinh(float arg) { return expr(std::sinh(arg)); }




   static expr cosh(float arg) { return expr(std::cosh(arg)); }




   static expr tanh(float arg) { return expr(std::tanh(arg)); }




   static expr asinh(float arg)
   {

    return expr(std::asinh(arg));



   }




   static expr acosh(float arg)
   {

    return expr(std::acosh(arg));



   }




   static expr atanh(float arg)
   {

    return expr(std::atanh(arg));



   }




   static expr erf(float arg)
   {

    return expr(std::erf(arg));



   }




   static expr erfc(float arg)
   {

    return expr(std::erfc(arg));



   }




   static expr lgamma(float arg)
   {

    return expr(std::lgamma(arg));
# 1721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }




   static expr tgamma(float arg)
   {

    return expr(std::tgamma(arg));
# 1748 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }




   static half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }




   static half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }




   static half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }




   static half round(half arg) { return half(binary, round_half_up(arg.data_)); }




   static long lround(half arg) { return detail::half2int_up<long>(arg.data_); }




   static half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }




   static long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }





   static long long llround(half arg) { return detail::half2int_up<long long>(arg.data_); }




   static long long llrint(half arg) { return detail::half2int<half::round_style,long long>(arg.data_); }






   static half frexp(half arg, int *exp)
   {
    unsigned int m = arg.data_ & 0x7FFF;
    if(m >= 0x7C00 || !m)
     return *exp = 0, arg;
    int e = m >> 10;
    if(!e)
     for(m<<=1; m<0x400; m<<=1,--e) ;
    return *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));
   }





   static half modf(half arg, half *iptr)
   {
    unsigned int e = arg.data_ & 0x7C00;
    if(e > 0x6000)
     return *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);
    if(e < 0x3C00)
     return iptr->data_ = arg.data_ & 0x8000, arg;
    e >>= 10;
    unsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;
    iptr->data_ = arg.data_ & ~mask;
    if(!m)
     return half(binary, arg.data_&0x8000);
    for(; m<0x400; m<<=1,--e) ;
    return half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));
   }





   static half scalbln(half arg, long exp)
   {
    long e = arg.data_ & 0x7C00;
    if(e == 0x7C00)
     return arg;
    unsigned int m = arg.data_ & 0x3FF;
    if(e >>= 10)
     m |= 0x400;
    else
    {
     if(!m)
      return arg;
     for(m<<=1; m<0x400; m<<=1,--e) ;
    }
    e += exp;
    uint16 value = arg.data_ & 0x8000;
    if(e > 30)
    {
     if(half::round_style == std::round_toward_zero)
      value |= 0x7BFF;
     else if(half::round_style == std::round_toward_infinity)
      value |= 0x7C00 - (value>>15);
     else if(half::round_style == std::round_toward_neg_infinity)
      value |= 0x7BFF + (value>>15);
     else
      value |= 0x7C00;
    }
    else if(e > 0)
     value |= (e<<10) | (m&0x3FF);
    else if(e > -11)
    {
     if(half::round_style == std::round_to_nearest)
     {
      m += 1 << -e;

      m -= (m>>(1-e)) & 1;

     }
     else if(half::round_style == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(1-e))-1U);
     else if(half::round_style == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(1-e))-1U);
     value |= m >> (1-e);
    }
    else if(half::round_style == std::round_toward_infinity)
     value |= ((value>>15)-1) & 1;
    else if(half::round_style == std::round_toward_neg_infinity)
     value |= value >> 15;
    return half(binary, value);
   }




   static int ilogb(half arg)
   {
    int exp = arg.data_ & 0x7FFF;
    if(!exp)
     return 
# 1894 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           ((int)0x80000000)
# 1894 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                    ;
    if(exp < 0x7C00)
    {
     if(!(exp>>=10))
      for(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;
     return exp - 15;
    }
    if(exp > 0x7C00)
     return 
# 1902 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           ((int)0x80000000)
# 1902 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                      ;
    return 0x7fffffff;
   }




   static half nextafter(half from, half to)
   {
    uint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;
    if(fabs > 0x7C00)
     return from;
    if(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))
     return to;
    if(!fabs)
     return half(binary, (to.data_&0x8000)+1);
    bool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) <
     (signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);
   }





   static half nexttoward(half from, long double to)
   {
    if(isnan(from))
     return from;
    long double lfrom = static_cast<long double>(from);
    if(builtin_isnan(to) || lfrom == to)
     return half(static_cast<float>(to));
    if(!(from.data_&0x7FFF))
     return half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);
   }





   static half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }





   static int fpclassify(half arg)
   {
    unsigned int abs = arg.data_ & 0x7FFF;
    if(abs > 0x7C00)
     return 
# 1953 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           0x0100
# 1953 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                 ;
    if(abs == 0x7C00)
     return 
# 1955 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           (0x0100 | 0x0400)
# 1955 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                      ;
    if(abs > 0x3FF)
     return 
# 1957 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           0x0400
# 1957 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                    ;
    return abs ? 
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
                (0x0400 | 0x4000) 
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                             : 
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
                               0x4000
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                                      ;
   }





   static bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }





   static bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }





   static bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }





   static bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }





   static bool signbit(half arg) { return (arg.data_&0x8000) != 0; }
# 1999 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_equal, x, y); }
   static bool isequal(float x, half y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(half x, float y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(double x, half y) { return xil_fpo_equal_d(x,y); }
   static bool isequal(half x, double y) { return xil_fpo_equal_d(x,y); }
# 2015 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isnotequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_notequal, x, y); }
   static bool isnotequal(float x, half y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(half x, float y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(double x, half y) { return xil_fpo_notequal_d(x,y); }
   static bool isnotequal(half x, double y) { return xil_fpo_notequal_d(x,y); }
# 2032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreater(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greater, x, y); }
   static bool isgreater(float x, half y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(half x, float y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(double x, half y) { return xil_fpo_greater_d(x,y); }
   static bool isgreater(half x, double y) { return xil_fpo_greater_d(x,y); }
# 2049 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreaterequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greaterequal, x, y); }
   static bool isgreaterequal(float x, half y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(half x, float y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(double x, half y) { return xil_fpo_greaterequal_d(x,y); }
   static bool isgreaterequal(half x, double y) { return xil_fpo_greaterequal_d(x,y); }
# 2066 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isless(T1 x, T2 y) { return binary_operator_compare(xip_fpo_less, x, y); }
   static bool isless(float x, half y) { return xil_fpo_less_flt(x,y); }
   static bool isless(half x, float y) { return xil_fpo_less_flt(x,y); }
   static bool isless(double x, half y) { return xil_fpo_less_d(x,y); }
   static bool isless(half x, double y) { return xil_fpo_less_d(x,y); }
# 2083 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool islessequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_lessequal, x, y); }
   static bool islessequal(float x, half y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(half x, float y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(double x, half y) { return xil_fpo_lessequal_d(x,y); }
   static bool islessequal(half x, double y) { return xil_fpo_lessequal_d(x,y); }







   static bool islessgreater(half x, half y)
   {
    if(isnan(x) || isnan(y))
     return false;



                return isless(x, y) || isgreater(x, y);
   }






   static bool isunordered(half x, half y) { return isnan(x) || isnan(y); }

  private:
   static double erf(double arg)
   {
    if(builtin_isinf(arg))
     return (arg<0.0) ? -1.0 : 1.0;
    double x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;
    double value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));
    return builtin_signbit(arg) ? -value : value;
   }

   static double lgamma(double arg)
   {
    double v = 1.0;
    for(; arg<8.0; ++arg) v *= arg;
    double w = 1.0 / (arg * arg);
    return (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+
     -0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+
     -5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+
     -0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg +
     0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);
   }
  };



  template<typename T> struct unary_specialized
  {



   static constexpr half negate(half arg) { return half(binary, arg.data_^0x8000); }




   static half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }
  };
  template<> struct unary_specialized<expr>
  {
   static constexpr expr negate(float arg) { return expr(-arg); }
   static expr fabs(float arg) { return expr(std::fabs(arg)); }
  };




  template<typename T,typename U> struct binary_specialized
  {




   static expr fmin(float x, float y)
   {

    return expr(std::fmin(x, y));







   }





   static expr fmax(float x, float y)
   {

    return expr(std::fmax(x, y));







   }
  };
  template<> struct binary_specialized<half,half>
  {
   static half fmin(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
   static half fmax(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
  };







  template<typename T,typename U,std::float_round_style R=(std::float_round_style)(1)> struct half_caster {};
  template<typename U,std::float_round_style R> struct half_caster<half,U,R>
  {




   typedef half type;
   static half cast(U arg) { return cast_impl(arg, is_float<U>()); };

  private:
   static half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }
   static half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,half,R>
  {




   typedef T type;
   template<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }

  private:
   static T cast_impl(float arg, true_type) { return static_cast<T>(arg); }
   static T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};
  template<std::float_round_style R> struct half_caster<half,half,R>
  {
   typedef half type;
   static half cast(half arg) { return arg; }
  };
  template<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};
# 2269 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }
# 2317 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }
# 2327 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }
# 2337 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }
# 2347 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }





  template<typename T> constexpr typename enable<T,T>::type operator+(T arg) { return arg; }




  template<typename T> constexpr typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }
# 2368 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type
   operator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }





  template<typename charT,typename traits> std::basic_istream<charT,traits>&
   operator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half abs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }





  inline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }






  inline expr fmod(half x, half y) { return functions::fmod(x, y); }
  inline expr fmod(half x, expr y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, half y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, expr y) { return functions::fmod(x, y); }






  inline expr remainder(half x, half y) { return functions::remainder(x, y); }
  inline expr remainder(half x, expr y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, half y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, expr y) { return functions::remainder(x, y); }







  inline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }







  inline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }

                inline expr mad(half x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, expr z) { return functions::fma(x, y, z); }






  inline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }
  inline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }
  inline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }
  inline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }






  inline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }
  inline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }
  inline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }
  inline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }






  inline expr fdim(half x, half y) { return functions::fdim(x, y); }
  inline expr fdim(half x, expr y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, half y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, expr y) { return functions::fdim(x, y); }

                inline expr maxmag(half x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(half x, expr y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, expr y) { return functions::maxmag(x, y); }

                inline expr minmag(half x, half y) { return functions::minmag(x, y); }
                inline expr minmag(half x, expr y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, half y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, expr y) { return functions::minmag(x, y); }




  inline half nanh(const char *arg) { return functions::nanh(arg); }
# 2504 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr exp(half arg) { return functions::exp(arg); }
  inline expr exp(expr arg) { return functions::exp(arg); }





  inline expr expm1(half arg) { return functions::expm1(arg); }
  inline expr expm1(expr arg) { return functions::expm1(arg); }





  inline expr exp2(half arg) { return functions::exp2(arg); }
  inline expr exp2(expr arg) { return functions::exp2(arg); }





  inline expr log(half arg) { return functions::log(arg); }
  inline expr log(expr arg) { return functions::log(arg); }





  inline expr log10(half arg) { return functions::log10(arg); }
  inline expr log10(expr arg) { return functions::log10(arg); }





  inline expr log1p(half arg) { return functions::log1p(arg); }
  inline expr log1p(expr arg) { return functions::log1p(arg); }





  inline expr log2(half arg) { return functions::log2(arg); }
  inline expr log2(expr arg) { return functions::log2(arg); }
# 2560 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half sqrt(half arg) { return math_function_1arg(xip_fpo_sqrt, arg); }

  inline expr sqrt(expr arg) { return functions::sqrt(arg); }





  inline expr cbrt(half arg) { return functions::cbrt(arg); }
  inline expr cbrt(expr arg) { return functions::cbrt(arg); }






  inline expr hypot(half x, half y) { return functions::hypot(x, y); }
  inline expr hypot(half x, expr y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, half y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, expr y) { return functions::hypot(x, y); }






  inline expr pow(half base, half exp) { return functions::pow(base, exp); }
  inline expr pow(half base, expr exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, half exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, expr exp) { return functions::pow(base, exp); }
                inline expr powr(half base, half exp) { return functions::powr(base, exp); }
                inline expr powr(half base, expr exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, half exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, expr exp) { return functions::powr(base, exp); }
                inline expr pown(half base, int exp) { return functions::pown(base, exp); }
                inline expr pown(expr base, int exp) { return functions::pown(base, exp); }
# 2605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr sin(half arg) { return functions::sin(arg); }
  inline expr sin(expr arg) { return functions::sin(arg); }





  inline expr cos(half arg) { return functions::cos(arg); }
  inline expr cos(expr arg) { return functions::cos(arg); }





  inline expr tan(half arg) { return functions::tan(arg); }
  inline expr tan(expr arg) { return functions::tan(arg); }





  inline expr asin(half arg) { return functions::asin(arg); }
  inline expr asin(expr arg) { return functions::asin(arg); }





  inline expr acos(half arg) { return functions::acos(arg); }
  inline expr acos(expr arg) { return functions::acos(arg); }





  inline expr atan(half arg) { return functions::atan(arg); }
  inline expr atan(expr arg) { return functions::atan(arg); }






  inline expr atan2(half x, half y) { return functions::atan2(x, y); }
  inline expr atan2(half x, expr y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, half y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, expr y) { return functions::atan2(x, y); }
# 2661 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr sinh(half arg) { return functions::sinh(arg); }
  inline expr sinh(expr arg) { return functions::sinh(arg); }





  inline expr cosh(half arg) { return functions::cosh(arg); }
  inline expr cosh(expr arg) { return functions::cosh(arg); }





  inline expr tanh(half arg) { return functions::tanh(arg); }
  inline expr tanh(expr arg) { return functions::tanh(arg); }





  inline expr asinh(half arg) { return functions::asinh(arg); }
  inline expr asinh(expr arg) { return functions::asinh(arg); }





  inline expr acosh(half arg) { return functions::acosh(arg); }
  inline expr acosh(expr arg) { return functions::acosh(arg); }





  inline expr atanh(half arg) { return functions::atanh(arg); }
  inline expr atanh(expr arg) { return functions::atanh(arg); }
# 2707 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr erf(half arg) { return functions::erf(arg); }
  inline expr erf(expr arg) { return functions::erf(arg); }





  inline expr erfc(half arg) { return functions::erfc(arg); }
  inline expr erfc(expr arg) { return functions::erfc(arg); }





                inline expr lgamma_r(half arg, int *signgamp) { return functions::lgamma(arg); }
                inline expr lgamma_r(expr arg, int *signgamp) { return functions::lgamma(arg); }
  inline expr lgamma(half arg) { return functions::lgamma(arg); }
  inline expr lgamma(expr arg) { return functions::lgamma(arg); }





  inline expr tgamma(half arg) { return functions::tgamma(arg); }
  inline expr tgamma(expr arg) { return functions::tgamma(arg); }
# 2741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half ceil(half arg) { return functions::ceil(arg); }
  inline half ceil(expr arg) { return functions::ceil(arg); }





  inline half floor(half arg) { return functions::floor(arg); }
  inline half floor(expr arg) { return functions::floor(arg); }





  inline half trunc(half arg) { return functions::trunc(arg); }
  inline half trunc(expr arg) { return functions::trunc(arg); }





  inline half round(half arg) { return functions::round(arg); }
  inline half round(expr arg) { return functions::round(arg); }





  inline long lround(half arg) { return functions::lround(arg); }
  inline long lround(expr arg) { return functions::lround(arg); }





  inline half nearbyint(half arg) { return functions::rint(arg); }
  inline half nearbyint(expr arg) { return functions::rint(arg); }





  inline half rint(half arg) { return functions::rint(arg); }
  inline half rint(expr arg) { return functions::rint(arg); }





  inline long lrint(half arg) { return functions::lrint(arg); }
  inline long lrint(expr arg) { return functions::lrint(arg); }





  inline long long llround(half arg) { return functions::llround(arg); }
  inline long long llround(expr arg) { return functions::llround(arg); }





  inline long long llrint(half arg) { return functions::llrint(arg); }
  inline long long llrint(expr arg) { return functions::llrint(arg); }
# 2817 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }
  inline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }






  inline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }
  inline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }






  inline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }
  inline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }
# 2859 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline int ilogb(half arg) { return functions::ilogb(arg); }
  inline int ilogb(expr arg) { return functions::ilogb(arg); }





  inline half logb(half arg) { return functions::logb(arg); }
  inline half logb(expr arg) { return functions::logb(arg); }






  inline half nextafter(half from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(half from, expr to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }






  inline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }
  inline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }






  inline half copysign(half x, half y) { return functions::copysign(x, y); }
  inline half copysign(half x, expr y) { return functions::copysign(x, y); }
  inline half copysign(expr x, half y) { return functions::copysign(x, y); }
  inline half copysign(expr x, expr y) { return functions::copysign(x, y); }
# 2910 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline int fpclassify(half arg) { return functions::fpclassify(arg); }
  inline int fpclassify(expr arg) { return functions::fpclassify(arg); }






  inline bool isfinite(half arg) { return functions::isfinite(arg); }
  inline bool isfinite(expr arg) { return functions::isfinite(arg); }






  inline bool isinf(half arg) { return functions::isinf(arg); }
  inline bool isinf(expr arg) { return functions::isinf(arg); }






  inline bool isnan(half arg) { return functions::isnan(arg); }
  inline bool isnan(expr arg) { return functions::isnan(arg); }






  inline bool isnormal(half arg) { return functions::isnormal(arg); }
  inline bool isnormal(expr arg) { return functions::isnormal(arg); }






  inline bool signbit(half arg) { return functions::signbit(arg); }
  inline bool signbit(expr arg) { return functions::signbit(arg); }
# 2963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline bool isgreater(half x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }







  inline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }







  inline bool isless(half x, half y) { return functions::isless(x, y); }
  inline bool isless(half x, expr y) { return functions::isless(x, y); }
  inline bool isless(expr x, half y) { return functions::isless(x, y); }
  inline bool isless(expr x, expr y) { return functions::isless(x, y); }







  inline bool islessequal(half x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }







  inline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }







  inline bool isunordered(half x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }
# 3040 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }
# 3057 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)
   { return half_caster<T,U,R>::cast(arg); }

 }

 using detail::operator==;
 using detail::operator!=;
 using detail::operator<;
 using detail::operator>;
 using detail::operator<=;
 using detail::operator>=;
 using detail::operator+;
 using detail::operator-;
 using detail::operator*;
 using detail::operator/;
 using detail::operator<<;
 using detail::operator>>;
# 3135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  using detail::fpclassify;
  using detail::isfinite;
  using detail::isinf;
  using detail::isnan;
  using detail::isnormal;
  using detail::signbit;
  using detail::isgreater;
  using detail::isgreaterequal;
  using detail::isless;
  using detail::islessequal;
  using detail::islessgreater;
  using detail::isunordered;

 using detail::half_cast;


namespace std
{



 template<> struct numeric_limits<half> : public numeric_limits<float>
 {
 public:

  static constexpr bool is_signed = true;


  static constexpr bool is_exact = false;


  static constexpr bool is_modulo = false;


  static constexpr bool is_iec559 = true;


  static constexpr bool has_infinity = true;


  static constexpr bool has_quiet_NaN = true;


  static constexpr float_denorm_style has_denorm = denorm_present;





  static constexpr float_round_style round_style = (std::numeric_limits<float>::round_style==
   half::round_style) ? half::round_style : round_indeterminate;


  static constexpr int digits = 11;


  static constexpr int digits10 = 3;


  static constexpr int max_digits10 = 5;


  static constexpr int radix = 2;


  static constexpr int min_exponent = -13;


  static constexpr int min_exponent10 = -4;


  static constexpr int max_exponent = 16;


  static constexpr int max_exponent10 = 4;


  static constexpr half min() noexcept { return half(detail::binary, 0x0400); }


  static constexpr half lowest() noexcept { return half(detail::binary, 0xFBFF); }


  static constexpr half max() noexcept { return half(detail::binary, 0x7BFF); }


  static constexpr half epsilon() noexcept { return half(detail::binary, 0x1400); }


  static constexpr half round_error() noexcept
   { return half(detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }


  static constexpr half infinity() noexcept { return half(detail::binary, 0x7C00); }


  static constexpr half quiet_NaN() noexcept { return half(detail::binary, 0x7FFF); }


  static constexpr half signaling_NaN() noexcept { return half(detail::binary, 0x7DFF); }


  static constexpr half denorm_min() noexcept { return half(detail::binary, 0x0001); }
 };




 template<> struct hash<half>
 {

  typedef half argument_type;


  typedef size_t result_type;




  result_type operator()(argument_type arg) const
   { return hash<detail::uint16>()(static_cast<unsigned int>(arg.data_)&-(arg.data_!=0x8000)); }
 };

}
# 3274 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
extern half half_nan(const char *tagp);





extern half half_atan(half t);
extern half half_atan2(half y, half x);
extern half half_copysign(half x, half y);

extern half half_fabs(half x);

extern half half_abs(half x);
extern half half_fma(half x, half y, half z);
extern half half_mad(half x, half y, half z);
extern half half_frexp (half x, int* exp);
extern half half_ldexp (half x, int exp);
extern half half_fmax(half x, half y);

extern half half_fmin(half x, half y);

extern half half_asin(half t_in);
extern half half_acos(half t_in);
extern half half_sin(half t_in);
extern half half_cos(half t_in);
extern void half_sincos(half x, half *sin, half *cos);
extern half half_sinh(half t_in);
extern half half_cosh(half t_in);
extern half half_sinpi(half t_in);
extern half half_cospi(half t_in);
extern half half_recip(half x);
extern half half_sqrt(half x);
extern half half_rsqrt(half x);
extern half half_cbrt(half x);
extern half half_hypot(half x, half y);
extern half half_log(half x);
extern half half_log10(half x);
extern half half_log2(half x);
extern half half_logb(half x);
extern half half_log1p(half x);
extern int half_ilogb(half x);
extern half half_exp(half x);
extern half half_exp10(half x);
extern half half_exp2(half x);
extern half half_expm1(half x);
extern half half_pow(half x, half y);
extern half half_powr(half x, half y);
extern half half_pown(half x, int y);
extern half half_rootn(half x, int y);
extern half half_floor(half x);

extern half half_ceil(half x);

extern half half_trunc(half x);

extern half half_round(half x);

extern half half_nearbyint(half x);
extern half half_rint(half x);
extern long int half_lrint(half x);
extern long long int half_llrint(half x);
extern long int half_lround(half x);
extern long long int half_llround(half x);
extern half half_modf(half x, half *intpart);

extern half half_fract(half x, half *intpart);
extern half half_nextafter(half x, half y);
extern half half_fmod(half x, half y);
extern half half_remainder(half x, half y);
extern half half_remquo(half x, half y, int* quo);
extern half half_divide(half x, half y);
# 91 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 101 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
namespace AESL_std {
template <class DataType>
DataType inline min(DataType a, DataType b) {
  return (a >= b) ? b : a;
}

template <class DataType>
DataType inline max(DataType a, DataType b) {
  return (a >= b) ? a : b;
}
}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 3
       
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 2 3
# 117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 1 3
# 24 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
#pragma pack(push,_CRT_PACKING)



# 27 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
extern "C" {
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
  typedef long clock_t;
# 112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
  extern __attribute__ ((__dllimport__)) int _daylight;
  extern __attribute__ ((__dllimport__)) long _dstbias;
  extern __attribute__ ((__dllimport__)) long _timezone;
  extern __attribute__ ((__dllimport__)) char * _tzname[2];

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_daylight(int *_Daylight);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_dstbias(long *_Daylight_savings_bias);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_timezone(long *_Timezone);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_tzname(size_t *_ReturnValue,char *_Buffer,size_t _SizeInBytes,int _Index);
  char *__attribute__((__cdecl__)) asctime(const struct tm *_Tm) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) asctime_s (char *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  char *__attribute__((__cdecl__)) _ctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime32_s (char *_Buf,size_t _SizeInBytes,const __time32_t *_Time);
  clock_t __attribute__((__cdecl__)) clock(void);
  double __attribute__((__cdecl__)) _difftime32(__time32_t _Time1,__time32_t _Time2);
  struct tm *__attribute__((__cdecl__)) _gmtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime32_s (struct tm *_Tm,const __time32_t *_Time);
  struct tm *__attribute__((__cdecl__)) _localtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime32_s (struct tm *_Tm,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) strftime(char * __restrict__ _Buf,size_t _SizeInBytes,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strftime_l(char * __restrict__ _Buf,size_t _Max_size,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdate(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strdate_s (char *_Buf,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtime(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strtime_s (char *_Buf ,size_t _SizeInBytes);
  __time32_t __attribute__((__cdecl__)) _time32(__time32_t *_Time);
  __time32_t __attribute__((__cdecl__)) _mktime32(struct tm *_Tm);
  __time32_t __attribute__((__cdecl__)) _mkgmtime32(struct tm *_Tm);


  void __attribute__((__cdecl__)) tzset(void) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _tzset(void);


  double __attribute__((__cdecl__)) _difftime64(__time64_t _Time1,__time64_t _Time2);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime64_s (char *_Buf,size_t _SizeInBytes,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _gmtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _localtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mktime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mkgmtime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _time64(__time64_t *_Time);
  unsigned __attribute__((__cdecl__)) _getsystime(struct tm *_Tm);
  unsigned __attribute__((__cdecl__)) _setsystime(struct tm *_Tm,unsigned _MilliSec);
# 203 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
double __attribute__((__cdecl__)) difftime(time_t _Time1,time_t _Time2);
char *__attribute__((__cdecl__)) ctime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) gmtime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) localtime(const time_t *_Time) ;

time_t __attribute__((__cdecl__)) mktime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) _mkgmtime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) time(time_t *_Time);
# 240 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) localtime_s(struct tm *_Tm,const time_t *_Time) { return _localtime64_s(_Tm,_Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) gmtime_s(struct tm *_Tm, const time_t *_Time) { return _gmtime64_s(_Tm, _Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) ctime_s(char *_Buf,size_t _SizeInBytes,const time_t *_Time) { return _ctime64_s(_Buf,_SizeInBytes,_Time); }






  __attribute__ ((__dllimport__)) extern int daylight;
  __attribute__ ((__dllimport__)) extern long timezone;
  __attribute__ ((__dllimport__)) extern char *tzname[2];
  void __attribute__((__cdecl__)) tzset(void) ;


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_timeval.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_timeval.h" 3
struct timeval
{
 long tv_sec;
 long tv_usec;
};
# 256 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 2 3



struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};

  extern int __attribute__((__cdecl__)) mingw_gettimeofday (struct timeval *p, struct timezone *z);



}


#pragma pack(pop)






inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) localtime_r(const time_t *_Time, struct tm *_Tm) {
  return localtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) gmtime_r(const time_t *_Time, struct tm *_Tm) {
  return gmtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) ctime_r(const time_t *_Time, char *_Str) {
  return ctime_s(_Str, 0x7fffffff, _Time) ? __null : _Str;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) asctime_r(const struct tm *_Tm, char * _Str) {
  return asctime_s(_Str, 0x7fffffff, _Tm) ? __null : _Str;
}
# 301 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_time.h" 1 3
# 74 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_time.h" 3
extern "C" {



       





int __attribute__((__cdecl__)) nanosleep(const struct timespec *request, struct timespec *remain);

int __attribute__((__cdecl__)) clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *request, struct timespec *remain);
int __attribute__((__cdecl__)) clock_getres(clockid_t clock_id, struct timespec *res);
int __attribute__((__cdecl__)) clock_gettime(clockid_t clock_id, struct timespec *tp);
int __attribute__((__cdecl__)) clock_settime(clockid_t clock_id, const struct timespec *tp);

       


}
# 302 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 2 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 2 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

namespace std
{

# 52 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 206 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/time_members.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/time_members.h" 3
namespace std
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 345 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

namespace std
{


namespace __cxx11 {
# 365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 403 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 427 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 509 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
# 556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
# 583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
# 603 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 621 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 640 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 659 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 678 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 697 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
# 794 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 815 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 834 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 854 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
# 926 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
# 1021 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 1050 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 1063 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 1078 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1092 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1105 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1182 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1198 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1256 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1268 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1281 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1294 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1307 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1348 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
# 1465 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1487 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1517 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1572 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1584 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1596 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1639 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1659 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1682 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1753 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
# 1796 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1824 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1838 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1869 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1887 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1898 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1918 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1937 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/messages_members.h" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/messages_members.h" 3
namespace std
{



  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }


}
# 2009 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3

namespace std
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 2012 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3

namespace std
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 367 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 573 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 2014 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 1 3
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 1 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
namespace std
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                __not_<is_array<_Up>>,
                __or_<__and_<is_reference<deleter_type>,
                             is_same<deleter_type, _Ep>>,
                      __and_<__not_<is_reference<deleter_type>>,
                             is_convertible<_Ep, deleter_type>>
                >
              >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
# 182 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 248 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 263 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;


    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;



      template<typename _Up, typename _Ep,
               typename _Up_up = unique_ptr<_Up, _Ep>,
        typename _Up_element_type = typename _Up_up::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<typename _Up_up::pointer, _Up_element_type*>,
          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
                __and_<__not_<is_reference<deleter_type>>,
                       is_convertible<_Ep, deleter_type>>>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      explicit
      unique_ptr(_Up __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
# 461 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion_up<_Up, _Ep>>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 531 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3

namespace std
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 return false;

      if (__result == codecvt_base::noconv)
 {
   __outstr.assign(__first, __last);
   __count = __last - __first;
 }
      else
 {
   __outstr.resize(__outchars);
   __count = __next - __first;
 }

      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }



namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;







      explicit
      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
# 195 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;
# 333 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && _M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes == 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 2 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 3






namespace std
{
  namespace __detail {
 




    template<typename _String, typename _CharT>
      struct _Quoted_string
      {
 static_assert(is_reference<_String>::value
     || is_pointer<_String>::value,
        "String type must be pointer or reference");

 _Quoted_string(_String __str, _CharT __del, _CharT __esc)
 : _M_string(__str), _M_delim{__del}, _M_escape{__esc}
 { }

 _Quoted_string&
 operator=(_Quoted_string&) = delete;

 _String _M_string;
 _CharT _M_delim;
 _CharT _M_escape;
      };







    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<const _CharT*, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (const _CharT* __c = __str._M_string; *__c; ++__c)
   {
     if (*__c == __str._M_delim || *__c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << *__c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }







    template<typename _CharT, typename _Traits, typename _String>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<_String, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (auto& __c : __str._M_string)
   {
     if (__c == __str._M_delim || __c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << __c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }





    template<typename _CharT, typename _Traits, typename _Alloc>
      std::basic_istream<_CharT, _Traits>&
      operator>>(std::basic_istream<_CharT, _Traits>& __is,
   const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
          _CharT>& __str)
      {
 _CharT __c;
 __is >> __c;
 if (!__is.good())
   return __is;
 if (__c != __str._M_delim)
   {
     __is.unget();
     __is >> __str._M_string;
     return __is;
   }
 __str._M_string.clear();
 std::ios_base::fmtflags __flags
   = __is.flags(__is.flags() & ~std::ios_base::skipws);
 do
   {
     __is >> __c;
     if (!__is.good())
       break;
     if (__c == __str._M_escape)
       {
  __is >> __c;
  if (!__is.good())
    break;
       }
     else if (__c == __str._M_delim)
       break;
     __str._M_string += __c;
   }
 while (true);
 __is.setf(__flags);

 return __is;
      }

 
  }
}
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 2 3



namespace std
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 224 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
# 257 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
# 304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }

  template<typename _CharT>
    struct _Put_time
    {
      const std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Put_time<_CharT>
    put_time(const std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_put<_CharT, _Iter> _TimePut;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                __err |= ios_base::badbit;
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __os._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __os._M_setstate(ios_base::badbit); }
          if (__err)
            __os.setstate(__err);
        }
      return __os;
    }

  template<typename _CharT>
    struct _Get_time
    {
      std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Get_time<_CharT>
    get_time(std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef istreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_get<_CharT, _Iter> _TimeGet;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __is._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __is._M_setstate(ios_base::badbit); }
          if (__err)
            __is.setstate(__err);
        }
      return __is;
    }
# 459 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline auto
    quoted(const _CharT* __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
            __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }
# 496 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 120 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2





# 124 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
namespace ap_private_ops {

static inline uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


static inline uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}

template <int _AP_W>
inline bool isNegative(const ap_private<_AP_W, false>& a) {
  return false;
}

template <int _AP_W>
inline bool isNegative(const ap_private<_AP_W, true>& a) {
  enum {
    APINT_BITS_PER_WORD = 64,
    _AP_N = (_AP_W + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD
  };
  static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) % APINT_BITS_PER_WORD);
  return (sign_mask & a.get_pVal(_AP_N - 1)) != 0;
}





static inline unsigned CountLeadingZeros_32(uint32_t Value) {
  unsigned Count;



  if (Value == 0) return 32;

  Count = __builtin_clz(Value);
# 175 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  return Count;
}





static inline unsigned CountLeadingZeros_64(uint64_t Value) {
  unsigned Count;



  if (!Value) return 64;

  Count = __builtin_clzll(Value);
# 219 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  return Count;
}





static inline unsigned CountTrailingZeros_64(uint64_t Value) {

  return (Value != 0) ? __builtin_ctzll(Value) : 64;
# 237 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
}



static inline unsigned CountPopulation_64(uint64_t Value) {

  return __builtin_popcountll(Value);






}

static inline uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {
  uint32_t Count = 0;
  if (skip) (__V) <<= (skip);
  while (__V && (__V & (1ULL << 63))) {
    Count++;
    (__V) <<= 1;
  }
  return Count;
}

static inline std::string oct2Bin(char oct) {
  switch (oct) {
    case '\0': {
      return "";
    }
    case '.': {
      return ".";
    }
    case '0': {
      return "000";
    }
    case '1': {
      return "001";
    }
    case '2': {
      return "010";
    }
    case '3': {
      return "011";
    }
    case '4': {
      return "100";
    }
    case '5': {
      return "101";
    }
    case '6': {
      return "110";
    }
    case '7': {
      return "111";
    }
  }
  
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 0 && "Invalid character in digit string"
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "0 && \"Invalid character in digit string\""
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",295),0))
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                 ;
  return "";
}

static inline std::string hex2Bin(char hex) {
  switch (hex) {
    case '\0': {
      return "";
    }
    case '.': {
      return ".";
    }
    case '0': {
      return "0000";
    }
    case '1': {
      return "0001";
    }
    case '2': {
      return "0010";
    }
    case '3': {
      return "0011";
    }
    case '4': {
      return "0100";
    }
    case '5': {
      return "0101";
    }
    case '6': {
      return "0110";
    }
    case '7': {
      return "0111";
    }
    case '8': {
      return "1000";
    }
    case '9': {
      return "1001";
    }
    case 'A':
    case 'a': {
      return "1010";
    }
    case 'B':
    case 'b': {
      return "1011";
    }
    case 'C':
    case 'c': {
      return "1100";
    }
    case 'D':
    case 'd': {
      return "1101";
    }
    case 'E':
    case 'e': {
      return "1110";
    }
    case 'F':
    case 'f': {
      return "1111";
    }
  }
  
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 0 && "Invalid character in digit string"
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "0 && \"Invalid character in digit string\""
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",362),0))
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                 ;
  return "";
}

static inline uint32_t decode_digit(char cdigit, int radix) {
  uint32_t digit = 0;
  if (radix == 16) {




    if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F'))) 
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                          (void) ((!!(
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                          0 && "Invalid hex digit in string"
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                          )) || (_assert(
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                          "0 && \"Invalid hex digit in string\""
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                          ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",373),0))
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                    ;
    if (((cdigit) >= '0' && (cdigit) <= '9'))
      digit = cdigit - '0';
    else if (cdigit >= 'a')
      digit = cdigit - 'a' + 10;
    else if (cdigit >= 'A')
      digit = cdigit - 'A' + 10;
    else
      
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     0 && "huh? we shouldn't get here"
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "0 && \"huh? we shouldn't get here\""
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",381),0))
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                              ;
  } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
    digit = cdigit - '0';
  } else {
    
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0 && "Invalid character in digit string"
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0 && \"Invalid character in digit string\""
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",385),0))
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
  }


  return digit;
}


static inline std::string parseString(const std::string& input, unsigned char& radix) {
  size_t len = input.length();
  if (len == 0) {
    if (radix == 0) radix = 10;
    return input;
  }

  size_t startPos = 0;

  while (input[startPos] == ' ' && startPos < len) startPos++;
  while (input[len - 1] == ' ' && startPos < len) len--;

  std::string val = input.substr(startPos, len - startPos);

  len = val.length();
  startPos = 0;



  if (len < 2) {
    if (radix == 0) radix = 10;
    return val;
  }

  bool isNegative = false;
  std::string ans;


  if (val[0] == '-') {
    ans = "-";
    ++startPos;
    isNegative = true;
  } else if (val[0] == '+')
    ++startPos;

  if (len - startPos < 2) {
    if (radix == 0) radix = 10;
    return val;
  }

  if (val.substr(startPos, 2) == "0x" || val.substr(startPos, 2) == "0X") {

    radix = 16;
    startPos += 2;
  } else if (val.substr(startPos, 2) == "0b" ||
             val.substr(startPos, 2) == "0B") {

    radix = 2;
    startPos += 2;
  } else if (val.substr(startPos, 2) == "0o" ||
             val.substr(startPos, 2) == "0O") {

    radix = 8;
    startPos += 2;
  } else if (radix == 0) {
    radix = 10;
  }

  int exp = 0;
  if (radix == 10) {


    size_t expPos = val.find('e');
    bool has_exponent = true;
    if (expPos == std::string::npos) expPos = val.find('E');
    if (expPos == std::string::npos) {

      expPos = len;
      has_exponent = false;
    }


    ans += val.substr(startPos, expPos - startPos);
    if (has_exponent) {

      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));
      iss >> exp;
    }
  } else {

    size_t expPos = val.find('p');
    bool has_exponent = true;
    if (expPos == std::string::npos) expPos = val.find('P');
    if (expPos == std::string::npos) {

      expPos = len;
      has_exponent = false;
    }



    
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   startPos <= expPos
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "startPos <= expPos"
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",484),0))
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                             ;

    for (size_t i = startPos; i < expPos; ++i) {
      if (radix == 16) {
        ans += hex2Bin(val[i]);
      } else if (radix == 8) {
        ans += oct2Bin(val[i]);
      } else {
        ans += val[i];
      }
    }

    radix = 2;
    if (has_exponent) {

      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));
      iss >> exp;
    }
  }
  if (exp == 0) return ans;

  size_t decPos = ans.find('.');
  if (decPos == std::string::npos) decPos = ans.length();
  if ((int)decPos + exp >= (int)ans.length()) {
    int i = decPos;
    for (; i < (int)ans.length() - 1; ++i) ans[i] = ans[i + 1];
    for (; i < (int)ans.length(); ++i) ans[i] = '0';
    for (; i < (int)decPos + exp; ++i) ans += '0';
    return ans;
  } else if ((int)decPos + exp < (int)isNegative) {
    std::string dupAns = "0.";
    if (ans[0] == '-') dupAns = "-0.";
    for (int i = 0; i < isNegative - (int)decPos - exp; ++i) dupAns += '0';
    for (size_t i = isNegative; i < ans.length(); ++i)
      if (ans[i] != '.') dupAns += ans[i];
    return dupAns;
  }

  if (exp > 0)
    for (size_t i = decPos; i < decPos + exp; ++i) ans[i] = ans[i + 1];
  else {
    if (decPos == ans.length()) ans += ' ';
    for (int i = decPos; i > (int)decPos + exp; --i) ans[i] = ans[i - 1];
  }
  ans[decPos + exp] = '.';
  return ans;
}







static inline bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {
  for (uint32_t i = 0; i < len; ++i) {
    uint64_t __X = x[i];
    x[i] -= y;
    if (y > __X)
      y = 1;
    else {
      y = 0;
      break;
    }
  }
  return (y != 0);
}





static inline bool add_1(uint64_t dest[], uint64_t x[], uint32_t len,
                         uint64_t y) {
  for (uint32_t i = 0; i < len; ++i) {
    dest[i] = y + x[i];
    if (dest[i] < y)
      y = 1;
    else {
      y = 0;
      break;
    }
  }
  return (y != 0);
}





static inline bool add(uint64_t* dest, const uint64_t* x, const uint64_t* y,
                       uint32_t destlen, uint32_t xlen, uint32_t ylen,
                       bool xsigned, bool ysigned) {
  bool carry = false;
  uint32_t len = AESL_std::min(xlen, ylen);
  uint32_t i;
  for (i = 0; i < len && i < destlen; ++i) {
    uint64_t limit =
        AESL_std::min(x[i], y[i]);
    dest[i] = x[i] + y[i] + carry;
    carry = dest[i] < limit || (carry && dest[i] == limit);
  }
  if (xlen > ylen) {
    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;
    for (i = ylen; i < xlen && i < destlen; i++) {
      uint64_t limit = AESL_std::min(x[i], yext);
      dest[i] = x[i] + yext + carry;
      carry = (dest[i] < limit) || (carry && dest[i] == limit);
    }
  } else if (ylen > xlen) {
    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;
    for (i = xlen; i < ylen && i < destlen; i++) {
      uint64_t limit = AESL_std::min(xext, y[i]);
      dest[i] = xext + y[i] + carry;
      carry = (dest[i] < limit) || (carry && dest[i] == limit);
    }
  }
  return carry;
}



static inline bool sub(uint64_t* dest, const uint64_t* x, const uint64_t* y,
                       uint32_t destlen, uint32_t xlen, uint32_t ylen,
                       bool xsigned, bool ysigned) {
  bool borrow = false;
  uint32_t i;
  uint32_t len = AESL_std::min(xlen, ylen);
  for (i = 0; i < len && i < destlen; ++i) {
    uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
    borrow = y[i] > x_tmp || (borrow && x[i] == 0);
    dest[i] = x_tmp - y[i];
  }
  if (xlen > ylen) {
    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;
    for (i = ylen; i < xlen && i < destlen; i++) {
      uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
      borrow = yext > x_tmp || (borrow && x[i] == 0);
      dest[i] = x_tmp - yext;
    }
  } else if (ylen > xlen) {
    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;
    for (i = xlen; i < ylen && i < destlen; i++) {
      uint64_t x_tmp = borrow ? xext - 1 : xext;
      borrow = y[i] > x_tmp || (borrow && xext == 0);
      dest[i] = x_tmp - y[i];
    }
  }
  return borrow;
}
# 643 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
static inline uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len,
                             uint64_t y) {

  uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;
  uint64_t carry = 0;
  static const uint64_t two_power_32 = 1ULL << 32;

  for (uint32_t i = 0; i < len; ++i) {

    uint64_t lx = x[i] & 0xffffffffULL;
    uint64_t hx = (x[i]) >> 32;




    uint8_t hasCarry = 0;
    dest[i] = carry + lx * ly;

    hasCarry = (dest[i] < carry) ? 1 : 0;
    carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);


    hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);

    carry += (lx * hy) & 0xffffffffULL;
    dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);
    carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +
            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;
  }
  return carry;
}







static inline void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen,
                       const uint64_t y[], uint32_t ylen, uint32_t destlen) {
  
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 xlen > 0
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "xlen > 0"
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",683),0))
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                 ;
  
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 ylen > 0
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "ylen > 0"
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",684),0))
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                 ;
  
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 destlen >= xlen + ylen
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "destlen >= xlen + ylen"
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",685),0))
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                               ;
  if (xlen < destlen) dest[xlen] = mul_1(dest, x, xlen, y[0]);
  for (uint32_t i = 1; i < ylen; ++i) {
    uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;
    uint64_t carry = 0, lx = 0, hx = 0;
    for (uint32_t j = 0; j < xlen; ++j) {
      lx = x[j] & 0xffffffffULL;
      hx = (x[j]) >> 32;




      uint8_t hasCarry = 0;
      uint64_t resul = carry + lx * ly;
      hasCarry = (resul < carry) ? 1 : 0;
      carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);
      hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
      carry += (lx * hy) & 0xffffffffULL;
      resul = ((carry) << 32) | (resul & 0xffffffffULL);
      if (i + j < destlen) dest[i + j] += resul;
      carry =
          (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0) +
          ((carry) >> 32) + (dest[i + j] < resul ? 1 : 0) + ((lx * hy) >> 32) +
          hx * hy;
    }
    if (i + xlen < destlen) dest[i + xlen] = carry;
  }
}





static inline void KnuthDiv(uint32_t* u, uint32_t* v, uint32_t* q, uint32_t* r,
                            uint32_t m, uint32_t n) {
  
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 u && "Must provide dividend"
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "u && \"Must provide dividend\""
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",720),0))
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
  
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 v && "Must provide divisor"
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "v && \"Must provide divisor\""
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",721),0))
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                    ;
  
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 q && "Must provide quotient"
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "q && \"Must provide quotient\""
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",722),0))
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
  
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 u != v && u != q && v != q && "Must us different memory"
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "u != v && u != q && v != q && \"Must us different memory\""
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",723),0))
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
  
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 n > 1 && "n must be > 1"
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "n > 1 && \"n must be > 1\""
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",724),0))
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                 ;



  uint64_t b = uint64_t(1) << 32;
# 746 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  uint32_t shift = CountLeadingZeros_32(v[n - 1]);
  uint32_t v_carry = 0;
  uint32_t u_carry = 0;
  if (shift) {
    for (uint32_t i = 0; i < m + n; ++i) {
      uint32_t u_tmp = (u[i]) >> (32 - shift);
      u[i] = ((u[i]) << (shift)) | u_carry;
      u_carry = u_tmp;
    }
    for (uint32_t i = 0; i < n; ++i) {
      uint32_t v_tmp = (v[i]) >> (32 - shift);
      v[i] = ((v[i]) << (shift)) | v_carry;
      v_carry = v_tmp;
    }
  }
  u[m + n] = u_carry;
# 771 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  int j = m;
  do {
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
    uint64_t dividend = ((uint64_t(u[j + n]) << 32) + u[j + n - 1]);

    uint64_t qp = dividend / v[n - 1];
    uint64_t rp = dividend % v[n - 1];
    if (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2]) {
      qp--;
      rp += v[n - 1];
      if (rp < b && (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2])) qp--;
    }






    bool isNeg = false;
    for (uint32_t i = 0; i < n; ++i) {
      uint64_t u_tmp = uint64_t(u[j + i]) | ((uint64_t(u[j + i + 1])) << 32);
      uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);
      bool borrow = subtrahend > u_tmp;




      uint64_t result = u_tmp - subtrahend;
      uint32_t k = j + i;
      u[k++] = (uint32_t)(result & (b - 1));
      u[k++] = (uint32_t)((result) >> 32);
      while (borrow && k <= m + n) {
        borrow = u[k] == 0;
        u[k]--;
        k++;
      }
      isNeg |= borrow;


    }
# 827 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
    if (isNeg) {
      bool carry = true;
      for (uint32_t i = 0; i <= m + n; ++i) {
        u[i] = ~u[i] + carry;
        carry = carry && u[i] == 0;
      }
    }






    q[j] = (uint32_t)qp;
    if (isNeg) {



      q[j]--;



      bool carry = false;
      for (uint32_t i = 0; i < n; i++) {
        uint32_t limit = AESL_std::min(u[j + i], v[i]);
        u[j + i] += v[i] + carry;
        carry = u[j + i] < limit || (carry && u[j + i] == limit);
      }
      u[j + n] += carry;
    }





  } while (--j >= 0);
# 871 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  if (r) {



    if (shift) {
      uint32_t carry = 0;

      for (int i = n - 1; i >= 0; i--) {
        r[i] = ((u[i]) >> (shift)) | carry;
        carry = (u[i]) << (32 - shift);

      }
    } else {
      for (int i = n - 1; i >= 0; i--) {
        r[i] = u[i];

      }
    }

  }

}

template <int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,
            ap_private<_AP_W, _AP_S>* Quotient,
            ap_private<_AP_W, _AP_S>* Remainder) {
  
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 lhsWords >= rhsWords && "Fractional result"
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "lhsWords >= rhsWords && \"Fractional result\""
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",899),0))
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
  enum { APINT_BITS_PER_WORD = 64 };







  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);
  uint32_t n = rhsWords * 2;
  uint32_t m = (lhsWords * 2) - n;



  uint32_t SPACE[128];
  uint32_t* __U = 0;
  uint32_t* __V = 0;
  uint32_t* __Q = 0;
  uint32_t* __R = 0;
  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {
    __U = &SPACE[0];
    __V = &SPACE[m + n + 1];
    __Q = &SPACE[(m + n + 1) + n];
    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];
  } else {
    __U = new uint32_t[m + n + 1];
    __V = new uint32_t[n];
    __Q = new uint32_t[m + n];
    if (Remainder) __R = new uint32_t[n];
  }


  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));
  for (unsigned i = 0; i < lhsWords; ++i) {
    uint64_t tmp = LHS.get_pVal(i);
    __U[i * 2] = (uint32_t)(tmp & mask);
    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }
  __U[m + n] = 0;


  memset(__V, 0, (n) * sizeof(uint32_t));
  for (unsigned i = 0; i < rhsWords; ++i) {
    uint64_t tmp = RHS.get_pVal(i);
    __V[i * 2] = (uint32_t)(tmp & mask);
    __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }


  memset(__Q, 0, (m + n) * sizeof(uint32_t));
  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));





  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {
    n--;
    m++;
  }
  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;







  
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 n != 0 && "Divide by zero?"
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "n != 0 && \"Divide by zero?\""
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",968),0))
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                    ;
  if (n == 1) {
    uint32_t divisor = __V[0];
    uint32_t remainder = 0;
    for (int i = m + n - 1; i >= 0; i--) {
      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
      if (partial_dividend == 0) {
        __Q[i] = 0;
        remainder = 0;
      } else if (partial_dividend < divisor) {
        __Q[i] = 0;
        remainder = (uint32_t)partial_dividend;
      } else if (partial_dividend == divisor) {
        __Q[i] = 1;
        remainder = 0;
      } else {
        __Q[i] = (uint32_t)(partial_dividend / divisor);
        remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));
      }
    }
    if (__R) __R[0] = remainder;
  } else {


    KnuthDiv(__U, __V, __Q, __R, m, n);
  }


  if (Quotient) {

    if (Quotient->BitWidth != LHS.BitWidth) {
      if (Quotient->isSingleWord()) Quotient->set_VAL(0);
    } else
      Quotient->clear();



    if (lhsWords == 1) {
      uint64_t tmp =
          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
      Quotient->set_VAL(tmp);
    } else {
      
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Quotient->isSingleWord() && "Quotient ap_private not large enough"
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Quotient->isSingleWord() && \"Quotient ap_private not large enough\""
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                   1011
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                    
# 1011 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
      for (unsigned i = 0; i < lhsWords; ++i)
        Quotient->set_pVal(
            i, uint64_t(__Q[i * 2]) |
                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Quotient->clearUnusedBits();
  }


  if (Remainder) {

    if (Remainder->BitWidth != RHS.BitWidth) {
      if (Remainder->isSingleWord()) Remainder->set_VAL(0);
    } else
      Remainder->clear();



    if (rhsWords == 1) {
      uint64_t tmp =
          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
      Remainder->set_VAL(tmp);
    } else {
      
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Remainder->isSingleWord() && "Remainder ap_private not large enough"
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Remainder->isSingleWord() && \"Remainder ap_private not large enough\""
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                    "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                    1036
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                     
# 1036 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
      for (unsigned i = 0; i < rhsWords; ++i)
        Remainder->set_pVal(
            i, uint64_t(__R[i * 2]) |
                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Remainder->clearUnusedBits();
  }


  if (__U != &SPACE[0]) {
    delete[] __U;
    delete[] __V;
    delete[] __Q;
    delete[] __R;
  }
}

template <int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            uint64_t RHS, ap_private<_AP_W, _AP_S>* Quotient,
            ap_private<_AP_W, _AP_S>* Remainder) {
  uint32_t rhsWords = 1;
  
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 lhsWords >= rhsWords && "Fractional result"
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "lhsWords >= rhsWords && \"Fractional result\""
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1059),0))
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
  enum { APINT_BITS_PER_WORD = 64 };







  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);
  uint32_t n = 2;
  uint32_t m = (lhsWords * 2) - n;



  uint32_t SPACE[128];
  uint32_t* __U = 0;
  uint32_t* __V = 0;
  uint32_t* __Q = 0;
  uint32_t* __R = 0;
  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {
    __U = &SPACE[0];
    __V = &SPACE[m + n + 1];
    __Q = &SPACE[(m + n + 1) + n];
    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];
  } else {
    __U = new uint32_t[m + n + 1];
    __V = new uint32_t[n];
    __Q = new uint32_t[m + n];
    if (Remainder) __R = new uint32_t[n];
  }


  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));
  for (unsigned i = 0; i < lhsWords; ++i) {
    uint64_t tmp = LHS.get_pVal(i);
    __U[i * 2] = tmp & mask;
    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }
  __U[m + n] = 0;


  memset(__V, 0, (n) * sizeof(uint32_t));
  __V[0] = RHS & mask;
  __V[1] = (RHS) >> (sizeof(uint32_t) * 8);


  memset(__Q, 0, (m + n) * sizeof(uint32_t));
  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));





  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {
    n--;
    m++;
  }
  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;







  
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 n != 0 && "Divide by zero?"
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "n != 0 && \"Divide by zero?\""
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1125),0))
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                    ;
  if (n == 1) {
    uint32_t divisor = __V[0];
    uint32_t remainder = 0;
    for (int i = m + n - 1; i >= 0; i--) {
      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
      if (partial_dividend == 0) {
        __Q[i] = 0;
        remainder = 0;
      } else if (partial_dividend < divisor) {
        __Q[i] = 0;
        remainder = partial_dividend;
      } else if (partial_dividend == divisor) {
        __Q[i] = 1;
        remainder = 0;
      } else {
        __Q[i] = partial_dividend / divisor;
        remainder = partial_dividend - (__Q[i] * divisor);
      }
    }
    if (__R) __R[0] = remainder;
  } else {


    KnuthDiv(__U, __V, __Q, __R, m, n);
  }


  if (Quotient) {

    if (Quotient->BitWidth != LHS.BitWidth) {
      if (Quotient->isSingleWord()) Quotient->set_VAL(0);
    } else
      Quotient->clear();



    if (lhsWords == 1) {
      uint64_t tmp =
          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
      Quotient->set_VAL(tmp);
    } else {
      
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Quotient->isSingleWord() && "Quotient ap_private not large enough"
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Quotient->isSingleWord() && \"Quotient ap_private not large enough\""
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                   1168
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                    
# 1168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
      for (unsigned i = 0; i < lhsWords; ++i)
        Quotient->set_pVal(
            i, uint64_t(__Q[i * 2]) |
                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Quotient->clearUnusedBits();
  }


  if (Remainder) {

    if (Remainder->BitWidth != 64 ) {
      if (Remainder->isSingleWord()) Remainder->set_VAL(0);
    } else
      Remainder->clear();



    if (rhsWords == 1) {
      uint64_t tmp =
          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
      Remainder->set_VAL(tmp);
    } else {
      
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Remainder->isSingleWord() && "Remainder ap_private not large enough"
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Remainder->isSingleWord() && \"Remainder ap_private not large enough\""
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                    "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                    1193
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                     
# 1193 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
      for (unsigned i = 0; i < rhsWords; ++i)
        Remainder->set_pVal(
            i, uint64_t(__R[i * 2]) |
                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Remainder->clearUnusedBits();
  }


  if (__U != &SPACE[0]) {
    delete[] __U;
    delete[] __V;
    delete[] __Q;
    delete[] __R;
  }
}


template <int _AP_W, bool _AP_S, bool _AP_C>
inline ap_private<_AP_W, _AP_S, _AP_C> lshr(
    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
  return LHS.lshr(shiftAmt);
}



template <int _AP_W, bool _AP_S, bool _AP_C>
inline ap_private<_AP_W, _AP_S, _AP_C> shl(
    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
  return LHS.shl(shiftAmt);
}

}





enum {
  MIN_INT_BITS = 1,

  MAX_INT_BITS = (1 << 23) - 1

};
# 1280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
typedef unsigned long long ap_ulong;
typedef signed long long ap_slong;

template <int _AP_N8, bool _AP_S>
struct valtype;

template <int _AP_N8>
struct valtype<_AP_N8, false> {
  typedef uint64_t Type;
};

template <int _AP_N8>
struct valtype<_AP_N8, true> {
  typedef int64_t Type;
};

template <>
struct valtype<1, false> {
  typedef unsigned char Type;
};
template <>
struct valtype<2, false> {
  typedef unsigned short Type;
};
template <>
struct valtype<3, false> {
  typedef unsigned int Type;
};
template <>
struct valtype<4, false> {
  typedef unsigned int Type;
};
template <>
struct valtype<1, true> {
  typedef signed char Type;
};
template <>
struct valtype<2, true> {
  typedef short Type;
};
template <>
struct valtype<3, true> {
  typedef int Type;
};
template <>
struct valtype<4, true> {
  typedef int Type;
};

template <bool enable>
struct ap_private_enable_if {};
template <>
struct ap_private_enable_if<true> {
  static const bool isValid = true;
};


template <int _AP_W, bool _AP_S>
class ap_private<_AP_W, _AP_S, true> {

  const static bool valid = ap_private_enable_if<_AP_W <= 64>::isValid;




 public:
  typedef typename valtype<(_AP_W + 7) / 8, _AP_S>::Type ValType;
  typedef ap_private<_AP_W, _AP_S> Type;
  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };
    typedef ap_private<mult_w, mult_s> mult;
    typedef ap_private<plus_w, plus_s> plus;
    typedef ap_private<minus_w, minus_s> minus;
    typedef ap_private<logic_w, logic_s> logic;
    typedef ap_private<div_w, div_s> div;
    typedef ap_private<mod_w, mod_s> mod;
    typedef ap_private<_AP_W, _AP_S> arg1;
    typedef bool reduce;
  };
  enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };
  enum {
    excess_bits = (_AP_W % APINT_BITS_PER_WORD)
                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)
                      : 0
  };
  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
  static const uint64_t not_mask = ~mask;
  static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD - 1);
  template <int _AP_W1>
  struct sign_ext_mask {
    static const uint64_t mask = ~0ULL << _AP_W1;
  };
  static const int width = _AP_W;

  enum {
    BitWidth = _AP_W,
    _AP_N = 1,
  };
  ValType VAL;





  void check_canary() {}
  void set_canary() {}


  inline ValType& get_VAL(void) { return VAL; }
  inline ValType get_VAL(void) const { return VAL; }
  inline ValType get_VAL(void) const volatile { return VAL; }
  inline void set_VAL(uint64_t value) { VAL = (ValType)value; }
  inline ValType& get_pVal(int i) { return VAL; }
  inline ValType get_pVal(int i) const { return VAL; }
  inline const uint64_t* get_pVal() const {
    
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0 && "invalid usage"
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0 && \"invalid usage\""
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1411),0))
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                               ;
    return 0;
  }
  inline ValType get_pVal(int i) const volatile { return VAL; }
  inline uint64_t* get_pVal() const volatile {
    
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0 && "invalid usage"
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0 && \"invalid usage\""
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1416),0))
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                               ;
    return 0;
  }
  inline void set_pVal(int i, uint64_t value) { VAL = (ValType)value; }

  inline uint32_t getBitWidth() const { return BitWidth; }

  template <int _AP_W1, bool _AP_S1>
  ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  ap_private<_AP_W, _AP_S>& operator=(
      const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  void operator=(const ap_private& RHS) volatile {

    VAL = RHS.get_VAL();
    clearUnusedBits();
  }

  ap_private& operator=(const ap_private& RHS) {

    VAL = RHS.get_VAL();
    clearUnusedBits();
    return *this;
  }

  void operator=(const volatile ap_private& RHS) volatile {

    VAL = RHS.get_VAL();
    clearUnusedBits();
  }

  ap_private& operator=(const volatile ap_private& RHS) {

    VAL = RHS.get_VAL();
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    *this = ap_private<_AP_W2, false>(op2);
    return *this;
  }
# 1479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
inline ap_private& operator=(const bool v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const signed char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const short v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned short v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const int v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned int v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const long v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned long v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const ap_slong v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const ap_ulong v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const half v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }

inline ap_private& operator=(const float v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const double v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }



  inline ap_private& operator=(const char* s) {
    ap_private tmp(s);
    operator=(tmp);
    return *this;
  }

 private:
  explicit inline ap_private(uint64_t* val) : VAL(val[0]) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  inline bool isSingleWord() const { return true; }

 public:
  inline void fromString(const char* strStart, uint32_t slen, uint8_t radix) {
    bool isNeg = strStart[0] == '-';
    if (isNeg) {
      strStart++;
      slen--;
    }

    if (strStart[0] == '0' && (strStart[1] == 'b' || strStart[1] == 'B')) {

      do { if ((radix != 2)) { fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 2, radix); fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'o' || strStart[1] == 'O')) {

      do { if ((radix != 8)) { fprintf(
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 8, radix); fprintf(
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'x' || strStart[1] == 'X')) {

      do { if ((radix != 16)) { fprintf(
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 16, radix); fprintf(
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'd' || strStart[1] == 'D')) {

      do { if ((radix != 10)) { fprintf(
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 10, radix); fprintf(
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (radix == 0) {

    }


    
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                             "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                             1547
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                              
# 1547 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   strStart && "String is null?"
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "strStart && \"String is null?\""
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1548),0))
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                        ;


    uint64_t tmpVAL = VAL = 0;

    switch (radix) {
      case 2:


        for (; *strStart; ++strStart) {
          
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         (*strStart == '0' || *strStart == '1') && ("Wrong binary number")
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "(*strStart == '0' || *strStart == '1') && (\"Wrong binary number\")"
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,
                                        "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
          ,
                                        1559
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
          ),0))
                                         
# 1559 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                        ;
          tmpVAL <<= 1;
          tmpVAL |= (*strStart - '0');
        }
        break;
      case 8:






        sscanf(strStart, "%llo", &tmpVAL);


        break;
      case 10:






        sscanf(strStart, "%llu", &tmpVAL);


        break;
      case 16:






        sscanf(strStart, "%llx", &tmpVAL);


        break;
      default:
        
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       (void) ((!!(
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       true && "Unknown radix"
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       )) || (_assert(
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       "true && \"Unknown radix\""
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1598),0))
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                      ;

    }
    VAL = isNeg ? (ValType)(-tmpVAL) : (ValType)(tmpVAL);

    clearUnusedBits();
  }

 private:
  inline ap_private(const std::string& val, uint8_t radix = 2) : VAL(0) {
    
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   !val.empty() && "String empty?"
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "!val.empty() && \"String empty?\""
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1608),0))
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                          ;
    set_canary();
    fromString(val.c_str(), val.size(), radix);
    check_canary();
  }

  inline ap_private(const char strStart[], uint32_t slen, uint8_t radix)
      : VAL(0) {
    set_canary();
    fromString(strStart, slen, radix);
    check_canary();
  }

  inline ap_private(uint32_t numWords, const uint64_t bigVal[])
      : VAL(bigVal[0]) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

 public:
  inline ap_private() {
    set_canary();
    clearUnusedBits();
    check_canary();
  }







  inline ap_private(bool v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(signed char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(ap_slong v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(ap_ulong v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(half v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(float v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(double v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }


  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)
      : VAL((ValType)that.get_VAL()) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)
      : VAL((ValType)that.get_VAL()) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  explicit inline ap_private(const char* val) {
    set_canary();
    unsigned char radix = 10;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');

    if (pos != std::string::npos) str = str.substr(pos);

    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
    operator=(ap_private_val);
    check_canary();
  }

  inline ap_private(const char* val, signed char rd) {
    set_canary();
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');

    if (pos != std::string::npos) str = str.substr(pos);

    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
    operator=(ap_private_val);
    check_canary();
  }

  inline ~ap_private() { check_canary(); }

  inline bool isNegative() const {
    static const uint64_t sign_mask = 1ULL << (_AP_W - 1);
    return _AP_S && (sign_mask & VAL);
  }

  inline bool isPositive() const { return !isNegative(); }

  inline bool isStrictlyPositive() const { return !isNegative() && VAL != 0; }

  inline bool isAllOnesValue() const { return (mask & VAL) == mask; }

  inline bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const {
    return VAL == RHS.get_VAL();
  }
  inline bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const {
    return (uint64_t)VAL == (uint64_t)RHS.get_VAL();
  }

  inline bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }
  inline bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }
  inline bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const {
    return VAL != RHS.get_VAL();
  }
  inline bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const {
    return (uint64_t)VAL != (uint64_t)RHS.get_VAL();
  }


  const ap_private operator++(int) {
    ap_private orig(*this);
    VAL++;
    clearUnusedBits();
    return orig;
  }


  const ap_private operator++() {
    ++VAL;
    clearUnusedBits();
    return *this;
  }


  const ap_private operator--(int) {
    ap_private orig(*this);
    --VAL;
    clearUnusedBits();
    return orig;
  }


  const ap_private operator--() {
    --VAL;
    clearUnusedBits();
    return *this;
  }


  inline ap_private<_AP_W + !_AP_S, true> operator~() const {
    ap_private<_AP_W + !_AP_S, true> Result(*this);
    Result.flip();
    return Result;
  }


  inline typename RType<1, false>::minus operator-() const {
    return ap_private<1, false>(0) - (*this);
  }


  inline bool operator!() const { return !VAL; }

  inline std::string toString(uint8_t radix, bool wantSigned) const;
  inline std::string toStringUnsigned(uint8_t radix = 10) const {
    return toString(radix, false);
  }
  inline std::string toStringSigned(uint8_t radix = 10) const {
    return toString(radix, true);
  }
  inline void clear() { VAL = 0; }
  inline ap_private& clear(uint32_t bitPosition) {
    VAL &= ~(1ULL << (bitPosition));
    clearUnusedBits();
    return *this;
  }

  inline ap_private ashr(uint32_t shiftAmt) const {
    if (_AP_S)
      return ap_private((shiftAmt == BitWidth) ? 0
                                               : ((int64_t)VAL) >> (shiftAmt));
    else
      return ap_private((shiftAmt == BitWidth) ? 0
                                               : ((uint64_t)VAL) >> (shiftAmt));
  }

  inline ap_private lshr(uint32_t shiftAmt) const {
    return ap_private((shiftAmt == BitWidth)
                          ? ap_private(0)
                          : ap_private((VAL & mask) >> (shiftAmt)));
  }

  inline ap_private shl(uint32_t shiftAmt) const




  {
    if (shiftAmt > BitWidth) {
      if (!isNegative())
        return ap_private(0);
      else
        return ap_private(-1);
    }
    if (shiftAmt == BitWidth)
      return ap_private(0);
    else
      return ap_private((VAL) << (shiftAmt));


  }

  inline int64_t getSExtValue() const { return VAL; }


  inline uint64_t getZExtValue() const { return VAL & mask; }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ref.get();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ((uint64_t)(bool)ref);
    check_canary();
  }
# 1867 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline void write(const ap_private<_AP_W, _AP_S>& op2) volatile {
    *this = (op2);
  }



  inline operator ValType() const { return get_VAL(); }

  inline int to_uchar() const { return (unsigned char)get_VAL(); }

  inline int to_char() const { return (signed char)get_VAL(); }

  inline int to_ushort() const { return (unsigned short)get_VAL(); }

  inline int to_short() const { return (short)get_VAL(); }

  inline int to_int() const {

    return (int)get_VAL();
  }

  inline unsigned to_uint() const { return (unsigned)get_VAL(); }

  inline long to_long() const { return (long)get_VAL(); }

  inline unsigned long to_ulong() const { return (unsigned long)get_VAL(); }

  inline ap_slong to_int64() const { return (ap_slong)get_VAL(); }

  inline ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }

  inline double to_double() const {
    if (isNegative())
      return roundToDouble(true);
    else
      return roundToDouble(false);
  }

  inline unsigned length() const { return _AP_W; }

  inline bool isMinValue() const { return VAL == 0; }
  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) & RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) | RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) ^ RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) * RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) + RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) - RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator&(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) &
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret & RHS;
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator^(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret ^ RHS;
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator|(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) |
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret | RHS;
    }
  }

  inline ap_private And(const ap_private& RHS) const {
    return ap_private(VAL & RHS.get_VAL());
  }

  inline ap_private Or(const ap_private& RHS) const {
    return ap_private(VAL | RHS.get_VAL());
  }

  inline ap_private Xor(const ap_private& RHS) const {
    return ap_private(VAL ^ RHS.get_VAL());
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::mult operator*(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) *
                                                  RHS.get_VAL());
      return Result;
    } else {
      typename RType<_AP_W1, _AP_S1>::mult Result(*this);
      Result *= RHS;
      return Result;
    }
  }

  inline ap_private Mul(const ap_private& RHS) const {
    return ap_private(VAL * RHS.get_VAL());
  }

  inline ap_private Add(const ap_private& RHS) const {
    return ap_private(VAL + RHS.get_VAL());
  }

  inline ap_private Sub(const ap_private& RHS) const {
    return ap_private(VAL - RHS.get_VAL());
  }

  inline ap_private& operator&=(uint64_t RHS) {
    VAL &= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator|=(uint64_t RHS) {
    VAL |= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator^=(uint64_t RHS) {
    VAL ^= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator*=(uint64_t RHS) {
    VAL *= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator+=(uint64_t RHS) {
    VAL += (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator-=(uint64_t RHS) {
    VAL -= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }

  inline bool isMinSignedValue() const {
    static const uint64_t min_mask = ~(~0ULL << (_AP_W - 1));
    return BitWidth == 1 ? VAL == 1
                         : (ap_private_ops::isNegative<_AP_W>(*this) &&
                            ((min_mask & VAL) == 0));
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::plus operator+(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::plus_w <= 64)
      return typename RType<_AP_W1, _AP_S1>::plus(
          RType<_AP_W1, _AP_S1>::plus_s
              ? int64_t(((uint64_t)VAL) + RHS.get_VAL())
              : uint64_t(((uint64_t)VAL) + RHS.get_VAL()));
    typename RType<_AP_W1, _AP_S1>::plus Result = RHS;
    Result += VAL;
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::minus operator-(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::minus_w <= 64)
      return typename RType<_AP_W1, _AP_S1>::minus(
          int64_t(((uint64_t)VAL) - RHS.get_VAL()));
    typename RType<_AP_W1, _AP_S1>::minus Result = *this;
    Result -= RHS;
    return Result;
  }

  inline uint32_t countPopulation() const {
    return ap_private_ops::CountPopulation_64(VAL);
  }
  inline uint32_t countLeadingZeros() const {
    int remainder = BitWidth % 64;
    int excessBits = (64 - remainder) % 64;
    uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);
    if (Count) Count -= excessBits;
    return AESL_std::min(Count, (uint32_t)_AP_W);
  }


  inline ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {
    ap_private<_AP_W, _AP_S> ret(*this);
    ret = (ret) >> (BitWidth - numBits);
    return ret;
  }


  inline ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {
    ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));
    ret = (ret) >> (BitWidth - numBits);
    return ret;


  }

  inline ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {
    VAL |= (1ULL << (bitPosition));
    clearUnusedBits();
    return *this;
  }

  inline void set() {
    VAL = (ValType)~0ULL;
    clearUnusedBits();
  }

  template <int _AP_W3>
  inline void set(const ap_private<_AP_W3, false>& val) {
    operator=(ap_private<_AP_W3, _AP_S>(val));
  }

  inline void set(const ap_private& val) { operator=(val); }

  inline void clearUnusedBits(void) volatile




  {
    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };
    VAL = (ValType)(
        _AP_S
            ? ((((int64_t)VAL) << (excess_bits)) >> (excess_bits))
            : (excess_bits ? (((uint64_t)VAL) << (excess_bits)) >> (excess_bits)
                           : (uint64_t)VAL));
  }

  inline void clearUnusedBitsToZero(void) {
    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };
    static uint64_t mask = ~0ULL >> (excess_bits);
    VAL &= mask;
  }

  inline ap_private udiv(const ap_private& RHS) const {
    return ap_private((uint64_t)VAL / RHS.get_VAL());
  }



  inline ap_private sdiv(const ap_private& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return ((uint64_t)(0 - (*this))) / (uint64_t)(0 - RHS);
      else
        return 0 - ((uint64_t)(0 - (*this)) / (uint64_t)(RHS));
    else if (RHS.isNegative())
      return 0 - (this->udiv((ap_private)(0 - RHS)));
    return this->udiv(RHS);
  }

  template <bool _AP_S2>
  inline ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {
    
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   RHS.get_VAL() != 0 && "Divide by 0"
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "RHS.get_VAL() != 0 && \"Divide by 0\""
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2173),0))
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                              ;
    return ap_private(((uint64_t)VAL) % ((uint64_t)RHS.get_VAL()));
  }



  template <bool _AP_S2>
  inline ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {
    if (isNegative()) {
      ap_private lhs = 0 - (*this);
      if (RHS.isNegative()) {
        ap_private rhs = 0 - RHS;
        return 0 - (lhs.urem(rhs));
      } else
        return 0 - (lhs.urem(RHS));
    } else if (RHS.isNegative()) {
      ap_private rhs = 0 - RHS;
      return this->urem(rhs);
    }
    return this->urem(RHS);
  }

  template <int _AP_W1, bool _AP_S1>
  inline bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return (*this) == RHS;
  }

  template <int _AP_W1, bool _AP_S1>
  inline bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (_AP_W1 <= 64) {
      uint64_t lhsZext = ((uint64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);
      uint64_t rhsZext =
          ((uint64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);
      return lhsZext < rhsZext;
    } else
      return RHS.uge(*this);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const




  {
    if (_AP_W1 <= 64) {
      int64_t lhsSext = ((int64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);
      int64_t rhsSext =
          ((int64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);
      return lhsSext < rhsSext;
    } else
      return RHS.sge(*this);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !ult(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !slt(RHS);
  }

  inline ap_private abs() const {
    if (isNegative()) return -(*this);
    return *this;
  }

  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> ret(*this);
    return ret;
  }

  inline static uint32_t getBitsNeeded(const char* str, uint32_t slen,
                                       uint8_t radix) {
    return _AP_W;
  }

  inline uint32_t getActiveBits() const {
    uint32_t bits = _AP_W - countLeadingZeros();
    return bits ? bits : 1;
  }

  inline double roundToDouble(bool isSigned = false) const {
    return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);
  }



  inline ap_private& reverse() {
    for (int i = 0; i < _AP_W / 2; ++i) {
      bool tmp = operator[](i);
      if (operator[](_AP_W - 1 - i))
        set(i);
      else
        clear(i);
      if (tmp)
        set(_AP_W - 1 - i);
      else
        clear(_AP_W - 1 - i);
    }
    clearUnusedBits();
    return *this;
  }


  inline bool iszero() const { return isMinValue(); }

  inline bool to_bool() const { return !iszero(); }


  inline bool sign() const {
    if (isNegative()) return true;
    return false;
  }


  inline void invert(int i) {
    
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2349),0))
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2350),0))
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    flip(i);
  }


  inline bool test(int i) const {
    
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2356),0))
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2357),0))
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return operator[](i);
  }



  inline void lrotate(int n) {
    
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2364),0))
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2365),0))
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(shl(n) | lshr(_AP_W - n));
  }



  inline void rrotate(int n) {
    
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2372),0))
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2373),0))
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(lshr(n) | shl(_AP_W - n));
  }


  inline void set(int i, bool v) {
    
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2379),0))
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2380),0))
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline void set_bit(int i, bool v) {
    
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2386),0))
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2387),0))
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline bool get_bit(int i) const {
    
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2393),0))
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2394),0))
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return (((1ULL << i) & VAL) != 0);
  }


  inline ap_private& flip() {
    VAL = (ValType)((~0ULL ^ VAL) & mask);
    clearUnusedBits();
    return *this;
  }


  inline ap_private& flip(uint32_t bitPosition) {
    
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   bitPosition < BitWidth && "Out of the bit-width range!"
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "bitPosition < BitWidth && \"Out of the bit-width range!\""
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2407),0))
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    set_bit(bitPosition, !get_bit(bitPosition));
    return *this;
  }


  inline void b_not() { flip(); }
# 2432 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::div operator/(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    return typename RType<_AP_W2, _AP_S2>::div(
        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::mod operator%(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    typename RType<_AP_W2, _AP_S2>::mod res =
        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)
                                                  : lhs.urem(rhs));
    return res;
  }
# 2472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator /=( const ap_private<_AP_W2, _AP_S2>& op) { *this = operator /(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator %=( const ap_private<_AP_W2, _AP_S2>& op) { *this = operator %(op); return *this; }
# 2490 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator<<(const char op) const { if (op >= _AP_W) return ap_private(0); if (CHAR_IS_SIGNED && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }



  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this << sh;
    } else {
      int sh = op2.to_int();
      return *this << sh;
    }
  }
# 2534 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator>>(const char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((CHAR_IS_SIGNED) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }



  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this >> sh;
    } else {
      int sh = op2.to_int();
      return *this >> sh;
    }
  }
# 2590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >>(op); clearUnusedBits(); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >>(op); clearUnusedBits(); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator >>(op); clearUnusedBits(); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator <<(op); clearUnusedBits(); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator <<(op); clearUnusedBits(); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator <<(op); clearUnusedBits(); return *this; }




  template <int _AP_W1, bool _AP_S1>
  inline bool operator==(const ap_private<_AP_W1, _AP_S1>& op) const {
    enum { _AP_MAX_W = ((((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) > (32) ? (((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) : (32)) };
    ap_private<_AP_MAX_W, false> lhs(*this);
    ap_private<_AP_MAX_W, false> rhs(op);
    if (_AP_MAX_W <= 64) {
      return (uint64_t)lhs.get_VAL() == (uint64_t)rhs.get_VAL();
    } else
      return lhs == rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this == op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);


    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);
    else if (_AP_W < 32 && _AP_W2 < 32)

      return lhs.sgt(rhs);
    else


        if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ugt(rhs);
      else
        return lhs.sgt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ugt(rhs);
    else
      return lhs.sgt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this > op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);
    else if (_AP_W < 32 && _AP_W2 < 32)
      return lhs.slt(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ult(rhs);
      else
        return lhs.slt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ult(rhs);
    else
      return lhs.slt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this < op);
  }




  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_bit_ref<_AP_W, _AP_S> operator[](int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }

  inline _private_bit_ref<_AP_W, _AP_S> bit(int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> bit(
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }
# 2915 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline bool and_reduce() const { return (VAL & mask) == mask; }

  inline bool nand_reduce() const { return (VAL & mask) != mask; }

  inline bool or_reduce() const { return (bool)VAL; }

  inline bool nor_reduce() const { return VAL == 0; }

  inline bool xor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? true : false;
  }

  inline bool xnor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? false : true;
  }

  inline std::string to_string(uint8_t radix = 2, bool sign = false) const {
    return toString(radix, radix == 10 ? _AP_S : sign);
  }
};

template <int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix,
                                                     bool wantSigned) const {
  
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,
                                           "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ,
                                           2942
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ),0))
                                            
# 2942 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                           ;
  static const char* digits[] = {"0", "1", "2", "3", "4", "5", "6", "7",
                                 "8", "9", "a", "b", "c", "d", "e", "f"};
  std::string result;
  if (radix != 10) {





    if (*this == (uint64_t)(0)) {


      switch (radix) {
        case 2:
          result = "0b0";
          break;
        case 8:
          result = "0o0";
          break;
        case 16:
          result = "0x0";
          break;
        default:
          
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "invalid radix" && 0
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2966),0))
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
      }
    } else {
      ap_private<_AP_W, false, true> tmp(*this);
      size_t insert_at = 0;
      bool leading_zero = true;
      if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        result = "-";
        insert_at = 1;
        leading_zero = false;
      }
      switch (radix) {
        case 2:
          result += "0b";
          break;
        case 8:
          result += "0o";
          break;
        case 16:
          result += "0x";
          break;
        default:
          
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "invalid radix" && 0
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2993),0))
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
      }
      insert_at += 2;


      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
      uint64_t mask = radix - 1;
      ap_private<_AP_W, false, true> zero(0);
      unsigned bits = 0;
      bool msb = false;
      while (tmp.ne(zero)) {
        unsigned digit = (unsigned)(tmp.get_VAL() & mask);
        result.insert(insert_at, digits[digit]);
        tmp = tmp.lshr(shift);
        bits++;
        msb = (digit >> (shift - 1)) == 1;
      }
      bits *= shift;
      if (bits < _AP_W && leading_zero && msb)
        result.insert(insert_at, digits[0]);
    }
    return result;
  }

  ap_private<_AP_W, false, true> tmp(*this);
  ap_private<6, false, true> divisor(radix);
  ap_private<_AP_W, _AP_S, true> zero(0);
  size_t insert_at = 0;
  if (wantSigned && isNegative()) {



    tmp.flip();
    tmp++;
    result = "-";
    insert_at = 1;
  }
  if (tmp == ap_private<_AP_W, false, true>(0ULL))
    result = "0";
  else
    while (tmp.ne(zero)) {
      ap_private<_AP_W, false, true> APdigit = tmp % divisor;
      ap_private<_AP_W, false, true> tmp2 = tmp / divisor;
      uint32_t digit = (uint32_t)(APdigit.getZExtValue());
      
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     digit < radix && "divide failed"
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "digit < radix && \"divide failed\""
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3037),0))
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
      result.insert(insert_at, digits[digit]);
      tmp = tmp2;
    }
  return result;

}


template <int _AP_W, bool _AP_S>
class ap_private<_AP_W, _AP_S, false> {

  const static bool valid = ap_private_enable_if<(_AP_W > 64)>::isValid;




 public:
  enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };
  static const int width = _AP_W;

 private:
# 3069 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(uint32_t numWords, const uint64_t bigVal[]) {
    set_canary();
    
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   bigVal && "Null pointer detected!"
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "bigVal && \"Null pointer detected!\""
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3071),0))
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    {

      memset(pVal, 0, _AP_N * sizeof(uint64_t));


      uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);

      memcpy(pVal, bigVal, words * APINT_WORD_SIZE);
      if (words >= _AP_W) clearUnusedBits();

    }
    check_canary();
  }
# 3094 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(const std::string& val, uint8_t radix = 2) {
    set_canary();
    
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   !val.empty() && "The input string is empty."
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "!val.empty() && \"The input string is empty.\""
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3096),0))
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                       ;
    const char* c_str = val.c_str();
    fromString(c_str, val.size(), radix);
    check_canary();
  }
# 3112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(const char strStart[], uint32_t slen, uint8_t radix) {
    set_canary();
    fromString(strStart, slen, radix);
    check_canary();
  }

  inline void report() {
    do { if ((_AP_W > ((1024 + 1023) / 1024) * 1024)) { fprintf(
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "ERROR: " "ap_%sint<%d>: Bitwidth exceeds the " "default max value %d. Please use macro " "AP_INT_MAX_W to set a larger max value.", _AP_S ? "" : "u", _AP_W, ((1024 + 1023) / 1024) * 1024); fprintf(
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); abort(); } } while (0)



                                                                     ;
  }





  uint64_t pVal[_AP_N];





  inline void check_canary() {}
  inline void set_canary() {}


 public:
  typedef typename valtype<8, _AP_S>::Type ValType;
  typedef ap_private<_AP_W, _AP_S> Type;

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  friend struct ap_fixed_base;


  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };
    typedef ap_private<mult_w, mult_s> mult;
    typedef ap_private<plus_w, plus_s> plus;
    typedef ap_private<minus_w, minus_s> minus;
    typedef ap_private<logic_w, logic_s> logic;
    typedef ap_private<div_w, div_s> div;
    typedef ap_private<mod_w, mod_s> mod;
    typedef ap_private<_AP_W, _AP_S> arg1;
    typedef bool reduce;
  };

  inline uint64_t& get_VAL(void) { return pVal[0]; }
  inline uint64_t get_VAL(void) const { return pVal[0]; }
  inline uint64_t get_VAL(void) const volatile { return pVal[0]; }
  inline void set_VAL(uint64_t value) { pVal[0] = value; }
  inline uint64_t& get_pVal(int index) { return pVal[index]; }
  inline uint64_t* get_pVal() { return pVal; }
  inline const uint64_t* get_pVal() const { return pVal; }
  inline uint64_t get_pVal(int index) const { return pVal[index]; }
  inline uint64_t* get_pVal() const volatile { return pVal; }
  inline uint64_t get_pVal(int index) const volatile { return pVal[index]; }
  inline void set_pVal(int i, uint64_t value) { pVal[i] = value; }


  enum {
    APINT_BITS_PER_WORD = sizeof(uint64_t) * 8,
    APINT_WORD_SIZE = sizeof(uint64_t)
  };

  enum {
    excess_bits = (_AP_W % APINT_BITS_PER_WORD)
                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)
                      : 0
  };
  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));

 public:

  explicit inline ap_private(const char* val) {
    set_canary();
    unsigned char radix = 10;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');
    if (pos != std::string::npos) str = str.substr(pos);
    ap_private ap_private_val(str, radix);
    operator=(ap_private_val);
    report();
    check_canary();
  }

  inline ap_private(const char* val, unsigned char rd) {
    set_canary();
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');
    if (pos != std::string::npos) str = str.substr(pos);
    ap_private ap_private_val(str, radix);
    operator=(ap_private_val);
    report();

    report();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ref.get();
    report();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ((uint64_t)(bool)ref);
    report();
    check_canary();
  }
# 3276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(const ap_private& that) {
      set_canary();
      memcpy(pVal, that.get_pVal(), _AP_N * APINT_WORD_SIZE);
      clearUnusedBits();
      check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, false>& that) {
    set_canary();
    operator=(that);
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, false>& that) {
    set_canary();
    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, false>&>(that));
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {
    set_canary();
    static const uint64_t that_sign_ext_mask =
        (_AP_W1 == APINT_BITS_PER_WORD)
            ? 0
            : ~0ULL >> (_AP_W1 % APINT_BITS_PER_WORD)
                           << (_AP_W1 % APINT_BITS_PER_WORD);
    if (that.isNegative()) {
      pVal[0] = that.get_VAL() | that_sign_ext_mask;
      memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1));
    } else {
      pVal[0] = that.get_VAL();
      memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1));
    }
    clearUnusedBits();
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, true>& that) {
    set_canary();
    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, true>&>(that));
    check_canary();
  }



  inline ~ap_private() { check_canary(); }







  inline ap_private() {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  inline ap_private(uint64_t* val, uint32_t bits = _AP_W) { 
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                           (void) ((!!(
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           0
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                           )) || (_assert(
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           "0"
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                           ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3339),0))
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                    ; }
  inline ap_private(const uint64_t* const val, uint32_t bits) { 
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                               (void) ((!!(
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                               0
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                               )) || (_assert(
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                               "0"
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                               ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3340),0))
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                        ; }
# 3363 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(bool val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(char val, bool isSigned = CHAR_IS_SIGNED) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(signed char val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned char val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(short val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned short val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(int val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned int val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(long val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned long val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(ap_slong val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(ap_ulong val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(half val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(float val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(double val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }




  inline bool isSingleWord() const { return false; }



  static inline uint32_t whichWord(uint32_t bitPosition) {

    return (bitPosition) >> 6;
  }




  static inline uint32_t whichBit(uint32_t bitPosition) {

    return bitPosition & 0x3f;
  }





  static inline uint64_t maskBit(uint32_t bitPosition) {
    return 1ULL << (whichBit(bitPosition));
  }



  inline uint64_t getWord(uint32_t bitPosition) const {
    return pVal[whichWord(bitPosition)];
  }






  inline void clearUnusedBits(void) volatile




  {
    pVal[_AP_N - 1] =
        _AP_S ? ((((int64_t)pVal[_AP_N - 1]) << (excess_bits)) >> excess_bits)
              : (excess_bits
                     ? ((pVal[_AP_N - 1]) << (excess_bits)) >> (excess_bits)
                     : pVal[_AP_N - 1]);
  }

  inline void clearUnusedBitsToZero(void) { pVal[_AP_N - 1] &= mask; }

  inline void clearUnusedBitsToOne(void) { pVal[_AP_N - 1] |= mask; }



  inline void fromString(const char* str, uint32_t slen, uint8_t radix) {
    enum { numbits = _AP_W };
    bool isNeg = str[0] == '-';
    if (isNeg) {
      str++;
      slen--;
    }

    if (str[0] == '0' && (str[1] == 'b' || str[1] == 'B')) {

      do { if ((radix != 2)) { fprintf(
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 2, radix); fprintf(
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'o' || str[1] == 'O')) {

      do { if ((radix != 8)) { fprintf(
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 8, radix); fprintf(
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {

      do { if ((radix != 16)) { fprintf(
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 16, radix); fprintf(
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'd' || str[1] == 'D')) {

      do { if ((radix != 10)) { fprintf(
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 10, radix); fprintf(
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (radix == 0) {

    }


    
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                             "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                             3471
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                              
# 3471 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   str && "String is null?"
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "str && \"String is null?\""
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3472),0))
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;


    while (*str == '0' && *(str + 1) != '\0') {
      str++;
      slen--;
    }
    
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (slen <= numbits || radix != 2) && "Insufficient bit width"
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(slen <= numbits || radix != 2) && \"Insufficient bit width\""
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3479),0))
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                      ;
    
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   ((slen - 1) * 3 <= numbits || radix != 8) && "Insufficient bit width"
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "((slen - 1) * 3 <= numbits || radix != 8) && \"Insufficient bit width\""
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                   3481
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                    
# 3481 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;
    
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   ((slen - 1) * 4 <= numbits || radix != 16) && "Insufficient bit width"
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "((slen - 1) * 4 <= numbits || radix != 16) && \"Insufficient bit width\""
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                   3483
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                    
# 3483 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;
    
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (((slen - 1) * 64) / 22 <= numbits || radix != 10) && "Insufficient bit width"
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(((slen - 1) * 64) / 22 <= numbits || radix != 10) && \"Insufficient bit width\""
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                   3485
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                    
# 3485 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;


    memset(pVal, 0, _AP_N * sizeof(uint64_t));


    uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);



    uint64_t bigVal[_AP_N];
    memset(bigVal, 0, _AP_N * sizeof(uint64_t));
    ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);
    ap_private<_AP_W, _AP_S> apradix(radix);


    for (unsigned i = 0; i < slen; i++) {

      uint32_t digit = 0;
      char cdigit = str[i];
      if (radix == 16) {




        if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F'))) 
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                              (void) ((!!(
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                              0 && "Invalid hex digit in string"
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                              )) || (_assert(
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                              "0 && \"Invalid hex digit in string\""
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                              ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3510),0))
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                        ;
        if (((cdigit) >= '0' && (cdigit) <= '9'))
          digit = cdigit - '0';
        else if (cdigit >= 'a')
          digit = cdigit - 'a' + 10;
        else if (cdigit >= 'A')
          digit = cdigit - 'A' + 10;
        else
          
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         0 && "huh? we shouldn't get here"
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "0 && \"huh? we shouldn't get here\""
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3518),0))
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                  ;
      } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
        digit = cdigit - '0';
      } else if (cdigit != '\0') {
        
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       (void) ((!!(
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       0 && "Invalid character in digit string"
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       )) || (_assert(
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       "0 && \"Invalid character in digit string\""
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3522),0))
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                       ;
      }



      if (shift)
        *this <<= shift;
      else
        *this *= apradix;


      apdigit.set_VAL(digit);
      *this += apdigit;
    }

    if (isNeg) {
      (*this)--;
      this->flip();
    }
    clearUnusedBits();
  }

  inline ap_private read() volatile { return *this; }

  inline void write(const ap_private& op2) volatile { *this = (op2); }

  inline operator ValType() const { return get_VAL(); }

  inline int to_uchar() const { return (unsigned char)get_VAL(); }

  inline int to_char() const { return (signed char)get_VAL(); }

  inline int to_ushort() const { return (unsigned short)get_VAL(); }

  inline int to_short() const { return (short)get_VAL(); }

  inline int to_int() const { return (int)get_VAL(); }

  inline unsigned to_uint() const { return (unsigned)get_VAL(); }

  inline long to_long() const { return (long)get_VAL(); }

  inline unsigned long to_ulong() const { return (unsigned long)get_VAL(); }

  inline ap_slong to_int64() const { return (ap_slong)get_VAL(); }

  inline ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }

  inline double to_double() const {
    if (isNegative())
      return roundToDouble(true);
    else
      return roundToDouble(false);
  }

  inline unsigned length() const { return _AP_W; }



  inline ap_private& reverse() {
    for (int i = 0; i < _AP_W / 2; ++i) {
      bool tmp = operator[](i);
      if (operator[](_AP_W - 1 - i))
        set(i);
      else
        clear(i);
      if (tmp)
        set(_AP_W - 1 - i);
      else
        clear(_AP_W - 1 - i);
    }
    clearUnusedBits();
    return *this;
  }


  inline bool iszero() const { return isMinValue(); }

  inline bool to_bool() const { return !iszero(); }


  inline bool sign() const {
    if (isNegative()) return true;
    return false;
  }


  inline void invert(int i) {
    
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3610),0))
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3611),0))
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    flip(i);
  }


  inline bool test(int i) const {
    
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3617),0))
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3618),0))
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return operator[](i);
  }


  inline void set(int i, bool v) {
    
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3624),0))
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3625),0))
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline void set_bit(int i, bool v) {
    
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3631),0))
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3632),0))
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline ap_private& set(uint32_t bitPosition) {
    pVal[whichWord(bitPosition)] |= maskBit(bitPosition);
    clearUnusedBits();
    return *this;
  }

  inline void set() {
    for (int i = 0; i < _AP_N; ++i) pVal[i] = ~0ULL;
    clearUnusedBits();
  }


  inline bool get(int i) const {
    
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3650),0))
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3651),0))
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
  }


  inline bool get_bit(int i) const {
    
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3657),0))
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3658),0))
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
  }



  inline void lrotate(int n) {
    
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3665),0))
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3666),0))
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(shl(n) | lshr(_AP_W - n));
  }



  inline void rrotate(int n) {
    
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3673),0))
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3674),0))
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(lshr(n) | shl(_AP_W - n));
  }



  inline ap_private& clear(uint32_t bitPosition) {
    pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);
    clearUnusedBits();
    return *this;
  }


  inline void clear() { memset(pVal, 0, _AP_N * APINT_WORD_SIZE); }


  ap_private& flip() {
    for (int i = 0; i < _AP_N; ++i) pVal[i] ^= ~0ULL;
    clearUnusedBits();
    return *this;
  }


  inline ap_private& flip(uint32_t bitPosition) {
    
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   bitPosition < BitWidth && "Out of the bit-width range!"
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "bitPosition < BitWidth && \"Out of the bit-width range!\""
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3698),0))
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    set_bit(bitPosition, !get_bit(bitPosition));
    return *this;
  }


  inline void b_not() { flip(); }

  inline ap_private getLoBits(uint32_t numBits) const {
    return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),
                                _AP_W - numBits);
  }

  inline ap_private getHiBits(uint32_t numBits) const {
    return ap_private_ops::lshr(*this, _AP_W - numBits);
  }
# 3757 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator &=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
# 3757 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (&__iob_func()[2])
# 3757 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "&=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] &= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] &= ext; } clearUnusedBits(); return *this; };
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator |=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
# 3758 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (&__iob_func()[2])
# 3758 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "|=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] |= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] |= ext; } clearUnusedBits(); return *this; };
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator ^=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
# 3759 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (&__iob_func()[2])
# 3759 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "^=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] ^= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] ^= ext; } clearUnusedBits(); return *this; };





  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    uint64_t RHSpVal[_AP_N1];
    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);
    ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,
                        _AP_S1);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    uint64_t RHSpVal[_AP_N1];
    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);
    ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,
                        _AP_S1);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;
    if (!lhsWords) {

      return *this;
    }

    ap_private dupRHS = RHS;

    uint32_t rhsBits = dupRHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;
    if (!rhsWords) {

      clear();
      return *this;
    }


    uint32_t destWords = rhsWords + lhsWords;
    uint64_t* dest = (uint64_t*)malloc(destWords * sizeof(uint64_t));


    ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords,
                        destWords);


    clear();
    uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;

    memcpy(pVal, dest, wordsToCopy * APINT_WORD_SIZE);

    uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;
    for (int i = wordsToCopy; i < _AP_N; i++) pVal[i] = ext;
    clearUnusedBits();

    free(dest);
    return *this;
  }
# 3836 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator /=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator /(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator %=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator %(op); return *this; }
# 3876 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator |( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] | RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] | ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) | ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext | ext2); } } Result.clearUnusedBits(); return Result; };
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator &( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] & RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] & ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) & ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext & ext2); } } Result.clearUnusedBits(); return Result; };
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator ^( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] ^ RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] ^ ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) ^ ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext ^ ext2); } } Result.clearUnusedBits(); return Result; };



  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::plus operator+(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::plus Result, lhs(*this), rhs(RHS);
    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::plus_w + 63) / 64;
    ap_private_ops::add(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),
                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
    Result.clearUnusedBits();
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::minus operator-(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::minus Result, lhs(*this), rhs(RHS);
    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::minus_w + 63) / 64;
    ap_private_ops::sub(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),
                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
    Result.clearUnusedBits();
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::mult operator*(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::mult temp = *this;
    temp *= RHS;
    return temp;
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::div operator/(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    return typename RType<_AP_W2, _AP_S2>::div(
        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::mod operator%(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    typename RType<_AP_W2, _AP_S2>::mod res =
        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)
                                                  : lhs.urem(rhs));
    return res;
  }
# 3951 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator<<(const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }

  inline ap_private operator<<(const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }


  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this << sh;
    } else {
      int sh = op2.to_int();
      return *this << sh;
    }
  }
# 3994 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator>>(const char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((CHAR_IS_SIGNED) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }


  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this >> sh;
    } else {
      int sh = op2.to_int();
      return *this >> sh;
    }
  }
# 4039 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >>(op); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >>(op); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator >>(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator <<(op); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator <<(op); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator <<(op); return *this; }




  inline bool operator==(const ap_private& RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 = RHS.getActiveBits();


    if (n1 != n2) return false;



    if (n1 <= APINT_BITS_PER_WORD) return pVal[0] == RHS.get_pVal(0);


    for (int i = whichWord(n1 - 1); i >= 0; --i)
      if (pVal[i] != RHS.get_pVal(i)) return false;
    return true;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)),
    };
    ap_private<_AP_MAX_W, false> lhs(*this);
    ap_private<_AP_MAX_W, false> rhs(op);
    return lhs == rhs;
  }

  inline bool operator==(uint64_t Val) const {
    uint32_t n = getActiveBits();
    if (n <= APINT_BITS_PER_WORD)
      return pVal[0] == Val;
    else
      return false;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this == op);
  }

  template <bool _AP_S1>
  inline bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }

  inline bool operator!=(uint64_t Val) const { return !((*this) == Val); }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this > op);
  }

  inline bool operator<(const ap_private& op) const {
    return _AP_S ? slt(op) : ult(op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ult(rhs);
      else
        return lhs.slt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ult(rhs);
    else
      return lhs.slt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this < op);
  }

  inline bool operator>(const ap_private& op) const {
    return _AP_S ? sgt(op) : ugt(op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ugt(rhs);
      else
        return lhs.sgt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ugt(rhs);
    else
      return lhs.sgt(rhs);
  }



  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> range(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> operator()(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> range(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(const_cast<ap_private*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> operator()(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline _private_bit_ref<_AP_W, _AP_S> operator[](int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  inline _private_bit_ref<_AP_W, _AP_S> bit(int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> bit(
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }
# 4409 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> ret(*this);
    return ret;
  }

  template <int _AP_W3>
  inline void set(const ap_private<_AP_W3, false>& val) {
    operator=(ap_private<_AP_W3, _AP_S>(val));
  }







  inline bool isNegative() const {

    enum { shift = (_AP_W - APINT_BITS_PER_WORD * (_AP_N - 1) - 1) };
    static const uint64_t mask = 1ULL << (shift);
    return _AP_S && (pVal[_AP_N - 1] & mask);
  }



  inline bool isPositive() const { return !isNegative(); }




  inline bool isStrictlyPositive() const {
    return isPositive() && (*this) != 0;
  }




  inline bool isAllOnesValue() const { return countPopulation() == _AP_W; }




  inline bool isMaxValue() const { return countPopulation() == _AP_W; }




  inline bool isMaxSignedValue() const {
    return !isNegative() && countPopulation() == _AP_W - 1;
  }




  inline bool isMinValue() const { return countPopulation() == 0; }




  inline bool isMinSignedValue() const {
    return isNegative() && countPopulation() == 1;
  }




  inline const uint64_t* getRawData() const { return &pVal[0]; }
# 4484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private sqrt() const {

    uint32_t magnitude = getActiveBits();



    if (magnitude <= 5) {
      static const uint8_t results[32] = {
                      0,
                      1, 1,
                      2, 2, 2, 2,
                      3, 3, 3, 3, 3, 3,
                      4, 4, 4, 4, 4, 4, 4, 4,
                      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                      6};
      return ap_private<_AP_W, _AP_S>( results[get_VAL()]);
    }





    if (magnitude < 52) {






      return ap_private<_AP_W, _AP_S>(
                                      uint64_t(
                                          ::round(::sqrt(double(get_VAL())))));

    }






    uint32_t nbits = BitWidth, i = 4;
    ap_private<_AP_W, _AP_S> testy(16);
    ap_private<_AP_W, _AP_S> x_old( 1);
    ap_private<_AP_W, _AP_S> x_new(0);
    ap_private<_AP_W, _AP_S> two( 2);


    for (;; i += 2, testy = testy.shl(2))
      if (i >= nbits || this->ule(testy)) {
        x_old = x_old.shl(i / 2);
        break;
      }


    for (;;) {
      x_new = (this->udiv(x_old) + x_old).udiv(two);
      if (x_old.ule(x_new)) break;
      x_old = x_new;
    }
# 4551 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
    ap_private<_AP_W, _AP_S> square(x_old * x_old);
    ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old + 1));
    if (this->ult(square))
      return x_old;
    else if (this->ule(nextSquare)) {
      ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));
      ap_private<_AP_W, _AP_S> offset(*this - square);
      if (offset.ult(midpoint))
        return x_old;
      else
        return x_old + 1;
    } else
      
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     0 && "Error in ap_private<_AP_W, _AP_S>::sqrt computation"
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\""
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4563),0))
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                       ;
    return x_old + 1;
  }






  inline ap_private& operator=(const ap_private& RHS) {
    if (this != &RHS) memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator=(const volatile ap_private& RHS) {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    clearUnusedBits();
    return *this;
  }
  inline void operator=(const ap_private& RHS) volatile {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    clearUnusedBits();
  }
  inline void operator=(const volatile ap_private& RHS) volatile {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    clearUnusedBits();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    if (_AP_S1)
      cpSextOrTrunc(RHS);
    else
      cpZextOrTrunc(RHS);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
    if (_AP_S1)
      cpSextOrTrunc(RHS);
    else
      cpZextOrTrunc(RHS);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    *this = ap_private<_AP_W2, false>(op2);
    return *this;
  }
# 4658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private& operator=(const bool rhs) { ap_private<(1), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const char rhs) { ap_private<(8), (CHAR_IS_SIGNED)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const signed char rhs) { ap_private<(8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned char rhs) { ap_private<(8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const short rhs) { ap_private<(sizeof(short) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned short rhs) { ap_private<(sizeof(unsigned short) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const int rhs) { ap_private<(sizeof(int) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned int rhs) { ap_private<(sizeof(unsigned int) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const long rhs) { ap_private<(sizeof(long) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned long rhs) { ap_private<(sizeof(unsigned long) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const ap_slong rhs) { ap_private<(sizeof(ap_slong) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const ap_ulong rhs) { ap_private<(sizeof(ap_ulong) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }




  inline ap_private& operator=(const char* s) {
    ap_private tmp(s);
    operator=(tmp);
    return *this;
  }






  inline const ap_private operator++(int) {
    ap_private API(*this);
    ++(*this);
    return API;
  }



  inline ap_private& operator++() {
    ap_private_ops::add_1(pVal, pVal, _AP_N, 1);
    clearUnusedBits();
    return *this;
  }



  inline const ap_private operator--(int) {
    ap_private API(*this);
    --(*this);
    return API;
  }



  inline ap_private& operator--() {
    ap_private_ops::sub_1(pVal, _AP_N, 1);
    clearUnusedBits();
    return *this;
  }




  inline ap_private<_AP_W + !_AP_S, true> operator~() const {
    ap_private<_AP_W + !_AP_S, true> Result(*this);
    Result.flip();
    return Result;
  }




  inline typename RType<1, false>::minus operator-() const {
    return ap_private<1, false>(0) - (*this);
  }




  inline bool operator!() const {
    for (int i = 0; i < _AP_N; ++i)
      if (pVal[i]) return false;
    return true;
  }

  template <bool _AP_S1>
  inline ap_private<_AP_W, _AP_S || _AP_S1> And(
      const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator&(RHS);
  }
  template <bool _AP_S1>
  inline ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator|(RHS);
  }
  template <bool _AP_S1>
  inline ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator^(RHS);
  }

  inline ap_private Mul(const ap_private& RHS) const {
    ap_private Result(*this);
    Result *= RHS;
    return Result;
  }

  inline ap_private Add(const ap_private& RHS) const {
    ap_private Result(0);
    ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,
                        _AP_N, _AP_S, _AP_S);
    Result.clearUnusedBits();
    return Result;
  }

  inline ap_private Sub(const ap_private& RHS) const {
    ap_private Result(0);
    ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,
                        _AP_N, _AP_S, _AP_S);
    Result.clearUnusedBits();
    return Result;
  }



  inline ap_private ashr(uint32_t shiftAmt) const {
    
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   shiftAmt <= BitWidth && "Invalid shift amount, too big"
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "shiftAmt <= BitWidth && \"Invalid shift amount, too big\""
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4779),0))
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;

    if (shiftAmt == 0) return ap_private(*this);





    if (shiftAmt == BitWidth) {
      if (isNegative())
        return ap_private(-1);
      else
        return ap_private(0);
    }


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();


    uint32_t wordShift =
        shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
    uint32_t breakWord = _AP_N - 1 - offset;
    uint32_t bitsInWord = whichBit(BitWidth);
    if (bitsInWord == 0) bitsInWord = APINT_BITS_PER_WORD;


    if (wordShift == 0) {

      for (uint32_t i = 0; i <= breakWord; ++i)
        val[i] = pVal[i + offset];


      if (isNegative())
        if (bitsInWord < APINT_BITS_PER_WORD)
          val[breakWord] |= ~0ULL << (bitsInWord);
    } else {

      for (uint32_t i = 0; i < breakWord; ++i) {


        val[i] = ((pVal[i + offset]) >> (wordShift));
        val[i] |= ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));
      }



      val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);




      if (isNegative()) {
        if (wordShift > bitsInWord) {
          if (breakWord > 0)
            val[breakWord - 1] |=
                ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));
          val[breakWord] |= ~0ULL;
        } else
          val[breakWord] |= (~0ULL << (bitsInWord - wordShift));
      }
    }


    uint64_t fillValue = (isNegative() ? ~0ULL : 0);
    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = fillValue;
    Retval.clearUnusedBits();
    return Retval;
  }



  inline ap_private lshr(uint32_t shiftAmt) const {



    if (shiftAmt == BitWidth) return ap_private(0);




    if (shiftAmt == 0) return ap_private(*this);


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();



    if (shiftAmt < APINT_BITS_PER_WORD) {
      uint64_t carry = 0;
      for (int i = _AP_N - 1; i >= 0; --i) {
        val[i] = ((pVal[i]) >> (shiftAmt)) | carry;
        carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);
      }
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


    if (wordShift == 0) {
      for (uint32_t i = 0; i < _AP_N - offset; ++i) val[i] = pVal[i + offset];
      for (uint32_t i = _AP_N - offset; i < _AP_N; i++) val[i] = 0;
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t breakWord = _AP_N - offset - 1;
    for (uint32_t i = 0; i < breakWord; ++i)
      val[i] = ((pVal[i + offset]) >> (wordShift)) |
               ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));

    val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);


    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = 0;
    Retval.clearUnusedBits();
    return Retval;
  }



  inline ap_private shl(uint32_t shiftAmt) const {
    
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   shiftAmt <= BitWidth && "Invalid shift amount, too big"
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "shiftAmt <= BitWidth && \"Invalid shift amount, too big\""
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4908),0))
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;



    if (shiftAmt == BitWidth) return ap_private(0);





    if (shiftAmt == 0) return ap_private(*this);


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();

    if (shiftAmt < APINT_BITS_PER_WORD) {
      uint64_t carry = 0;
      for (int i = 0; i < _AP_N; i++) {
        val[i] = ((pVal[i]) << (shiftAmt)) | carry;
        carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);
      }
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


    if (wordShift == 0) {
      for (uint32_t i = 0; i < offset; i++) val[i] = 0;
      for (int i = offset; i < _AP_N; i++) val[i] = pVal[i - offset];
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t i = _AP_N - 1;
    for (; i > offset; --i)
      val[i] = (pVal[i - offset]) << (wordShift) |
               (pVal[i - offset - 1]) >> (APINT_BITS_PER_WORD - wordShift);
    val[offset] = (pVal[0]) << (wordShift);
    for (i = 0; i < offset; ++i) val[i] = 0;
    Retval.clearUnusedBits();
    return Retval;
  }

  inline ap_private rotl(uint32_t rotateAmt) const {
    if (rotateAmt == 0) return ap_private(*this);

    ap_private hi(*this);
    ap_private lo(*this);
    hi.shl(rotateAmt);
    lo.lshr(BitWidth - rotateAmt);
    return hi | lo;
  }

  inline ap_private rotr(uint32_t rotateAmt) const {
    if (rotateAmt == 0) return ap_private(*this);

    ap_private hi(*this);
    ap_private lo(*this);
    lo.lshr(rotateAmt);
    hi.shl(BitWidth - rotateAmt);
    return hi | lo;
  }






  inline ap_private udiv(const ap_private& RHS) const {

    uint32_t rhsBits = RHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
    
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   rhsWords && "Divided by zero???"
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "rhsWords && \"Divided by zero???\""
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4986),0))
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                           ;
    uint32_t lhsBits = this->getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


    if (!lhsWords)

      return ap_private(0);
    else if (lhsWords < rhsWords || this->ult(RHS)) {

      return ap_private(0);
    } else if (*this == RHS) {

      return ap_private(1);
    } else if (lhsWords == 1 && rhsWords == 1) {

      return ap_private(this->pVal[0] / RHS.get_pVal(0));
    }


    ap_private Quotient(0);
    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient,
                           (ap_private*)0);
    return Quotient;
  }



  inline ap_private sdiv(const ap_private& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return (-(*this)).udiv(-RHS);
      else
        return -((-(*this)).udiv(RHS));
    else if (RHS.isNegative())
      return -(this->udiv((ap_private)(-RHS)));
    return this->udiv(RHS);
  }
# 5033 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private urem(const ap_private& RHS) const {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


    uint32_t rhsBits = RHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
    
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   rhsWords && "Performing remainder operation by zero ???"
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "rhsWords && \"Performing remainder operation by zero ???\""
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5041),0))
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                   ;


    if (lhsWords == 0) {

      return ap_private(0);
    } else if (lhsWords < rhsWords || this->ult(RHS)) {

      return *this;
    } else if (*this == RHS) {

      return ap_private(0);
    } else if (lhsWords == 1) {

      return ap_private(pVal[0] % RHS.get_pVal(0));
    }


    ap_private Remainder(0);
    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0),
                           &Remainder);
    return Remainder;
  }

  inline ap_private urem(uint64_t RHS) const {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);

    uint32_t rhsWords = 1;

    
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   rhsWords && "Performing remainder operation by zero ???"
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "rhsWords && \"Performing remainder operation by zero ???\""
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5072),0))
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                   ;

    if (lhsWords == 0) {

      return ap_private(0);
    } else if (lhsWords < rhsWords || this->ult(RHS)) {

      return *this;
    } else if (*this == RHS) {

      return ap_private(0);
    } else if (lhsWords == 1) {

      return ap_private(pVal[0] % RHS);
    }


    ap_private Remainder(0);
    divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);
    return Remainder;
  }



  inline ap_private srem(const ap_private& RHS) const {
    if (isNegative()) {
      ap_private lhs = -(*this);
      if (RHS.isNegative()) {
        ap_private rhs = -RHS;
        return -(lhs.urem(rhs));
      } else
        return -(lhs.urem(RHS));
    } else if (RHS.isNegative()) {
      ap_private rhs = -RHS;
      return this->urem(rhs);
    }
    return this->urem(RHS);
  }



  inline ap_private srem(int64_t RHS) const {
    if (isNegative())
      if (RHS < 0)
        return -((-(*this)).urem(-RHS));
      else
        return -((-(*this)).urem(RHS));
    else if (RHS < 0)
      return this->urem(-RHS);
    return this->urem(RHS);
  }





  template <bool _AP_S1>
  inline bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return (*this) == RHS;
  }





  template <bool _AP_S1>
  inline bool ne(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }





  template <bool _AP_S1>
  inline bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 = RHS.getActiveBits();


    if (n1 < n2) return true;


    if (n2 < n1) return false;


    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
      return pVal[0] < RHS.get_pVal(0);


    uint32_t topWord = whichWord(AESL_std::max(n1, n2) - 1);
    for (int i = topWord; i >= 0; --i) {
      if (pVal[i] > RHS.get_pVal(i)) return false;
      if (pVal[i] < RHS.get_pVal(i)) return true;
    }
    return false;
  }

  inline bool ult(uint64_t RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 =
        64 - ap_private_ops::CountLeadingZeros_64(RHS);


    if (n1 < n2) return true;


    if (n2 < n1) return false;


    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
      return pVal[0] < RHS;
    
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0"
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5186),0))
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
            ;
  }

  template <bool _AP_S1>
  inline bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    ap_private lhs(*this);
    ap_private<_AP_W, _AP_S1> rhs(RHS);
    bool lhsNeg = isNegative();
    bool rhsNeg = rhs.isNegative();
    if (lhsNeg) {

      lhs.flip();
      lhs++;
    }
    if (rhsNeg) {

      rhs.flip();
      rhs++;
    }



    if (lhsNeg)
      if (rhsNeg)
        return lhs.ugt(rhs);
      else
        return true;
    else if (rhsNeg)
      return false;
    else
      return lhs.ult(rhs);
  }





  template <bool _AP_S1>
  inline bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  template <bool _AP_S1>
  inline bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  template <bool _AP_S1>
  inline bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  template <bool _AP_S1>
  inline bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  template <bool _AP_S1>
  inline bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {
    return !ult(RHS);
  }





  template <bool _AP_S1>
  inline bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !slt(RHS);
  }


  template <int _AP_W1, bool _AP_S1>
  inline void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {
    
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 < BitWidth && "Invalid ap_private SignExtend request"
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\""
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5276),0))
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                       ;
    
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 <= MAX_INT_BITS && "Too many bits"
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 <= MAX_INT_BITS && \"Too many bits\""
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5277),0))
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;

    if (!that.isNegative()) {
      cpZext(that);
      return;
    }


    enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD };
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;

    if (_AP_N1 == _AP_N) {
      enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };

      static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      pVal[_AP_N - 1] |= mask;
      return;
    }

    enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };

    static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;
    int i;
    for (i = 0; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);
    pVal[i - 1] |= mask;
    for (; i < _AP_N - 1; i++) pVal[i] = ~0ULL;
    pVal[i] = ~0ULL;
    clearUnusedBits();
    return;
  }


  template <int _AP_W1, bool _AP_S1>
  inline void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {
    
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 < BitWidth && "Invalid ap_private ZeroExtend request"
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\""
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5312),0))
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                       ;
    
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 <= MAX_INT_BITS && "Too many bits"
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 <= MAX_INT_BITS && \"Too many bits\""
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5313),0))
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    int i = 0;
    for (; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);
    for (; i < _AP_N; ++i) pVal[i] = 0;
    clearUnusedBits();
  }

  template <int _AP_W1, bool _AP_S1>
  inline void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
    if (BitWidth > _AP_W1)
      cpZext(that);
    else {
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      clearUnusedBits();
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
    if (BitWidth > _AP_W1)
      cpSext(that);
    else {
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      clearUnusedBits();
    }
  }






  inline uint32_t getBitWidth() const { return BitWidth; }




  inline uint32_t getNumWords() const {
    return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
  }





  inline uint32_t getActiveBits() const {
    uint32_t bits = BitWidth - countLeadingZeros();
    return bits ? bits : 1;
  }






  inline uint64_t getZExtValue() const {
    
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   getActiveBits() <= 64 && "Too many bits for uint64_t"
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "getActiveBits() <= 64 && \"Too many bits for uint64_t\""
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5370),0))
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                ;
    return *pVal;
  }






  inline int64_t getSExtValue() const {
    
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   getActiveBits() <= 64 && "Too many bits for int64_t"
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "getActiveBits() <= 64 && \"Too many bits for int64_t\""
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5380),0))
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                               ;
    return int64_t(pVal[0]);
  }




  inline static uint32_t getBitsNeeded(const char* str, uint32_t slen,
                                       uint8_t radix) {
    
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   str != 0 && "Invalid value string"
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "str != 0 && \"Invalid value string\""
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5389),0))
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   slen > 0 && "Invalid string length"
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "slen > 0 && \"Invalid string length\""
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5390),0))
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                              ;


    uint32_t isNegative = str[0] == '-';
    if (isNegative) {
      slen--;
      str++;
    }


    if (radix == 2) return slen + isNegative;
    if (radix == 8) return slen * 3 + isNegative;
    if (radix == 16) return slen * 4 + isNegative;


    
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   radix == 10 && "Invalid radix"
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "radix == 10 && \"Invalid radix\""
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5405),0))
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                         ;






    return isNegative + slen * 4;
  }







  inline uint32_t countLeadingZeros() const {
    enum {
      msw_bits = (BitWidth % APINT_BITS_PER_WORD)
                     ? (BitWidth % APINT_BITS_PER_WORD)
                     : APINT_BITS_PER_WORD,
      excessBits = APINT_BITS_PER_WORD - msw_bits
    };
    uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N - 1]);
    if (Count >= excessBits) Count -= excessBits;
    if (!pVal[_AP_N - 1]) {
      for (int i = _AP_N - 1; i; --i) {
        if (!pVal[i - 1])
          Count += APINT_BITS_PER_WORD;
        else {
          Count += ap_private_ops::CountLeadingZeros_64(pVal[i - 1]);
          break;
        }
      }
    }
    return Count;
  }






  inline uint32_t countLeadingOnes() const {
    if (isSingleWord())
      return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);

    uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;
    uint32_t shift =
        (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);
    int i = _AP_N - 1;
    uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);
    if (Count == highWordBits) {
      for (i--; i >= 0; --i) {
        if (get_pVal(i) == ~0ULL)
          Count += APINT_BITS_PER_WORD;
        else {
          Count += countLeadingOnes_64(get_pVal(i), 0);
          break;
        }
      }
    }
    return Count;
  }
# 5477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline uint32_t countTrailingZeros() const {
    uint32_t Count = 0;
    uint32_t i = 0;
    for (; i < _AP_N && get_pVal(i) == 0; ++i) Count += APINT_BITS_PER_WORD;
    if (i < _AP_N) Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));
    return AESL_std::min(Count, BitWidth);
  }






  inline uint32_t countPopulation() const {
    uint32_t Count = 0;
    for (int i = 0; i < _AP_N - 1; ++i)
      Count += ap_private_ops::CountPopulation_64(pVal[i]);
    Count += ap_private_ops::CountPopulation_64(pVal[_AP_N - 1] & mask);
    return Count;
  }







  inline std::string toString(uint8_t radix, bool wantSigned) const;






  inline std::string toStringUnsigned(uint8_t radix = 10) const {
    return toString(radix, false);
  }






  inline std::string toStringSigned(uint8_t radix = 10) const {
    return toString(radix, true);
  }


  inline double roundToDouble(bool isSigned) const {

    if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {
      uint64_t val = pVal[0];
      if (isSigned) {
        int64_t sext = ((int64_t(val)) << (64 - BitWidth)) >> (64 - BitWidth);
        return double(sext);
      } else
        return double(val);
    }


    bool isNeg = isSigned ? (*this)[BitWidth - 1] : false;


    ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));


    uint32_t n = Tmp.getActiveBits();




    uint64_t exp = n;


    if (exp > 1023) {
      if (!isSigned || !isNeg)
        return std::numeric_limits<double>::infinity();
      else
        return -std::numeric_limits<double>::infinity();
    }
    exp += 1023;



    uint64_t mantissa;
    unsigned hiWord = whichWord(n - 1);
    if (hiWord == 0) {
      mantissa = Tmp.get_pVal(0);
      if (n > 52)
        (mantissa) >>= (n - 52);
    } else {
      
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     hiWord > 0 && "High word is negative?"
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "hiWord > 0 && \"High word is negative?\""
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5568),0))
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
      uint64_t hibits = (Tmp.get_pVal(hiWord))
                        << (52 - n % APINT_BITS_PER_WORD);
      uint64_t lobits =
          (Tmp.get_pVal(hiWord - 1)) >> (11 + n % APINT_BITS_PER_WORD);
      mantissa = hibits | lobits;
    }


    uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;
    union {
      double __D;
      uint64_t __I;
    } __T;
    __T.__I = sign | ((exp) << 52) | mantissa;
    return __T.__D;
  }


  inline double roundToDouble() const { return roundToDouble(false); }


  inline double signedRoundToDouble() const { return roundToDouble(true); }





  inline double bitsToDouble() const {
    union {
      uint64_t __I;
      double __D;
    } __T;
    __T.__I = pVal[0];
    return __T.__D;
  }





  inline float bitsToFloat() const {
    union {
      uint32_t __I;
      float __F;
    } __T;
    __T.__I = uint32_t(pVal[0]);
    return __T.__F;
  }





  inline ap_private& doubleToBits(double __V) {
    union {
      uint64_t __I;
      double __D;
    } __T;
    __T.__D = __V;
    pVal[0] = __T.__I;
    return *this;
  }





  inline ap_private& floatToBits(float __V) {
    union {
      uint32_t __I;
      float __F;
    } __T;
    __T.__F = __V;
    pVal[0] = __T.__I;
  }



  inline bool and_reduce() const { return isMaxValue(); }

  inline bool nand_reduce() const { return isMinValue(); }

  inline bool or_reduce() const { return (bool)countPopulation(); }

  inline bool nor_reduce() const { return countPopulation() == 0; }

  inline bool xor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? true : false;
  }

  inline bool xnor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? false : true;
  }
  inline std::string to_string(uint8_t radix = 16, bool sign = false) const {
    return toString(radix, radix == 10 ? _AP_S : sign);
  }
};

namespace ap_private_ops {

enum { APINT_BITS_PER_WORD = 64 };
template <int _AP_W, bool _AP_S>
inline bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
  return V2 == V1;
}

template <int _AP_W, bool _AP_S>
inline bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
  return V2 != V1;
}

template <int _AP_W, bool _AP_S, int index>
inline bool get(const ap_private<_AP_W, _AP_S>& a) {
  static const uint64_t mask = 1ULL << (index & 0x3f);
  return ((mask & a.get_pVal((index) >> 6)) != 0);
}

template <int _AP_W, bool _AP_S, int msb_index, int lsb_index>
inline void set(ap_private<_AP_W, _AP_S>& a,
                const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
  enum {
    APINT_BITS_PER_WORD = 64,
    lsb_word = lsb_index / APINT_BITS_PER_WORD,
    msb_word = msb_index / APINT_BITS_PER_WORD,
    msb = msb_index % APINT_BITS_PER_WORD,
    lsb = lsb_index % APINT_BITS_PER_WORD
  };
  if (msb_word == lsb_word) {
    const uint64_t mask = ~0ULL >>
                          (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>
                          (APINT_BITS_PER_WORD - msb - 1);

    a.get_pVal(msb_word) |= mask;
  } else {
    const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);
    const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>
                              (APINT_BITS_PER_WORD - msb - 1);

    a.get_pVal(lsb_word) |= lsb_mask;
    for (int i = lsb_word + 1; i < msb_word; i++) {
      a.set_pVal(i, ~0ULL);

    }


    a.get_pVal(msb_word) |= msb_mask;
  }
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int msb_index, int lsb_index>
inline void clear(ap_private<_AP_W, _AP_S>& a,
                  const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                  const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
  enum {
    APINT_BITS_PER_WORD = 64,
    lsb_word = lsb_index / APINT_BITS_PER_WORD,
    msb_word = msb_index / APINT_BITS_PER_WORD,
    msb = msb_index % APINT_BITS_PER_WORD,
    lsb = lsb_index % APINT_BITS_PER_WORD
  };
  if (msb_word == lsb_word) {
    const uint64_t mask =
        ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>
          (APINT_BITS_PER_WORD - msb - 1));

    a.get_pVal(msb_word) &= mask;
  } else {
    const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));
    const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>
                                (APINT_BITS_PER_WORD - msb - 1));

    a.get_pVal(lsb_word) &= lsb_mask;
    for (int i = lsb_word + 1; i < msb_word; i++) {

      a.get_pVal(i) = 0;
    }

    a.get_pVal(msb_word) &= msb_mask;
  }
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int index>
inline void set(ap_private<_AP_W, _AP_S>& a,
                const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };
  static const uint64_t mask = 1ULL << (index % APINT_BITS_PER_WORD);

  a.get_pVal(word) |= mask;
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int index>
inline void clear(ap_private<_AP_W, _AP_S>& a,
                  const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };
  static const uint64_t mask = ~(1ULL << (index % APINT_BITS_PER_WORD));

  a.get_pVal(word) &= mask;
  a.clearUnusedBits();
}

}

template <int _AP_W, bool _AP_S>
inline std::string ap_private<_AP_W, _AP_S, false>::toString(
    uint8_t radix, bool wantSigned) const {
  
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,
                                           "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ,
                                           5781
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ),0))
                                            
# 5781 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                           ;
  static const char* digits[] = {"0", "1", "2", "3", "4", "5", "6", "7",
                                 "8", "9", "A", "B", "C", "D", "E", "F"};
  std::string result;

  if (radix != 10) {





    if (*this == (uint64_t)(0))
      result = "0";
    else {
      ap_private<_AP_W, false> tmp(*this);
      size_t insert_at = 0;
      bool leading_zero = true;
      if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        tmp.clearUnusedBitsToZero();
        result = "-";
        insert_at = 1;
        leading_zero = false;
      }
      switch (radix) {
        case 2:
          result += "0b";
          break;
        case 8:
          result += "0o";
          break;
        case 16:
          result += "0x";
          break;
        default:
          
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "invalid radix" && 0
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5820),0))
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
      }
      insert_at += 2;

      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
      uint64_t mask = radix - 1;
      ap_private<_AP_W, false> zero(0);
      unsigned bits = 0;
      while (tmp.ne(zero)) {
        uint64_t digit = tmp.get_VAL() & mask;
        result.insert(insert_at, digits[digit]);
        tmp = tmp.lshr(shift);
        ++bits;
      }
      bits *= shift;
      if (bits < _AP_W && leading_zero) result.insert(insert_at, digits[0]);
    }
    return result;
  }

  ap_private<_AP_W, false> tmp(*this);
  ap_private<_AP_W, false> divisor(radix);
  ap_private<_AP_W, false> zero(0);
  size_t insert_at = 0;
  if (wantSigned && isNegative()) {



    tmp.flip();
    tmp++;
    tmp.clearUnusedBitsToZero();
    result = "-";
    insert_at = 1;
  }
  if (tmp == ap_private<_AP_W, false>(0))
    result = "0";
  else
    while (tmp.ne(zero)) {
      ap_private<_AP_W, false> APdigit(0);
      ap_private<_AP_W, false> tmp2(0);
      ap_private_ops::divide(tmp, tmp.getNumWords(), divisor,
                             divisor.getNumWords(), &tmp2, &APdigit);
      uint64_t digit = APdigit.getZExtValue();
      
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     digit < radix && "divide failed"
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "digit < radix && \"divide failed\""
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5863),0))
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
      result.insert(insert_at, digits[digit]);
      tmp = tmp2;
    }

  return result;
}

template <int _AP_W, bool _AP_S>
std::ostream &operator<<(std::ostream &os, const ap_private<_AP_W, _AP_S> &x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.toString(16, false);
  } else if (ff & std::cout.oct) {
    os << x.toString(8, false);
  } else {
    os << x.toString(10, _AP_S);
  }
  return os;
}
# 6128 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S>
struct _private_range_ref {



  ap_private<_AP_W, _AP_S>& d_bv;
  int l_index;
  int h_index;

 public:

  inline _private_range_ref(const _private_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}


  inline _private_range_ref(ap_private<_AP_W, _AP_S>* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
    do { if ((h < 0 || l < 0)) { fprintf(
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Higher bound (%d) and lower bound (%d) cannot be " "negative.", h, l); fprintf(
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)


                     ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Higher bound (%d) or lower bound (%d) out of range (%d).", h, l, _AP_W); fprintf(
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                      ;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator|=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= " "ap_private<>.range()."); fprintf(
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv |= ref.d_bv;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator|=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() |= _AP_ROOT_TYPE<>."); fprintf(
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv |= ref.V;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator&=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= " "ap_private<>.range()."); fprintf(
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv &= ref.d_bv;
    return *this;
  };


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator&=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= _AP_ROOT_TYPE<>."); fprintf(
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv &= ref.V;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator^=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() ^= " "ap_private<>.range()."); fprintf(
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv ^= ref.d_bv;
    return *this;
  };


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator^=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() ^= _AP_ROOT_TYPE<>."); fprintf(
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv ^= ref.V;
    return *this;
  }



  inline operator ap_private<_AP_W, false>() const {
    ap_private<_AP_W, false> val(0);
    if (h_index >= l_index) {
      if (_AP_W > 64) {
        val = d_bv;
        ap_private<_AP_W, false> mask(-1);
        mask >>= _AP_W - (h_index - l_index + 1);
        val >>= l_index;
        val &= mask;
      } else {
        const static uint64_t mask = (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));
        val = (d_bv >> l_index) & (mask >> (_AP_W - (h_index - l_index + 1)));
      }
    } else {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    }
    return val;
  }

  inline operator unsigned long long() const { return to_uint64(); }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(const ap_private<_AP_W2, _AP_S2>& val) {
    ap_private<_AP_W, false> vval = ap_private<_AP_W, false>(val);
    if (l_index > h_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);
    } else {
      if (_AP_W > 64) {
        ap_private<_AP_W, false> mask(-1);
        if (l_index > 0) {
          mask <<= l_index;
          vval <<= l_index;
        }
        if (h_index < _AP_W - 1) {
          ap_private<_AP_W, false> mask2(-1);
          mask2 >>= _AP_W - h_index - 1;
          mask &= mask2;
          vval &= mask2;
        }
        mask.flip();
        d_bv &= mask;
        d_bv |= vval;
      } else {
        unsigned shift = 64 - _AP_W;
        uint64_t mask = ~0ULL >> (shift);
        if (l_index > 0) {
          vval = mask & vval << l_index;
          mask = mask & mask << l_index;
        }
        if (h_index < _AP_W - 1) {
          uint64_t mask2 = mask;
          mask2 >>= (_AP_W - h_index - 1);
          mask &= mask2;
          vval &= mask2;
        }
        mask = ~mask;
        d_bv &= mask;
        d_bv |= vval;
      }
    }
    return *this;
  }

  inline _private_range_ref& operator=(unsigned long long val) {
    const ap_private<_AP_W, _AP_S> vval = val;
    return operator=(vval);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(
      const _private_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((unsigned long long)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(
      const _private_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_private<_AP_W, false> tmpVal(val);
    return operator=(tmpVal);
  }
# 6312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(val.to_ap_int_base().V);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(val.operator ap_int_base<_AP_W2, false>().V);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((unsigned long long)(bool)val);
  }
# 6405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs == rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs != rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs > rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs >= rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs < rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs <= rhs;
  }

  template <int _AP_W2>
  inline void set(const ap_private<_AP_W2, false>& val) {
    ap_private<_AP_W, _AP_S> vval = val;
    if (l_index > h_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);
    } else {
      if (_AP_W > 64) {
        ap_private<_AP_W, _AP_S> mask(-1);
        if (l_index > 0) {
          ap_private<_AP_W, false> mask1(-1);
          mask1 >>= _AP_W - l_index;
          mask1.flip();
          mask = mask1;

          vval <<= l_index;
        }
        if (h_index < _AP_W - 1) {
          ap_private<_AP_W, false> mask2(-1);
          mask2 <<= h_index + 1;
          mask2.flip();
          mask &= mask2;
          vval &= mask2;
        }
        mask.flip();
        d_bv &= mask;
        d_bv |= vval;
      } else {
        uint64_t mask = ~0ULL >> (64 - _AP_W);
        if (l_index > 0) {
          uint64_t mask1 = mask;
          mask1 = mask & (mask1 >> (_AP_W - l_index));
          vval = mask & (vval << l_index);
          mask = ~mask1 & mask;

        }
        if (h_index < _AP_W - 1) {
          uint64_t mask2 = ~0ULL >> (64 - _AP_W);
          mask2 = mask & (mask2 << (h_index + 1));
          mask &= ~mask2;
          vval &= ~mask2;
        }
        d_bv &= (~mask & (~0ULL >> (64 - _AP_W)));
        d_bv |= vval;
      }
    }
  }

  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> val(0);
    if (h_index < l_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    } else {
      val = d_bv;
      val >>= l_index;
      if (h_index < _AP_W - 1) {
        if (_AP_W <= 64) {
          const static uint64_t mask =
              (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));
          val &= (mask >> (_AP_W - (h_index - l_index + 1)));
        } else {
          ap_private<_AP_W, false> mask(-1);
          mask >>= _AP_W - (h_index - l_index + 1);
          val &= mask;
        }
      }
    }
    return val;
  }

  inline ap_private<_AP_W, false> get() {
    ap_private<_AP_W, false> val(0);
    if (h_index < l_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    } else {
      val = d_bv;
      val >>= l_index;
      if (h_index < _AP_W - 1) {
        if (_AP_W <= 64) {
          static const uint64_t mask = ~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0);
          return val &= ((mask) >> (_AP_W - (h_index - l_index + 1)));
        } else {
          ap_private<_AP_W, false> mask(-1);
          mask >>= _AP_W - (h_index - l_index + 1);
          val &= mask;
        }
      }
    }
    return val;
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline int to_int() const {
    ap_private<_AP_W, false> val = get();
    return val.to_int();
  }

  inline unsigned int to_uint() const {
    ap_private<_AP_W, false> val = get();
    return val.to_uint();
  }

  inline long to_long() const {
    ap_private<_AP_W, false> val = get();
    return val.to_long();
  }

  inline unsigned long to_ulong() const {
    ap_private<_AP_W, false> val = get();
    return val.to_ulong();
  }

  inline ap_slong to_int64() const {
    ap_private<_AP_W, false> val = get();
    return val.to_int64();
  }

  inline ap_ulong to_uint64() const {
    ap_private<_AP_W, false> val = get();
    return val.to_uint64();
  }

  inline std::string to_string(uint8_t radix = 2) const {
    return get().to_string(radix);
  }

  inline bool and_reduce() {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret &= d_bv[i];
    return ret;
  }

  inline bool or_reduce() {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret |= d_bv[i];
    return ret;
  }

  inline bool xor_reduce() {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret ^= d_bv[i];
    return ret;
  }
};





template <int _AP_W, bool _AP_S>
struct _private_bit_ref {



  ap_private<_AP_W, _AP_S>& d_bv;
  int d_index;

 public:

  inline _private_bit_ref(const _private_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}


  inline _private_bit_ref(ap_private<_AP_W, _AP_S>& bv, int index = 0)
      : d_bv(bv), d_index(index) {
    do { if ((d_index < 0)) { fprintf(
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Index of bit vector  (%d) cannot be negative.\n", d_index); fprintf(
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                        ;
    do { if ((d_index >= _AP_W)) { fprintf(
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W); fprintf(
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                                ;
  }

  inline operator bool() const { return d_bv.get_bit(d_index); }

  inline bool to_bool() const { return operator bool(); }

  template <typename T>
  inline _private_bit_ref& operator=(const T& val) {
    if (!!val)
      d_bv.set(d_index);
    else
      d_bv.clear(d_index);
    return *this;
  }
# 6730 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {
    return get() != op.get();
  }

  inline bool get() const { return operator bool(); }
# 6752 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline int length() const { return 1; }






};
# 6780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(const ap_private<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(const ap_private<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
# 6806 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline float operator *(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline float operator *(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline float operator /(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline float operator /(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline float operator +(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline float operator +(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline float operator -(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline float operator -(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline double operator *(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline double operator *(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline double operator /(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline double operator /(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline double operator +(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline double operator +(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline double operator -(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline double operator -(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
# 6911 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::mult operator *(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator *(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::plus operator +(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator +(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::minus operator -(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator -(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::div operator /(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator /(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::mod operator %(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator %(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator &(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator &(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator |(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator |(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator ^(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> bool operator >>(bool i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> bool operator <<(bool i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator +=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator -=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator *=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator /=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator %=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator &=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator |=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator ^=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, bool op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, bool op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator >(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator <(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator >=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator <=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator ==(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator !=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::mult operator *(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator *(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::plus operator +(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator +(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::minus operator -(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator -(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::div operator /(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator /(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::mod operator %(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator %(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator &(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator &(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator |(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator |(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator ^(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator ^(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> char operator >>(char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> char operator <<(char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator +=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator -=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator *=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator /=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator %=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator &=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator |=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator ^=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator >(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator <(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator >=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator <=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator ==(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator !=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator *(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator +(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator -(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::div operator /(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator /(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator %(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator &(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator |(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator ^(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> signed char operator >>(signed char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> signed char operator <<(signed char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator +=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator -=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator *=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator /=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator %=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator &=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator |=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator ^=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, signed char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, signed char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator >(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator <(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator >=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator <=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator ==(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator !=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator *(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator +(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator -(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator /(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator %(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator &(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator |(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator ^(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned char operator >>(unsigned char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned char operator <<(unsigned char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator +=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator -=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator *=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator /=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator %=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator &=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator |=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator ^=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator >(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator <(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator >=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator <=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator ==(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator !=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator *(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator +(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator -(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator /(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator %(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator &(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator |(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator ^(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> short operator >>(short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> short operator <<(short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator +=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator -=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator *=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator /=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator %=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator &=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator |=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator ^=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, short op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, short op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator >(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator <(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator >=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator <=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator ==(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator !=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator *(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator +(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator -(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator /(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator %(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator &(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator |(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator ^(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned short operator >>(unsigned short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned short operator <<(unsigned short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator +=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator -=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator *=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator /=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator %=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator &=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator |=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator ^=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator >(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator <(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator >=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator <=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator ==(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator !=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator *(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator +(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator -(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator /(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator %(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator &(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator |(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator ^(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> int operator >>(int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> int operator <<(int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator +=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator -=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator *=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator /=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator %=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator &=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator |=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator ^=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, int op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, int op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator >(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator <(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator >=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator <=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator ==(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator !=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator *(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator +(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator -(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator /(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator %(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator &(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator |(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator ^(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned int operator >>(unsigned int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned int operator <<(unsigned int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator +=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator -=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator *=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator /=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator %=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator &=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator |=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator ^=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator >(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator <(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator >=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator <=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator ==(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator !=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator *(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator +(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator -(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator /(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator %(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator &(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator |(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator ^(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> long operator >>(long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> long operator <<(long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator +=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator -=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator *=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator /=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator %=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator &=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator |=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator ^=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, long op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, long op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator >(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator <(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator >=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator <=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator ==(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator !=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator *(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator +(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator -(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator /(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator %(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator &(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator |(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator ^(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned long operator >>(unsigned long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned long operator <<(unsigned long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator +=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator -=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator *=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator /=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator %=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator &=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator |=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator ^=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator >(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator <(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator >=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator <=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator ==(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator !=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator *(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator +(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator -(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator /(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator %(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator &(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator |(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator ^(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> ap_slong operator >>(ap_slong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> ap_slong operator <<(ap_slong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator +=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator -=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator *=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator /=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator %=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator &=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator |=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator ^=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator >(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator <(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator >=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator <=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator ==(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator !=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator *(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator +(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator -(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator /(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator %(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator &(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator |(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator ^(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> ap_ulong operator >>(ap_ulong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> ap_ulong operator <<(ap_ulong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator +=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator -=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator *=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator /=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator %=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator &=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator |=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator ^=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator >(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator <(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator >=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator <=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator ==(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator !=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator !=(op); }
# 6977 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator +(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator -(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator *(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator /(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator %(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator &(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator |(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ^(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <<(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<(ap_private<_AP_W2, false>(op2)); }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator +=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator +=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator -=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator -=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator *=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator *=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator /=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator /=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator %=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator %=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator &=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator &=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator |=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator |=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator ^=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator ^=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator >>=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator >>=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator <<=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator <<=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_private<_AP_W2, false>()); }
# 7052 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator +=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator +=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator -=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator -=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator *=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator *=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator /=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator /=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator %=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator %=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator &=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator &=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator |=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator |=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator ^=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator ^=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator >>=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator >>=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator <<=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator <<=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator +(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator -(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator *(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator /(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator %(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator &(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator |(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator ^(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator >>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator <<(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<(ap_private<1, false>(op2)); }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(ap_private<1, false>(op2)); }
# 7117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
# 7163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::div operator /(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::div operator /(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::div operator /(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
# 7188 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator +( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator -( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator *( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator /( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator %( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator &( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator |( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator ^( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator >>( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator <<( ap_private<_AP_W2, false>(rhs)); }
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2


template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ROOT_op_concat(const _Tp1& Ret, const _Tp2& X, const _Tp3& Y) {
  _Tp1 r = (X).operator,(Y);
  return r;
}

template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1& _AP_ROOT_op_set_bit(_Tp1& Val, const _Tp2& Bit, const _Tp3& Repl) {
  (Val).set_bit((Bit), (Repl));
  return Val;
}



template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
inline _Tp1& _AP_ROOT_op_set_range(_Tp1& Val, const _Tp2& Lo, const _Tp3& Hi,
                                   const _Tp4& Repl) {
  (Val).range((Hi), (Lo)) = Repl;
  return (Val);
}
# 691 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
inline ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline unsigned short halfToRawBits(half pf) {
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
  return pf.get_bits();

}


inline double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline half rawBitsToHalf(unsigned short pi) {
# 753 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
  half __D;
  __D.set_bits(pi);
  return __D;

}
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 1
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int_sim<_AP_W, _AP_S> {
 public:
  typedef ssdm_int_sim<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 237 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline ap_int_base(const bool op) { Base::V = op; }
  inline ap_int_base(const char op) { Base::V = op; }
  inline ap_int_base(const signed char op) { Base::V = op; }
  inline ap_int_base(const unsigned char op) { Base::V = op; }
  inline ap_int_base(const short op) { Base::V = op; }
  inline ap_int_base(const unsigned short op) { Base::V = op; }
  inline ap_int_base(const int op) { Base::V = op; }
  inline ap_int_base(const unsigned int op) { Base::V = op; }
  inline ap_int_base(const long op) { Base::V = op; }
  inline ap_int_base(const unsigned long op) { Base::V = op; }
  inline ap_int_base(const ap_slong op) { Base::V = op; }
  inline ap_int_base(const ap_ulong op) { Base::V = op; }




  inline ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = (reg.V).get_bit((BITS - 1));

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = (reg.V).range((BITS - 2), (23));
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = (reg.V).range((23 - 1), (0));

    do { if ((exp == ((unsigned char)(((1L << (8 - 1L)) - 1L) + 1)) && man.V != 0)) { fprintf(
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "WARNING: " "assign NaN to ap integer value"); fprintf(
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); } } while (0)
                                                 ;

    man.V = _AP_ROOT_op_set_bit(man.V, 23, 1);


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = (reg.V).get_bit((BITS - 1));

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = (reg.V).range((BITS - 2), (52));
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = (reg.V).range((52 - 1), (0));

    do { if ((exp == ((unsigned char)(((1L << (11 - 1L)) - 1L) + 1)) && man.V != 0)) { fprintf(
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "WARNING: " "assign NaN to ap integer value"); fprintf(
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); } } while (0)
                                                 ;

    man.V = _AP_ROOT_op_set_bit(man.V, 52, 1);


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }




  inline ap_int_base(const char* s, signed char rd = 0) {
    if (rd == 0)
      rd = guess_radix(s);
    unsigned int length = strlen(s);
    Base::V.fromString(s, length, rd);
  }
# 405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    Base::V = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }
# 482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





  inline operator RetType() const { return (RetType)(Base::V); }




  inline bool to_bool() const { return (bool)(Base::V); }
  inline char to_char() const { return (char)(Base::V); }
  inline signed char to_schar() const { return (signed char)(Base::V); }
  inline unsigned char to_uchar() const { return (unsigned char)(Base::V); }
  inline short to_short() const { return (short)(Base::V); }
  inline unsigned short to_ushort() const { return (unsigned short)(Base::V); }
  inline int to_int() const { return (int)(Base::V); }
  inline unsigned to_uint() const { return (unsigned)(Base::V); }
  inline long to_long() const { return (long)(Base::V); }
  inline unsigned long to_ulong() const { return (unsigned long)(Base::V); }
  inline ap_slong to_int64() const { return (ap_slong)(Base::V); }
  inline ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline float to_float() const { return (float)(Base::V); }
  inline double to_double() const { return (double)(Base::V); }
# 586 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline int length() const volatile { return _AP_W; }


  inline bool iszero() const { return Base::V == 0; }


  inline bool is_zero() const { return Base::V == 0; }


  inline bool sign() const {
    if (_AP_S &&
        (Base::V).get_bit((_AP_W - 1)))
      return true;
    else
      return false;
  }


  inline void clear(int i) {
    
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",605),0))
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);
  }


  inline void invert(int i) {
    
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",611),0))
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    bool val = (Base::V).get_bit((i));
    if (val)
      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);
    else
      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);
  }

  inline bool test(int i) const {
    
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",620),0))
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    return (Base::V).get_bit((i));
  }


  inline ap_int_base& get() { return *this; }


  inline void set(int i) {
    
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",629),0))
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);
  }


  inline void set(int i, bool v) {
    
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",635),0))
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);
  }



  inline ap_int_base& lrotate(int n) {
    
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (n >= 0 && n < _AP_W) && ("shift value out of range")
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(n >= 0 && n < _AP_W) && (\"shift value out of range\")"
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",642),0))
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                             ;






    Base::V.lrotate(n);

    return *this;
  }



  inline ap_int_base& rrotate(int n) {
    
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (n >= 0 && n < _AP_W) && ("shift value out of range")
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(n >= 0 && n < _AP_W) && (\"shift value out of range\")"
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",657),0))
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                             ;






    Base::V.rrotate(n);

    return *this;
  }



  inline ap_int_base& reverse() {
    Base::V = (Base::V).range((0), (_AP_W - 1));
    return *this;
  }


  inline void set_bit(int i, bool v) {
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);
  }


  inline bool get_bit(int i) const {
    return (bool)(Base::V).get_bit((i));
  }


  inline void b_not() { Base::V = ~Base::V; }
# 699 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "&=" "ap_[u]int."); fprintf(
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "|=" "ap_[u]int."); fprintf(
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "^=" "ap_[u]int."); fprintf(
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V ^= op2.V; return *this; }





  inline ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




  inline typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


  inline typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




  inline bool operator!() const { return Base::V == 0; }





  inline typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 828 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2>
  inline ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
  inline ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
  inline ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
  inline ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    do { if ((Hi >= _AP_W)) { fprintf(
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Hi(%d)out of bound(%d) in range()", Hi, _AP_W); fprintf(
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    do { if ((Lo >= _AP_W)) { fprintf(
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Lo(%d)out of bound(%d) in range()", Lo, _AP_W); fprintf(
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    do { if ((Hi >= _AP_W)) { fprintf(
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Hi(%d)out of bound(%d) in range()", Hi, _AP_W); fprintf(
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    do { if ((Lo >= _AP_W)) { fprintf(
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Lo(%d)out of bound(%d) in range()", Lo, _AP_W); fprintf(
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
    
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",987),0))
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",988),0))
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",996),0))
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",997),0))
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline bool operator[](int index) const {
    
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1003),0))
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1004),0))
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
    
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1010),0))
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline ap_bit_ref<_AP_W, _AP_S> bit(int index) {
    
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1016),0))
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1017),0))
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1024),0))
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1025),0))
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline bool bit(int index) const {
    
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1031),0))
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1032),0))
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1053 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline int countLeadingZeros() {
# 1088 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
    return (Base::V).countLeadingZeros();

  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline bool and_reduce() const { return (Base::V).and_reduce(); }
  inline bool nand_reduce() const { return (Base::V).nand_reduce(); }
  inline bool or_reduce() const { return (Base::V).or_reduce(); }
  inline bool nor_reduce() const { return !((Base::V).or_reduce()); }
  inline bool xor_reduce() const { return (Base::V).xor_reduce(); }
  inline bool xnor_reduce() const {
    return !((Base::V).xor_reduce());
  }





  std::string to_string(signed char rd = 2, bool sign = _AP_S) const {


    if (rd == 2) sign = false;
    return (Base::V).to_string(rd, sign);
  }





};




template <int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& os,
                                const ap_int_base<_AP_W, _AP_S>& x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.to_string(16);
  } else if (ff & std::cout.oct) {
    os << x.to_string(8);
  } else {
    os << x.to_string(10);
  }
  return os;
}



template <int _AP_W, bool _AP_S>
inline std::istream& operator>>(std::istream& in,
                                ap_int_base<_AP_W, _AP_S>& op) {
  std::string str;
  in >> str;
  const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;
  unsigned radix = (basefield == std::ios_base::dec) ? 0 : (
                     (basefield == std::ios_base::oct) ? 8 : (
                       (basefield == std::ios_base::hex) ? 16 : 0));
  op = ap_int_base<_AP_W, _AP_S>(str.c_str(), radix);
  return in;
}
# 1352 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret; ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret; ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret; ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V ^ rhs.V; return ret; }
# 1371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret; ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret; ret.V = op.V % op2.V; return ret; }
# 1399 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1427 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1461 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1500 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1524 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
# 1555 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1659 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1690 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1768 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 1799 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1831 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1850 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h" 1
# 73 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = (vval.V).range((W_ref1 + W_ref2 - 1), (W_ref2));
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = (vval.V).range((W_ref2 - 1), (0));
    mbv2.set(Part2);
    return *this;
  }
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = _AP_ROOT_op_set_range(tmpVal.V, 0, W_ref2 - 1, v2.V);
    tmpVal.V =
        _AP_ROOT_op_set_range(tmpVal.V, W_ref2, W_ref1 + W_ref2 - 1, v1.V);
    return tmpVal;
  }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = (vval.V).range((W_ref1 + W_ref2 - 1), (W_ref2));
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = (vval.V).range((W_ref2 - 1), (0));
    mbv2.set(tmpVal2);
  }

  inline int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  inline operator ap_ulong() const { return to_uint64(); }
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }




  inline ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }




  inline ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };

  inline ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  template <int _AP_W2>
  inline void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline int to_int() const {
    return (int)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned to_uint() const {
    return (unsigned)((d_bv.V).range((h_index), (l_index)));
  }

  inline long to_long() const {
    return (long)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned long to_ulong() const {
    return (unsigned long)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_slong to_int64() const {
    return (ap_slong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_ulong to_uint64() const {
    return (ap_ulong)((d_bv.V).range((h_index), (l_index)));
  }

  inline bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret &= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  inline bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret |= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  inline bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret ^= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  std::string to_string(signed char radix = 2) const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_string(radix);
  }






};




template <int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& os,
                                const ap_range_ref<_AP_W, _AP_S>& x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.to_string(16);
  } else if (ff & std::cout.oct) {
    os << x.to_string(8);
  } else {
    os << x.to_string(10);
  }
  return os;
}



template <int _AP_W, bool _AP_S>
inline std::istream& operator>>(std::istream& in,
                                ap_range_ref<_AP_W, _AP_S>& op) {
  std::string str;
  in >> str;
  op = ap_int_base<_AP_W, _AP_S>(str.c_str());
  return in;
}






template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline operator bool() const { return (d_bv.V).get_bit((d_index)); }
  inline bool to_bool() const { return (d_bv.V).get_bit((d_index)); }
# 810 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_bit_ref& operator=(bool val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(signed char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(short val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned short val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(int val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned int val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(long val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned long val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(ap_slong val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(ap_ulong val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
# 832 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }
  inline ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }
  inline ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline bool get() const { return (d_bv.V).get_bit((d_index)); }

  inline bool get() { return (d_bv.V).get_bit((d_index)); }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline bool operator~() const {
    bool bit = (d_bv.V).get_bit((d_index));
    return bit ? false : true;
  }

  inline int length() const { return 1; }


  std::string to_string() const { return get() ? "1" : "0"; }




};
# 1030 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1089 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1140 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1189 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1336 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline ap_int() : Base() {}
  template <int _AP_W2>
  inline ap_int(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }
# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline ap_int(bool val) { Base::V = val; }
  inline ap_int(char val) { Base::V = val; }
  inline ap_int(signed char val) { Base::V = val; }
  inline ap_int(unsigned char val) { Base::V = val; }
  inline ap_int(short val) { Base::V = val; }
  inline ap_int(unsigned short val) { Base::V = val; }
  inline ap_int(int val) { Base::V = val; }
  inline ap_int(unsigned int val) { Base::V = val; }
  inline ap_int(long val) { Base::V = val; }
  inline ap_int(unsigned long val) { Base::V = val; }
  inline ap_int(ap_slong val) { Base::V = val; }
  inline ap_int(ap_ulong val) { Base::V = val; }

  ap_int(double val) : Base(val) {}
  ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline ap_int(const char* s) : Base(s) {}

  inline ap_int(const char* s, signed char rd) : Base(s, rd) {}




  inline ap_int& operator=(const ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline void operator=(const ap_int<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline ap_uint() : Base() {}
  template <int _AP_W2>
  inline ap_uint(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }
# 236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline ap_uint(bool val) { Base::V = val; }
  inline ap_uint(char val) { Base::V = val; }
  inline ap_uint(signed char val) { Base::V = val; }
  inline ap_uint(unsigned char val) { Base::V = val; }
  inline ap_uint(short val) { Base::V = val; }
  inline ap_uint(unsigned short val) { Base::V = val; }
  inline ap_uint(int val) { Base::V = val; }
  inline ap_uint(unsigned int val) { Base::V = val; }
  inline ap_uint(long val) { Base::V = val; }
  inline ap_uint(unsigned long val) { Base::V = val; }
  inline ap_uint(ap_slong val) { Base::V = val; }
  inline ap_uint(ap_ulong val) { Base::V = val; }

  ap_uint(double val) : Base(val) {}
  ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline ap_uint(const char* s) : Base(s) {}

  inline ap_uint(const char* s, signed char rd) : Base(s, rd) {}




  inline ap_uint& operator=(const ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline void operator=(const ap_uint<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};
# 359 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h" 1
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h" 2




namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 222 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 1
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 1
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 1
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 2
# 78 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 1 3
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3

# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3
typedef unsigned short fexcept_t;





typedef struct
{
  unsigned short __control_word;
  unsigned short __unused0;
  unsigned short __status_word;
  unsigned short __unused1;
  unsigned short __tag_word;
  unsigned short __unused2;
  unsigned int __ip_offset;
  unsigned short __ip_selector;
  unsigned short __opcode;
  unsigned int __data_offset;
  unsigned short __data_selector;
  unsigned short __unused3;
  unsigned int __mxcsr;
} fenv_t;
# 124 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3
extern "C" {





extern int __attribute__((__cdecl__)) feclearexcept (int);
extern int __attribute__((__cdecl__)) fegetexceptflag (fexcept_t * flagp, int excepts);
extern int __attribute__((__cdecl__)) feraiseexcept (int excepts );
extern int __attribute__((__cdecl__)) fesetexceptflag (const fexcept_t *, int);
extern int __attribute__((__cdecl__)) fetestexcept (int excepts);



extern int __attribute__((__cdecl__)) fegetround (void);
extern int __attribute__((__cdecl__)) fesetround (int mode);



extern int __attribute__((__cdecl__)) fegetenv(fenv_t * envp);
extern int __attribute__((__cdecl__)) fesetenv(const fenv_t * );
extern int __attribute__((__cdecl__)) feupdateenv(const fenv_t *);
extern int __attribute__((__cdecl__)) feholdexcept(fenv_t *);


}
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 2 3
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 2 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 79 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 2
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"

# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <typename _Tp1, typename _Tp2>
inline bool _AP_ctype_op_get_bit(_Tp1& var, const _Tp2& index) {
  return !!(var & (1ull << (index)));
}
template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ctype_op_set_bit(_Tp1& var, const _Tp2& index, const _Tp3& x) {
  var |= (((x) ? 1ull : 0ull) << (index));
  return var;
}
template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ctype_op_get_range(_Tp1& var, const _Tp2& low,
                                   const _Tp3& high) {
  _Tp1 r = var;
  ap_ulong mask = -1ll;
  mask >>= (sizeof(_Tp1) * 8 - ((high) - (low) + 1));
  r >>= (low);
  r &= mask;
  return r;
}
template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
inline _Tp1 _AP_ctype_op_set_range(_Tp1& var, const _Tp2& low, const _Tp3& high,
                                   const _Tp4& x) {
  ap_ulong mask = -1ll;
  mask >>= (_AP_SIZE_ap_slong - ((high) - (low) + 1));
  var &= ~(mask << (low));
  var |= ((mask & x) << (low));
  return var;
}






template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 154 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int_sim<_AP_W, _AP_S> {
 public:
  typedef ssdm_int_sim<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:


  void fromString(const std::string& val, unsigned char radix) {
    do { if ((!(radix == 2 || radix == 8 || radix == 10 || radix == 16))) { fprintf(
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "ERROR: " "ap_fixed_base::fromString(%s, %d)", val.c_str(), radix); fprintf(
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); abort(); } } while (0)
                                                                      ;

    Base::V = 0;
    int startPos = 0;
    int endPos = val.length();
    int decPos = val.find(".");
    if (decPos == -1) decPos = endPos;


    bool isNegative = false;
    if (val[0] == '-') {
      isNegative = true;
      ++startPos;
    } else if (val[0] == '+')
      ++startPos;
# 244 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    ap_fixed_base<((_AP_I) > (4) ? (_AP_I) : (4)) + 4, ((_AP_I) > (4) ? (_AP_I) : (4)) + 4, false>
        integer_bits = 0;


    unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);




    bool sticky_int = false;


    for (int i = startPos; i < decPos; i++) {

      char cdigit = val[i];
      if (cdigit == '\0') continue;
      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);

      sticky_int |= integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 1] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 2] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 4];

      if (shift)
        integer_bits <<= shift;
      else
        integer_bits *= radix;


      integer_bits += digit;


    }
    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] =
        integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] | sticky_int;

    ap_fixed_base<((_AP_W - _AP_I) > (0) ? (_AP_W - _AP_I) : (0)) + 4 + 4, 4, false> fractional_bits = 0;
    bool sticky = false;


    for (int i = endPos - 1; i >= decPos + 1; i--) {

      char cdigit = val[i];
      if (cdigit == '\0') continue;
      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);

      fractional_bits += digit;

      sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] |
                fractional_bits[3];

      if (shift)
        fractional_bits >>= shift;
      else
        fractional_bits /= radix;



    }




    fractional_bits[0] = fractional_bits[0] | sticky;

    if (isNegative)
      *this = -(integer_bits + fractional_bits);
    else
      *this = integer_bits + fractional_bits;


  }


  inline void report() {
    if (!_AP_S && _AP_O == AP_WRAP_SM) {
      fprintf(
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
             (&__iob_func()[2])
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
                   , "ap_ufxied<...> cannot support AP_WRAP_SM.\n");
      exit(1);
    }
    if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
      fprintf(
# 324 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
             (&__iob_func()[2])
# 324 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
                   ,
              "[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the "
              "default max value %d. Please use macro "
              "AP_INT_MAX_W to set a larger max value.\n",
              _AP_S ? "" : "u", _AP_W, ((1024 + 1023) / 1024) * 1024);
      exit(1);
    }
  }






  inline void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 1, mask.V);
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = (Base::V).get_bit((_AP_W - 1));
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, lD);
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = (Base::V).get_bit((_AP_W - _AP_N));
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);
        }
        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

  inline bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)(Base::V).get_bit((_AP_W - 1));
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= (Base::V).get_bit((0)) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)(Base::V).get_bit((_AP_W - 1)));
  }


 public:



  inline ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }



  inline ap_fixed_base(const char* s, signed char rd = 0) {
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(s, radix);
    do { if ((radix == 0)) { fprintf(
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "ERROR: " "ap_fixed_base(const char* \"%s\", %d), str=%s, radix = %d", s, rd, str.c_str(), radix); fprintf(
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); abort(); } } while (0)
                                        ;
    fromString(str, radix);
  }
# 491 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  inline ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







  ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = (ireg.V).get_bit((63));

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        (ireg.V).range((52 + 11 - 1), (52));
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = (ireg.V).range((52 - 1), (0));

    do { if ((exp == ((1L << (11 - 1L)) - 1L) + 1 && man.V != 0)) { fprintf(
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "assign NaN to fixed point value"); fprintf(
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                  ;
    man.V = _AP_ROOT_op_set_bit(man.V, 52, 1);
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)(man.V).get_bit((F2 - _AP_F - 1))
                                                                              ;
          bool r =
              (F2 > _AP_F + 1)
                  ? (man.V).range(((F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)), (0))

                                                                        != 0
                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = (Base::V).get_bit((_AP_W - 1));
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? (Base::V).range((_AP_W - 2), (0)) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 688 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = (op.V).get_bit((_AP_W2 - 1));
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = (op.V).get_bit((F2 - _AP_F - 1));

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? ((op.V).range((hi), (0)) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = (Base::V).get_bit((_AP_W - 1));
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? (op.V).get_bit((pos1))
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2;
          Range2.V = (op.V).range((_AP_W2 - 1), (pos2));
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1;
          Range1.V = (op.V).range((_AP_W2 - 1), (pos1));
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? (Base::V).range((_AP_W - 2), (0)) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


  inline ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;



    t.V.set_bits(bv);

    return t;
  }





  inline ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret;
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = (Base::V).range((_AP_W - 1), (_AP_W - _AP_I));
    } else if (_AP_I > _AP_W) {
      ret.V = (Base::V).range((_AP_W - 1), (0));
      ret.V <<= (_AP_I - _AP_W);
    }
# 848 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && (Base::V).get_bit((_AP_W - 1)) && (_AP_I < _AP_W) &&
          ((Base::V).range((_AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1), (0))
                                                                      != 0))
        ++ret;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
  inline operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


  inline char to_char() const { return to_ap_int_base().to_char(); }

  inline int to_int() const { return to_ap_int_base().to_int(); }

  inline unsigned to_uint() const { return to_ap_int_base().to_uint(); }

  inline ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

  inline ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }



  inline double to_double() const {

    do { if ((std::fegetround() != 
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   0x0000
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   )) { fprintf(
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    ap_ulong m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (_AP_ctype_op_get_bit(m, 52 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);

    m = _AP_ctype_op_set_range(m, 52, 52 + 11 - 1, e);


    return rawBitsToDouble(m);
  }



  inline float to_float() const {

    do { if ((std::fegetround() != 
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   0x0000
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   )) { fprintf(
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (_AP_ctype_op_get_bit(m, 23 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);
    m = _AP_ctype_op_set_range(m, 23, 23 + 8 - 1, e);

    return rawBitsToFloat(m);
  }



  inline half to_half() const {

    do { if ((std::fegetround() != 
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   0x0000
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   )) { fprintf(
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (_AP_ctype_op_get_bit(m, 10 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);
    m = _AP_ctype_op_set_range(m, 10, 10 + 5 - 1, e);

    return rawBitsToHalf(m);
  }


  inline operator long double() const { return (long double)to_double(); }

  inline operator double() const { return to_double(); }

  inline operator float() const { return to_float(); }

  inline operator half() const { return to_half(); }

  inline operator bool() const { return (bool)Base::V != 0; }

  inline operator char() const { return (char)to_int(); }

  inline operator signed char() const { return (signed char)to_int(); }

  inline operator unsigned char() const { return (unsigned char)to_uint(); }

  inline operator short() const { return (short)to_int(); }

  inline operator unsigned short() const { return (unsigned short)to_uint(); }

  inline operator int() const { return to_int(); }

  inline operator unsigned int() const { return to_uint(); }



  inline operator long() const { return (long)to_int64(); }

  inline operator unsigned long() const { return (unsigned long)to_uint64(); }






  inline operator ap_ulong() const { return to_uint64(); }

  inline operator ap_slong() const { return to_int64(); }

  inline int length() const { return _AP_W; };




  inline ap_ulong bits_to_uint64() const {
    return (Base::V).to_uint64();
  }





  inline int countLeadingZeros() {
# 1104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return Base::V.countLeadingZeros();

  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r, t;
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;

    enum {F2 = _AP_W2-_AP_I2,
              _W1=((_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) > (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)) ? (_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) : (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)))};
    ap_int_base<_W1,_AP_S||_AP_S2> dividend,divisior;
    ap_int_base<_W1,_AP_S> tmp1;
    ap_int_base<_W1,_AP_S2> tmp2;
    tmp1.V = Base::V;
    tmp1.V <<= ((F2) > (0) ? (F2) : (0));
    tmp2.V = op2.V;
    dividend = tmp1;
    divisior = tmp2;
    r.V = ((_AP_S||_AP_S2) ? dividend.V.sdiv(divisior.V): dividend.V.udiv(divisior.V));
# 1177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return r;
  }
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1210 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline ap_fixed_base operator+() { return *this; }

  inline ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

  inline ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



  inline bool operator!() const { return Base::V == 0; }




  inline ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
  inline ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
  inline ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }





  inline ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V << sh;
# 1328 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return r;
  }

  inline ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V >> sh;
# 1350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return r;
  }


  inline ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r;
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

  inline ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
  inline ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
  inline ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





  inline ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

  inline ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


  inline ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

  inline ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1494 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline bool operator >(double d) const { return to_double() > d; }
  inline bool operator <(double d) const { return to_double() < d; }
  inline bool operator >=(double d) const { return to_double() >= d; }
  inline bool operator <=(double d) const { return to_double() <= d; }
  inline bool operator ==(double d) const { return to_double() == d; }
  inline bool operator !=(double d) const { return to_double() != d; }


  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    do { if ((index >= _AP_W)) { fprintf(
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    do { if ((index < 0)) { fprintf(
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index >= _AP_W)) { fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline bool operator[](unsigned index) const {
    do { if ((index >= _AP_W)) { fprintf(
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index));
  }

  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    do { if ((index >= _AP_W)) { fprintf(
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    do { if ((index < 0)) { fprintf(
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index >= _AP_W)) { fprintf(
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline bool bit(unsigned index) const {
    do { if ((index >= _AP_W)) { fprintf(
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index));
  }

  template <int _AP_W2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    do { if ((index < _AP_I - _AP_W)) { fprintf(
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                             ;
    do { if ((index >= _AP_I)) { fprintf(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

  inline bool get_bit(int index) const {
    do { if ((index >= _AP_I)) { fprintf(
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index < _AP_I - _AP_W)) { fprintf(
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index + _AP_W - _AP_I))
                                                     ;
  }
# 1580 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2>
  inline bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    do { if ((index >= _AP_I)) { fprintf(
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index < _AP_I - _AP_W)) { fprintf(
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index.to_int() + _AP_W - _AP_I))
                                                              ;
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    do { if (((Hi >= _AP_W) || (Lo >= _AP_W))) { fprintf(
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Out of bounds in range()"); fprintf(
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    do { if (((Hi >= _AP_W) || (Lo >= _AP_W))) { fprintf(
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Out of bounds in range()"); fprintf(
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline bool is_zero() const { return Base::V == 0; }

  inline bool is_neg() const {
    if (_AP_S && (Base::V).get_bit((_AP_W - 1))) return true;
    return false;
  }

  inline int wl() const { return _AP_W; }

  inline int iwl() const { return _AP_I; }

  inline ap_q_mode q_mode() const { return _AP_Q; }

  inline ap_o_mode o_mode() const { return _AP_O; }

  inline int n_bits() const { return _AP_N; }
# 1680 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  std::string to_string(unsigned char radix = 2, bool sign = _AP_S) const {


    if (radix == 2) sign = false;

    std::string str;
    str.clear();
    char step = 0;
    bool isNeg = sign && (Base::V < 0);


    ap_fixed_base<_AP_W + 1, _AP_I + 1> tmp(*this);
    if (isNeg) {
      tmp = -tmp;
      str += '-';
    }
    std::string prefix;
    switch (radix) {
      case 2:
        prefix = "0b";
        step = 1;
        break;
      case 8:
        prefix = "0o";
        step = 3;
        break;
      case 16:
        prefix = "0x";
        step = 4;
        break;
      default:
        break;
    }

    if (_AP_I > 0) {




      ap_int_base<((_AP_I + 1) > (1) ? (_AP_I + 1) : (1)), false> int_part;




      int_part.V = (tmp.V).range((_AP_W), (_AP_W - _AP_I))
                                      ;
      str += int_part.to_string(radix, false);
    } else {
      str += prefix;
      str += '0';
    }

    ap_fixed_base<((_AP_W - _AP_I) > (1) ? (_AP_W - _AP_I) : (1)), 0, false> frac_part = tmp;

    if (radix == 10) {
      if (frac_part != 0) {
        str += ".";
        while (frac_part != 0) {
          char digit = (frac_part * radix).to_char();
          str += static_cast<char>(digit + '0');
          frac_part *= radix;
        }
      }
    } else {
      if (frac_part != 0) {
        str += ".";
        for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {
          char digit = frac_part.range(i, ((0) > (i - step + 1) ? (0) : (i - step + 1))).to_char();


          int offset = ((0) < (i - step + 1) ? (0) : (i - step + 1));
          digit <<= -offset;
          str += digit < 10 ? static_cast<char>(digit + '0')
                            : static_cast<char>(digit - 10 + 'a');
        }
        if (radix == 16)
          str += "p0";
      }
    }
    return str;
  }






};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t;
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 1869 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
inline std::string scientificFormat(std::string& input) {
  if (input.length() == 0) return input;

  size_t decPosition = input.find('.');
  if (decPosition == std::string::npos) decPosition = input.length();

  size_t firstNonZeroPos = 0;
  for (; input[firstNonZeroPos] > '9' || input[firstNonZeroPos] < '1';
       firstNonZeroPos++)
    ;

  int exp;
  if (firstNonZeroPos > decPosition)
    exp = decPosition - firstNonZeroPos;
  else
    exp = decPosition - firstNonZeroPos - 1;
  std::string expString = "";
  if (exp == 0)
    ;
  else if (exp < 0) {
    expString += "e-";
    exp = -exp;
  } else
    expString += "e+";

  if (exp < 10 && exp > 0) {
    expString += '0';
    expString += (char)('0' + exp);
  } else if (exp != 0) {
    std::string tmp;

    std::ostringstream oss;
    oss << exp;

    tmp = oss.str();
    expString += tmp;
  }

  int lastNonZeroPos = (int)(input.length() - 1);
  for (; lastNonZeroPos >= 0; --lastNonZeroPos)
    if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0') break;

  std::string ans = "";
  ans += input[firstNonZeroPos];
  if (firstNonZeroPos != (size_t)lastNonZeroPos) {
    ans += '.';
    for (int i = firstNonZeroPos + 1; i <= lastNonZeroPos; i++)
      if (input[i] != '.') ans += input[i];
  }

  ans += expString;
  return ans;
}

inline std::string reduceToPrecision(std::string& input, int precision) {
  bool isZero = true;
  size_t inputLen = input.length();
  for (size_t i = 0; i < inputLen && isZero; i++)
    if (input[i] != '.' && input[i] != '0') isZero = false;
  if (isZero) return "0";


  int FirstNonZeroPos = 0;
  int LastNonZeroPos = (int)inputLen - 1;
  int truncBitPosition = 0;
  size_t decPosition = input.find('.');
  for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';
       FirstNonZeroPos++)
    ;

  for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';
       LastNonZeroPos--)
    ;

  if (decPosition == std::string::npos) decPosition = inputLen;

  if ((int)decPosition > LastNonZeroPos) {
    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) return input;
    truncBitPosition = FirstNonZeroPos + precision;
  } else if ((int)decPosition < FirstNonZeroPos) {
    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {
      if (FirstNonZeroPos - decPosition - 1 < 4) {
        return input;
      } else {
        if (input[0] == '-') {
          std::string tmp = input.substr(1, inputLen - 1);
          return std::string("-") + scientificFormat(tmp);
        } else
          return scientificFormat(input);
      }
    }
    truncBitPosition = FirstNonZeroPos + precision;
  } else {
    if (LastNonZeroPos - FirstNonZeroPos <= precision) return input;
    truncBitPosition = FirstNonZeroPos + precision + 1;
  }



  std::string ans = "";
  std::string dupInput = "0";
  if (input[0] == '-') {
    ans += '-';
    dupInput += input.substr(1, inputLen - 1);
  } else {
    dupInput += input.substr(0, inputLen);
    ++truncBitPosition;
  }


  bool carry = dupInput[truncBitPosition] > '4';
  for (int i = truncBitPosition - 1; i >= 0 && carry; i--) {
    if (dupInput[i] == '.') continue;
    if (dupInput[i] == '9')
      dupInput[i] = '0';
    else {
      ++dupInput[i];
      carry = false;
    }
  }


  if (dupInput[0] == '1')
    FirstNonZeroPos = 0;
  else {
    FirstNonZeroPos = 0;
    while (dupInput[FirstNonZeroPos] < '1' || dupInput[FirstNonZeroPos] > '9')
      ++FirstNonZeroPos;
  }

  unsigned it = FirstNonZeroPos;
  int NValidNumber = 0;
  while (it < dupInput.length()) {
    if (dupInput[it] == '.') {
      ++it;
      continue;
    }
    ++NValidNumber;
    if (NValidNumber > precision) dupInput[it] = '0';
    ++it;
  }


  decPosition = dupInput.find('.');
  if (decPosition == std::string::npos)
    truncBitPosition = (int)dupInput.length();
  else
    for (truncBitPosition = (int)(dupInput.length() - 1); truncBitPosition >= 0;
         --truncBitPosition) {
      if (dupInput[truncBitPosition] == '.') break;
      if (dupInput[truncBitPosition] != '0') {
        truncBitPosition++;
        break;
      }
    }

  if (dupInput[0] == '1')
    dupInput = dupInput.substr(0, truncBitPosition);
  else
    dupInput = dupInput.substr(1, truncBitPosition - 1);

  decPosition = dupInput.find('.');
  if (decPosition != std::string::npos) {
    size_t it = 0;
    for (it = decPosition + 1; dupInput[it] == '0'; it++)
      ;
    if (it - decPosition - 1 < 4) {
      ans += dupInput;
      return ans;
    } else {
      ans += scientificFormat(dupInput);
      return ans;
    }
  } else if ((int)(dupInput.length()) <= precision) {
    ans += dupInput;
    return ans;
  }

  ans += scientificFormat(dupInput);
  return ans;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void print(
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  if (_AP_I > 0) {
    ap_int_base<_AP_I, _AP_S> p1;
    p1.V = x.V >> (_AP_W - _AP_I);
    print(p1.V);
  } else {
    printf("0");
  }
  printf(".");
  if (_AP_I < _AP_W) {
    ap_int_base<_AP_W - _AP_I, false> p2;
    p2.V = (x.V).range((_AP_W - _AP_I), (0));
    print(p2.V, false);
  }
}
# 2080 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& out,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {

  unsigned width = out.width();
  unsigned precision = out.precision();
  char fill = out.fill();
  std::string str = x.to_string(10, _AP_S);
  str = reduceToPrecision(str, precision);
  if (width > str.length()) {
    for (unsigned i = 0; i < width - str.length(); ++i)
      out << fill;
  }
  out << str;
  return out;
}





template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::istream& operator>>(
    std::istream& in,
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  double d;
  in >> d;
  x = ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(d);
  return in;
}
# 2213 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2301 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 1
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {

    do { if ((d_index < 0)) { fprintf(
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Index of bit vector  (%d) cannot be negative.", d_index); fprintf(
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                        ;
    do { if ((d_index >= _AP_W)) { fprintf(
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Index of bit vector (%d) out of range (%d).", d_index, _AP_W); fprintf(
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                               ;

  }

  inline af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline operator bool() const { return (d_bv.V).get_bit((d_index)); }



  inline af_bit_ref& operator=(bool val) {
    d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val);
    return *this;
  }



  inline af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline bool operator~() const {
    bool bit = (d_bv.V).get_bit((d_index));
    return bit ? false : true;
  }

  inline bool get() const { return (d_bv.V).get_bit((d_index)); }

  inline int length() const { return 1; }


  std::string to_string() const { return get() ? "1" : "0"; }




};




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& os,
    const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  os << x.to_string();
  return os;
}




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {

    do { if ((h < 0 || l < 0)) { fprintf(
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) and lower(%d) bound cannot be negative.", h, l); fprintf(
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)

                  ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) or lower(%d) bound out of range.", h, l); fprintf(
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                                                                          ;
    do { if ((h < l)) { fprintf(
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "The bits selected will be returned in reverse order."); fprintf(
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0);

  }

  inline af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {

    do { if ((h < 0 || l < 0)) { fprintf(
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) and lower(%d) bound cannot be negative.", h, l); fprintf(
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)

                  ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) or lower(%d) bound out of range.", h, l); fprintf(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                                                                          ;
    do { if ((h < l)) { fprintf(
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "The bits selected will be returned in reverse order."); fprintf(
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0);

  }
# 311 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
  inline af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }



  inline af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
    return *this;
  }




  inline af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_uint64();
  }

  inline operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  inline ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }


  inline char to_char() const {
    return (char)((d_bv.V).range((h_index), (l_index)));
  }

  inline int to_int() const {
    return (int)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned to_uint() const {
    return (unsigned)((d_bv.V).range((h_index), (l_index)));
  }

  inline long to_long() const {
    return (long)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned long to_ulong() const {
    return (unsigned long)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_slong to_int64() const {
    return (ap_slong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_ulong to_uint64() const {
    return (ap_ulong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  template <int _AP_W2>
  inline void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }


  std::string to_string(signed char rd = 2) const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_string(rd);
  }






};




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& os,
    const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  os << x.to_string();
  return os;
}
# 696 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 742 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
# 145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





  inline ap_fixed(bool v) : Base(v) {}
  inline ap_fixed(char v) : Base(v) {}
  inline ap_fixed(signed char v) : Base(v) {}
  inline ap_fixed(unsigned char v) : Base(v) {}
  inline ap_fixed(short v) : Base(v) {}
  inline ap_fixed(unsigned short v) : Base(v) {}
  inline ap_fixed(int v) : Base(v) {}
  inline ap_fixed(unsigned int v) : Base(v) {}
  inline ap_fixed(long v) : Base(v) {}
  inline ap_fixed(unsigned long v) : Base(v) {}
  inline ap_fixed(ap_slong v) : Base(v) {}
  inline ap_fixed(ap_ulong v) : Base(v) {}
  inline ap_fixed(half v) : Base(v) {}
  inline ap_fixed(float v) : Base(v) {}
  inline ap_fixed(double v) : Base(v) {}


  inline ap_fixed(const char* s) : Base(s) {}

  inline ap_fixed(const char* s, signed char rd) : Base(s, rd) {}






  inline ap_fixed& operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
# 307 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




  inline ap_ufixed(bool v) : Base(v) {}
  inline ap_ufixed(char v) : Base(v) {}
  inline ap_ufixed(signed char v) : Base(v) {}
  inline ap_ufixed(unsigned char v) : Base(v) {}
  inline ap_ufixed(short v) : Base(v) {}
  inline ap_ufixed(unsigned short v) : Base(v) {}
  inline ap_ufixed(int v) : Base(v) {}
  inline ap_ufixed(unsigned int v) : Base(v) {}
  inline ap_ufixed(long v) : Base(v) {}
  inline ap_ufixed(unsigned long v) : Base(v) {}
  inline ap_ufixed(ap_slong v) : Base(v) {}
  inline ap_ufixed(ap_ulong v) : Base(v) {}
  inline ap_ufixed(half v) : Base(v) {}
  inline ap_ufixed(float v) : Base(v) {}
  inline ap_ufixed(double v) : Base(v) {}


  inline ap_ufixed(const char* s) : Base(s) {}

  inline ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}


  inline ap_ufixed& operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 398 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h" 1
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h" 2




namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 221 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 399 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 2
# 368 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2
# 5 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 13 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h"
typedef std::complex<float> COMPLEXD;


struct axis_data {
 COMPLEXD data;
 ap_uint<1> last;
};

const COMPLEXD LS_gold[52] = {
 -0.5484816+0.3837994i,-0.3623023+1.075885i,-0.7660071+0.6852779i,
 0.0140981+0.6291122i,1.606364+0.8892474i,1.678347+0.05568536i,0.163479-1.465672i,
 0.329441-0.8346519i,-1.457966-1.253829i,-0.7650381+0.3915202i,-0.4770873+1.216696i,
 0.2704967+1.656089i,1.11718+1.513583i,1.672272+0.8698606i,1.692708+0.02713398i,
 0.1664147-1.464067i,-0.6496252-1.655365i,-0.3944012-0.4606687i,-0.7537365+0.3073461i,
 -1.556247+0.3100925i,0.1550612+1.652639i,0.01961903+0.7737306i,1.68035+0.9939642i,
 1.78702+0.103106i,1.291099-0.6523168i,0.4208774-0.9108285i,-0.8138225+0.2705191i,
 -1.606952+0.3237317i,-0.8732339+0.854722i,1.039143+1.616512i,1.681558+0.9887982i,
 0.7549856-0.7285228i,1.262935-0.6302111i,-0.5989876-1.687877i,-0.3743775-0.4899487i,
 -1.744228-0.5375728i,-1.516853+0.2750378i,-0.8335972+0.7399392i,
 -0.03111804+0.6592211i,0.5190284+0.09958155i,1.598747+0.1686445i,1.184511-0.4442197i,
 -0.5149598-1.484886i,-1.168673-1.230752i,-0.505945+0.1895986i,-1.430026+0.03442641i,
 0.06406594+1.334762i,-0.2785636+0.5794072i,1.305439+1.046659i,1.525923+0.4044627i,
 1.291645-0.2355201i,0.7046942-0.5829725i
};

const half mean_in[2*52] = {
  -0.002801,-0.001319,0.000619,0.002338,0.003245,0.002902,0.001239,-0.001215,-0.003457,
  -0.004229,-0.002923,0.000030,0.003187,0.004866,0.004111,0.001250,-0.002243,-0.004613,
  -0.004734,-0.002598,0.000759,0.003683,0.004866,0.003758,0.000928,-0.002286,-0.004461,
  -0.002506,0.000572,0.003393,0.004687,0.003859,0.001245,-0.002083,-0.004532,-0.004873,
  -0.002744,0.000873,0.004102,0.005162,0.003470,0.000007,-0.003223,-0.004458,-0.003278,
  -0.000723,0.001678,0.002778,0.002538,0.001517,0.000348,-0.000724,0.001517,0.002888,
  0.002972,0.002033,0.000369,-0.001730,-0.003455,-0.003560,-0.002210,0.000699,0.003464,
  0.004726,0.003657,0.000674,-0.002723,-0.004911,-0.004557,-0.001857,0.001611,0.004155,
  0.004937,0.003143,0.000153,-0.002969,-0.004637,-0.004105,0.001536,0.003884,0.004560,
  0.003285,0.000408,-0.002812,-0.004574,-0.004498,-0.001990,0.001373,0.004296,0.005060,
  0.003147,-0.000472,-0.003667,-0.004876,-0.003546,-0.000431,0.002596,0.003641,0.003018,
  0.001027,-0.000622,-0.001690,-0.002025,-0.001861
};

const half std_in[2*52] = {
  0.705987,0.712985,0.715984,0.710446,0.706627,0.711434,0.715377,0.712315,0.708409,0.711200,
  0.714397,0.712777,0.709545,0.710609,0.713690,0.712636,0.709293,0.711077,0.714375,0.712414,
  0.708085,0.710263,0.714894,0.713154,0.707299,0.708790,0.715342,0.707630,0.707000,0.714685,
  0.716715,0.709428,0.705274,0.711627,0.716612,0.711057,0.704658,0.707428,0.713964,0.713374,
  0.706441,0.704360,0.710523,0.714952,0.710675,0.703944,0.707337,0.715074,0.714238,0.705734,
  0.704286,0.712670,0.715589,0.708963,0.705941,0.712021,0.715820,0.711238,0.707965,0.710969,
  0.714914,0.712653,0.709524,0.711071,0.714132,0.712923,0.709764,0.711074,0.714153,0.712296,
  0.708854,0.710419,0.714810,0.712379,0.707746,0.709410,0.715224,0.713840,0.707810,0.715327,
  0.715931,0.708683,0.706276,0.713513,0.716744,0.710521,0.704557,0.709600,0.715218,0.711905,
  0.705018,0.705532,0.712106,0.713965,0.708675,0.704167,0.708745,0.715143,0.712871,0.704651,
  0.705812,0.714111,0.715435,0.707134
};

const half mean_o[2*52] = {
  -0.002808,-0.001326,0.000626,0.002345,0.003239,0.002896,0.001246,-0.001222,-0.003451,-0.004236,
  -0.002930,0.000023,0.003181,0.004859,0.004104,0.001257,-0.002237,-0.004620,-0.004741,-0.002591,
  0.000752,0.003690,0.004859,0.003752,0.000921,-0.002293,-0.004467,-0.002500,0.000579,0.003386,
  0.004681,0.003865,0.001238,-0.002077,-0.004539,-0.004866,-0.002738,0.000880,0.004109,0.005169,
  0.003463,0.000001,-0.003216,-0.004451,-0.003285,-0.000716,0.001671,0.002785,0.002531,0.001510,
  0.000341,-0.000731,0.001447,0.002818,0.003042,0.002103,0.000299,-0.001800,-0.003386,-0.003630,
  -0.002140,0.000629,0.003394,0.004656,0.003587,0.000604,-0.002793,-0.004841,-0.004487,-0.001927,
  0.001541,0.004225,0.004867,0.003213,0.000083,-0.003039,-0.004707,-0.004175,0.001466,0.003954,
  0.004630,0.003215,0.000339,-0.002742,-0.004644,-0.004428,-0.002060,0.001443,0.004366,0.005130,
  0.003217,-0.000402,-0.003737,-0.004946,-0.003476,-0.000361,0.002526,0.003711,0.002948,0.001097,
  -0.000692,-0.001760,-0.002095,-0.001931
};

const half std_o[2*52] = {
  0.705393,0.712541,0.715544,0.709867,0.706533,0.711260,0.715011,0.711802,0.708324,0.710597,0.713940,
  0.712523,0.709451,0.710540,0.713497,0.712330,0.709155,0.710466,0.713859,0.712066,0.707861,0.709730,
  0.714688,0.712869,0.706931,0.708359,0.714862,0.707370,0.706656,0.714426,0.716525,0.708920,0.704986,
  0.711323,0.716129,0.710855,0.704407,0.707100,0.713564,0.712918,0.706221,0.704131,0.710105,0.714646,
  0.710161,0.703809,0.706814,0.714737,0.714054,0.705657,0.704174,0.712392,0.715201,0.708467,0.705799,
  0.711840,0.715439,0.710991,0.707433,0.710839,0.714450,0.712305,0.709040,0.710519,0.713607,0.712504,
  0.709485,0.710558,0.713594,0.712131,0.708558,0.710194,0.714244,0.712286,0.707261,0.709102,0.715087,
  0.713781,0.707534,0.715123,0.715865,0.708058,0.705772,0.713134,0.716639,0.709866,0.704464,0.709208,
  0.715051,0.711879,0.704976,0.705325,0.711860,0.713892,0.708034,0.703633,0.708405,0.714984,0.712271,
  0.704536,0.705378,0.713845,0.715294,0.707028
};


const half L1_BIAS[52] = {
  -0.257672,0.010955,-0.427076,-0.674760,-0.003050,-0.354949,-0.017629,0.044782,-0.011473,-0.010642,0.064564,
  0.813054,0.017445,0.548345,0.006756,-0.053699,-0.026147,-0.482557,-0.117330,-0.258870,-0.320991,-0.429637,
  -0.045513,-0.010844,-0.220136,-0.071144,0.113705,-0.008028,-0.297397,0.305242,-0.006648,-0.020427,-0.002411,
  -0.319708,-0.032194,0.456231,-0.209027,-0.064414,0.007566,0.026169,-0.254766,0.005862,0.010840,0.055728,
  -0.173064,0.031788,-0.667923,-0.426306,-0.031856,0.035470,0.011146,-0.023091
};


const half L1_WEIGHTS[2*52][52] = {
  {0.015622,-0.118225,-0.216345,0.087524,0.103408,-0.257011,-0.146548,0.069903,0.013814,0.014035,-0.040006,-0.253056,-0.069315,0.095431,-0.173083,-0.085477,0.036833,0.122120,-0.066324,-0.075206,0.009255,0.146178,-0.019650,0.142067,0.027454,0.031346,-0.240769,0.053807,0.121753,0.119201,0.234918,0.121578,0.019032,-0.131507,-0.052606,0.158118,-0.033236,-0.043719,-0.114136,-0.149605,0.039071,-0.056052,-0.061718,0.051228,0.134713,0.100022,-0.142806,-0.048505,-0.084823,0.101552,-0.037126,0.088339},
  {0.068933,0.049082,0.014130,-0.104489,0.149704,-0.203339,0.000991,-0.041159,0.138566,-0.045635,0.004831,-0.138682,-0.075059,-0.146256,-0.186896,0.094229,0.029530,0.103387,-0.052581,0.050165,0.000204,0.044107,-0.034954,-0.014555,0.061277,0.039234,-0.134573,0.343200,0.021754,0.210124,0.171168,0.050602,-0.112127,-0.040845,0.061296,0.208924,-0.037357,0.057496,-0.324747,-0.142393,0.019304,-0.123123,0.121722,-0.076426,-0.038517,-0.043050,0.080577,0.001887,-0.052695,-0.027471,-0.133667,0.050442},
  {-0.063232,0.220224,-0.061702,-0.061969,0.170974,-0.084334,-0.054960,-0.027829,0.057996,-0.121633,-0.017514,0.100749,-0.002106,-0.170390,-0.068084,0.154756,-0.039303,-0.010836,-0.013424,0.036155,0.071102,-0.044232,-0.060333,-0.274354,0.102124,-0.022435,-0.095171,0.337535,-0.023876,0.070127,0.112893,-0.047013,-0.080483,0.005953,0.074314,0.208693,0.076531,0.035823,-0.252244,-0.047891,0.029053,-0.071653,0.066584,-0.222654,-0.043711,-0.048172,0.025576,-0.054204,0.069003,0.003827,-0.121782,-0.020287},
  {-0.067195,0.264770,0.189614,-0.008580,0.067499,0.179398,0.019867,0.028153,-0.037938,-0.066515,-0.051662,0.206105,0.051910,-0.051614,0.174785,0.117380,0.003535,-0.186228,-0.131000,-0.009287,0.155724,-0.118117,-0.043559,-0.149127,0.056121,0.059677,-0.057660,-0.008902,-0.000141,-0.112798,-0.111148,-0.093986,-0.069616,-0.024268,-0.053585,0.047196,-0.067064,0.030706,-0.070649,0.080026,-0.033065,-0.034033,0.081920,-0.095387,-0.057155,-0.130735,0.010160,0.030535,0.093611,-0.081724,0.062626,-0.147628},
  {-0.017641,0.119528,0.185541,-0.027527,-0.067631,0.307471,0.073878,-0.051336,-0.085635,0.002515,-0.054074,0.135036,0.111856,0.012508,0.131217,-0.068593,0.024646,-0.208749,-0.002450,0.088142,-0.025096,-0.162535,0.040261,-0.078015,0.009781,0.034215,0.157457,-0.069473,-0.090575,-0.228039,-0.206192,-0.079407,0.050017,0.025342,0.065348,0.127628,0.033307,0.157270,0.090141,0.027609,-0.084123,0.028480,0.042072,0.029588,-0.083751,-0.119781,0.002430,0.005820,0.073435,0.033790,0.164418,-0.150674},
  {0.023072,-0.099243,0.107788,0.020227,-0.131072,0.157464,0.045236,-0.037111,-0.024645,-0.057138,-0.005621,0.005843,0.058218,0.067632,0.204177,-0.162279,-0.028611,0.006443,0.025615,0.103397,-0.024617,-0.039867,-0.088149,0.034373,0.077338,-0.048545,0.024645,-0.285845,-0.029318,-0.093952,-0.119276,-0.051089,0.090081,0.030705,-0.053479,0.150115,0.034776,0.014124,0.232309,0.073757,0.057889,0.125718,-0.005451,0.164066,-0.060676,-0.029481,-0.171175,0.014188,0.061361,-0.004066,0.074037,0.009859},
  {0.026185,-0.093725,-0.069887,-0.014148,-0.055059,-0.122374,0.043454,0.116798,-0.090751,-0.062598,0.121578,-0.200046,0.022436,-0.061392,0.045047,-0.144887,-0.046366,0.137152,-0.028733,-0.057915,-0.052656,0.016210,-0.139767,0.116750,-0.020381,-0.051013,0.142164,-0.225841,-0.056440,0.088153,-0.036988,-0.020279,0.047336,0.017207,-0.038196,0.030076,0.009303,-0.040684,0.131466,0.049350,-0.028478,0.102349,-0.000230,0.127192,-0.024335,0.132052,-0.047651,0.062897,-0.059029,-0.012416,0.012864,-0.099981},
  {-0.069237,-0.145747,-0.069349,-0.045217,-0.018199,-0.114719,0.032353,0.035228,0.178806,-0.046915,0.132005,0.056062,-0.087667,-0.066531,-0.068570,-0.200625,0.079554,-0.006248,0.020323,-0.056713,0.025542,-0.007956,0.005225,0.138509,0.003852,0.004438,0.117874,0.029137,-0.100754,0.092068,0.110024,-0.013775,-0.021846,0.017325,0.022000,-0.049474,0.061939,-0.127015,-0.089806,-0.115346,0.047494,0.021756,0.009001,0.129564,-0.053411,0.000182,0.108096,-0.079593,-0.040472,-0.072478,-0.188556,0.068386},
  {-0.062788,-0.098968,-0.058809,-0.084488,0.000503,-0.025224,0.054327,-0.011221,0.167813,0.032939,0.109755,0.006059,-0.049366,0.016349,-0.142193,0.048047,0.022607,0.064779,-0.013412,0.009601,-0.042814,-0.058443,0.025280,0.081985,-0.057418,-0.046334,0.153383,0.183967,0.110505,0.095432,0.132424,0.072868,-0.013207,-0.033029,0.030436,-0.163278,0.022585,-0.043591,-0.110181,-0.000610,0.010054,-0.049393,-0.063430,0.095015,-0.035394,0.111115,0.155397,-0.044511,-0.047559,-0.078505,-0.096020,0.057770},
  {0.057234,0.018191,0.040705,-0.069942,-0.013669,0.163661,0.044020,-0.135205,-0.039900,0.062477,-0.054840,0.085202,-0.080807,0.191926,-0.095196,0.049748,0.076011,-0.016837,0.012645,0.038725,-0.003445,-0.037394,0.181778,-0.034731,-0.048502,0.018003,-0.026464,0.046107,0.135502,-0.174062,0.197471,0.070329,-0.066343,-0.107982,0.053080,-0.193722,-0.072537,0.104082,-0.142834,-0.047634,0.050472,-0.000085,-0.086595,-0.000322,0.023627,0.056506,0.094891,0.002632,-0.073829,-0.050919,0.010025,0.063490},
  {0.084643,0.130021,-0.067491,0.067198,-0.025322,0.099802,-0.077349,-0.116228,-0.137136,0.020112,-0.118401,0.064741,-0.024225,0.208512,-0.010914,0.158195,0.023819,0.068543,0.046114,0.037695,0.065133,0.047660,0.062560,-0.134349,-0.019488,-0.083474,-0.073518,-0.033220,0.171617,-0.099302,0.114401,0.043590,0.090203,0.021960,-0.141826,-0.131296,0.052435,0.157752,-0.023634,-0.093717,0.033755,-0.029898,-0.086983,-0.120561,0.011455,-0.047746,-0.072004,0.048590,0.041632,0.099331,0.148340,0.090668},
  {0.074834,0.111948,-0.043579,0.166311,-0.021790,-0.034685,-0.136184,0.054531,-0.229874,-0.083254,-0.148804,-0.128427,-0.030202,0.073163,0.039108,0.075216,-0.050744,0.075952,0.034613,0.020623,-0.085571,0.017527,0.034227,-0.102732,-0.076850,0.053302,-0.220704,-0.176566,0.031940,0.132402,-0.093944,0.054039,0.020483,-0.059102,-0.128698,-0.049991,0.052619,0.191261,0.051125,-0.009530,0.046908,-0.021191,-0.023997,-0.115425,0.048084,0.019265,-0.110134,0.052055,0.037591,0.087874,0.136483,-0.008194},
  {-0.026595,-0.039086,-0.132424,0.133386,0.031892,-0.220855,0.030051,0.166396,-0.031796,-0.078691,-0.133185,-0.109764,-0.000969,-0.042319,0.101824,-0.019217,0.004864,0.109260,0.016635,-0.003233,0.071497,0.029650,-0.088683,-0.053990,0.075693,-0.086475,-0.120498,-0.036663,0.010716,0.150519,-0.032926,-0.031560,-0.067866,-0.053551,0.038708,0.125858,-0.095860,0.007673,0.124599,0.043707,-0.016110,-0.061128,0.039854,0.003374,0.021697,-0.097985,-0.010996,-0.018159,-0.002839,-0.014521,0.030946,-0.057970},
  {-0.054465,-0.117720,0.009496,-0.087317,0.171352,-0.153526,0.004903,0.140583,0.158045,-0.098000,0.049102,0.027651,0.115773,-0.055123,0.106122,-0.065710,0.018327,0.098193,-0.080665,0.060458,0.080473,-0.008554,-0.176037,0.123709,-0.027764,-0.027421,-0.156115,-0.086139,0.017291,0.086581,0.031966,-0.017904,-0.149000,0.003984,0.047737,0.061176,0.008638,0.013756,-0.014720,0.080083,-0.006218,-0.073771,0.128098,0.049016,-0.078575,-0.097103,0.118923,-0.059289,0.050097,-0.062025,-0.134390,-0.124127},
  {-0.050983,-0.060772,0.076755,-0.112141,0.117460,0.119189,0.019781,0.014586,0.159350,-0.126525,0.165602,0.159255,0.059422,-0.069190,0.027463,-0.063627,0.028601,-0.042052,-0.068445,0.093456,0.117398,-0.159254,0.037858,0.114891,0.108890,0.030402,-0.016730,0.043844,0.077056,-0.143967,0.048935,-0.033463,-0.009360,-0.035495,0.077968,0.047456,0.000039,-0.125916,-0.110174,0.164728,-0.104501,-0.126264,0.061042,0.145233,0.019433,-0.072753,0.149351,-0.080964,0.056501,-0.200452,-0.185614,-0.002488},
  {0.049193,-0.129331,0.105472,-0.072168,-0.004687,0.227968,0.135845,-0.115562,-0.025815,-0.004629,0.191204,0.091829,-0.041118,0.121755,-0.056825,-0.052776,-0.047068,-0.034911,0.018723,0.020204,0.004802,-0.000435,0.103753,0.037582,0.095206,0.044126,0.049272,0.165689,0.009459,-0.186598,-0.009439,-0.110095,-0.002322,-0.062991,0.135559,0.099230,0.052621,-0.094173,-0.232564,0.025895,-0.053310,0.058925,-0.022581,0.037871,-0.003092,0.010033,0.023542,-0.064872,-0.039925,0.021405,0.013791,-0.061801},
  {0.023144,0.015595,0.117202,0.040523,-0.169648,0.173044,-0.056144,-0.159466,-0.074504,0.135556,0.079614,-0.043758,-0.057180,0.035043,0.034685,-0.010334,-0.020205,-0.070955,0.035858,0.012068,-0.038120,-0.052744,0.146698,0.009727,0.041217,-0.023952,0.102476,0.188602,-0.009283,-0.233263,0.099456,0.020091,0.060223,-0.045440,-0.055906,0.011093,0.058939,-0.150288,-0.180550,0.065300,-0.045087,0.126975,-0.094620,-0.081603,-0.033550,-0.040563,-0.056349,-0.022784,-0.000398,-0.014574,0.088362,-0.022716},
  {-0.047651,0.208010,0.065595,0.075456,-0.116269,0.130159,-0.018864,-0.073205,-0.198776,0.131028,0.114453,-0.043428,-0.130109,-0.017351,0.023612,0.046458,-0.026792,-0.110927,0.028918,-0.080956,-0.043472,-0.079036,-0.017334,-0.192672,0.018268,-0.057317,0.095087,0.098944,-0.152625,-0.135490,-0.078262,0.150950,0.129053,0.090999,-0.064115,0.038803,0.004633,-0.084725,-0.048561,-0.123091,0.011951,0.190988,-0.208185,-0.005791,0.012915,0.128911,-0.064014,0.014449,-0.081618,0.041329,0.152401,0.143550},
  {-0.056048,0.111174,-0.048471,-0.042260,-0.041799,-0.149156,0.049801,0.078861,-0.007241,0.067300,-0.121593,-0.024029,-0.168484,-0.163993,0.025645,0.048928,-0.106132,-0.032775,-0.052023,-0.046999,0.003963,0.042235,-0.042130,-0.066722,0.053273,-0.023481,0.202533,-0.074503,-0.064543,0.073586,-0.022645,0.026567,-0.053130,0.063534,0.010457,-0.076682,0.064065,0.075843,0.091363,-0.120962,-0.036803,0.021540,-0.013950,-0.019462,-0.020334,0.010810,-0.080431,-0.013419,-0.075130,0.095884,0.065416,0.138221},
  {0.013102,-0.002300,-0.054444,-0.033738,0.116597,-0.194610,0.093579,0.204906,0.051216,-0.056863,-0.179647,0.073298,-0.023705,-0.103497,0.011886,0.008351,0.008210,0.077689,0.002591,-0.079468,-0.014004,0.080103,-0.117972,-0.099761,0.001710,-0.001050,0.121102,-0.117376,-0.002456,0.145643,0.065481,0.035410,-0.036388,0.072543,0.008023,-0.076693,0.004885,0.244731,0.110548,0.009212,-0.007392,-0.077201,0.029927,-0.021101,0.039488,-0.050919,0.015263,-0.054691,0.076902,-0.031466,-0.080882,-0.045569},
  {-0.018822,-0.131982,-0.044797,-0.084074,0.078253,-0.048670,0.006079,-0.010277,0.244855,-0.205839,-0.117050,0.150605,-0.067531,0.173893,-0.043200,-0.012118,0.041019,0.014050,0.073829,-0.001068,0.009251,-0.024642,-0.094086,0.168818,-0.060417,-0.023191,0.060836,-0.130021,-0.037949,0.041634,-0.013112,-0.000840,0.011199,-0.103939,0.140725,-0.245798,-0.003498,0.123542,0.206105,-0.052962,0.050367,-0.136333,0.093671,-0.024448,0.044654,-0.086124,0.034748,-0.108618,0.075831,-0.170538,-0.235756,0.018481},
  {-0.037518,-0.283925,-0.042688,0.053906,-0.030574,0.090165,-0.049080,-0.139231,0.116764,-0.093809,-0.089655,-0.001473,0.056345,0.095192,-0.021023,0.031096,0.060300,0.075980,-0.000991,0.034204,-0.069429,0.034304,0.121997,0.236370,0.005358,-0.036296,-0.045890,0.000090,0.080570,-0.105381,0.027272,-0.030817,-0.007995,-0.094304,0.065253,-0.174387,-0.075573,0.080312,-0.045642,0.025561,0.097166,0.005061,0.046920,-0.032569,0.113035,-0.060465,-0.022811,-0.021627,0.131089,-0.038905,-0.064131,-0.059212},
  {-0.033094,-0.179709,-0.033263,0.148263,-0.066918,0.092588,-0.076892,-0.152410,-0.052909,-0.089137,-0.070353,0.005884,0.016879,0.147617,0.113222,0.020296,0.054941,0.051388,-0.066893,-0.035846,-0.051946,0.096106,0.157633,0.228302,-0.052120,0.083448,-0.179333,0.151470,0.094373,-0.172079,-0.061057,0.044046,0.095342,0.012284,-0.081694,0.027053,0.026322,-0.037153,-0.169131,0.070589,0.068328,0.108052,0.068821,-0.134764,0.053542,-0.005344,-0.151337,-0.011548,-0.032020,-0.010448,-0.016085,-0.021993},
  {0.011658,0.004345,0.019064,0.149964,-0.139358,-0.041206,-0.065016,-0.156581,-0.180323,-0.007866,0.181686,-0.010897,0.105730,0.042478,0.068649,0.034813,-0.151976,-0.010314,-0.008686,0.004976,-0.031341,0.015115,0.119803,-0.019845,0.076724,-0.023448,-0.180812,0.207543,-0.001267,0.051276,-0.049766,-0.002312,0.031214,0.023144,-0.133343,-0.002520,-0.019793,-0.074851,-0.191522,-0.026044,-0.004458,0.119639,0.033725,-0.017506,0.042467,0.083834,-0.187368,0.011599,0.027250,0.233313,0.177136,-0.055748},
  {0.041971,0.139151,0.060001,0.027472,-0.001187,-0.117580,-0.106854,-0.024574,-0.091030,0.136047,0.132358,-0.010215,0.061988,-0.120693,-0.016361,-0.048035,0.049685,-0.033860,-0.045155,0.027594,0.067699,-0.008742,-0.036487,-0.271752,0.009355,-0.061626,-0.113321,0.186572,0.078689,0.078821,-0.007637,-0.040192,-0.041251,-0.020790,-0.105823,0.050043,0.056011,-0.112238,-0.040920,-0.002241,0.026281,0.010700,-0.092898,0.065471,0.048918,0.084900,0.018720,-0.009927,-0.149827,0.093449,0.142249,-0.050514},
  {0.087481,0.254226,0.115207,-0.059910,0.053496,-0.008708,0.060642,0.122120,0.033089,0.033917,0.047987,0.117833,0.009621,-0.159247,-0.006659,-0.165273,0.007651,-0.152674,-0.028734,0.067079,0.116338,-0.079408,-0.038654,-0.227141,-0.005269,-0.013282,0.021552,-0.174095,0.004086,-0.019821,-0.002720,-0.046173,-0.069821,0.028836,0.070434,0.102893,0.031611,-0.067377,0.141592,-0.029367,-0.087633,-0.128102,-0.032567,0.096762,-0.096164,-0.002374,0.023399,-0.087525,-0.124393,-0.160378,-0.060672,0.053402},
  {0.074645,-0.183522,0.119651,-0.060186,0.010136,0.289406,0.064130,0.012781,0.108682,0.074420,-0.128024,0.102647,-0.014486,0.118872,-0.036375,0.045469,-0.008905,-0.083881,-0.074565,0.054373,-0.018398,-0.092932,0.018935,0.116381,0.061042,-0.010589,0.093909,-0.171285,-0.050538,-0.303396,0.040772,0.001362,-0.052943,-0.033629,0.188071,0.062703,-0.022264,0.094131,0.175007,-0.076866,-0.083565,-0.027073,0.023182,-0.000228,-0.083620,-0.007444,0.015377,-0.149223,0.001231,-0.123356,-0.131178,0.095116},
  {0.062314,-0.179196,0.021480,0.004415,-0.057727,0.047328,0.058197,0.011628,-0.079525,-0.050962,-0.095895,-0.195690,-0.072413,0.123344,0.062071,0.155230,-0.085673,0.021113,0.030741,-0.069198,-0.116348,-0.106248,0.036417,0.194557,0.055577,-0.011802,0.157088,-0.032440,-0.054816,-0.066756,-0.097098,-0.039106,0.042490,0.058393,0.127146,-0.014802,0.017043,0.174774,-0.022682,-0.101215,-0.039450,0.047046,-0.030076,-0.222022,-0.020233,-0.077875,-0.073433,-0.000213,-0.004849,-0.040316,-0.061101,0.057891},
  {-0.061344,-0.091575,-0.054405,0.084297,-0.044202,-0.090024,-0.080995,-0.097720,-0.093319,-0.058938,-0.085652,-0.147357,-0.083240,-0.031853,0.092306,0.091500,-0.056265,0.066651,0.009677,-0.046825,-0.094960,0.047857,-0.058647,0.151381,-0.020045,-0.052550,0.120297,0.193991,-0.088916,0.038060,-0.104199,0.037527,0.065241,0.094828,-0.118694,-0.112928,0.094337,-0.007183,-0.135141,-0.137979,0.026493,0.033671,0.062462,-0.170746,-0.046845,-0.008221,-0.048435,-0.039241,0.010443,0.023554,0.122436,0.076287},
  {0.017000,0.091208,-0.006902,-0.000067,0.029113,-0.102526,0.043552,-0.013265,-0.190599,-0.107636,-0.012514,0.024524,-0.042616,-0.083767,0.078167,-0.083491,0.030985,0.072669,0.022592,-0.047130,-0.050908,0.024312,-0.007746,0.058467,0.009562,0.049614,0.158194,0.140054,-0.078591,0.086033,-0.119797,-0.052888,0.045661,-0.018834,-0.058137,-0.227309,-0.041104,-0.020035,-0.208893,-0.016886,0.069284,-0.002227,0.117524,0.074089,-0.045821,0.020679,-0.012644,0.056032,-0.005872,0.087859,0.129351,0.039587},
  {-0.118860,0.135301,-0.072131,-0.140872,0.059278,-0.158427,-0.052661,0.048442,-0.154186,-0.115232,0.006019,0.064394,0.048845,-0.000861,-0.037333,-0.192849,0.000188,0.016616,-0.004026,-0.048813,0.016414,0.038211,-0.015803,-0.161948,-0.053281,0.001010,-0.009706,-0.035059,0.112462,0.184764,0.087003,-0.058464,-0.064340,-0.074462,-0.090001,-0.121231,-0.071173,0.035527,-0.061434,0.075365,-0.040836,-0.053580,0.038266,0.153144,-0.063531,-0.108368,0.066505,0.082767,0.002281,0.081553,0.078856,-0.079805},
  {0.002571,0.221929,-0.025132,-0.039363,0.003899,-0.078620,-0.003795,0.062784,0.106464,0.058393,-0.147384,0.063842,0.162759,-0.014954,-0.329375,-0.139257,0.155365,0.010643,0.074811,-0.009551,-0.026065,-0.016423,-0.099446,-0.066529,-0.023734,0.022501,-0.195053,-0.105354,0.056527,0.064799,0.304082,-0.085884,0.056668,-0.079048,-0.077563,-0.114320,-0.025568,0.077369,0.009448,0.059705,-0.023922,0.001388,-0.021325,0.150616,0.088924,-0.001325,0.007217,-0.015058,-0.017324,0.041606,-0.048573,-0.109862},
  {0.035037,0.033761,-0.021339,0.020446,0.026262,0.097826,-0.078366,-0.039037,0.175896,0.151901,-0.094030,0.054224,0.082539,0.233868,-0.209294,0.010045,0.064098,-0.021971,-0.009391,0.095621,0.001932,-0.039068,-0.028204,-0.010215,0.010323,0.081421,-0.229339,-0.047013,0.022031,-0.095640,0.144007,-0.103777,0.084826,-0.113839,0.073865,-0.055770,-0.035342,0.136411,0.023819,0.044727,0.054278,0.099233,-0.044130,-0.005982,0.064470,0.023595,0.000364,0.030840,-0.010186,0.011566,-0.189347,-0.142264},
  {-0.020249,-0.072543,-0.033131,0.064197,-0.084831,-0.065443,-0.035860,0.039770,0.101598,0.161302,0.018987,0.010671,0.099967,0.126788,0.044137,0.220315,0.006371,-0.032636,0.008790,0.016654,0.060481,0.053406,-0.036937,0.115813,-0.017221,-0.010463,-0.255573,0.022580,-0.037821,0.002587,0.038467,-0.037663,0.109299,-0.045535,0.015992,0.210185,-0.000965,0.072731,0.014240,0.136165,0.094752,0.033126,-0.171197,-0.226300,-0.011260,0.015425,-0.105220,-0.049236,0.003841,-0.038590,-0.085612,-0.144939},
  {-0.053040,-0.237875,0.062233,0.100295,-0.044640,-0.041033,0.101671,0.098667,0.004122,-0.003862,0.123736,0.002514,0.053292,-0.083646,0.046070,0.178796,-0.006988,-0.004441,-0.047287,0.042840,0.063131,-0.014940,-0.046908,0.179333,0.125588,-0.001075,-0.111417,-0.007469,-0.032014,0.078159,-0.177673,0.112386,0.004683,0.038946,0.049321,0.161580,-0.022157,-0.093214,-0.112212,-0.077403,-0.020026,0.063241,-0.050811,-0.217001,0.036519,-0.009797,-0.095613,0.103945,-0.103651,-0.086747,-0.048008,0.070828},
  {-0.020963,-0.046033,-0.040305,0.010149,0.117453,-0.180983,0.097790,0.103206,-0.130050,-0.033405,0.152824,0.032294,-0.002071,-0.055565,0.150220,0.075718,-0.025282,-0.026480,-0.098590,-0.057020,0.082919,-0.009944,-0.010936,0.122096,-0.044596,0.025682,-0.103389,-0.058895,-0.010261,0.112950,-0.225813,0.108930,-0.069547,0.051128,0.047003,0.120488,-0.046410,-0.191783,-0.047121,-0.094573,-0.050385,-0.072823,-0.020855,-0.066801,0.018065,0.011993,-0.040534,-0.013461,-0.054619,-0.050988,0.139377,0.086984},
  {-0.050240,0.036223,0.122188,-0.078565,0.195418,0.038012,0.066923,0.042072,-0.224733,-0.122697,0.058534,0.007113,-0.077992,-0.033748,0.160571,-0.116824,-0.008654,-0.011877,-0.061350,0.016911,0.083788,-0.096794,-0.075853,-0.094751,0.017501,0.003438,-0.025673,-0.069895,0.037980,-0.044392,-0.066377,0.013317,-0.085242,-0.087536,0.066340,0.055267,0.071489,-0.146054,-0.012102,-0.123285,-0.037515,-0.083348,0.125941,0.109309,-0.049719,-0.047896,-0.019474,-0.032458,-0.021079,-0.063125,0.183622,0.087136},
  {-0.068937,0.054085,0.020882,-0.037849,0.119836,0.190161,0.015703,-0.028753,-0.117405,-0.076368,-0.011499,0.022614,0.005398,0.116568,-0.085869,-0.253518,0.087735,-0.110157,0.008764,0.002890,0.095152,-0.118174,0.032998,-0.147852,0.145208,0.052404,0.078046,-0.024620,0.047935,-0.220967,0.064696,0.025667,-0.000385,-0.018022,-0.041106,0.042490,0.035192,0.100045,0.042267,-0.015278,-0.109903,-0.000465,0.121299,0.273126,-0.075146,0.015419,0.055038,0.029248,0.046047,-0.003253,0.110416,0.030606},
  {-0.034439,0.180154,0.011643,-0.021615,-0.099631,0.045236,0.017248,-0.026127,0.067896,-0.032159,-0.078926,-0.105047,0.034681,0.060924,-0.140177,-0.138358,-0.049567,-0.023875,-0.032691,-0.066309,-0.101646,-0.068509,0.124895,-0.134884,0.022870,-0.057352,0.118830,-0.021578,-0.066478,-0.082355,0.099316,-0.018679,0.006017,0.075577,-0.099956,0.091864,-0.005228,0.183190,-0.021466,0.142152,-0.021125,-0.009898,-0.034335,0.178990,-0.011847,-0.091599,-0.023150,-0.038073,-0.064471,0.103072,-0.112856,-0.015963},
  {0.100901,-0.013612,-0.086915,0.090615,-0.161597,-0.018237,-0.065613,-0.015482,0.095149,0.122794,-0.213420,-0.129996,0.092180,-0.038354,-0.072663,-0.002463,-0.082301,0.035226,0.004176,-0.156827,-0.092973,0.076780,0.085792,0.000140,-0.048648,0.016256,0.185798,0.047964,-0.097506,0.009905,0.016242,-0.035269,0.008334,0.176679,-0.158605,0.075438,-0.009042,0.167072,-0.072230,0.047228,0.029846,0.086834,-0.170210,-0.037964,0.071018,-0.016553,-0.107667,0.006912,0.060195,0.120616,-0.159096,-0.024504},
  {0.001023,-0.146305,-0.121417,-0.005923,-0.055650,-0.138288,-0.018218,0.054302,0.079168,0.173536,-0.067000,0.018961,0.064872,-0.108019,0.145351,0.090955,-0.124227,0.086787,0.081206,-0.072974,-0.025921,-0.017493,-0.041400,0.098140,-0.015205,-0.045493,0.214553,0.031827,-0.097894,0.152797,-0.192878,0.000872,0.044132,0.164633,-0.100919,-0.123805,0.075265,0.116313,-0.064199,0.086612,0.040665,0.108791,-0.154601,-0.117645,-0.026332,0.011537,-0.019555,0.009536,0.041203,0.131488,-0.130388,-0.071136},
  {-0.032313,0.012378,-0.108679,-0.110513,-0.018655,-0.175396,-0.034593,0.148217,0.087123,0.128884,0.006318,0.015692,0.001302,-0.114546,0.097152,0.143515,0.057578,0.083369,0.090438,-0.005938,-0.030453,0.067224,-0.105667,0.083931,-0.075247,-0.005192,0.076902,0.104383,0.056731,0.151296,-0.163217,-0.042621,0.017117,0.005924,0.077695,-0.158905,-0.042199,-0.113090,-0.064925,0.064069,0.030725,-0.061460,-0.102960,-0.134558,0.042909,0.056233,0.080340,0.018760,0.026549,-0.081243,0.058613,-0.063011},
  {0.042743,-0.074881,-0.047146,-0.025295,0.095493,-0.151276,-0.013405,0.069384,-0.171085,0.139976,0.082448,0.059534,0.028891,-0.015216,0.018109,0.048970,0.112385,0.083350,0.063546,0.072001,-0.010634,-0.020615,-0.101297,-0.035448,0.025874,-0.062908,-0.057180,-0.115678,0.067286,0.186111,-0.027064,-0.021058,-0.082715,-0.093132,0.081019,-0.165418,-0.114141,-0.146232,0.022533,-0.010422,0.013083,-0.125194,-0.104003,-0.088297,0.053679,0.025658,0.017044,0.087396,-0.027581,-0.007110,0.148632,0.022728},
  {0.028065,0.105067,0.033595,0.021127,0.088316,-0.039113,-0.043934,0.056970,-0.128366,-0.110081,0.113119,-0.049402,0.025140,0.108694,-0.120116,0.049189,0.056832,-0.070367,0.017363,0.004647,0.036819,0.024398,-0.007007,-0.067103,0.021525,-0.007877,-0.188824,0.003767,0.267199,-0.016379,0.099018,0.014197,-0.018219,-0.159695,0.162003,-0.087957,0.048129,-0.027565,0.073512,0.026076,0.068933,-0.104057,0.167790,0.023245,0.046695,0.001898,0.099267,0.063117,-0.062361,-0.123898,0.090916,0.006234},
  {0.060692,0.115741,0.017911,-0.034815,-0.152486,0.143482,0.022145,-0.143034,-0.040739,-0.119053,-0.040085,-0.013869,-0.017846,0.157721,-0.142227,0.029058,0.007702,-0.064986,-0.096485,0.053363,0.012604,0.001711,0.173898,-0.054613,0.064878,-0.013002,-0.119181,-0.046732,0.008060,-0.134110,0.216405,0.069896,0.190991,-0.022844,0.124920,0.045622,-0.029432,-0.024446,0.106296,0.016549,-0.002856,0.111765,0.210224,-0.015487,0.059055,0.088495,-0.028602,-0.060321,0.026897,-0.082900,0.029991,-0.103761},
  {-0.030101,0.110451,0.063226,0.076934,-0.257148,-0.056556,-0.101681,-0.124361,0.152347,-0.144124,-0.115839,0.028122,-0.043274,-0.062543,-0.103417,-0.048392,-0.061955,-0.021376,0.049811,0.002341,0.067275,-0.024271,0.019555,-0.061356,-0.047420,-0.014589,-0.144274,-0.009024,-0.083223,-0.019106,0.086375,0.031209,0.140154,0.110848,-0.040885,0.113406,0.027396,0.073693,0.035484,-0.077446,0.061772,0.172436,0.156457,-0.011448,0.001947,0.030854,-0.117590,0.014163,-0.046202,-0.003954,-0.042692,0.062607},
  {0.024245,-0.106420,0.152889,0.029129,-0.056796,-0.061612,-0.055249,-0.067379,0.128607,-0.045933,-0.028122,0.108789,-0.075717,-0.151834,0.082809,-0.123021,-0.055925,-0.099123,-0.019446,0.008562,0.003441,-0.110684,0.020077,0.084126,-0.004565,0.022724,0.015047,0.049354,-0.030119,-0.015642,-0.168476,0.076542,0.124668,0.055908,-0.087836,0.174954,0.026965,0.117391,-0.049312,-0.115823,-0.088572,0.066399,0.053411,0.123661,0.093407,0.057552,-0.041610,-0.030005,0.039514,0.123403,-0.046655,0.155511},
  {0.017381,-0.095781,0.002334,-0.007060,0.062285,0.011194,-0.097418,0.090493,0.070230,0.189750,-0.115853,0.035414,-0.145355,0.004613,0.220468,-0.138396,0.058313,-0.021515,-0.067494,0.032675,0.094021,-0.033693,-0.014624,0.074894,-0.008496,0.006794,-0.085181,0.019891,-0.017407,-0.072499,-0.189900,0.176883,0.042372,-0.033347,-0.085894,0.084963,-0.032579,0.056571,0.002406,-0.146736,-0.021084,-0.008668,-0.170154,0.051903,-0.014413,0.027721,-0.033657,-0.037569,-0.002832,0.167743,-0.031354,0.140061},
  {-0.008774,-0.105796,0.087201,-0.016017,0.178979,0.179338,0.108643,0.033094,-0.102458,0.262328,0.037366,-0.012715,-0.066925,0.121890,0.089880,-0.062752,0.005066,-0.173941,0.030638,0.062833,0.030493,-0.059207,-0.010783,0.089564,0.081565,-0.057919,0.086600,0.066509,0.070966,-0.188430,-0.037563,0.032686,-0.130176,-0.116748,-0.056981,0.038644,0.006398,0.037906,0.007523,-0.060544,-0.057013,-0.118149,-0.259258,0.146358,0.000266,-0.109558,0.078216,-0.017357,0.133843,0.002275,0.055260,0.081350},
  {-0.057680,-0.095650,0.074998,-0.059309,0.207550,0.249439,0.012089,-0.008708,-0.130020,0.072888,-0.036993,-0.306246,-0.035852,0.135136,-0.107261,-0.040745,0.095066,-0.059351,-0.041357,-0.080005,-0.024469,-0.084927,0.024753,-0.021953,-0.009649,-0.020651,0.034785,0.021247,0.133712,-0.151728,0.048680,-0.014339,-0.163273,-0.048144,-0.010449,0.047997,0.034108,-0.041875,-0.086617,0.033012,-0.131450,-0.221090,-0.194293,-0.043775,-0.083528,-0.143779,0.010214,-0.067908,0.174830,0.024569,0.136119,-0.062011},
  {-0.008792,0.101152,-0.044435,0.051618,-0.038086,0.049601,0.093283,-0.033697,-0.056924,-0.072297,-0.074980,-0.269437,0.069178,-0.014701,-0.218614,0.131363,-0.066695,0.054884,-0.028996,-0.132769,-0.038779,0.046631,0.029859,-0.024369,-0.015437,0.031477,0.213476,0.054676,-0.108997,-0.172045,0.223414,-0.083331,-0.068916,0.152143,0.023759,0.081361,0.038445,0.012212,-0.054925,0.079303,-0.021160,0.042058,0.043153,-0.179231,-0.078337,-0.062574,0.060539,0.054951,-0.007439,-0.170024,0.043300,-0.094959},
  {-0.104234,0.153018,-0.160707,-0.082544,-0.113333,-0.177943,0.087786,0.061639,0.063018,-0.226942,0.087381,-0.019673,0.110411,-0.234472,-0.150135,0.202864,-0.100646,0.113049,0.043869,-0.136565,-0.101951,0.091810,-0.032318,-0.165560,-0.025552,-0.025351,0.324897,0.088036,-0.210743,0.073167,0.149262,-0.179810,0.138724,0.144339,0.051686,-0.005838,0.001614,-0.056298,-0.012622,0.310200,0.038441,0.124466,0.286951,-0.233474,-0.046083,0.112226,0.008176,-0.067712,0.011428,-0.032569,-0.048179,-0.204433},
  {0.046751,0.157323,0.069310,-0.107460,0.150867,-0.070358,0.019438,-0.056227,0.215797,-0.059414,0.000603,-0.037657,0.114413,-0.225634,-0.033427,0.204966,0.003745,0.015489,-0.059546,0.057310,0.031688,-0.034812,0.032206,-0.137675,0.032028,-0.006055,0.056624,0.257437,-0.095710,0.052990,-0.010723,-0.076476,-0.154696,0.092551,0.047118,0.225218,0.047622,-0.036314,-0.381827,0.038685,0.011644,-0.037479,0.082221,-0.171050,-0.028309,0.027930,0.010405,-0.036678,0.067011,-0.027803,-0.127909,-0.004811},
  {-0.008720,0.205927,0.260311,-0.165018,0.053876,0.103643,0.141803,0.012955,-0.019943,-0.076319,-0.020212,0.223957,0.028069,-0.191096,0.134294,0.100131,-0.024424,-0.214768,-0.059603,-0.015838,-0.037993,-0.101123,0.027961,-0.208387,0.031071,-0.052569,0.111203,0.169747,-0.120803,-0.131084,-0.107390,-0.061406,-0.046574,-0.000947,0.112927,0.157222,0.048157,-0.045848,-0.156297,0.053549,-0.022738,-0.051456,0.117651,-0.080172,-0.067526,-0.131277,0.122100,-0.109634,0.047207,-0.123670,-0.078959,-0.078232},
  {-0.019788,0.175165,0.170677,0.004986,-0.030953,0.255298,0.007406,-0.086987,-0.090142,-0.068472,0.047601,0.213233,-0.015020,-0.024972,0.181447,-0.013871,0.062306,-0.201925,-0.047214,0.020269,-0.023621,-0.161834,0.037103,-0.116825,-0.001487,-0.020401,0.170477,-0.063097,0.024240,-0.290434,-0.230340,-0.007285,0.022196,0.028820,0.055646,-0.045965,0.095607,-0.077787,-0.003135,0.146342,-0.045891,0.075987,0.065776,-0.042660,-0.032318,-0.116226,0.079450,-0.064872,0.178979,-0.141143,0.051602,-0.069605},
  {0.036285,-0.050853,0.122839,0.044997,-0.172500,0.105930,0.002088,-0.012704,-0.114058,0.036628,0.084515,0.069319,0.006631,0.006725,0.192182,-0.104426,-0.078537,-0.088748,-0.008087,0.036819,0.010822,-0.025354,0.099400,0.055083,0.086705,0.040419,0.140552,-0.341726,-0.014228,-0.092483,-0.091646,-0.138372,0.037875,0.031692,-0.026902,0.002428,0.045141,-0.070908,0.274619,0.125513,0.003084,0.155114,-0.077905,0.166823,-0.082553,-0.057063,-0.007077,-0.076568,-0.017658,0.041319,0.115204,-0.054819},
  {-0.012104,-0.122183,-0.058231,0.117181,-0.091419,-0.046692,-0.041318,0.036101,-0.146914,0.122814,0.082706,-0.153270,-0.016191,0.142425,-0.016436,-0.155171,-0.043736,0.113677,0.019498,-0.089033,-0.068900,-0.013276,-0.079481,0.154641,-0.066160,-0.075699,0.099300,-0.247359,0.000477,0.089469,-0.034674,-0.049114,0.089844,-0.006806,-0.056606,0.027856,-0.036017,-0.096576,0.150682,0.007792,0.011896,0.093616,-0.019490,0.179504,-0.018330,0.053474,-0.056029,0.010319,0.006810,0.059214,0.172892,-0.014436},
  {0.014655,-0.132815,-0.105005,-0.027448,-0.011314,-0.151365,0.000257,0.022109,0.090688,0.068925,0.052575,-0.152412,-0.036768,-0.016006,-0.039367,-0.144179,-0.024491,0.217683,0.056795,-0.058651,0.002140,0.086089,-0.118787,0.184658,-0.081879,0.015479,0.042569,0.073676,0.019558,0.200483,0.009676,0.028476,0.002028,-0.013633,0.074511,-0.142101,-0.002905,0.006199,-0.016608,-0.085336,0.096291,-0.019640,-0.076661,0.122090,-0.028380,-0.011116,0.045028,0.031885,-0.103804,0.019877,-0.081403,0.115429},
  {-0.099915,-0.082985,-0.101839,-0.153070,0.044453,-0.109165,0.036092,0.038106,0.135562,-0.083344,0.092810,0.043203,-0.099524,-0.087468,-0.097678,-0.075281,0.068288,0.166139,0.080625,-0.032217,-0.069121,0.056854,-0.057738,0.072667,-0.068504,-0.074302,0.031125,0.086554,0.013718,0.195038,0.074190,0.082212,-0.122823,-0.049589,-0.019560,-0.134513,0.032614,-0.144034,-0.181928,-0.112593,0.041313,-0.165908,0.032701,0.082265,-0.004689,-0.034777,0.148143,0.025798,-0.020486,-0.063591,-0.153837,0.053968},
  {-0.069589,0.015996,-0.004601,-0.038894,-0.017950,0.100240,0.029037,-0.103723,0.028890,0.044632,0.015279,0.076075,-0.074881,0.077925,-0.108358,-0.025409,0.067270,0.018912,-0.039564,0.049827,-0.042191,-0.066768,0.134153,-0.039951,-0.043853,-0.015332,0.018497,0.069265,0.094627,-0.059387,0.147326,0.109884,-0.066881,-0.084761,0.039757,-0.114025,-0.092702,0.007061,-0.184299,-0.037809,0.048874,-0.097138,-0.051270,-0.053099,-0.071005,0.046309,0.001204,-0.027257,-0.060403,-0.083694,-0.026467,0.097218},
  {0.005515,0.199823,0.085416,-0.069610,0.077121,0.178494,-0.033454,-0.050332,-0.078657,0.004887,-0.059957,0.123626,-0.010186,0.127789,0.002352,0.068319,0.045165,-0.046840,0.045585,0.046508,-0.002876,-0.027706,0.019906,-0.183459,-0.019178,0.017056,-0.145484,0.023195,0.085670,-0.077016,-0.033027,0.034492,0.025877,-0.110462,0.054437,-0.071557,-0.073221,0.159240,-0.043676,-0.112848,0.005532,-0.073930,-0.061829,-0.093657,0.023025,-0.031692,0.033259,-0.023903,0.010224,0.082506,0.114754,0.094175},
  {0.049193,0.094534,0.000088,0.171854,-0.069649,0.010699,-0.171372,-0.078375,-0.213657,0.014707,-0.136942,-0.010167,0.087082,0.175528,-0.020898,0.179944,0.011503,0.054038,0.017792,0.024292,0.032017,0.078755,0.050777,-0.206784,-0.052369,-0.018673,-0.191762,-0.086892,0.047639,-0.010047,-0.049520,0.008679,0.047204,-0.003422,-0.184820,-0.027295,0.052297,0.184347,0.106771,0.016659,0.030649,0.014761,-0.067468,-0.166254,0.099622,0.010397,-0.096182,0.004431,-0.043539,0.201396,0.262928,-0.015199},
  {0.073227,-0.028392,0.030595,0.151473,-0.079229,-0.141695,-0.094110,0.015525,-0.161621,-0.089391,-0.154656,-0.220319,0.041719,-0.023081,0.047635,0.030521,-0.001516,-0.030015,-0.002909,-0.009127,-0.075582,0.030442,-0.120392,0.007371,-0.053994,0.068093,-0.075015,-0.158805,-0.067374,0.108966,-0.063197,-0.107075,-0.068183,-0.052709,-0.037562,0.194794,-0.003071,0.087210,0.096750,0.026483,0.065704,0.029592,0.103160,0.024842,0.113224,-0.094434,-0.118337,0.080862,-0.048353,0.091240,0.117674,-0.084297},
  {-0.005416,0.015388,-0.044271,0.023369,0.004530,-0.167304,0.050086,0.071038,0.041105,-0.145227,-0.027402,-0.063006,0.127789,-0.097306,0.071334,-0.048300,0.072174,0.045552,-0.083772,-0.024485,0.046384,-0.050659,-0.162800,0.013983,0.126942,0.043049,-0.085200,-0.002066,0.002952,0.173776,-0.085528,-0.031652,-0.085344,0.014719,0.090436,0.149894,-0.006941,0.018967,0.080335,0.006203,-0.032779,-0.074703,0.038193,0.118110,-0.087612,-0.014802,-0.080770,-0.014257,0.031975,0.011846,-0.046655,-0.114259},
  {0.084813,-0.041284,0.091609,-0.104153,0.109844,-0.059468,-0.001247,0.021365,0.149614,-0.074471,0.134007,0.001568,0.064412,-0.125933,0.014628,-0.128732,0.069951,-0.159901,-0.043950,0.008535,-0.007331,-0.023879,-0.000160,0.055021,0.013277,0.020538,-0.025533,0.080324,0.035663,-0.012244,-0.029964,0.037722,-0.033075,0.077911,0.103469,0.115979,0.108027,-0.102618,-0.099376,0.045440,-0.066082,-0.042747,0.121787,0.138950,-0.076454,-0.099783,0.122147,-0.073543,0.127635,-0.103835,-0.165514,-0.085690},
  {0.018900,-0.104229,0.120256,-0.084952,-0.007525,0.207121,0.088876,-0.063515,0.086372,0.027117,0.093472,0.040790,-0.026379,0.138733,-0.078948,-0.083121,-0.012377,-0.094956,-0.014209,0.074089,0.020534,-0.022903,0.051770,0.065098,0.028110,0.071951,0.154531,0.113838,-0.012345,-0.207652,0.013869,-0.070342,0.048442,-0.007797,0.051489,0.064141,-0.002520,-0.130431,-0.117434,-0.006752,-0.064447,0.010825,-0.024282,0.140195,-0.086942,-0.092253,0.105366,-0.049607,-0.064165,-0.181877,-0.086042,0.054548},
  {-0.025923,0.016585,0.166572,0.045322,-0.136616,0.244777,0.087250,-0.275747,-0.007966,0.173174,0.008931,-0.065785,-0.088672,0.080171,0.012997,-0.058879,0.054378,-0.153169,-0.006874,-0.032992,-0.093367,-0.017823,0.160005,-0.065088,0.012553,0.074046,0.142908,0.169231,-0.014441,-0.337065,-0.010406,0.110766,0.070409,-0.027024,0.054752,-0.040979,0.093307,-0.111958,-0.085390,-0.115570,-0.027983,0.156692,-0.216404,-0.021345,-0.054774,0.097057,-0.035815,-0.082706,-0.076009,-0.017124,0.124629,0.101212},
  {0.018728,0.127290,0.068339,0.158838,-0.104496,0.162617,-0.019659,-0.081473,-0.232561,0.167084,-0.035710,0.018531,-0.045030,0.028224,-0.050337,0.094066,0.008881,0.024699,-0.051210,-0.144206,-0.071151,-0.072299,0.104425,-0.037762,-0.062980,0.006657,0.108063,-0.069867,-0.074521,-0.092597,0.026669,0.071879,0.134714,0.067554,-0.051309,-0.031861,0.058474,0.020140,0.077715,-0.145403,0.028650,0.076302,-0.118399,-0.052924,-0.043217,0.081518,-0.093274,0.001071,-0.120989,0.101642,0.091581,0.077882},
  {-0.108374,0.060164,-0.064606,0.015298,0.088641,-0.180149,-0.011167,0.099351,-0.043209,0.093069,-0.132343,-0.059304,-0.046747,-0.143366,0.025299,0.115537,0.017389,0.167395,0.073451,-0.093206,-0.057904,-0.019422,-0.155393,-0.110550,-0.063796,-0.019548,0.123434,-0.162494,-0.086796,0.184565,0.033727,0.059929,-0.047175,0.150010,-0.111231,-0.101992,0.030893,0.138008,0.192082,-0.032071,0.010383,-0.007826,-0.102437,-0.095161,-0.026803,0.067879,-0.011402,-0.023172,-0.111296,0.061586,0.019610,0.155780},
  {-0.064575,0.065062,-0.147184,0.079202,0.084009,-0.309203,-0.070166,0.181272,0.008257,0.068615,-0.105224,-0.028104,-0.067577,-0.105705,0.006074,0.069402,0.003138,0.065634,0.031874,-0.004942,-0.073461,0.046659,-0.101412,0.008268,-0.143533,0.057780,0.045131,-0.255632,-0.084413,0.144177,0.039119,0.065641,-0.029978,0.049140,-0.054902,-0.069622,-0.000486,0.141621,0.146115,-0.048843,0.074759,-0.075459,0.097868,-0.107514,0.043962,0.023439,-0.006927,0.010260,-0.004638,0.007646,0.025280,0.051299},
  {0.016531,-0.066350,-0.069100,-0.133937,0.090768,-0.084903,0.051724,-0.005834,0.149373,-0.128077,-0.090972,0.054906,0.009326,-0.059645,0.008333,-0.055498,0.118060,0.071241,0.052284,-0.044786,-0.052693,0.076985,-0.039741,0.063573,-0.036453,-0.038765,-0.097390,-0.023840,0.019112,0.101058,-0.001491,0.015389,-0.077654,0.023724,0.013125,-0.141195,0.022440,0.074051,0.211775,0.074462,-0.051683,-0.109942,0.165307,-0.050947,0.054301,-0.092982,0.055242,-0.094412,0.073413,-0.042790,-0.125713,-0.017242},
  {-0.031026,-0.219984,0.006833,-0.067562,0.054085,0.029237,-0.003993,0.045605,0.075058,-0.159426,-0.017386,0.105661,0.074665,0.124776,0.014246,0.009218,0.087308,0.061600,0.058772,-0.004242,0.104567,0.051328,0.009516,0.154360,-0.057589,0.032250,-0.102006,-0.016492,0.123448,0.053371,-0.015646,0.017950,-0.009550,-0.074057,0.071798,-0.110782,-0.021160,0.073240,0.009408,0.051001,0.003591,-0.053827,0.235235,0.020605,0.041566,-0.137116,0.076987,-0.093337,0.106740,0.003452,-0.098073,-0.006585},
  {0.055949,-0.152132,-0.043617,0.078162,-0.108649,0.219286,-0.049904,-0.173619,-0.043712,-0.077732,0.064937,0.095184,0.127253,0.095822,-0.049165,0.030438,-0.052164,-0.024899,-0.006865,0.013878,0.066272,-0.026883,0.233801,0.166132,-0.044127,-0.065201,-0.190027,0.129771,0.052319,-0.125637,0.044472,-0.049115,0.106923,-0.106812,-0.054451,0.032976,-0.037354,0.027174,-0.103328,0.095857,0.065105,0.088388,-0.002050,-0.032419,0.004898,-0.021841,-0.079522,-0.000223,0.070229,0.145252,0.032450,-0.088706},
  {0.009708,0.106918,-0.036422,0.043328,-0.123387,-0.001413,-0.083476,-0.008917,-0.174430,0.017954,0.097492,-0.001124,0.076808,0.005792,0.083582,0.048959,-0.059229,-0.005281,-0.055963,0.069092,0.014699,-0.009765,0.135198,-0.034060,0.021307,-0.025425,-0.153253,0.250865,0.026785,0.032817,0.068409,-0.068854,0.014932,0.014661,-0.135611,0.114478,-0.050295,-0.225405,-0.119521,-0.030833,0.013308,0.065803,0.058021,-0.094855,0.115294,0.038827,-0.055435,-0.009578,-0.090658,0.144011,0.104772,-0.148829},
  {-0.030457,0.096828,0.012118,0.044853,-0.056651,-0.080034,-0.142054,0.053697,-0.177512,0.045054,0.205225,-0.058432,0.026145,-0.123180,0.029749,-0.062525,-0.055264,-0.038419,0.003442,0.007169,0.002026,-0.033472,0.038428,-0.200441,0.036722,-0.044822,-0.131464,0.079046,-0.109805,0.085687,-0.014189,0.069674,-0.017204,-0.057035,-0.192340,0.119578,-0.006951,-0.107655,-0.119320,0.073807,-0.060927,0.048758,-0.097300,0.027332,0.093986,0.105074,-0.130056,-0.004993,-0.134280,0.181140,0.213798,-0.017385},
  {-0.004362,0.241168,0.083202,0.062128,0.125307,-0.024648,-0.017495,0.128213,-0.112266,0.149871,0.108197,-0.030922,-0.056910,-0.196525,0.000092,-0.068411,-0.003154,-0.025806,-0.035186,0.058956,-0.000968,0.012627,-0.104485,-0.218179,0.102981,0.095328,0.022849,-0.091584,0.011955,-0.018751,0.012163,0.073943,-0.095709,0.081624,-0.083549,0.163202,0.060528,-0.013172,0.069888,-0.074486,0.017204,-0.011595,-0.124273,0.060601,0.029789,0.132696,-0.028936,-0.062761,-0.063935,0.076303,0.067991,0.066289},
  {-0.052638,0.142897,0.041031,-0.102055,0.118664,0.129259,0.122609,0.078019,0.015798,0.010941,-0.036087,0.091295,-0.008532,-0.020700,-0.001588,-0.138707,-0.024676,-0.092898,-0.031330,-0.012641,0.018740,-0.076398,-0.124924,-0.111832,0.040266,0.039985,0.149925,-0.151292,0.003523,-0.062320,0.026518,0.030167,-0.067259,-0.025436,0.159087,0.102115,-0.019369,0.019540,0.148920,0.021950,-0.080298,-0.024894,-0.177155,0.088576,-0.086927,0.050165,0.133505,0.019274,0.029216,-0.089756,-0.093089,0.018530},
  {0.027087,-0.094389,0.084067,-0.029130,0.129553,0.323438,0.030617,0.005842,0.191296,0.059549,-0.177315,-0.000734,-0.048373,0.042865,0.025292,-0.045525,0.070978,-0.030097,-0.005532,0.001297,-0.074359,-0.003029,0.000226,0.110902,-0.021074,-0.053158,0.113596,-0.058869,-0.010372,-0.257319,0.043880,0.088261,-0.081199,0.037997,0.051920,0.016549,-0.043424,0.196948,0.133418,-0.109023,-0.059115,-0.031715,-0.017421,0.046185,-0.049342,-0.050508,0.096023,-0.048653,0.034335,-0.141615,-0.115594,-0.008621},
  {-0.062045,-0.134148,-0.148137,0.102170,-0.102097,-0.022971,-0.001979,-0.087660,-0.098836,-0.040016,-0.088804,-0.207577,-0.011260,0.083079,0.084158,0.158824,-0.005195,0.062912,0.045716,-0.112025,-0.075949,0.044993,0.149089,0.165147,-0.055515,-0.069056,0.211164,0.168655,0.035606,-0.013691,-0.025365,0.017699,0.073722,0.030853,-0.066704,-0.194015,0.029532,0.129158,-0.126681,-0.094057,0.073047,0.113754,0.084531,-0.087191,0.088087,-0.111245,-0.112612,0.014808,0.024291,0.056190,0.065529,0.055458},
  {0.029600,-0.097367,-0.138381,-0.014330,0.016773,-0.212374,-0.117343,-0.062555,-0.182643,-0.107811,0.040348,-0.096399,-0.072223,-0.186574,0.034707,0.017119,0.047358,0.089979,-0.011685,-0.075790,-0.062550,0.057700,0.059383,0.006732,-0.097106,0.022084,0.000824,0.196299,-0.042726,0.206725,-0.068828,0.008268,-0.037529,0.045501,-0.080990,-0.100078,-0.033988,0.023396,-0.235235,0.057323,0.109826,0.056569,0.173272,0.017566,-0.033405,0.065597,0.066175,0.124136,-0.037223,0.137474,0.174703,-0.073569},
  {-0.042183,0.112216,-0.082557,-0.072373,0.076539,-0.336358,-0.054580,-0.010528,-0.110219,-0.075048,0.157635,0.038122,0.100147,-0.065493,-0.037054,-0.091625,0.059555,0.013225,0.029257,-0.013814,0.027654,0.027552,-0.000453,-0.130717,-0.095414,-0.017578,-0.068467,0.152580,0.099671,0.284154,0.002521,-0.018682,0.008069,-0.018188,0.002786,-0.228333,-0.029109,-0.092337,-0.072089,0.008282,0.050586,-0.106428,0.077146,0.143601,0.096522,-0.028702,0.122211,-0.005236,-0.002204,0.087867,0.135825,-0.068522},
  {-0.056030,0.232938,0.036131,0.044985,0.060289,-0.112595,-0.110752,0.023882,-0.001592,0.014820,-0.068185,0.168000,0.107987,-0.033924,-0.168948,-0.218381,0.038551,0.119785,-0.047713,0.066290,0.031616,0.042379,-0.019245,-0.202731,-0.052904,-0.041187,-0.092602,-0.042772,0.023366,0.054726,0.202183,-0.045231,0.091287,-0.017515,-0.067492,-0.173787,-0.051489,0.029149,0.063969,-0.040956,0.034635,-0.064407,-0.126590,0.204703,0.054911,0.056750,0.043058,0.054172,-0.074144,0.145720,-0.052972,-0.059970},
  {0.025441,0.093036,0.045438,0.009774,-0.003788,0.071901,-0.108401,-0.007067,0.159417,0.037222,-0.093783,0.017347,0.073431,0.167771,-0.089109,-0.050500,0.001724,-0.078567,-0.023869,0.044046,0.078507,-0.020583,-0.099123,-0.040819,0.062719,-0.028317,-0.186010,-0.168151,0.003407,-0.079431,0.145689,-0.067444,-0.038462,-0.094728,0.033127,-0.002371,-0.021397,0.047643,0.151288,0.116077,-0.066188,0.005172,-0.082244,0.099525,0.046202,0.009902,-0.099203,0.012480,0.008693,0.039752,-0.142569,-0.193142},
  {0.024168,-0.065114,-0.005890,0.084401,-0.108792,-0.020307,0.027101,0.037733,0.191096,0.010858,-0.017612,-0.024490,0.114801,0.092032,-0.023523,0.147718,-0.012603,-0.011297,-0.118334,0.095003,0.089981,-0.035553,-0.073686,0.058181,0.005180,0.051820,-0.171168,-0.124584,0.048097,-0.028682,0.032011,-0.043741,-0.013410,0.053878,0.085096,0.247646,-0.057654,-0.014615,0.144596,-0.007957,0.026599,0.066387,-0.018863,-0.187216,0.011450,-0.023701,-0.005090,-0.011494,-0.062295,-0.138727,-0.247618,-0.078795},
  {0.036555,-0.111292,0.047205,0.192974,-0.077252,0.056662,0.053499,0.021282,0.046934,0.039696,0.006124,0.032513,-0.009961,-0.011286,0.055801,0.263769,-0.098030,-0.056666,-0.079476,-0.071092,-0.049279,0.018750,0.006232,0.067796,0.105812,0.027234,-0.017759,0.001566,-0.026989,-0.022582,-0.060849,0.019134,0.085144,0.042206,0.052285,0.063282,0.090525,-0.043697,-0.017148,-0.073773,-0.033111,0.098378,-0.001531,-0.231848,0.023536,-0.021459,-0.104085,-0.012643,0.053304,0.006894,-0.063879,-0.021676},
  {-0.001848,-0.063830,-0.007161,0.018638,0.072001,-0.096679,-0.001331,-0.002596,-0.002280,-0.117687,0.189867,-0.132903,-0.036799,-0.116737,0.260077,0.111382,-0.018369,-0.110045,-0.068678,0.052610,0.021630,0.033784,-0.089506,0.169563,0.001275,0.011234,-0.048288,0.082677,-0.075053,-0.024010,-0.166064,0.097859,-0.079235,0.000595,0.139932,0.199074,0.013752,-0.119928,0.022972,-0.084427,-0.027230,0.010673,0.091897,-0.095668,-0.040579,0.034433,0.011588,0.040142,-0.017791,-0.128476,0.122995,0.151679},
  {0.014594,0.022223,0.104338,-0.018672,0.041786,0.058287,0.089410,-0.050369,-0.187445,-0.139497,0.154168,-0.013273,-0.067760,-0.030472,0.172644,-0.060685,0.023848,-0.119455,0.043667,0.024510,-0.033326,-0.012533,0.037764,0.030815,0.015422,0.054797,0.058077,0.046646,0.019188,-0.000967,-0.077026,0.059012,-0.097261,-0.001466,0.017427,0.062136,-0.072829,-0.143531,-0.034092,-0.060916,-0.062244,-0.097567,0.035694,0.047355,-0.070395,-0.036018,0.111430,-0.001793,0.033248,-0.095212,0.198831,0.060431},
  {0.037114,0.148139,0.122620,-0.106787,0.074523,0.143043,0.020285,-0.034344,-0.174076,-0.130149,0.012319,-0.014948,-0.049967,0.044710,-0.040563,-0.206095,-0.028294,-0.087352,-0.031052,0.015760,0.004752,-0.002958,0.015816,-0.139327,0.048319,-0.031821,0.178098,0.033091,0.079242,-0.149838,-0.013228,0.092654,-0.042512,-0.132184,-0.007666,-0.042202,0.013636,-0.073776,-0.028835,-0.074852,-0.111676,-0.062226,0.157169,0.253285,-0.056293,0.016777,0.112494,0.067161,0.071089,0.014305,0.155202,0.009981},
  {-0.005500,0.134999,-0.015696,-0.078609,-0.028942,0.087938,0.048019,-0.121063,0.051817,-0.068831,-0.100123,-0.019358,0.057695,0.090878,-0.095655,-0.214576,0.006446,-0.007500,-0.047971,-0.033737,-0.107630,0.040577,0.077821,-0.157640,0.029689,-0.016185,0.166169,-0.045528,-0.012570,-0.111284,0.092437,-0.053051,0.028388,-0.008919,-0.042367,0.002528,-0.100333,0.081631,0.050585,0.052269,-0.024197,-0.065604,0.054282,0.223475,-0.030120,-0.020082,-0.043249,-0.020846,0.010136,0.003255,-0.037344,-0.007709},
  {0.089894,0.023077,-0.124265,0.046987,-0.140140,0.065916,0.069635,-0.092776,0.189418,0.120578,-0.216106,-0.119663,0.099238,0.024579,-0.067955,-0.023948,-0.087466,0.076435,-0.043184,-0.029593,-0.039880,0.095687,0.068384,0.063468,-0.052634,-0.016611,0.061450,0.024265,-0.053842,-0.077298,0.174089,-0.140471,0.132939,0.021728,-0.068765,-0.018615,0.086362,0.112373,0.074594,0.115343,0.078405,0.131913,-0.021873,-0.018973,0.008250,-0.039639,-0.005398,-0.018266,0.026480,0.140100,-0.106325,-0.119701},
  {-0.031865,-0.084667,-0.095606,0.018085,-0.070983,-0.162093,-0.025834,0.043036,0.174058,0.082151,-0.067619,-0.038676,0.060145,-0.106997,0.052978,0.191783,-0.049959,0.125062,-0.007612,-0.082817,-0.076630,0.024327,-0.064474,0.078893,-0.136285,-0.012706,0.041068,0.056893,-0.174067,0.206388,0.015780,-0.125185,0.086301,0.061225,-0.140786,-0.123987,-0.020250,0.149344,-0.142758,0.073392,0.032224,0.077957,-0.148426,-0.133735,0.025716,0.042124,-0.015568,-0.028135,-0.029709,0.039805,-0.197002,-0.099705},
  {-0.084687,-0.100283,-0.041460,-0.027593,0.027409,-0.228292,0.003310,0.068564,0.103858,0.069236,0.076961,0.047207,0.085279,-0.070851,0.065657,0.171724,0.045735,0.077003,0.017640,-0.070671,-0.036761,0.084826,-0.155109,0.124789,-0.049084,-0.078690,-0.034757,-0.008311,-0.001284,0.155332,-0.073889,0.027197,0.033183,0.024969,0.035495,-0.030677,-0.067780,-0.030222,-0.062740,0.058774,0.049829,0.001498,-0.141029,-0.132142,0.075797,0.043058,-0.032369,-0.021482,-0.061603,-0.020654,-0.027823,-0.071714},
  {0.056204,-0.010463,-0.106242,-0.019838,0.070693,-0.139327,0.002373,-0.011057,-0.112571,0.108386,0.053905,0.124269,0.006730,0.061570,0.091628,0.048960,0.051741,0.001238,-0.046089,0.054116,0.070008,0.016288,-0.089926,0.101879,0.004785,0.029893,-0.141657,-0.022311,0.025878,0.085871,-0.036715,0.005687,0.036174,-0.188221,0.041914,-0.297329,-0.118613,-0.173079,0.036645,-0.102756,0.042408,-0.110459,0.014096,-0.063650,0.041998,-0.030530,-0.038950,0.111824,-0.024859,-0.053838,0.033492,0.061228},
  {-0.072889,0.099728,0.019747,-0.092305,0.100857,0.035507,0.002371,-0.016400,-0.187372,-0.036321,0.190859,-0.027459,0.064637,0.111689,-0.067101,0.046440,0.087431,-0.053462,-0.096744,0.090642,0.080291,-0.094319,0.002034,-0.051161,-0.012763,-0.046061,-0.149704,-0.082528,0.189286,-0.048599,0.034885,0.022989,-0.076634,-0.211285,0.075911,-0.116448,0.007081,-0.085326,0.062644,-0.065530,-0.025762,-0.172591,0.083376,-0.050817,0.124814,0.063987,-0.025831,0.054522,0.028001,-0.016096,0.176543,0.004321},
  {0.075338,0.108230,0.034800,-0.077291,-0.077833,0.088180,-0.007400,-0.107972,-0.058152,-0.187419,0.076054,-0.001563,0.059523,0.151165,-0.255162,-0.047657,0.017018,-0.083318,-0.040648,0.099105,0.039830,-0.030541,0.088949,-0.135900,0.042384,-0.047332,-0.207273,-0.033529,0.044448,-0.062531,0.211415,0.070390,-0.005977,-0.082395,0.118790,0.025693,0.014357,-0.030161,-0.002511,-0.082255,-0.017224,0.091575,0.143938,0.037041,0.097172,0.084772,0.001920,-0.054936,-0.016736,-0.147643,0.084944,-0.046684},
  {0.039687,0.052157,0.093267,0.018548,-0.115073,0.145781,0.093809,-0.113056,0.075836,-0.150071,-0.058969,-0.091317,0.003566,-0.071973,-0.168348,-0.136079,-0.041059,-0.082504,-0.060225,0.018627,0.030507,0.002588,0.077725,-0.079960,0.066982,0.037000,-0.072979,-0.056871,-0.055589,-0.144657,0.113845,0.010407,0.061926,-0.029996,0.051443,0.232295,-0.027111,0.054839,-0.049456,-0.011338,-0.035401,0.192398,0.205262,0.151128,-0.017487,-0.026528,-0.073572,-0.012986,-0.034535,-0.029020,-0.017543,0.021851},
  {0.044116,0.011653,0.008130,0.126096,-0.118667,0.111392,-0.083853,-0.002004,0.063812,0.014325,-0.086736,-0.055184,-0.043570,-0.029254,0.085406,-0.025074,-0.039936,0.005442,-0.049408,0.052536,0.015805,-0.113140,0.041016,0.043820,0.062703,-0.079623,0.031992,0.060402,-0.089983,0.006525,-0.082214,0.124900,0.068782,0.076483,-0.205601,0.164045,0.088683,0.035526,-0.135627,-0.028803,0.018093,0.150749,0.052537,0.169483,-0.014658,0.009492,0.016737,0.028728,0.009088,0.213575,-0.032990,0.106132},
  {-0.017848,-0.131180,0.052366,-0.012584,-0.007484,-0.049147,0.008191,0.036635,0.107145,0.165922,-0.037124,0.087602,-0.100537,-0.162757,0.104346,-0.031049,-0.009506,-0.128797,-0.071497,0.009018,0.063018,0.000518,-0.021680,0.027409,0.000104,0.000423,0.026006,0.031589,-0.169414,0.013618,-0.095721,0.114001,-0.046939,0.115519,0.005313,0.113230,-0.001550,0.044018,-0.031067,-0.118680,-0.001877,0.020037,-0.151043,-0.027332,-0.018986,-0.057157,-0.006833,-0.018115,0.041726,0.071090,-0.144365,0.037722},
  {-0.081009,-0.126483,0.062807,-0.002904,0.096252,-0.016143,-0.009241,0.035429,-0.002582,0.279547,-0.007388,0.056892,-0.065513,0.132358,0.191025,-0.071688,-0.044943,-0.096033,0.022062,0.017596,0.057420,0.003565,-0.086412,0.171557,0.040474,0.002483,0.074292,0.068824,0.044305,-0.096302,-0.172400,-0.001473,-0.079519,-0.009082,-0.099192,-0.118914,0.024550,0.094585,-0.029604,0.033845,-0.078735,-0.105170,-0.183347,0.138350,-0.019359,-0.094887,-0.048593,0.007932,0.110434,0.034309,0.011781,-0.003220},
  {-0.024908,0.001773,-0.021903,-0.077002,0.263629,0.083805,0.008802,0.112580,-0.099800,0.168484,0.048592,-0.024976,0.052362,0.114106,-0.042214,0.082325,0.074853,0.060739,-0.062463,-0.073509,0.000129,-0.051855,-0.072480,-0.076774,-0.011013,-0.000436,0.071496,0.047721,0.082968,-0.093829,-0.002647,0.018754,-0.114302,-0.098233,0.147811,0.008131,0.038235,-0.013221,-0.005930,0.113033,-0.031027,-0.311788,-0.184896,-0.079570,0.011827,-0.063962,0.115092,-0.021499,0.110471,-0.043797,0.154141,-0.037267},
  {0.045009,0.031547,-0.095907,0.013571,0.133410,0.123053,0.096544,0.005563,-0.049283,0.022624,0.020686,-0.191258,0.026525,0.173661,-0.196679,0.156728,-0.004869,0.044862,0.023466,-0.067438,-0.109091,0.075596,0.074959,-0.095600,-0.056136,-0.027535,0.104702,-0.030296,-0.011004,-0.031622,0.165291,-0.105896,-0.022062,-0.009399,0.093617,0.013629,-0.000704,0.031542,0.011445,0.177017,0.020340,0.006216,0.021872,-0.176771,0.009414,-0.067306,-0.063104,-0.037721,0.056904,-0.126386,0.149033,-0.115976},
  {0.060682,0.019552,-0.102528,0.011965,-0.104793,-0.020073,0.027982,-0.044345,-0.099713,-0.192163,0.030519,-0.170878,0.090274,-0.164681,-0.117367,0.257778,-0.087417,0.143443,0.061992,-0.119524,-0.184897,0.048514,0.046940,-0.124989,-0.175928,-0.037880,0.126870,0.029815,-0.002614,0.096811,0.102928,-0.155483,0.143726,0.105082,0.107960,-0.138061,-0.009907,0.007393,-0.066494,0.245631,0.051977,0.117517,0.233816,-0.196426,0.019246,-0.003786,0.021799,0.001556,-0.016195,-0.049606,0.045507,-0.140594},
  {-0.043267,0.042803,-0.089152,-0.031623,-0.287767,-0.218964,-0.009788,0.004464,0.087750,-0.342516,0.026927,0.205198,0.034542,-0.150386,-0.024411,0.110580,-0.060758,0.037039,0.034007,-0.175554,0.032673,0.045136,0.063893,-0.105839,-0.092616,0.006286,0.035676,-0.001078,-0.173488,0.178163,0.112307,-0.001501,0.121085,0.240628,-0.021694,-0.035604,-0.051782,-0.001202,0.026761,0.080712,0.071654,0.126380,0.138291,-0.152330,0.049643,0.061128,0.107259,0.023487,-0.056142,0.060337,-0.062234,-0.108418},
  {-0.101867,-0.116108,-0.038691,-0.042295,-0.264035,-0.161660,-0.068075,-0.055373,0.090619,-0.119997,0.054166,0.402526,-0.090463,-0.099502,0.129420,-0.088056,0.011140,0.019320,0.005547,0.001486,0.019571,0.060662,0.111221,0.002608,-0.139107,-0.067535,-0.094187,-0.046129,0.008209,0.193646,-0.205784,0.033931,0.228340,0.054694,-0.003730,-0.163390,-0.045502,-0.107937,0.060238,-0.160447,0.007455,0.225485,0.157305,0.066179,0.060467,0.075144,0.005888,-0.055206,-0.113203,0.031868,-0.148155,0.090764}
};


const half L2_BIAS[2*52] = {
  0.157195,0.072193,-0.035439,-0.126320,-0.081899,-0.001953,0.081786,0.033099,-0.003965,-0.028709,0.001168,
  0.036264,0.031349,-0.012334,-0.073890,-0.087751,-0.042296,0.058714,0.089379,0.063621,0.019602,-0.022528,
  0.004750,0.012372,0.007208,-0.033544,-0.051988,0.037221,0.092493,0.106291,0.041323,-0.036188,-0.069527,
  -0.063285,-0.049350,0.004054,0.005553,0.002819,0.028574,0.028254,0.019648,0.008989,0.004817,0.026118,
  -0.016253,-0.018025,-0.074108,-0.064073,-0.011094,0.101192,0.132221,0.088347,0.006004,-0.085327,-0.129239,
  -0.035141,0.067551,0.086074,0.030196,-0.020338,-0.038882,-0.013075,0.040270,-0.000574,-0.036411,-0.076371,
  -0.034423,0.035204,0.101458,0.065949,0.017444,-0.019258,-0.046593,0.006473,0.015359,-0.007622,-0.053561,
  -0.046789,0.077645,0.115564,0.068819,-0.038396,-0.080836,-0.085604,-0.049000,0.012731,0.028655,0.024424,
  0.017366,0.007243,0.046889,0.001973,-0.002918,0.003261,-0.010268,-0.023915,-0.040953,-0.044434,0.003027,
  0.070859,0.120979,0.062148,-0.000989,-0.125427
};


const half L2_WEIGHTS[52][2*52] = {
  {0.002600,0.007330,0.003316,0.001247,-0.006744,-0.003867,-0.012359,-0.002097,-0.002654,-0.000439,0.005940,0.010639,0.002032,-0.001506,-0.008368,0.001505,0.002099,0.001263,0.000873,-0.010255,-0.000738,-0.001632,0.000748,0.010285,0.001158,-0.002933,-0.019054,-0.003323,0.004413,0.012810,0.012391,-0.000219,0.003778,-0.000342,-0.004409,0.003218,-0.001215,-0.001811,0.005808,0.003826,0.003410,-0.002027,-0.007861,0.000804,0.013497,0.011991,-0.006750,-0.019370,-0.020029,-0.001187,0.021958,0.023994,0.018753,0.006569,0.001067,-0.009587,-0.005575,-0.004697,0.002117,0.001680,0.008169,0.007205,0.011000,0.001649,-0.006043,-0.005095,-0.003905,0.006795,0.003293,0.004675,-0.005586,0.000134,0.001716,0.010794,0.001528,-0.005721,-0.010893,-0.008983,0.004637,0.006877,0.005606,-0.001625,-0.004788,-0.005812,-0.003113,-0.003219,-0.000308,0.000209,0.004982,-0.008725,-0.003927,-0.000475,-0.007239,-0.008272,0.002651,0.005405,0.001156,-0.012168,-0.013238,-0.007575,0.014006,0.029406,0.013872,-0.007960},
  {-0.082842,0.036074,0.122295,0.107854,0.039993,-0.049112,-0.105131,-0.091432,-0.017287,0.052248,0.085581,0.049561,-0.008589,-0.075312,-0.087861,-0.039026,0.027081,0.101891,0.101748,0.022463,-0.066484,-0.141775,-0.112812,-0.011690,0.108431,0.149199,-0.043825,-0.102766,-0.093987,-0.004782,0.080261,0.070748,0.017964,-0.048668,-0.066477,-0.012709,0.029876,0.053849,0.044822,-0.005814,-0.041441,-0.034942,-0.022281,0.020178,0.029281,0.024226,-0.018322,-0.047069,-0.021820,0.017278,0.054667,0.054629,0.120732,0.133247,0.055205,-0.038281,-0.109480,-0.103766,-0.036802,0.046412,0.099043,0.060386,0.004216,-0.052168,-0.079908,-0.055863,0.015794,0.082748,0.091626,0.047282,-0.049913,-0.112455,-0.105016,-0.010386,0.090760,0.136052,0.092906,-0.027881,-0.117499,-0.047443,0.055944,0.090409,0.050224,-0.012572,-0.065430,-0.055804,0.011980,0.067892,0.051281,-0.005628,-0.042338,-0.057453,-0.016742,0.009239,0.044139,0.026486,0.007820,-0.043136,-0.020704,0.013340,0.034237,0.046684,0.027381,-0.026273},
  {-0.000167,0.001295,0.002670,0.001265,0.000567,0.000479,-0.003128,-0.004899,-0.004915,-0.001191,0.004040,0.006953,0.006305,-0.001264,-0.005642,-0.005725,-0.002981,0.003857,0.005708,0.001670,-0.001732,-0.004293,-0.001412,0.001567,0.001221,-0.000118,-0.003720,-0.000401,0.003012,0.002191,0.002312,-0.001259,-0.002703,-0.001542,-0.000274,0.000095,0.000809,0.001442,0.001554,0.004136,0.002089,-0.002081,-0.005174,-0.005989,-0.002910,0.002266,0.005114,0.003443,0.001467,-0.003086,-0.002910,-0.001233,0.003506,0.000846,-0.001040,0.000737,-0.002726,-0.003061,-0.003731,-0.001861,0.003765,0.007302,0.006488,0.001514,-0.005000,-0.006725,-0.005114,0.002786,0.005047,0.004851,0.001265,-0.004794,-0.004461,0.000210,0.000700,0.002054,-0.001835,-0.004112,0.001136,0.002876,0.002246,-0.001003,-0.003058,-0.002406,-0.001467,0.001184,0.002709,0.002153,0.001412,0.002044,-0.000422,-0.001347,-0.002875,-0.005828,-0.002654,0.002998,0.006635,0.004542,0.001863,-0.002074,-0.005418,-0.002517,0.000561,0.002694},
  {0.008488,-0.011358,-0.009922,-0.013763,-0.018889,0.009572,0.013170,0.012768,0.017303,-0.000312,-0.018125,-0.012569,-0.009944,-0.003172,0.003985,0.002529,0.010285,0.010860,0.011216,-0.005305,-0.015603,-0.015081,0.000669,-0.004792,0.014603,0.012568,0.004967,-0.008835,-0.010458,-0.006315,-0.003337,-0.001012,0.008123,0.007714,0.006545,0.018498,-0.013235,-0.011342,-0.015620,-0.018800,0.003362,0.013631,0.015489,0.013281,0.006296,-0.008298,-0.013087,-0.011386,-0.007786,-0.001381,0.008086,0.011130,-0.009549,-0.013263,-0.022805,0.013549,0.009255,0.012695,0.017244,-0.013800,-0.012375,-0.011186,-0.009876,0.001505,0.009776,0.009081,0.010621,0.008014,0.005095,-0.000622,-0.008786,-0.011793,-0.001365,0.008708,0.010080,0.014504,0.010023,0.002176,-0.014191,-0.005813,-0.004625,-0.000577,0.008262,0.007959,0.004221,0.011989,-0.004357,-0.006021,-0.011888,-0.022304,0.009164,0.017636,0.019251,0.013775,0.003771,-0.010624,-0.012609,-0.013562,-0.007712,0.008696,0.011282,0.006390,0.015798,0.015971},
  {0.054592,0.147513,0.140537,0.075576,-0.037203,-0.085487,-0.096199,-0.024901,0.004944,-0.006970,-0.006314,0.031447,0.058239,0.098019,0.024289,-0.045471,-0.108682,-0.096588,0.008087,0.077256,0.106059,0.036444,-0.045889,-0.046540,-0.020051,0.021500,-0.014019,-0.042281,-0.000007,0.065654,0.061964,0.018817,-0.060396,-0.091734,-0.048380,0.043447,0.108499,0.060989,-0.017767,-0.076241,-0.035345,0.045095,0.088437,0.013688,-0.069871,-0.139060,-0.068422,0.082113,0.175850,0.186861,0.043827,-0.124981,0.190028,0.092166,-0.035371,-0.142479,-0.112303,-0.049735,0.037081,0.048015,0.030592,0.025185,0.044234,0.053611,0.021913,-0.030246,-0.108563,-0.091367,-0.017258,0.084280,0.100217,0.064756,-0.029417,-0.096968,-0.063237,-0.008832,0.043478,0.039803,-0.027584,0.000989,0.046143,0.037252,-0.031653,-0.079653,-0.062123,0.011074,0.095998,0.081293,0.018756,-0.087335,-0.089514,-0.020914,0.047476,0.060165,-0.015276,-0.099347,-0.090841,0.030937,0.133457,0.150636,0.047768,-0.098680,-0.214961,-0.174666},
  {-0.060848,-0.042828,0.015982,0.056510,0.064343,0.001925,-0.022294,-0.033473,0.004897,0.037797,0.028460,-0.017281,-0.056276,-0.033723,0.018169,0.057724,0.049163,0.017650,-0.016007,-0.026736,0.000688,0.017246,0.009531,-0.019506,-0.026689,-0.004126,0.053622,0.034375,-0.006139,-0.027871,-0.033538,-0.000463,0.004763,-0.008478,-0.019893,-0.000279,0.025136,0.044119,0.029872,-0.009419,-0.041768,-0.041965,-0.000299,0.023590,0.011057,-0.004495,-0.013196,0.012482,0.021183,0.030536,0.001640,-0.026266,-0.010231,0.062083,0.071753,0.025339,-0.026551,-0.054630,-0.032666,0.022943,0.034745,0.005672,-0.033826,-0.044915,-0.005578,0.048190,0.065709,0.026356,-0.026052,-0.054148,-0.030948,0.010353,0.015271,0.012552,-0.009833,-0.014240,0.015088,0.046672,0.005700,-0.027415,-0.042325,-0.025107,0.012358,0.008941,0.009452,-0.001362,0.009461,0.024384,0.023864,-0.004600,-0.027315,-0.049034,-0.020114,0.022752,0.028407,0.018920,-0.010765,-0.005464,-0.003090,0.018495,0.012449,-0.025651,-0.030266,-0.039234},
  {-0.036905,0.033674,0.008364,0.016133,-0.005097,0.011325,0.040303,0.050071,0.002413,-0.005398,-0.041175,-0.053307,-0.032073,-0.013150,0.044011,0.024166,0.009587,0.005120,-0.035038,0.042732,0.036943,0.002012,-0.071826,-0.069219,-0.032402,0.007002,0.080952,0.045769,0.008630,-0.023205,-0.047877,-0.037582,-0.057129,-0.011683,-0.016257,0.025328,0.042780,0.031458,-0.003622,-0.023952,-0.037120,0.023426,0.027123,0.031261,0.003625,-0.011241,-0.027576,-0.050995,-0.020686,0.027958,0.054889,0.081716,0.014075,0.064948,0.016907,-0.021631,-0.007436,-0.000629,0.024413,-0.001812,-0.040742,-0.072509,-0.051899,-0.021573,0.068617,0.048294,0.033825,-0.010239,-0.017137,-0.015135,0.029125,0.011814,-0.013815,-0.045359,-0.003668,0.018551,0.062793,0.079596,0.010653,-0.015610,-0.064933,-0.021423,-0.031835,0.001322,0.012802,0.034564,0.015806,0.026087,0.000206,-0.012252,-0.021521,-0.016113,0.017898,0.014639,0.003593,-0.039982,-0.057612,-0.026005,0.003532,0.022172,0.061135,0.049550,0.018378,-0.052337},
  {-0.003447,0.031799,0.008987,-0.035694,-0.002653,0.019062,0.096271,0.056876,-0.033246,-0.069100,-0.050603,0.012537,0.092506,0.066832,0.026347,-0.062910,-0.075253,0.000165,0.069996,0.082140,0.004555,-0.057721,-0.077718,-0.042698,0.049304,0.084739,-0.003341,-0.049803,-0.061315,-0.042763,0.003500,0.039515,0.025864,0.028384,0.047248,0.029664,-0.035290,-0.062939,-0.087137,-0.028767,0.035157,0.080852,0.080213,0.020125,-0.057007,-0.079949,-0.054336,-0.012078,0.020496,0.015502,0.033631,0.028947,-0.018607,-0.020690,-0.015322,0.015261,0.031959,0.045974,-0.018370,-0.052308,-0.067984,-0.028313,0.031097,0.086556,0.042428,-0.037311,-0.066529,-0.056514,0.013797,0.074410,0.060626,-0.034087,-0.092398,-0.045669,0.027709,0.083526,0.074898,0.003882,-0.053969,-0.017888,0.000403,0.031510,0.040621,0.016626,0.034110,0.008338,-0.027341,-0.037344,-0.068249,-0.009799,0.030182,0.079744,0.090548,0.018697,-0.060834,-0.071104,-0.057731,-0.007329,0.013694,0.048077,0.037519,0.014228,0.014005,-0.053129},
  {0.035584,0.094172,0.065344,-0.032588,-0.096899,-0.082305,-0.008862,0.077566,0.098368,0.020422,-0.058358,-0.089354,-0.043177,0.044858,0.065073,0.039068,-0.039990,-0.053685,-0.012855,0.025068,0.075692,0.017958,-0.053591,-0.077926,-0.036260,0.049458,0.069064,0.002000,-0.076837,-0.077507,-0.033381,0.039673,0.093784,0.072550,-0.001037,-0.056899,-0.091357,-0.051259,0.046478,0.092803,0.080633,0.009353,-0.079359,-0.095764,-0.035085,0.050779,0.085885,0.046986,-0.019011,-0.052912,-0.038308,0.006664,0.091805,0.025321,-0.075450,-0.102019,-0.032189,0.056206,0.103556,0.055222,-0.027147,-0.100125,-0.064301,0.021215,0.074070,0.059491,-0.008254,-0.050445,-0.051459,0.014881,0.049605,0.051963,-0.009944,-0.057252,-0.055495,-0.003450,0.077210,0.078836,-0.054557,-0.104202,-0.057447,0.016992,0.079049,0.094593,0.032880,-0.064271,-0.088953,-0.057737,0.014513,0.060098,0.089791,0.019974,-0.054142,-0.101037,-0.054660,0.013346,0.088233,0.062612,0.008447,-0.047205,-0.071643,-0.019065,0.043812,0.054458},
  {0.026943,-0.043525,-0.057821,-0.036720,-0.013541,0.006292,0.008599,0.012753,0.042332,0.056299,0.024167,-0.042162,-0.100360,-0.112539,-0.043774,0.051341,0.129993,0.122708,0.038521,-0.049686,-0.128506,-0.126166,-0.058312,0.022027,0.094170,0.121301,0.008525,-0.077969,-0.133073,-0.119564,-0.029835,0.064923,0.136239,0.123784,0.035557,-0.076500,-0.143056,-0.131880,-0.046062,0.068951,0.145772,0.139430,0.045565,-0.068103,-0.158039,-0.139196,-0.038463,0.087791,0.159604,0.112851,-0.010458,-0.112786,-0.068919,-0.060207,-0.014570,0.034372,0.032325,0.024294,0.020285,0.023375,0.010510,-0.024211,-0.070502,-0.093226,-0.036070,0.047223,0.122074,0.118798,0.049337,-0.067746,-0.128711,-0.123856,-0.047937,0.044781,0.108860,0.129968,0.069547,-0.012288,-0.135097,-0.100829,-0.016158,0.078533,0.139590,0.120180,0.021135,-0.070171,-0.143820,-0.128452,-0.040166,0.076498,0.149099,0.140772,0.049622,-0.063317,-0.147293,-0.143084,-0.046445,0.079077,0.169675,0.137424,0.023105,-0.109049,-0.149769,-0.073141},
  {-0.024979,-0.060394,-0.090612,-0.084612,-0.034147,0.044845,0.111960,0.135990,0.098069,-0.029028,-0.133570,-0.167797,-0.112993,0.027723,0.111737,0.143151,0.109546,0.047360,-0.041753,-0.139100,-0.129985,-0.087779,0.002606,0.102163,0.130617,0.105725,-0.050159,-0.076472,-0.050916,0.002392,-0.015754,-0.019695,-0.018277,0.016748,0.090948,0.120610,0.059521,-0.049677,-0.138041,-0.144672,-0.052101,0.068079,0.134886,0.105627,0.036202,-0.060263,-0.079518,-0.079801,-0.033906,0.000509,0.053066,0.055794,-0.065189,-0.038690,-0.018394,0.044504,0.098121,0.117352,0.073129,-0.033537,-0.126070,-0.158356,-0.095576,0.029716,0.133216,0.154254,0.108530,0.024597,-0.089595,-0.138369,-0.133648,-0.068809,0.039302,0.119232,0.135966,0.096046,0.031839,-0.069759,-0.070182,-0.028697,0.026437,0.028936,0.001359,0.020214,0.067099,0.068694,0.060176,-0.032184,-0.125783,-0.152622,-0.054054,0.068682,0.144758,0.129548,0.044465,-0.085026,-0.115320,-0.106979,-0.041410,0.046680,0.059557,0.063802,0.066413,0.043596},
  {-0.241714,-0.115977,0.072535,0.181383,0.091358,-0.057190,-0.126714,-0.048170,0.057205,0.102693,0.038682,-0.042735,-0.070051,-0.011533,0.054286,0.053855,0.011732,-0.056775,-0.051670,0.004363,0.030127,0.032437,-0.017367,-0.031350,-0.008381,0.042032,0.015909,-0.072818,-0.091446,-0.054818,0.011055,0.070572,0.055168,0.024333,0.014772,-0.009017,-0.006742,-0.027355,-0.066022,-0.043441,0.009841,0.047775,0.050767,-0.011804,-0.022060,-0.003177,0.078645,0.076434,-0.033804,-0.181785,-0.193497,-0.038565,-0.008274,0.167019,0.178081,0.016872,-0.126286,-0.119784,0.002847,0.103103,0.086503,0.005400,-0.087583,-0.069661,0.011611,0.072306,0.045841,-0.025753,-0.067230,-0.035420,0.025874,0.037563,0.015521,-0.041464,-0.035874,0.018004,0.057422,0.040236,-0.083881,-0.063872,0.003702,0.081949,0.079413,0.026547,-0.012655,-0.027995,-0.024648,-0.025616,-0.031112,-0.017467,-0.007164,0.053452,0.055917,0.027253,-0.029230,-0.033666,0.002700,0.054965,0.000523,-0.097042,-0.150375,-0.066900,0.103887,0.257542},
  {-0.063226,-0.038054,-0.030594,0.023266,0.095979,0.080577,0.059987,0.009139,-0.077836,-0.090474,-0.091382,-0.009236,0.052737,0.126795,0.115102,0.064154,-0.030197,-0.083881,-0.115629,-0.055941,-0.004724,0.057977,0.116330,0.062387,0.035268,0.000200,-0.054557,-0.074276,-0.053450,-0.044011,0.035951,0.103628,0.113556,0.088444,0.013857,-0.076178,-0.092421,-0.057281,-0.031956,0.047439,0.067891,0.061010,0.046491,0.013474,-0.032906,-0.075181,-0.093675,-0.030597,0.019821,0.069883,0.102263,0.081359,0.003509,0.049415,0.067016,0.077265,0.015368,-0.050381,-0.095209,-0.100696,-0.067279,0.010454,0.099845,0.102733,0.113771,0.070427,-0.058497,-0.112724,-0.123997,-0.036135,0.052746,0.101896,0.098178,0.102905,0.022381,-0.031481,-0.102899,-0.054364,-0.057893,-0.000817,0.037633,0.076440,0.115275,0.024793,-0.043142,-0.076156,-0.100843,-0.069962,-0.008111,0.034059,0.087174,0.059862,0.014763,-0.036585,-0.049572,-0.041305,-0.043360,-0.016429,-0.012038,0.058875,0.082569,0.051952,-0.005476,-0.054258},
  {0.031456,-0.028811,-0.054598,-0.018186,0.019446,0.014665,-0.044292,-0.037285,-0.011325,0.045593,0.063089,0.013629,-0.034276,-0.049740,0.008411,0.069998,0.042774,-0.039316,-0.093348,-0.078382,0.022252,0.093500,0.068275,-0.010699,-0.077042,-0.068420,0.054311,0.049138,-0.013293,-0.058441,-0.026084,0.019953,0.049103,0.032846,-0.001290,-0.018187,-0.004451,0.026985,0.020156,-0.022748,-0.051301,-0.020405,0.024206,0.047619,0.034563,-0.038377,-0.061263,-0.018577,0.074806,0.086778,0.007322,-0.121731,-0.095944,-0.088057,0.001108,0.038792,0.011707,-0.028233,-0.028593,0.012831,0.066209,0.037103,-0.026002,-0.041669,-0.036456,0.023292,0.043253,0.008586,-0.066810,-0.053637,-0.012393,0.066685,0.093805,0.026125,-0.063200,-0.107951,-0.040980,0.035591,0.036826,-0.050082,-0.073305,-0.020552,0.031050,0.064390,0.029959,-0.034755,-0.032148,0.014882,0.027215,0.002252,-0.054215,-0.048046,0.003960,0.032062,0.054675,0.005134,-0.041208,-0.055805,0.011455,0.070882,0.034483,-0.034854,-0.122657,-0.087637},
  {-0.149831,-0.109021,0.003378,0.089725,0.134921,0.095782,-0.007739,-0.087893,-0.120743,-0.088090,-0.011935,0.043118,0.070376,0.042385,0.012273,0.007732,-0.028166,-0.033057,-0.027755,-0.023876,0.008021,0.013340,0.028880,0.023516,0.005132,-0.041124,-0.035127,0.058459,0.103097,0.078374,0.005370,-0.109702,-0.112319,-0.031590,0.052236,0.109177,0.048525,-0.044258,-0.050680,-0.010024,0.063799,0.084818,-0.008784,-0.093250,-0.122405,-0.022702,0.075098,0.138056,0.089071,-0.011411,-0.119323,-0.098854,-0.006504,0.101223,0.153561,0.102776,0.008160,-0.101294,-0.139721,-0.098170,0.000562,0.055877,0.099592,0.081235,0.014184,-0.029344,-0.057928,-0.046966,-0.019486,0.012409,0.008507,0.033174,0.023882,0.027376,0.009034,-0.044218,-0.066885,-0.044583,0.075995,0.070682,0.007703,-0.089267,-0.115893,-0.049669,0.037534,0.101494,0.084311,0.004632,-0.065774,-0.078883,-0.000142,0.048287,0.044529,-0.050871,-0.095008,-0.058510,0.051127,0.121971,0.130412,0.010936,-0.107498,-0.125641,-0.060671,0.039415},
  {-0.040470,0.059498,0.108425,0.102008,0.028133,-0.066494,-0.125823,-0.102690,-0.011588,0.084530,0.136176,0.104913,0.000754,-0.078305,-0.116572,-0.071217,0.009947,0.064653,0.063600,0.017927,0.008267,0.007953,0.000624,-0.017354,-0.060959,-0.058028,0.088407,0.110642,0.049352,-0.063150,-0.160272,-0.113323,0.019261,0.145668,0.174456,0.074842,-0.068472,-0.152460,-0.131256,-0.039337,0.054351,0.092819,0.086535,0.046646,0.021778,-0.035230,-0.073353,-0.105158,-0.077793,0.013507,0.125106,0.147581,0.117130,0.112098,0.027633,-0.070983,-0.117137,-0.098665,-0.014067,0.077873,0.130620,0.109590,0.013873,-0.085957,-0.131032,-0.089635,0.003602,0.087666,0.087529,0.043605,-0.012476,-0.034337,-0.017918,-0.017076,-0.030591,-0.039696,0.003171,0.058105,0.067590,-0.038086,-0.123536,-0.121776,-0.024386,0.113484,0.181726,0.098017,-0.042042,-0.163327,-0.158395,-0.057612,0.072579,0.132877,0.099858,0.034684,-0.023003,-0.066655,-0.077658,-0.078615,-0.062306,0.015203,0.093424,0.136183,0.090606,-0.024207},
  {0.004002,0.002514,0.006206,-0.009176,-0.002997,-0.022092,-0.008685,-0.006355,0.014122,0.013613,0.003539,-0.006360,0.001158,-0.015671,-0.000975,-0.001816,-0.004065,-0.002719,-0.007599,0.001732,0.008668,0.004044,-0.002054,-0.004005,0.005947,-0.009347,0.000777,-0.005387,0.000866,0.002916,0.012198,0.005129,0.014102,-0.000262,-0.007577,-0.005531,0.002001,0.002511,-0.004157,-0.012236,-0.006662,0.005413,0.004414,0.021637,0.000251,0.000538,-0.011239,-0.000569,0.003648,-0.000941,-0.016133,-0.012034,-0.014636,0.010747,0.000701,-0.019979,-0.005957,0.002459,0.006008,0.011384,0.012602,0.002474,-0.009642,0.007308,-0.001924,0.002570,-0.002910,-0.008874,-0.005583,0.000290,0.021044,0.012509,0.011997,0.001076,-0.003069,-0.008069,0.002285,-0.001138,0.001855,-0.004048,0.004098,0.010023,0.016650,-0.009675,-0.008484,-0.015452,0.007457,-0.003842,0.001325,0.002201,-0.004857,0.007699,0.009446,-0.006883,-0.004832,-0.008361,-0.012170,-0.003932,0.011601,0.007155,0.010012,0.005284,-0.015027,-0.009617},
  {-0.004366,-0.003885,-0.003474,-0.004488,0.002323,0.003961,0.004956,0.005338,-0.000843,-0.003592,-0.003676,-0.004067,-0.003182,0.001067,-0.000154,0.000254,0.005137,0.003007,0.002431,-0.000070,-0.002775,-0.001875,-0.002625,-0.001670,0.000810,0.001682,0.006019,0.002490,-0.001876,-0.007243,-0.007408,-0.000308,0.004722,0.007823,0.002691,-0.007318,-0.007374,-0.005827,0.004557,0.010573,0.008047,0.002023,-0.006259,-0.006316,-0.001638,0.003077,0.002292,-0.001566,-0.003824,-0.002344,0.004902,0.007959,-0.001962,0.001174,0.003129,0.002802,0.005083,0.005791,-0.001209,-0.003897,-0.004725,-0.005697,-0.000032,0.003401,0.002355,0.002036,0.005024,0.001550,0.001290,0.000190,-0.005117,-0.002922,-0.001372,-0.000608,0.002632,0.000910,0.004134,0.003981,-0.000406,-0.007706,-0.007291,-0.001683,0.002853,0.008485,0.006922,-0.004371,-0.005002,-0.007388,0.000795,0.009040,0.009236,0.004527,-0.005521,-0.010590,-0.005884,-0.000331,0.004129,0.002111,-0.001431,-0.002807,0.002019,0.005610,0.005697,0.000332},
  {-0.001486,0.001231,0.002255,-0.000481,0.002386,0.000918,0.000414,-0.003395,0.000546,0.002626,0.001499,0.000539,0.003451,0.002720,0.000610,-0.008882,-0.002027,0.004036,-0.007608,-0.002772,-0.007395,0.008053,0.009489,0.004078,-0.007127,-0.010943,0.002616,0.007434,0.006780,0.001579,-0.008013,-0.003456,-0.006359,-0.002615,0.012213,0.000051,0.000517,0.002048,0.000569,0.001439,-0.009068,-0.011870,-0.005863,-0.003998,0.002836,0.001373,0.010141,-0.000465,0.004695,-0.006955,-0.003279,-0.004670,-0.003868,-0.005771,-0.005842,0.003823,-0.004542,0.003894,-0.001826,-0.002339,0.000108,0.004925,-0.000088,-0.000680,0.002712,-0.007556,0.001200,-0.005497,-0.001894,-0.004447,-0.002734,-0.000276,0.005010,0.006866,-0.003245,-0.003530,-0.000226,-0.006188,0.013799,0.003518,0.001021,-0.003147,-0.009263,-0.001959,0.006995,0.008235,0.006195,-0.003892,-0.005456,0.006879,0.004136,-0.002781,-0.005133,-0.000592,0.003597,0.009340,0.007508,0.003048,-0.000499,0.003740,-0.001773,-0.006016,0.001549,0.009688},
  {0.017033,0.006760,-0.001286,-0.011146,-0.012458,-0.003088,0.007134,0.006469,0.001386,-0.003900,-0.004537,0.003565,0.009373,0.001446,0.003299,-0.011045,-0.008306,-0.005448,0.004290,0.014768,0.005743,-0.000333,-0.005339,-0.008163,0.001929,0.005793,0.004829,-0.016878,-0.019014,-0.011990,0.004895,0.016554,0.014930,0.005082,-0.015278,-0.017773,-0.010310,0.003790,0.012299,0.005284,-0.001349,-0.013396,-0.000344,0.009087,0.005812,-0.003481,-0.013724,-0.007816,-0.001418,0.004483,0.015247,-0.000146,-0.002851,-0.015310,-0.013893,-0.004685,0.002306,0.008831,0.006994,-0.001116,-0.006845,0.002198,0.001541,0.001781,0.002020,-0.005314,-0.003931,-0.005727,0.002519,0.005705,0.011206,0.002990,-0.006662,-0.011332,-0.009947,0.005988,0.007149,0.008939,-0.016326,-0.008668,-0.000675,0.014679,0.019979,0.003630,-0.015293,-0.013266,-0.010103,0.002225,0.014418,0.017505,0.003771,-0.001447,-0.005374,0.003284,0.005116,0.007749,-0.006471,-0.007047,-0.006836,0.003021,0.015682,0.005165,-0.005078,-0.012442},
  {-0.014720,-0.008640,0.003644,0.005728,0.008448,0.004402,-0.000219,-0.000461,-0.001228,0.000164,-0.000164,-0.003124,0.002549,-0.000475,0.003963,0.001836,0.001305,-0.001743,0.000456,-0.002007,-0.006524,-0.004661,-0.000272,0.003933,0.002657,-0.000105,0.001879,0.002035,-0.002390,-0.007872,-0.003252,-0.000047,-0.001524,0.002678,-0.001343,0.002209,-0.001069,0.001404,-0.001221,-0.000168,0.006601,0.001506,0.003851,-0.003052,-0.005694,-0.003380,-0.000697,-0.001541,-0.000101,0.000025,-0.000855,0.000532,0.004984,0.009123,0.014001,0.005713,-0.004401,-0.001457,-0.005086,-0.000406,0.001818,0.000473,0.000515,-0.002563,0.001977,0.002931,0.010637,-0.000206,-0.004790,-0.002276,-0.006806,0.001184,0.001335,0.002018,0.003025,0.002238,-0.001665,-0.002178,-0.001816,-0.000060,-0.004442,-0.002237,0.000409,0.004796,0.000513,0.001428,0.000166,0.003428,-0.004567,0.000514,0.001951,-0.001284,0.004464,0.002215,-0.005073,-0.002795,-0.004650,0.002657,0.000495,-0.001059,0.001449,0.003778,-0.004312,-0.003052},
  {0.017930,0.015024,0.002839,-0.007529,-0.011222,-0.005958,0.001919,0.006483,0.003601,-0.003925,-0.001991,-0.002955,0.000760,0.008063,-0.003859,-0.007914,-0.008731,-0.001489,0.006617,0.014691,0.012059,0.002568,-0.003266,-0.002482,0.005289,0.007974,-0.007977,-0.014792,-0.008453,0.004808,0.005462,0.007803,0.000546,-0.003284,0.001101,0.000482,0.005697,-0.007306,-0.012242,-0.004396,-0.002821,-0.000782,0.010545,0.001844,0.004015,-0.001159,-0.004627,-0.004611,-0.007784,-0.003500,-0.000408,0.009555,0.003042,-0.010649,-0.013972,-0.011358,0.001511,0.007979,0.009603,0.002746,-0.006589,-0.005711,0.000804,0.005545,-0.003815,-0.002735,-0.014191,-0.002879,0.007458,0.008737,0.009430,-0.001571,-0.006912,-0.010669,0.000249,0.001398,0.004340,-0.000884,-0.004721,0.001290,0.009093,0.014297,0.005501,-0.000832,-0.000913,-0.003161,0.000572,-0.006565,-0.002331,-0.010194,-0.004439,0.003624,0.010100,0.005786,0.002656,-0.000553,-0.006048,-0.005235,-0.005487,0.000223,-0.004407,0.006409,0.009959,0.001621},
  {0.003350,-0.030965,-0.008817,0.034924,0.002673,-0.018403,-0.093913,-0.055497,0.032228,0.067293,0.049336,-0.012166,-0.090224,-0.064961,-0.025590,0.061453,0.073408,-0.000269,-0.068445,-0.080265,-0.004489,0.056401,0.075911,0.041748,-0.048079,-0.082505,0.003276,0.048466,0.059593,0.041539,-0.003512,-0.038383,-0.025125,-0.027561,-0.046064,-0.028998,0.034340,0.061348,0.084990,0.028113,-0.034262,-0.078850,-0.078206,-0.019755,0.055614,0.077927,0.053086,0.011814,-0.019942,-0.015122,-0.032744,-0.028271,0.018261,0.020151,0.014945,-0.014779,-0.031195,-0.044973,0.017809,0.050922,0.066275,0.027657,-0.030201,-0.084445,-0.041287,0.036426,0.064890,0.055081,-0.013593,-0.072685,-0.059245,0.033325,0.090257,0.044662,-0.026977,-0.081448,-0.073060,-0.003782,0.052475,0.017314,-0.000450,-0.030601,-0.039512,-0.016004,-0.033226,-0.008179,0.026488,0.036382,0.066557,0.009543,-0.029382,-0.077803,-0.088346,-0.018201,0.059393,0.069341,0.056334,0.007158,-0.013436,-0.046905,-0.036720,-0.014005,-0.013627,0.051942},
  {0.083036,-0.035596,-0.121948,-0.107879,-0.040137,0.048928,0.105001,0.091284,0.017226,-0.052291,-0.085441,-0.049326,0.008830,0.075070,0.087473,0.038707,-0.027109,-0.101416,-0.101246,-0.022380,0.066056,0.140915,0.112194,0.011819,-0.107562,-0.148382,0.043377,0.102049,0.093498,0.004894,-0.079741,-0.070368,-0.017833,0.048492,0.066119,0.012700,-0.029742,-0.053656,-0.044642,0.005755,0.041202,0.034792,0.022122,-0.019993,-0.029034,-0.023918,0.018292,0.046729,0.021576,-0.017263,-0.054450,-0.054407,-0.120329,-0.133005,-0.055431,0.037921,0.109276,0.103677,0.036830,-0.046440,-0.098891,-0.060253,-0.004086,0.052244,0.079693,0.055483,-0.015986,-0.082489,-0.091168,-0.046939,0.049754,0.111917,0.104529,0.010493,-0.090026,-0.135262,-0.092506,0.027502,0.116854,0.047297,-0.055508,-0.089834,-0.049922,0.012454,0.065101,0.055492,-0.011912,-0.067632,-0.051075,0.005544,0.042141,0.057229,0.016707,-0.009218,-0.043919,-0.026330,-0.007743,0.042850,0.020537,-0.013384,-0.034027,-0.046363,-0.027269,0.026042},
  {-0.012352,-0.001089,0.007149,0.013153,0.012212,0.000809,-0.005446,-0.002007,-0.005325,0.000976,0.004793,-0.000421,-0.002641,0.004149,0.002437,0.004023,0.002946,-0.002009,-0.003768,0.002750,0.000797,-0.004471,-0.006704,-0.007457,-0.003098,0.009187,0.002171,-0.004100,-0.012889,-0.009174,0.007019,0.011999,0.004881,-0.004353,-0.009901,-0.007662,0.000302,0.010236,0.006919,0.004101,-0.001773,-0.004457,-0.004566,-0.004194,-0.008213,-0.004357,-0.000219,0.004586,0.010545,0.009625,0.002617,-0.008211,0.007152,0.011339,0.013761,0.001425,-0.008487,-0.010044,-0.009544,-0.000234,0.004784,0.000689,-0.001706,-0.000567,-0.001140,0.003400,0.006665,-0.002032,-0.006087,0.000274,-0.000453,0.001401,-0.002687,-0.002999,-0.003064,0.006628,0.005518,0.004108,-0.011559,-0.006120,-0.001456,0.007598,0.007779,0.000182,-0.010647,-0.008038,-0.003418,0.010748,0.008702,0.004298,-0.002842,-0.010261,-0.007096,-0.002107,0.000105,0.000423,0.002082,0.004482,0.007050,0.008874,0.001480,-0.007035,-0.013364,-0.011189},
  {-0.031024,0.028445,0.003716,0.044638,-0.001059,-0.005327,-0.011233,-0.004464,0.003981,-0.010590,0.001713,0.018577,-0.020730,0.040051,0.000124,-0.026941,-0.004974,0.007660,0.012449,-0.002163,0.017923,-0.022417,0.006445,-0.002958,-0.014470,-0.010871,0.027157,0.026274,-0.011192,-0.024630,-0.005593,0.006565,-0.016758,-0.029274,0.013198,0.013363,0.027381,0.021577,-0.017487,0.002759,-0.023405,0.009937,0.016378,0.001766,-0.017375,0.005751,0.036260,-0.020115,-0.004488,0.019779,0.003866,-0.022060,0.038535,-0.013122,-0.016514,0.019558,-0.006196,0.009469,-0.008736,-0.002178,-0.004435,-0.021004,0.003488,-0.011040,0.003775,-0.015611,-0.020705,0.020499,-0.010438,0.038507,-0.027081,0.006828,0.017274,-0.003293,0.004290,-0.011932,-0.012028,-0.039728,-0.023897,0.013340,0.004859,0.009020,0.011742,0.018453,0.036339,0.008425,0.004332,0.006953,-0.006677,0.032025,0.011725,-0.034154,-0.036860,0.042190,0.019580,0.003856,-0.028404,0.006848,0.014239,-0.023304,-0.012624,-0.017064,0.006064,0.023166},
  {-0.150693,-0.085093,-0.029386,0.006761,0.019519,0.033326,0.057738,0.099356,0.082703,0.017664,-0.056811,-0.090774,-0.090588,-0.051606,-0.015824,0.027000,0.058415,0.074508,0.082931,0.052151,0.007912,-0.042802,-0.077044,-0.090935,-0.079250,-0.041666,0.059638,0.084621,0.093919,0.057335,0.006482,-0.040518,-0.067315,-0.069452,-0.043646,-0.033601,0.002471,0.044440,0.072801,0.093158,0.071124,0.006774,-0.052856,-0.086921,-0.060506,-0.046425,-0.023453,-0.016578,-0.001615,0.044944,0.129139,0.154406,0.007805,0.065956,0.080707,0.060002,0.047163,0.051480,0.040564,-0.012422,-0.068405,-0.095797,-0.087345,-0.027755,0.021278,0.071728,0.070884,0.072999,0.045107,0.033809,-0.018163,-0.070884,-0.091421,-0.087445,-0.056255,-0.000861,0.051448,0.089619,0.065245,0.012308,-0.036114,-0.077490,-0.090438,-0.079062,-0.028980,0.008464,0.051983,0.064881,0.074149,0.062715,0.026906,-0.014537,-0.078641,-0.110914,-0.080457,-0.021115,0.030152,0.042551,0.026028,0.039318,0.065865,0.098313,0.048653,-0.043639},
  {0.019683,0.168944,0.185689,0.060058,-0.076922,-0.141492,-0.072578,0.026683,0.078433,0.069430,-0.007497,-0.077547,-0.062878,-0.019860,0.080043,0.109119,0.059439,-0.035750,-0.113199,-0.106597,-0.054684,0.051743,0.123011,0.104650,0.036865,-0.071388,-0.103233,-0.008814,0.072243,0.087569,0.075754,0.004422,-0.046749,-0.051412,-0.034981,-0.018689,-0.018779,-0.001068,0.025515,0.063648,0.065411,0.027832,-0.040461,-0.079150,-0.086436,-0.025697,0.020717,0.055285,0.059055,0.041215,0.020158,0.001703,0.186794,0.094492,-0.050245,-0.147803,-0.133792,-0.019905,0.074620,0.102450,0.035673,-0.058364,-0.091581,-0.033187,0.046451,0.094785,0.069434,-0.028255,-0.097953,-0.107290,-0.044355,0.045696,0.107155,0.116838,0.045935,-0.060905,-0.138128,-0.120475,0.077283,0.128062,0.080191,0.000137,-0.059322,-0.080121,-0.052086,-0.005385,0.008501,0.030401,0.029839,0.053738,0.038169,0.013258,-0.026640,-0.080902,-0.083522,-0.015534,0.043817,0.080205,0.073469,0.028649,-0.005072,-0.029835,-0.051156,-0.087148},
  {0.001159,-0.003358,-0.005748,-0.003990,-0.002569,0.001932,0.003582,0.003801,0.002457,0.000991,-0.000485,-0.001403,-0.002488,-0.000840,-0.000163,0.000618,-0.000376,0.000801,0.001377,0.001605,0.002480,0.001184,0.000637,-0.000996,-0.003210,-0.001048,-0.000948,0.000928,0.000821,0.001611,0.000727,0.001351,-0.000962,-0.000443,-0.000350,-0.000420,-0.002090,-0.002583,-0.001344,0.000597,0.002235,0.003180,0.003643,0.001064,-0.000496,-0.002695,-0.002849,-0.003851,-0.002629,-0.000087,0.003295,0.004459,-0.005098,-0.006763,-0.002349,0.003541,0.004333,0.003655,0.002828,0.000638,-0.002507,-0.003249,-0.002212,-0.003919,-0.000073,0.000814,0.001500,0.002530,0.001161,0.000442,-0.000057,-0.000114,-0.001717,-0.001584,-0.002783,-0.001547,-0.001412,0.000268,0.001733,0.002573,0.001431,-0.000196,-0.002059,-0.000027,-0.000983,-0.000235,-0.002483,-0.000319,-0.000710,-0.000161,0.002799,0.002186,0.002432,0.003394,-0.000301,-0.002794,-0.003009,-0.003467,-0.001903,0.000884,0.002013,0.002652,0.005443,0.003638},
  {0.073287,0.051173,-0.019206,-0.068350,-0.077823,-0.003441,0.026109,0.039999,-0.004598,-0.043936,-0.033251,0.020614,0.066922,0.039405,-0.022400,-0.069364,-0.058996,-0.021060,0.019588,0.032320,-0.000312,-0.020294,-0.011226,0.023057,0.031775,0.004735,-0.064202,-0.041237,0.007294,0.033526,0.040689,0.000895,-0.005277,0.009882,0.023507,0.000429,-0.029856,-0.052620,-0.036003,0.010239,0.049224,0.050019,0.000988,-0.026800,-0.012348,0.005671,0.015186,-0.015606,-0.026051,-0.037123,-0.002536,0.031413,0.011447,-0.074689,-0.086423,-0.031010,0.031715,0.065949,0.040003,-0.026257,-0.040691,-0.006734,0.039589,0.052935,0.005839,-0.057851,-0.078477,-0.031113,0.031614,0.065023,0.037454,-0.012087,-0.018282,-0.015352,0.011278,0.016691,-0.018054,-0.055773,-0.006726,0.032807,0.051044,0.030388,-0.014339,-0.010985,-0.011759,0.001214,-0.011093,-0.029140,-0.028538,0.004994,0.032180,0.058639,0.024683,-0.025974,-0.033127,-0.022495,0.012171,0.005394,0.003023,-0.022363,-0.014684,0.031182,0.036640,0.047481},
  {0.149573,0.108530,-0.003231,-0.089488,-0.134702,-0.095742,0.007388,0.087491,0.120652,0.087982,0.011956,-0.043028,-0.070245,-0.042137,-0.012224,-0.007592,0.028061,0.032733,0.027798,0.023619,-0.008139,-0.013297,-0.028507,-0.023369,-0.005146,0.041133,0.034895,-0.058476,-0.103120,-0.078437,-0.005310,0.109502,0.112381,0.031670,-0.051820,-0.108834,-0.048429,0.044000,0.050329,0.009803,-0.063693,-0.084784,0.008907,0.093171,0.122191,0.022557,-0.075041,-0.137582,-0.088610,0.011409,0.118821,0.098073,0.006575,-0.101259,-0.153285,-0.102418,-0.008234,0.101091,0.139417,0.098073,-0.000389,-0.055524,-0.099257,-0.080991,-0.014323,0.029326,0.057715,0.046813,0.019345,-0.012450,-0.008649,-0.033082,-0.023825,-0.027265,-0.009217,0.044100,0.066595,0.044337,-0.076170,-0.070824,-0.007576,0.089065,0.115966,0.049753,-0.037384,-0.101224,-0.084088,-0.004763,0.065423,0.078479,-0.000044,-0.048112,-0.044242,0.051180,0.095017,0.058603,-0.050932,-0.121807,-0.130089,-0.010868,0.107047,0.125044,0.060210,-0.039129},
  {0.168039,0.115193,-0.002813,-0.056896,-0.062130,-0.098908,-0.025984,0.036835,0.091869,0.103270,0.053598,0.039740,-0.027020,-0.068393,-0.050384,-0.040076,0.005328,0.084083,0.073908,0.076120,0.022264,-0.058990,-0.032796,-0.102596,-0.082421,-0.026031,0.081700,0.073735,0.038157,-0.024527,-0.083306,-0.070753,-0.050558,0.039780,0.093379,0.103365,0.087409,0.041728,-0.038505,-0.025627,-0.063883,-0.073554,-0.062852,-0.004553,0.027698,0.074418,0.091930,0.073312,0.007800,-0.092107,-0.118299,-0.124532,0.012887,-0.084632,-0.154699,-0.072682,-0.078648,-0.014363,0.077956,0.077760,0.048528,0.023201,-0.017912,-0.103344,-0.054839,-0.002756,0.010410,0.068602,0.047492,0.103099,0.067734,-0.010292,-0.062927,-0.021669,-0.051446,0.009672,0.010616,0.110936,-0.010079,-0.047461,-0.094171,-0.116339,-0.032570,-0.015098,0.066996,0.104937,0.087288,0.034967,-0.053833,-0.114528,-0.064930,-0.045276,-0.034636,-0.006880,0.032011,0.090658,0.126374,0.048650,-0.056662,-0.090890,-0.102105,-0.115296,0.003237,0.131403},
  {-0.026494,-0.083821,-0.064935,-0.059077,0.018309,-0.005797,0.030488,-0.009418,0.027524,0.040900,0.019802,-0.027777,-0.027894,-0.096774,-0.020614,0.017642,0.051059,0.047054,-0.024127,-0.039640,-0.039722,-0.005808,0.030070,0.015064,0.016867,-0.043486,0.009703,0.018913,0.007341,-0.032792,-0.007854,0.000009,0.069106,0.053195,0.010295,-0.042740,-0.065008,-0.030810,0.005322,0.024265,0.010020,-0.016256,-0.048860,0.035117,0.039681,0.084007,0.015181,-0.049923,-0.096304,-0.113153,-0.061787,0.047899,-0.143331,-0.030028,0.025072,0.040765,0.047401,0.028282,-0.013307,0.002479,0.019675,-0.000979,-0.046824,-0.016799,-0.024922,0.017301,0.055323,0.031177,-0.002253,-0.046303,-0.006323,-0.004709,0.048565,0.059348,0.021616,-0.021048,-0.028073,-0.027639,0.028206,-0.005282,-0.017888,-0.002783,0.054123,0.025464,0.015743,-0.045061,-0.042775,-0.056534,-0.003699,0.064406,0.046496,0.030188,-0.011015,-0.057364,-0.004440,0.042156,0.032246,-0.024495,-0.051530,-0.070810,-0.004069,0.069859,0.096894,0.082246},
  {0.001996,0.002913,0.000612,-0.000036,-0.002059,0.002326,0.003466,0.003037,-0.003105,-0.004573,-0.002938,0.000427,0.003318,0.006639,0.000753,-0.002799,-0.002850,-0.002741,0.001927,0.002828,-0.001192,-0.000620,-0.000526,0.000070,0.000149,0.002713,-0.000485,0.000380,-0.000168,-0.000307,-0.003006,-0.001858,-0.003072,0.000214,0.003335,0.001712,-0.000955,-0.002632,-0.001023,0.002406,0.002858,0.000740,-0.000966,-0.004793,-0.001237,0.000195,0.002704,0.000054,-0.001429,-0.000647,0.002702,0.003713,0.004890,-0.002909,-0.003175,0.000896,0.001418,0.002106,-0.000016,-0.002395,-0.004554,-0.002285,0.003615,0.001938,0.001890,-0.001941,-0.002988,-0.002644,0.001387,0.002710,-0.001735,-0.000635,-0.002795,-0.001748,0.001009,0.002790,0.000628,-0.000496,-0.000893,0.000951,-0.000293,-0.001579,-0.003274,0.001566,0.002940,0.003594,-0.001007,-0.000941,-0.002503,-0.000316,0.002558,0.001214,-0.000582,0.000487,-0.000688,0.000535,0.002496,0.001529,-0.001488,-0.001597,-0.001716,-0.000274,0.003977,0.001540},
  {-0.035808,-0.047510,0.009002,-0.015336,-0.035976,-0.030206,0.008279,0.045134,0.066313,0.022833,-0.054199,-0.104711,-0.063054,-0.023399,0.047211,0.063979,0.022174,-0.025301,-0.004706,0.040230,0.017794,-0.029515,-0.072651,-0.128270,-0.059096,0.051105,0.110936,0.058973,-0.052698,-0.133976,-0.081585,-0.078649,0.001956,0.053065,0.089290,0.094075,0.055228,-0.022826,-0.090383,-0.119449,-0.079109,0.002090,0.081831,0.133532,0.064261,0.001476,-0.103479,-0.100974,-0.050544,0.005827,0.035989,0.065874,-0.011798,-0.020697,0.008153,0.027123,0.009634,0.034986,0.032289,0.021701,-0.028424,-0.080194,-0.071918,-0.012538,0.046593,0.084314,0.047825,-0.022664,-0.025332,-0.012031,0.010662,0.004998,-0.056449,-0.078009,-0.061792,0.041172,0.083101,0.098954,-0.079302,-0.128300,-0.107441,-0.063648,0.045266,0.086387,0.064688,0.079645,0.025982,-0.023688,-0.081842,-0.101312,-0.084195,0.004784,0.102568,0.137129,0.091480,0.021116,-0.072926,-0.113831,-0.038833,0.012488,0.072159,0.076181,0.042951,0.013758},
  {0.044956,0.093869,0.068275,0.044760,0.035466,0.050678,0.023038,-0.024903,-0.093001,-0.116275,-0.072424,0.010679,0.070657,0.069803,0.047140,0.031000,0.036508,0.013549,-0.019489,-0.064278,-0.096751,-0.074940,-0.036362,0.015647,0.042805,0.057664,0.087205,0.039346,-0.033425,-0.117958,-0.139067,-0.088439,0.011226,0.078259,0.088387,0.036351,0.020670,0.034639,0.045293,0.023108,-0.048337,-0.126633,-0.134882,-0.061653,0.058668,0.110305,0.100626,0.044509,0.015070,0.012341,0.014305,-0.043365,0.138710,0.047924,-0.003745,-0.021656,-0.010965,-0.026324,-0.069851,-0.100185,-0.061314,0.030543,0.090567,0.114345,0.060263,0.010657,-0.024092,-0.027230,-0.035742,-0.052417,-0.070189,-0.065787,-0.005305,0.034052,0.071927,0.077616,0.066104,0.038788,-0.054516,-0.116369,-0.129495,-0.071881,0.021153,0.104379,0.125699,0.073631,0.012082,-0.029371,-0.013986,0.001609,-0.047796,-0.082100,-0.109209,-0.058420,0.053520,0.138452,0.132408,0.058471,-0.027049,-0.066239,-0.048066,-0.026132,-0.080042,-0.101892},
  {0.010567,0.001772,-0.007699,0.001407,0.013648,0.003325,0.002629,-0.008213,-0.004832,-0.001803,0.015680,0.016298,0.014306,0.004043,-0.002705,-0.010653,-0.005577,0.004102,0.005412,-0.002488,0.006260,-0.003569,0.002004,-0.001440,-0.008305,-0.004168,-0.003387,-0.008964,-0.003354,0.003131,0.002854,0.011669,0.014190,-0.002670,0.007928,0.006647,-0.003262,0.001620,-0.013644,-0.008544,-0.001925,0.001065,0.013272,0.010209,-0.002942,-0.014426,-0.012906,0.005855,0.007678,0.003858,-0.012222,-0.018307,-0.008426,-0.004483,-0.002701,0.001077,0.004634,-0.005644,-0.009160,-0.008904,0.008443,0.011831,0.011401,0.004924,-0.011876,-0.013798,-0.009308,-0.001722,-0.003024,0.015322,0.007321,0.000734,0.001303,0.002901,-0.010551,-0.003151,0.000095,-0.000109,0.001302,0.002211,0.003367,0.002431,0.009738,-0.005972,0.008343,-0.002118,-0.002331,0.004531,-0.009694,-0.009812,-0.000831,0.000905,0.011715,0.009036,-0.001059,-0.011183,-0.008624,-0.002180,0.000662,0.008243,-0.002219,-0.011433,-0.002750,0.001268},
  {0.025182,0.060767,0.091053,0.084840,0.034185,-0.045123,-0.112412,-0.136563,-0.098498,0.029129,0.134120,0.168531,0.113569,-0.027874,-0.112299,-0.143880,-0.110098,-0.047522,0.042016,0.139792,0.130545,0.088084,-0.002706,-0.102625,-0.131074,-0.106136,0.050360,0.076787,0.051172,-0.002382,0.015882,0.019734,0.018353,-0.016847,-0.091351,-0.121113,-0.059766,0.049900,0.138610,0.145265,0.052329,-0.068358,-0.135500,-0.106058,-0.036377,0.060595,0.079884,0.080178,0.034050,-0.000550,-0.053379,-0.056040,0.065486,0.038887,0.018387,-0.044834,-0.098513,-0.117751,-0.073410,0.033674,0.126608,0.159041,0.096027,-0.029741,-0.133797,-0.154996,-0.109093,-0.024728,0.090084,0.139049,0.134311,0.069063,-0.039545,-0.119776,-0.136484,-0.096384,-0.031930,0.070018,0.070475,0.028831,-0.026511,-0.029032,-0.001335,-0.020366,-0.067428,-0.068990,-0.060379,0.032297,0.126295,0.153285,0.054294,-0.068955,-0.145352,-0.130156,-0.044692,0.085402,0.115826,0.107470,0.041642,-0.046905,-0.059838,-0.064061,-0.066768,-0.043867},
  {-0.020215,-0.170849,-0.188082,-0.060621,0.078093,0.143563,0.073790,-0.026870,-0.079663,-0.070423,0.007513,0.078533,0.063716,0.020020,-0.080946,-0.110564,-0.060139,0.036426,0.114472,0.108099,0.055496,-0.052342,-0.124802,-0.106045,-0.037389,0.072163,0.104721,0.009082,-0.072903,-0.088386,-0.076753,-0.004465,0.046906,0.051755,0.035048,0.018722,0.019080,0.001420,-0.025493,-0.064086,-0.066175,-0.028093,0.040758,0.079799,0.087306,0.025961,-0.020756,-0.055968,-0.059750,-0.041613,-0.020166,-0.001382,-0.189077,-0.095184,0.051077,0.149628,0.135448,0.020012,-0.075598,-0.103894,-0.036307,0.058924,0.092673,0.033466,-0.046761,-0.095960,-0.070220,0.028725,0.099205,0.108577,0.045020,-0.046316,-0.108461,-0.118350,-0.046336,0.061697,0.140019,0.122203,-0.077899,-0.129335,-0.081293,-0.000107,0.059648,0.080830,0.052625,0.005398,-0.008601,-0.030458,-0.029916,-0.054052,-0.038471,-0.013595,0.026648,0.081466,0.084256,0.015447,-0.044388,-0.080965,-0.074252,-0.028914,0.005262,0.030262,0.051831,0.087907},
  {-0.166567,-0.131318,-0.016547,0.080699,0.112082,0.127827,0.052842,-0.028011,-0.093478,-0.129277,-0.081600,-0.025065,0.051936,0.073358,0.083956,0.060889,0.005095,-0.079572,-0.094959,-0.091229,-0.030920,0.032617,0.054742,0.104506,0.074913,0.003759,-0.103280,-0.098981,-0.057396,0.030948,0.090154,0.107822,0.090184,0.012544,-0.083367,-0.122775,-0.119460,-0.073496,0.034461,0.073905,0.104498,0.094007,0.046655,-0.007664,-0.050930,-0.084155,-0.102632,-0.085881,-0.014424,0.109222,0.156082,0.144233,-0.000927,0.094236,0.163494,0.112515,0.067670,-0.026248,-0.096457,-0.120837,-0.080464,-0.012682,0.049476,0.111569,0.073761,0.022880,-0.019484,-0.078077,-0.083518,-0.084674,-0.047790,0.034277,0.082535,0.057496,0.053463,-0.017650,-0.051393,-0.106116,-0.017190,0.042624,0.097808,0.115390,0.061634,0.019663,-0.067645,-0.131492,-0.121366,-0.050206,0.053724,0.122893,0.105028,0.074252,0.018116,-0.030387,-0.082084,-0.100808,-0.093844,-0.037879,0.053082,0.090959,0.144044,0.131806,0.013441,-0.127430},
  {-0.006421,-0.007218,0.003626,0.008792,0.004706,-0.001190,-0.006266,-0.005106,-0.002227,0.003805,0.001975,0.000169,0.000287,-0.001005,-0.001045,0.003051,0.004009,-0.000099,-0.001664,-0.003527,-0.006525,-0.002613,0.001358,0.004265,0.001268,0.001288,-0.005102,-0.004043,-0.001974,0.001888,0.003475,0.001897,0.000067,-0.001554,-0.001171,0.000195,0.002693,0.003235,0.000617,-0.001180,-0.002105,-0.001996,-0.002445,-0.000963,0.001334,0.003691,0.005715,0.000295,-0.003673,-0.003499,-0.004840,0.000402,0.001894,0.003600,0.007589,0.001610,-0.005643,-0.005976,-0.003040,0.002647,0.004413,0.003085,0.000282,-0.003128,-0.000034,0.001535,0.004515,-0.000459,-0.001195,-0.005021,-0.005464,-0.001658,0.001044,0.000733,0.001828,0.002882,-0.003736,-0.004755,-0.004142,0.004152,0.004003,0.002875,-0.000159,-0.002411,-0.002283,-0.000407,0.002077,0.000126,0.000546,0.002128,-0.003704,-0.001570,-0.001885,0.000739,0.000350,0.002455,0.004112,0.002889,0.000417,-0.005313,-0.004818,0.001751,0.000220,0.003516},
  {-0.042847,-0.105864,-0.113293,-0.040595,0.028941,0.106361,0.088973,0.037126,-0.028978,-0.025429,-0.008440,-0.013823,-0.045769,-0.036158,-0.012031,0.038900,0.086439,0.075505,0.010330,-0.058694,-0.092933,-0.037985,0.030231,0.042745,0.009144,0.009962,0.008487,0.035017,-0.005755,-0.050894,-0.067297,-0.022406,0.014309,0.064993,0.049045,-0.016462,-0.075611,-0.047162,0.016914,0.071203,0.034138,-0.040268,-0.065066,-0.046132,0.050123,0.095874,0.069189,-0.056327,-0.129624,-0.128802,-0.000826,0.109249,-0.106845,-0.085223,0.020985,0.135942,0.094041,0.035459,-0.033180,-0.058892,-0.052395,-0.028743,-0.013574,-0.050216,-0.005807,0.021005,0.082965,0.082685,0.022563,-0.061522,-0.113717,-0.072807,-0.005182,0.066015,0.056717,0.027530,-0.029066,-0.024553,0.009943,0.003787,-0.039969,-0.042249,-0.007740,0.073785,0.060804,0.024228,-0.079181,-0.049794,-0.019094,0.050954,0.068443,-0.000150,-0.047648,-0.024141,0.021782,0.083432,0.081867,-0.016289,-0.116314,-0.120706,-0.053732,0.059254,0.176113,0.140174},
  {-0.026816,0.043278,0.057472,0.036564,0.013549,-0.006234,-0.008593,-0.012815,-0.042269,-0.056058,-0.023994,0.042099,0.100003,0.112135,0.043554,-0.051214,-0.129573,-0.122277,-0.038424,0.049497,0.128070,0.125794,0.058164,-0.021890,-0.093808,-0.120882,-0.008488,0.077666,0.132592,0.119113,0.029689,-0.064663,-0.135695,-0.123291,-0.035453,0.076191,0.142508,0.131372,0.045866,-0.068732,-0.145255,-0.138871,-0.045336,0.067862,0.157475,0.138668,0.038350,-0.087425,-0.158996,-0.112456,0.010313,0.112271,0.068502,0.059944,0.014547,-0.034208,-0.032161,-0.024260,-0.020265,-0.023277,-0.010391,0.024234,0.070312,0.092852,0.035881,-0.047116,-0.121669,-0.118357,-0.049135,0.067477,0.128280,0.123463,0.047856,-0.044571,-0.108446,-0.129523,-0.069319,0.012225,0.134620,0.100480,0.016115,-0.078179,-0.139036,-0.119722,-0.021058,0.069885,0.143265,0.127903,0.040008,-0.076231,-0.148516,-0.140204,-0.049400,0.063131,0.146764,0.142480,0.046194,-0.078787,-0.169047,-0.136903,-0.023073,0.108565,0.149150,0.072892},
  {0.038738,-0.057314,-0.104353,-0.098022,-0.026874,0.064093,0.121144,0.098813,0.011011,-0.081416,-0.131151,-0.101080,-0.000886,0.075346,0.112351,0.068711,-0.009466,-0.062261,-0.061435,-0.017283,-0.007895,-0.007573,-0.000702,0.016643,0.058726,0.055869,-0.085035,-0.106566,-0.047519,0.060844,0.154403,0.109224,-0.018570,-0.140413,-0.168358,-0.072204,0.066032,0.147051,0.126690,0.037989,-0.052399,-0.089404,-0.083440,-0.045036,-0.021088,0.033909,0.070708,0.101403,0.075065,-0.012889,-0.120515,-0.142187,-0.112853,-0.107641,-0.026335,0.068332,0.112728,0.094782,0.013403,-0.075034,-0.125752,-0.105556,-0.013469,0.082777,0.126285,0.086441,-0.003291,-0.084459,-0.084407,-0.042087,0.012056,0.033156,0.017355,0.016425,0.029500,0.038193,-0.002964,-0.055850,-0.065063,0.036675,0.118914,0.117376,0.023518,-0.109405,-0.175158,-0.094518,0.040542,0.157464,0.152875,0.055632,-0.069971,-0.128125,-0.096345,-0.033608,0.022065,0.064131,0.074778,0.075879,0.060208,-0.014562,-0.089962,-0.131231,-0.087457,0.023086},
  {0.006158,-0.001851,0.002959,0.006449,0.000733,-0.004850,0.002224,-0.005473,-0.002108,0.001104,0.003475,0.003843,0.007036,0.006633,-0.003308,-0.012734,-0.003038,-0.000853,0.002835,0.005064,-0.006529,-0.002450,0.006443,0.004284,-0.000572,0.002896,-0.009924,0.009361,-0.000436,0.006386,0.004583,-0.008669,-0.008840,-0.005568,0.000462,0.001453,0.010138,0.001971,-0.001515,-0.001362,0.003211,-0.000741,-0.002541,-0.005770,-0.000190,0.000883,0.004252,0.007038,0.006520,-0.005473,-0.002522,-0.010066,0.004009,0.000575,-0.004597,-0.001041,-0.002331,-0.003332,-0.001211,0.004019,0.001868,0.001874,0.005018,0.004004,-0.002377,-0.011455,-0.002607,-0.000771,0.003048,0.006884,-0.005471,-0.002900,0.003974,-0.001483,0.002090,0.003891,-0.003449,-0.008274,-0.002508,0.005327,0.011032,-0.008891,-0.005953,-0.004439,-0.001254,0.003069,0.011902,0.002779,-0.002608,0.001079,-0.002085,-0.000246,-0.000044,0.000790,0.000206,0.000299,0.002899,0.004377,-0.000000,-0.003537,-0.002287,-0.009653,-0.003995,0.008153},
  {0.074502,0.020135,-0.058506,-0.102830,-0.090157,-0.032284,0.021019,0.090740,0.059949,0.040809,0.018417,-0.009572,-0.059870,-0.093526,-0.069944,0.040556,0.093208,0.091248,0.070977,-0.002047,-0.069471,-0.097443,-0.070830,0.013080,0.079667,0.063419,-0.009173,-0.028818,-0.022728,-0.033322,-0.019475,-0.012974,0.021414,0.069063,0.056053,0.039500,0.001897,-0.056382,-0.051438,-0.041275,-0.005922,0.024217,0.038984,0.041222,0.063987,0.069317,0.009131,-0.025947,-0.117827,-0.084138,-0.061351,0.056353,-0.065460,-0.104378,-0.054663,-0.042164,0.065994,0.084645,0.080260,0.033207,-0.011052,-0.050161,-0.058131,-0.050969,-0.055334,0.027793,0.054596,0.082937,0.074148,0.024195,-0.087069,-0.100004,-0.095746,-0.019792,0.086678,0.066491,0.021116,-0.004336,-0.053133,-0.029772,-0.025374,-0.004877,0.031104,0.044181,0.048079,0.027117,-0.023541,-0.067486,-0.054091,-0.052957,-0.024613,0.011775,0.041254,0.033855,0.025765,0.043233,-0.008684,-0.019072,-0.080249,-0.122868,-0.045223,0.068045,0.084582,0.063865},
  {-0.008936,-0.017740,-0.013014,-0.001050,0.011318,0.009609,0.001130,-0.004561,-0.006352,-0.001427,0.006931,0.008600,0.003961,0.000210,-0.005991,0.004334,0.016483,0.000741,0.004777,-0.010653,-0.009746,0.003490,0.017161,0.007517,0.000721,-0.008171,0.000666,0.005140,0.007958,0.001238,-0.007427,-0.002813,0.000713,0.001930,0.002561,-0.000351,0.000805,0.002925,0.003955,-0.003017,-0.003636,-0.008757,-0.001305,0.002279,0.006658,0.003456,0.000305,0.000672,-0.006132,-0.004372,-0.000516,0.004267,-0.017194,0.000288,0.009317,0.015269,0.009856,0.001465,-0.010185,-0.005533,0.003881,0.010763,0.007237,0.002540,-0.009653,-0.000196,0.010750,0.005656,0.000677,-0.005117,-0.014935,-0.005219,0.008869,0.008909,0.003709,-0.006253,-0.014470,-0.001501,0.009378,0.005022,-0.005211,-0.009642,-0.002569,-0.001948,0.009805,0.001851,0.003926,-0.001285,0.002446,-0.001495,-0.001995,-0.004440,-0.006241,0.001774,0.004530,0.008506,0.003133,-0.001058,-0.009993,-0.005707,-0.003037,0.006314,0.007882,-0.000956},
  {0.001600,0.013866,0.008057,0.003669,-0.008066,-0.011619,-0.014203,-0.009852,0.001993,0.009745,0.011010,0.008192,0.000584,-0.005294,-0.007199,-0.002004,-0.001253,-0.003348,-0.006213,0.003154,-0.001973,-0.000354,0.001445,-0.001765,0.000933,0.001174,-0.003551,-0.004738,-0.001212,0.001379,0.005596,0.013575,0.003011,0.001903,-0.005008,-0.006213,-0.007806,-0.006149,-0.001088,0.001326,0.010496,0.014729,0.006936,-0.002201,-0.014220,-0.012261,-0.001937,0.005629,0.010820,0.010632,-0.003649,-0.003542,0.007620,0.004263,-0.002098,-0.014199,-0.012030,-0.009016,0.007097,0.011329,0.010181,0.005759,-0.002888,-0.011649,-0.005985,-0.006794,-0.000923,0.000191,0.000628,0.002521,-0.002914,0.003347,0.005023,-0.003223,0.003074,0.001399,-0.003487,-0.000336,0.000013,0.003732,0.004770,0.012323,0.001016,-0.000272,-0.004311,-0.010492,-0.010408,0.000206,-0.002367,0.003415,0.008613,0.007261,0.006428,-0.000111,-0.010533,-0.015389,-0.006966,0.003669,0.014421,0.012102,-0.001492,-0.005253,-0.011029,-0.007776},
  {-0.074355,-0.019827,0.058282,0.102569,0.089870,0.032230,-0.020823,-0.090335,-0.059859,-0.040666,-0.018292,0.009672,0.059677,0.093023,0.069631,-0.040548,-0.092886,-0.090735,-0.070729,0.002249,0.069328,0.097036,0.070316,-0.013138,-0.079361,-0.063250,0.009243,0.028809,0.022817,0.033359,0.019343,0.012858,-0.021613,-0.068875,-0.055982,-0.039310,-0.001817,0.056244,0.051308,0.041242,0.005932,-0.023942,-0.038875,-0.041214,-0.063831,-0.068986,-0.008939,0.025749,0.117186,0.083702,0.061161,-0.055808,0.065222,0.104316,0.054528,0.041857,-0.065826,-0.084470,-0.079935,-0.033106,0.010989,0.049924,0.057836,0.050632,0.055192,-0.027797,-0.054369,-0.082536,-0.073750,-0.023975,0.086888,0.099585,0.095294,0.019623,-0.086205,-0.066200,-0.020954,0.004464,0.053148,0.029882,0.025187,0.004836,-0.031248,-0.044154,-0.047894,-0.026938,0.023462,0.067325,0.053958,0.052824,0.024606,-0.011731,-0.041138,-0.033918,-0.025869,-0.043262,0.008621,0.019087,0.079935,0.122285,0.045089,-0.067641,-0.084031,-0.063666},
  {0.049280,0.030904,-0.012013,0.007698,0.035923,0.023768,-0.024568,-0.063324,-0.063496,-0.019238,0.068285,0.120948,0.072723,0.027547,-0.062861,-0.070449,-0.024983,0.021670,0.018994,-0.055611,-0.031943,0.027178,0.098402,0.149668,0.068965,-0.051305,-0.138222,-0.074494,0.046247,0.136132,0.096825,0.089767,0.021800,-0.045269,-0.077580,-0.099349,-0.069910,0.008479,0.086895,0.122783,0.090140,-0.011705,-0.088529,-0.139074,-0.062186,0.003232,0.109102,0.116433,0.056317,-0.017000,-0.056631,-0.096083,0.005302,-0.007617,-0.014876,-0.016636,-0.005992,-0.032687,-0.040472,-0.019642,0.043746,0.105735,0.089333,0.020669,-0.072517,-0.099646,-0.059167,0.025638,0.031053,0.017711,-0.022066,-0.009506,0.059014,0.092309,0.059599,-0.046746,-0.104545,-0.126311,0.070554,0.127617,0.128303,0.068837,-0.029622,-0.082082,-0.066380,-0.089501,-0.031111,0.011568,0.077228,0.100776,0.088453,0.002150,-0.104300,-0.135553,-0.087851,-0.003343,0.092754,0.118229,0.035208,-0.020930,-0.093432,-0.092468,-0.048174,0.008719},
  {-0.036271,-0.096968,-0.067597,0.033128,0.099446,0.084666,0.009166,-0.079814,-0.101279,-0.020955,0.060263,0.092316,0.044802,-0.046122,-0.067268,-0.040575,0.040832,0.055097,0.013398,-0.025669,-0.077808,-0.018181,0.055534,0.080367,0.037276,-0.051165,-0.071298,-0.002089,0.079247,0.079923,0.034457,-0.040773,-0.096486,-0.074636,0.001234,0.058542,0.093996,0.052670,-0.048049,-0.095558,-0.083055,-0.009657,0.081815,0.098633,0.036399,-0.052060,-0.088279,-0.048484,0.019210,0.053945,0.039070,-0.006886,-0.094905,-0.026534,0.077295,0.104977,0.033357,-0.057548,-0.106438,-0.056780,0.028038,0.103327,0.066481,-0.021889,-0.076514,-0.061580,0.008089,0.051966,0.053204,-0.015081,-0.050892,-0.053358,0.010273,0.058921,0.057015,0.003310,-0.079841,-0.081318,0.056338,0.107512,0.059346,-0.017427,-0.081372,-0.097468,-0.033847,0.066160,0.091559,0.059282,-0.015103,-0.061904,-0.092435,-0.020458,0.055853,0.104307,0.056438,-0.013593,-0.090800,-0.064643,-0.009120,0.048169,0.073442,0.019690,-0.044816,-0.055548},
  {0.090863,0.075747,0.042182,-0.056976,-0.140154,-0.116776,-0.079765,-0.006128,0.085019,0.122413,0.111926,0.002455,-0.072750,-0.119064,-0.134680,-0.080377,0.013589,0.081002,0.128468,0.077892,0.018403,-0.032436,-0.119039,-0.076280,-0.040869,0.015611,0.084850,0.101451,0.070232,0.020367,-0.056111,-0.134945,-0.139752,-0.109917,0.003771,0.104821,0.125865,0.086904,0.018229,-0.092030,-0.109822,-0.086561,-0.035247,0.001123,0.055990,0.086539,0.106110,0.055369,-0.006197,-0.094764,-0.147310,-0.114683,-0.011488,-0.069611,-0.100688,-0.118451,-0.021275,0.075809,0.111683,0.140851,0.096398,-0.012582,-0.112740,-0.113505,-0.119918,-0.074523,0.056381,0.113049,0.143112,0.035821,-0.042278,-0.104180,-0.110875,-0.120180,-0.032700,0.034403,0.122214,0.065529,0.069025,-0.006924,-0.056989,-0.087606,-0.125516,-0.027527,0.050856,0.112476,0.134279,0.077835,-0.007804,-0.064676,-0.124173,-0.086921,-0.003481,0.063968,0.097190,0.065628,0.033002,0.014268,-0.002224,-0.068685,-0.132319,-0.086689,-0.012012,0.071881}
};


float ReLU(float x);
# 315 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h"
void DNN_wlo(hls::stream<axis_data>&LS_stream, hls::stream<axis_data>&DNN_out);
void separate_complex_wlo(hls::stream<axis_data>&LS_stream, half y_sep[2*52]);
void normalize_wlo(float LS_data[2*52], half norm_data[2*52], const half mean[2*52], const half std[2*52]);
void L2_wlo(const half bias[52], const half w[52*2][52], half x[52*2], half y_L2[52]);
void L3_wlo(const half bias[2*52], const half w[52][2*52], half x[52], half y_L3[2*52]);
void denormalize_wlo(half DNN_data[2*52], half denorm_data[2*52], const half mean_o[2*52], const half std_o[2*52]);
void reconstruct_complex_wlo(half y_L3[52*2], hls::stream<axis_data>&DNN_out);
# 2 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.h" 2




const float preamble[200][2*52] = {
  {0.047241,0.207046,-0.173066,-0.142572,0.139176,-0.008964,0.244692,-0.182351,0.234299,0.037051,0.231752,0.353737,0.314084,0.112453,-0.141387,0.398549,0.334592,0.015611,0.275433,-0.277471,0.290538,0.054159,-0.154270,-0.217067,-0.111603,0.078084,0.265778,-0.063893,0.090595,-0.106898,-0.132766,0.148110,0.128641,-0.147322,0.256897,0.005073,0.213913,0.332554,0.260163,0.028299,0.319038,0.386857,-0.114865,0.171844,-0.278333,0.390330,-0.063965,-0.110863,0.397002,0.360758,0.150262,-0.100011,0.260946,0.199367,-0.029845,0.123045,-0.194612,-0.201936,0.142877,0.032600,-0.164833,0.279901,0.236481,0.057990,-0.170777,-0.312511,-0.264819,0.066822,-0.198060,0.358818,0.276026,-0.007785,-0.206787,0.319749,-0.187777,0.026124,0.206275,0.251035,-0.015210,0.176313,0.206095,-0.092406,0.061289,-0.163161,0.205846,-0.062767,-0.097352,0.251798,0.219676,0.028535,-0.198818,-0.296658,0.204874,-0.060665,0.318817,0.352098,-0.131560,-0.135809,0.358259,-0.308592,0.114681,-0.155381,-0.312984,-0.277581},
  {0.042141,0.105821,-0.080974,-0.096852,0.135195,0.049361,0.125061,-0.112467,0.195745,-0.062360,0.037349,0.150279,0.235236,0.246763,0.156833,0.092267,0.266845,-0.262975,-0.174000,0.033982,0.268894,-0.291968,0.290004,0.086155,-0.120371,-0.227252,-0.101207,0.040385,-0.094686,0.280600,0.323460,-0.171985,0.043418,0.300816,-0.401435,0.430653,0.139562,-0.248039,-0.500287,-0.450435,0.191898,-0.235194,0.579934,0.538236,-0.148609,-0.166226,0.497779,-0.414092,0.255534,-0.063845,-0.295347,-0.334709,0.127709,0.112587,-0.042032,0.038656,-0.100190,-0.142146,0.140500,-0.043811,-0.038887,0.145965,0.187581,0.163138,0.068778,-0.072638,-0.204019,0.269325,0.180905,0.037418,0.245159,-0.317599,0.249050,-0.008916,-0.196367,-0.300158,-0.242066,-0.077071,0.214285,-0.231961,-0.197548,0.114383,-0.051533,0.258738,-0.355675,0.319074,-0.049499,-0.266877,-0.490753,-0.442796,-0.121316,0.296908,-0.542918,-0.493957,0.180672,-0.236253,0.517851,-0.471590,0.212715,0.165127,-0.389699,-0.407011,-0.216174,0.061138},
  {1.097695,1.250451,-0.760746,0.081486,-0.858747,-1.251047,1.085963,-0.365792,-0.448272,1.126614,1.283065,0.875629,0.063288,-0.805078,-1.325365,1.261291,0.554364,0.473203,1.264503,-1.421233,0.952417,0.033967,-0.928053,-1.397544,-1.201273,-0.448553,1.228182,-1.359368,-0.895045,0.043167,-0.860833,1.391925,-1.203210,0.509697,0.479828,-1.162031,-1.308671,-0.832927,0.018706,0.836221,-1.211436,-1.049442,0.450871,-0.348516,0.982220,-1.085191,0.765889,-0.070936,-0.543846,-0.908762,-0.866239,-0.478407,0.594968,-0.257449,1.005316,1.276685,-0.937727,-0.153997,-0.694890,1.206029,-1.181425,0.621146,-0.217713,-0.980530,-1.325217,-1.071867,-0.302284,-0.651249,-1.322845,1.366036,0.746284,0.241032,-1.123561,1.450735,-1.094215,-0.226437,0.728055,1.329087,0.698069,0.228225,1.054557,-1.401198,-1.092731,0.266244,0.676100,-1.303740,1.297840,-0.689914,0.230380,1.013342,1.298639,0.976377,-0.228059,0.594924,-1.118388,-1.113268,0.607545,0.132229,-0.781451,1.039213,-0.842432,-0.303198,0.315053,0.758948},
  {0.001744,-0.132749,0.237664,0.217996,-0.086024,0.047748,-0.134780,0.238869,-0.187085,0.120384,-0.037390,-0.186110,-0.252752,-0.194158,-0.028215,-0.131583,-0.259298,0.290863,0.158646,0.070576,-0.198490,0.299783,-0.208242,-0.058261,0.125582,0.269424,0.222894,-0.000011,0.206115,-0.297997,-0.281749,0.159677,0.104752,-0.262266,0.368012,-0.244270,-0.032898,0.213927,0.385818,0.394079,-0.180472,0.113790,-0.346415,-0.441314,0.331421,0.025624,-0.313742,0.495985,-0.348111,-0.047058,0.270430,0.434915,-0.264799,-0.203462,0.014871,-0.124284,0.160814,0.184600,-0.188626,0.005814,0.074993,-0.247940,-0.274929,-0.193243,-0.027050,0.150945,0.251524,-0.280441,-0.125474,-0.137326,-0.285735,0.252072,-0.215859,-0.021545,0.135005,0.239739,0.232041,0.111978,-0.255111,0.280046,0.226879,-0.111444,0.111500,-0.336645,0.298980,-0.233262,-0.052488,0.211334,0.330885,0.289962,0.094992,-0.176671,0.337748,0.392685,-0.293569,0.018353,-0.383950,0.447401,-0.379216,-0.001032,0.267559,0.425947,0.337582,0.068152},
  {-1.262178,-0.573055,-0.391705,-1.168316,1.380487,0.933951,-0.066750,-0.784915,1.244527,-1.126006,-0.534350,0.250770,0.899741,1.163943,0.950473,-0.339252,0.429022,-1.041162,-1.226143,0.868915,-0.085612,-0.771663,1.309997,1.244548,0.584328,-0.371902,-1.423250,1.004974,0.104417,0.850982,1.401693,-1.288188,0.578115,0.398640,-1.169185,1.392576,0.972441,0.122247,-0.762147,-1.286142,1.232144,0.631844,0.244034,1.005254,-1.317446,1.048132,-0.299646,-0.583853,1.213518,1.290293,0.780053,-0.083026,0.600059,1.276906,-1.361962,-0.782093,-0.175241,-1.011337,1.331757,-1.059873,0.295390,0.522415,1.082541,1.155253,0.744785,0.037601,-0.682178,1.112358,1.100621,-0.627799,0.161900,-0.935550,1.286059,-1.086782,0.331538,-0.596498,-1.275551,-1.368644,0.131074,-1.039965,-1.447802,1.157778,0.335839,0.626159,-1.319348,1.356484,-0.796805,-0.151343,-0.995802,-1.373574,-1.129294,-0.390742,-0.521260,-1.174914,1.288744,0.846237,-0.042035,-0.817317,1.281680,-1.202522,0.543401,-0.351552,-1.091512,-1.337977},
  {0.319545,0.860020,-0.942721,-0.582693,-0.049033,-0.707807,1.040712,-0.731371,0.183180,0.520367,0.886520,0.844688,0.461882,-0.072742,-0.546768,0.850164,0.760629,-0.285254,0.309502,-0.763650,0.990014,-0.613511,0.007693,-0.671645,-0.992478,-0.778203,0.532624,-0.861373,-0.786333,0.395396,-0.173906,0.647199,-0.683308,0.535833,-0.085211,-0.248063,-0.501620,-0.533943,-0.348827,-0.024467,-0.253530,-0.481319,0.570616,0.380762,0.022824,-0.323026,0.614232,-0.537534,0.328533,-0.091209,-0.473158,-0.638095,0.898292,0.504984,0.197023,0.813506,-1.004968,-0.691448,0.042731,0.646089,-0.942549,0.808324,0.297218,-0.297244,-0.714123,-0.808355,-0.570835,0.121788,-0.413715,0.823560,0.871341,-0.486725,-0.132532,0.771819,-1.004397,-0.736933,-0.073916,0.628097,0.841585,-0.266480,0.373202,-0.755698,-0.765477,0.453270,0.053268,-0.438987,0.643751,-0.536236,-0.247597,0.120228,0.427530,0.564652,-0.462459,-0.198109,-0.129779,-0.433005,0.587790,-0.459836,0.168235,0.256713,-0.548160,-0.624279,-0.413299,-0.001177},
  {-0.067207,0.146313,-0.252626,-0.269197,0.221552,0.089819,0.110811,-0.273376,0.424688,-0.349792,-0.078539,0.321574,0.628689,0.625527,0.260666,0.314841,0.736292,-0.750160,-0.372625,-0.194946,0.712982,-0.817690,0.549684,-0.018489,-0.573325,-0.834514,-0.150186,-0.424021,-0.795915,0.771828,0.333097,0.278797,-0.675453,0.757825,-0.419454,-0.052000,-0.483917,-0.654886,-0.505282,-0.120901,-0.285704,-0.560892,0.570789,0.273409,0.169344,-0.448074,0.506798,-0.248235,-0.054093,-0.275019,-0.288851,-0.152620,0.346632,0.317109,-0.097352,0.080818,-0.154241,-0.245925,0.339707,-0.181394,0.035966,0.333047,0.556322,0.534361,0.210301,-0.276749,-0.649351,0.736793,0.352531,0.303654,0.762696,-0.768810,0.495644,0.163303,-0.614175,-0.808628,-0.576139,-0.031898,0.873437,-0.694128,-0.211772,-0.318593,-0.723688,0.798737,-0.344175,-0.132222,0.634880,-0.674576,-0.442672,-0.002365,0.430229,0.658154,-0.510910,-0.174752,-0.182651,-0.486160,0.577930,-0.240505,-0.071548,0.420816,-0.375788,-0.184693,0.063308,0.209341},
  {-1.529102,-1.350299,0.524760,-0.608363,1.482210,1.599795,-0.901764,-0.169721,1.195584,-1.562346,-1.200652,-0.276139,0.757701,1.415359,1.401528,-0.706720,0.273873,-1.067259,-1.353259,1.019409,-0.174356,-0.636614,1.157878,1.103816,0.588427,-0.122912,-0.988959,0.872146,0.377629,0.295919,0.817060,-0.956898,0.733098,-0.128172,-0.453317,0.866377,0.863329,0.521022,0.013963,-0.460800,0.791884,0.828205,-0.536118,-0.020024,-0.567085,1.058893,-1.045805,0.560832,0.339969,1.125831,1.393823,0.965116,-0.255278,0.826256,-1.522405,-1.494173,0.735766,-0.405535,1.355200,-1.597817,1.091476,-0.043643,0.981224,1.516471,1.329094,0.530431,-0.489379,1.265421,1.412315,-0.877808,0.034403,-0.873577,1.290727,-1.059521,0.399875,-0.393765,-0.947183,-1.055009,-0.111552,-0.501017,-0.908612,0.949622,0.572740,0.067680,-0.643212,0.953774,-0.801485,0.340810,-0.244042,-0.681370,-0.822156,-0.655182,0.279679,-0.219748,0.698570,0.949504,-0.815086,0.308431,0.470914,-1.093488,1.259937,0.769900,-0.154220,-1.043740},
  {-0.296423,0.045710,-0.356569,-0.437063,0.263719,-0.012505,0.236895,-0.362416,0.247871,-0.057151,0.166686,0.277807,0.219956,0.032853,-0.167719,0.232481,0.161679,-0.010635,0.147956,-0.207795,0.077037,0.056719,-0.182082,-0.157103,-0.033434,0.102055,0.121373,-0.022849,0.120380,-0.236337,-0.215852,0.043713,0.149490,-0.349228,0.322020,-0.124081,0.223672,0.481380,0.453385,0.112375,0.325994,0.615490,-0.550545,-0.116415,-0.421740,0.666385,-0.556881,0.079666,0.385097,0.632874,0.513837,0.116578,0.415915,0.487030,-0.254818,0.055737,-0.268702,-0.358535,0.296787,0.001506,-0.182413,0.344867,0.276971,0.078993,-0.134227,-0.240383,-0.180947,0.054225,-0.128592,0.248796,0.161111,0.063948,-0.138555,0.194829,-0.022647,0.124042,0.199059,0.158370,-0.098518,0.220610,0.185572,-0.001151,0.170988,-0.243868,0.291680,-0.059395,-0.166191,0.440764,0.432784,0.151810,-0.260272,-0.541804,0.538655,0.143800,0.409338,0.693322,-0.519404,0.120762,0.441737,-0.643522,0.562671,0.132119,-0.335810,-0.583871},
  {-0.587304,-0.419197,0.012470,-0.451130,0.748456,0.720241,-0.317275,-0.350855,0.855692,-0.977478,-0.558192,0.176554,0.835803,1.060870,0.727560,-0.034840,0.687677,-1.069749,-0.891572,0.255804,0.452056,-0.957492,0.939516,0.480836,-0.199161,-0.760753,-0.668733,0.079998,-0.499656,0.800290,0.732257,-0.346856,-0.220146,0.619450,-0.749061,0.480720,0.017967,-0.424131,-0.631498,-0.526765,0.178116,-0.178575,0.373777,0.392928,-0.287670,0.084165,0.061756,-0.222504,0.298090,0.320636,0.218143,-0.014231,0.111942,0.468847,-0.680963,-0.583944,0.160470,-0.402427,0.819319,-0.871596,0.424847,0.263585,0.866630,1.027710,0.641038,-0.096635,-0.794931,1.071095,0.808978,-0.152073,0.581223,-1.021276,0.918369,-0.392899,-0.335871,-0.865276,-0.959463,-0.591623,0.616925,-0.887621,-0.718808,0.213070,-0.354770,0.719497,-0.761074,0.420464,0.073547,-0.533204,-0.701733,-0.529624,-0.127475,0.285476,-0.523880,-0.482123,0.232885,-0.044048,0.226316,-0.321201,0.291291,-0.229158,0.077726,-0.113453,-0.313250,-0.424660},
  {0.105689,-0.135066,0.260203,0.268629,-0.176447,0.007715,-0.190155,0.203806,-0.200600,0.062302,-0.056282,-0.158080,-0.213407,-0.198399,-0.106629,-0.073090,-0.203908,0.216776,0.152543,-0.038777,-0.158531,0.202870,-0.209894,-0.097095,0.026968,0.104762,0.109803,-0.117068,-0.061136,-0.076967,-0.205245,0.252059,-0.243175,0.001148,0.233125,-0.442323,-0.375787,-0.078531,0.281281,0.477444,-0.418489,-0.087817,-0.307161,-0.477630,0.343129,-0.105577,-0.210107,0.309613,-0.311234,-0.162418,0.009913,0.144670,-0.311523,-0.304022,0.144141,-0.073487,0.232218,0.260549,-0.168866,0.028210,0.106896,-0.180434,-0.188377,-0.131944,-0.026764,0.097496,0.194918,-0.213125,-0.134874,-0.013598,-0.165945,0.240627,-0.188454,0.052334,0.100945,0.184813,0.176179,0.105105,-0.045130,0.104466,0.157648,-0.181851,-0.133722,-0.013629,0.220725,-0.351985,0.301874,-0.043523,0.282658,0.474443,0.391642,0.067498,0.305791,0.493101,-0.386685,-0.072421,-0.248541,0.403722,-0.326213,0.111213,0.116767,0.248032,0.262115,0.187277},
  {-0.265096,-0.440286,0.389876,0.225590,-0.011823,0.250418,-0.449157,0.358198,-0.196040,-0.144792,-0.371201,-0.432432,-0.314615,-0.088763,0.140464,-0.342589,-0.377943,0.244548,0.062169,0.129487,-0.406121,0.450323,-0.380092,-0.049136,0.350971,0.602927,0.156396,0.300296,0.654086,-0.700891,-0.335711,-0.239199,0.584472,-0.704987,0.380876,0.016952,0.408389,0.565072,0.444962,0.134931,0.162214,0.408969,-0.522409,-0.387331,0.055786,0.215638,-0.505768,0.495691,-0.349663,0.019402,0.392682,0.578181,-0.375836,-0.143119,-0.110472,-0.333905,0.442316,0.343469,-0.071640,-0.185976,0.410910,-0.396314,-0.223571,0.045728,0.282058,0.388058,0.340055,-0.150285,0.059280,-0.227361,-0.355722,0.390474,-0.210132,-0.051085,0.397305,0.576670,0.483830,0.120550,-0.654960,0.647257,0.264101,0.291905,0.674097,-0.675812,0.376239,0.148244,-0.519527,0.659296,0.457254,0.071090,-0.303015,-0.505440,0.502912,0.277951,0.067116,0.354754,-0.479614,0.463078,-0.195235,-0.127513,0.469128,0.588661,0.433463,0.058516},
  {1.649349,1.212063,-0.168645,0.896927,-1.474083,-1.381522,0.709198,0.306814,-1.085323,1.453555,1.174802,0.400187,-0.559861,-1.297447,-1.466246,0.989870,-0.002619,1.052780,1.591020,-1.347084,0.533899,0.589405,-1.355222,-1.516491,-0.980984,-0.006140,1.516704,-1.356122,-0.612819,-0.386903,-1.249186,1.570638,-1.096462,0.182327,0.876243,-1.448582,-1.377025,-0.674952,0.321649,1.160336,-1.438034,-1.105701,0.319568,-0.630639,1.325000,-1.357466,0.852054,0.098100,-0.927974,-1.368106,-1.194031,-0.491905,-0.077211,-1.119969,1.582278,1.304708,-0.455649,0.585276,-1.340209,1.420801,-0.948703,0.030470,-0.867536,-1.410792,-1.361248,-0.710950,0.283720,-1.213811,-1.580180,1.180340,0.234418,0.807100,-1.523330,1.462361,-0.782743,0.266335,1.167988,1.524791,0.320104,0.670047,1.390150,-1.509792,-0.912273,-0.136512,1.068052,-1.559280,1.267256,-0.453164,0.576606,1.314507,1.437527,0.910519,-0.016799,0.893994,-1.424047,-1.294411,0.565623,0.353787,-1.167906,1.397577,-1.060944,-0.233349,0.681093,1.284123},
  {0.402281,0.218985,0.032769,0.275633,-0.418630,-0.390688,0.198162,0.064158,-0.309819,0.420210,0.375805,0.190363,-0.076659,-0.342721,-0.510438,0.481060,0.226985,0.184557,0.582316,-0.741537,0.513003,0.007286,-0.581675,-0.877318,-0.722914,-0.189055,0.849084,-0.833903,-0.411617,-0.201158,-0.702781,0.866495,-0.639437,0.104126,0.473819,-0.847193,-0.816715,-0.392852,0.225462,0.735639,-0.890368,-0.604951,0.025504,-0.549578,0.842201,-0.736533,0.273928,0.293997,-0.717530,-0.784388,-0.478135,0.043737,-0.179798,-0.375648,0.415380,0.311435,-0.097727,0.171095,-0.385386,0.414636,-0.305016,0.049268,-0.211481,-0.401433,-0.456385,-0.346060,-0.082654,-0.276526,-0.561955,0.613506,0.372738,0.093197,-0.603420,0.817326,-0.637953,-0.092510,0.521829,0.874811,0.286424,0.326855,0.780785,-0.865873,-0.532519,-0.054971,0.585699,-0.873361,0.727421,-0.263189,0.346687,0.794702,0.857475,0.497992,0.092621,0.644768,-0.887436,-0.685442,0.148162,0.417779,-0.796572,0.760745,-0.393493,0.160853,0.617933,0.760974},
  {0.230935,-0.230059,0.539163,0.642477,-0.490957,-0.056031,-0.472960,0.702457,-0.700623,0.239142,-0.330308,-0.773760,-0.844791,-0.487831,0.116944,-0.704569,-0.879729,0.557564,0.003973,0.485481,-0.807582,0.623291,-0.248409,0.259847,0.601711,0.631834,-0.075730,0.409051,0.582574,-0.528307,-0.193764,-0.262196,0.484485,-0.571647,0.286476,0.029477,0.358615,0.479103,0.337808,0.025109,0.221084,0.352200,-0.323933,-0.114139,-0.126571,0.130870,-0.143032,0.032773,-0.100649,-0.153642,-0.148868,-0.012111,-0.629654,-0.653642,0.336432,-0.112592,0.490818,0.684532,-0.590731,0.131441,0.355346,-0.765867,-0.775776,-0.390842,0.206542,0.703526,0.829058,-0.550171,0.039657,-0.624967,-0.846545,0.606517,-0.145973,-0.425342,0.692703,0.643729,0.288862,-0.186128,-0.661949,0.431941,0.045410,0.315363,0.547392,-0.550382,0.230844,0.120428,-0.471356,0.516556,0.335334,-0.011767,-0.338732,-0.475452,0.327092,0.059496,0.156774,0.261397,-0.235753,0.058796,-0.004378,-0.040437,-0.020223,0.019977,0.140562,0.249980},
  {-0.268591,-0.546448,0.538832,0.228934,0.208524,0.515089,-0.538357,0.318642,0.083175,-0.408400,-0.536881,-0.386332,-0.031409,0.341213,0.527373,-0.407462,-0.080717,-0.252948,-0.420814,0.345319,-0.069436,-0.159007,0.267740,0.199162,0.066001,-0.028098,-0.045640,0.072743,0.098863,-0.079945,-0.017010,-0.066740,0.155847,-0.133925,0.071033,0.046558,0.116175,0.134523,0.113109,0.067229,0.015848,0.098394,-0.152956,-0.165884,0.106239,0.055207,-0.182317,0.259895,-0.182882,-0.024617,0.159721,0.288241,-0.522497,-0.197292,-0.262512,-0.555414,0.526481,0.248096,0.125012,-0.479161,0.531429,-0.372169,-0.003800,0.356534,0.521683,0.400777,0.057973,0.281616,0.468631,-0.404350,-0.103804,-0.234788,0.336820,-0.283755,0.049621,-0.120859,-0.174201,-0.132524,-0.047793,0.008940,-0.022420,0.056808,0.115367,-0.142518,0.030390,0.049075,-0.154664,0.123824,0.065553,-0.011404,-0.077387,-0.124469,0.117235,0.102548,-0.062687,0.055009,-0.198332,0.203873,-0.161061,-0.029732,0.164644,0.254917,0.223410,0.079140},
  {0.452753,-0.231673,0.862196,1.143677,-0.879112,-0.097745,-0.838892,1.370126,-1.267294,0.425626,-0.682643,-1.500253,-1.563591,-0.801786,0.403911,-1.445169,-1.721244,1.077708,-0.108739,1.215418,-1.734704,1.306624,-0.262845,0.913969,1.586095,1.421257,-0.591699,1.337828,1.387725,-0.766530,0.200680,-1.006793,1.207820,-0.865565,0.112354,0.562436,0.926831,0.831883,0.374346,-0.203206,0.605471,0.713735,-0.516255,-0.101386,-0.313450,0.471627,-0.442356,0.204486,-0.012550,0.122662,0.174073,0.199888,-0.872418,-1.029030,0.646083,-0.094152,0.848898,1.267552,-1.081781,0.243693,0.743563,-1.469290,-1.432711,-0.633107,0.538614,1.463233,1.631207,-0.962754,0.247123,-1.361892,-1.747127,1.202037,-0.094346,-1.103294,1.660987,1.379092,0.391753,-0.772055,-1.453652,0.647321,-0.411626,1.168170,1.312320,-0.830997,-0.054143,0.771141,-1.105674,0.846257,0.255892,-0.389044,-0.797532,-0.817438,0.451834,-0.049279,0.442067,0.606448,-0.504745,0.155561,0.130889,-0.337098,0.309626,0.215876,0.116440,0.043078},
  {0.233943,0.593643,-0.656218,-0.334356,-0.194297,-0.599819,0.657469,-0.397659,-0.058248,0.414109,0.556630,0.447510,0.163896,-0.174626,-0.443855,0.522629,0.385197,-0.070921,0.306073,-0.557162,0.510677,-0.239358,-0.165129,-0.463302,-0.537140,-0.373103,0.263592,-0.484398,-0.487518,0.262148,-0.081248,0.386886,-0.536886,0.397752,-0.092763,-0.266070,-0.462596,-0.435985,-0.232060,0.035920,-0.276082,-0.395102,0.363063,0.202751,0.051450,-0.344680,0.476856,-0.403266,0.087275,-0.270230,-0.484898,-0.447623,0.586800,0.283497,0.230286,0.628173,-0.666851,-0.352488,-0.121936,0.534324,-0.612798,0.429672,0.063336,-0.287317,-0.489512,-0.484039,-0.278992,-0.034306,-0.365828,0.561898,0.480626,-0.144664,-0.232496,0.527933,-0.525720,-0.290956,0.067845,0.380283,0.436994,-0.156354,0.179221,-0.429639,-0.507451,0.361432,-0.000593,-0.325680,0.519509,-0.419222,-0.145033,0.170526,0.381650,0.421874,-0.287194,-0.074624,-0.150172,-0.352646,0.446582,-0.308038,0.036962,0.317073,-0.490871,-0.426523,-0.138466,0.205743},
  {0.552953,1.076004,-1.060679,-0.572030,-0.163710,-0.862484,1.183276,-0.853364,0.186359,0.641539,1.108261,1.034557,0.478090,-0.263478,-0.822244,0.997681,0.685674,-0.071531,0.488917,-0.772276,0.805274,-0.436885,-0.022917,-0.507028,-0.769794,-0.689859,0.240044,-0.620546,-0.747315,0.584034,0.159311,0.337280,-0.606169,0.728634,-0.505424,0.153621,-0.345410,-0.756925,-0.865747,-0.550300,-0.058170,-0.744168,1.132298,0.912594,-0.171602,-0.596114,1.136663,-1.022514,0.487875,-0.288816,-0.884138,-1.040111,0.978355,0.405475,0.350340,0.970338,-1.153126,-0.762368,-0.020017,0.748552,-1.157560,0.951866,0.306742,-0.473313,-0.998957,-1.028587,-0.583884,-0.112419,-0.681267,0.886015,0.721746,-0.296915,-0.267656,0.655513,-0.817460,-0.619243,-0.161544,0.365313,0.754307,-0.466992,0.032935,-0.512923,-0.733333,0.631344,-0.343796,-0.113068,0.492992,-0.764577,-0.731090,-0.374540,0.209728,0.772815,-1.036167,-0.764763,0.044998,-0.725359,1.128293,-1.000656,0.315465,0.469839,-1.046494,-1.080869,-0.617630,0.097153},
  {0.876118,0.900204,-0.569729,0.055312,-0.675741,-0.896754,0.643293,-0.257869,-0.338149,0.612051,0.668077,0.436985,0.031295,-0.387733,-0.664013,0.613623,0.368543,-0.014962,0.423218,-0.746124,0.599155,-0.311993,-0.255868,-0.647151,-0.763493,-0.560487,0.334344,-0.723699,-0.746479,0.380976,-0.108644,0.510243,-0.827521,0.626496,-0.263371,-0.358401,-0.746915,-0.804099,-0.523560,-0.049161,-0.490263,-0.765630,0.680178,0.381126,0.043981,-0.644848,0.878214,-0.857443,0.253507,-0.487543,-1.063416,-1.136785,0.430873,-0.249280,0.800870,0.931014,-0.605547,-0.052657,-0.458581,0.785986,-0.692545,0.372051,-0.099309,-0.490972,-0.660886,-0.559263,-0.230781,-0.168775,-0.536961,0.714402,0.555676,-0.114093,-0.333031,0.694596,-0.682662,-0.387887,0.084075,0.520815,0.641314,-0.244565,0.241027,-0.611451,-0.749024,0.573964,-0.064768,-0.430082,0.788186,-0.718315,-0.342754,0.183836,0.616608,0.777419,-0.588200,-0.192978,-0.258178,-0.656796,0.840915,-0.611117,0.127233,0.547942,-0.970073,-0.963118,-0.435922,0.374507},
  {0.112702,-0.242987,0.458516,0.430879,-0.170695,0.205346,-0.480194,0.442957,-0.216675,-0.153607,-0.408062,-0.452466,-0.280490,0.010998,0.276926,-0.419109,-0.338012,0.080243,-0.186306,0.333357,-0.360881,0.174865,0.037259,0.239193,0.317498,0.245285,-0.152330,0.274623,0.289596,-0.187019,0.026250,-0.245224,0.293130,-0.235206,0.017350,0.150126,0.242989,0.198727,0.059249,-0.090294,0.150890,0.148808,-0.106697,-0.018002,-0.077378,0.081474,-0.096978,0.036619,-0.025785,-0.003418,0.006636,0.022190,-0.428414,-0.406081,0.154329,-0.219635,0.492675,0.467846,-0.165128,-0.173784,0.450597,-0.436991,-0.221529,0.097630,0.357692,0.438328,0.312226,-0.023651,0.245453,-0.367462,-0.328992,0.156592,0.125588,-0.290057,0.356530,0.238781,0.025847,-0.183217,-0.271253,0.141921,-0.073053,0.274261,0.323463,-0.192960,0.012598,0.212865,-0.274658,0.236506,0.066853,-0.108672,-0.200175,-0.176850,0.098633,-0.020673,0.125647,0.142553,-0.081429,0.047096,0.035333,-0.042010,0.072757,0.062463,0.055583,0.057373},
  {-0.499811,-0.419417,0.165400,-0.195662,0.501475,0.567230,-0.340371,-0.036830,0.422134,-0.563774,-0.435327,-0.103118,0.257457,0.478447,0.477374,-0.261548,0.041353,-0.305273,-0.448845,0.410806,-0.161548,-0.141712,0.412483,0.477842,0.314479,0.002321,-0.437674,0.367861,0.118905,0.171166,0.337766,-0.320626,0.197835,0.001232,-0.132583,0.220142,0.228813,0.194051,0.115703,-0.020714,0.218064,0.373609,-0.374048,-0.175146,-0.173145,0.529848,-0.610254,0.366425,0.151770,0.614431,0.751315,0.467096,-0.037117,0.283893,-0.513127,-0.513526,0.258086,-0.128867,0.457853,-0.588666,0.398993,-0.039479,0.334971,0.525154,0.455573,0.183278,-0.151557,0.388196,0.460347,-0.349047,-0.080290,-0.236523,0.428939,-0.454571,0.240982,-0.081226,-0.369017,-0.476729,-0.064097,-0.246842,-0.405174,0.347777,0.149337,0.073761,-0.250715,0.273341,-0.219044,0.088740,-0.028841,-0.134203,-0.226985,-0.284362,0.237884,0.070586,0.189510,0.442507,-0.516166,0.271573,0.156595,-0.584438,0.691227,0.412341,-0.125894,-0.611356},
  {1.174651,0.926461,-0.188893,0.630511,-1.143569,-1.158728,0.640155,0.301366,-1.054196,1.391043,1.002683,0.105371,-0.856533,-1.389860,-1.214383,0.461027,-0.553426,1.315394,1.381893,-0.736177,-0.172088,1.050704,-1.321866,-0.988323,-0.184271,0.695182,1.177621,-0.528536,0.321660,-0.953835,-1.131769,0.785132,0.002139,-0.657986,1.014854,-0.768502,-0.210755,0.378533,0.702302,0.652945,-0.295319,0.059585,-0.237792,-0.294341,0.305184,-0.217073,0.216197,-0.055290,-0.129282,-0.410111,-0.572475,-0.451184,0.052435,-0.709737,1.206246,1.084378,-0.380682,0.484573,-1.100487,1.324268,-0.774439,-0.065002,-0.957510,-1.376241,-1.090025,-0.228787,0.774181,-1.338582,-1.281340,0.639180,-0.357989,1.210045,-1.334005,0.930203,0.026137,0.891570,1.324614,1.133330,-0.448919,1.136926,1.208732,-0.643108,0.162827,-0.800126,1.127872,-0.766863,0.176773,0.554000,0.886975,0.767377,0.326156,-0.159133,0.513747,0.523123,-0.279579,-0.074872,0.001752,0.158933,-0.193063,0.383821,-0.372082,-0.246270,0.093618,0.518444},
  {0.026495,-0.262969,0.393076,0.354494,-0.204488,-0.015942,-0.159982,0.291231,-0.317744,0.232839,0.044602,-0.170951,-0.319955,-0.334585,-0.208707,0.002781,-0.204406,0.334397,0.336079,-0.209821,0.005922,0.227653,-0.392352,-0.423106,-0.272628,0.032737,0.610091,-0.564222,-0.218385,-0.297110,-0.731761,0.827126,-0.471469,-0.169942,0.775983,-0.986306,-0.672681,0.012813,0.699799,1.017429,-0.800209,-0.185081,-0.497607,-0.911999,0.872505,-0.411669,-0.220884,0.741074,-0.894992,-0.623552,-0.049729,0.549649,-0.523434,-0.388258,0.101180,-0.137931,0.255611,0.306875,-0.294640,0.116960,0.036264,-0.257959,-0.355641,-0.317243,-0.151001,0.073342,0.258630,-0.367323,-0.298448,0.084272,-0.130643,0.271570,-0.392602,0.301176,-0.153421,0.118217,0.377339,0.502661,0.071505,0.327455,0.660237,-0.723169,-0.370068,-0.259712,0.747253,-0.941573,0.563630,0.076194,0.732124,1.000307,0.728069,0.064129,0.593027,0.958588,-0.861693,-0.318140,-0.386101,0.812239,-0.908141,0.506306,0.060544,0.623318,0.873699,0.684860},
  {0.326471,0.189049,0.046978,0.270292,-0.384912,-0.346286,0.144974,0.181607,-0.414441,0.476550,0.280663,-0.059226,-0.361514,-0.469276,-0.340642,0.077638,-0.204031,0.383496,0.385322,-0.235422,0.038617,0.208133,-0.372194,-0.424793,-0.290976,0.015881,0.599654,-0.514569,-0.146567,-0.327337,-0.664931,0.658732,-0.256682,-0.263063,0.659906,-0.657951,-0.313163,0.178416,0.538184,0.588471,-0.326253,0.046562,-0.324173,-0.415617,0.325509,-0.099341,-0.090922,0.242984,-0.272082,-0.229981,-0.111031,0.060020,-0.141764,-0.314176,0.344418,0.256401,-0.066294,0.204894,-0.430565,0.407506,-0.226744,-0.138129,-0.423395,-0.502447,-0.332800,-0.011303,0.288926,-0.453616,-0.382370,0.137593,-0.113304,0.278563,-0.395770,0.323889,-0.181041,0.087732,0.361263,0.504382,0.064246,0.340184,0.629290,-0.615354,-0.231605,-0.322645,0.660823,-0.687140,0.284320,0.210326,0.587564,0.619381,0.317460,-0.122418,0.423575,0.493704,-0.343753,-0.049149,-0.231901,0.315870,-0.315988,0.162018,-0.030089,0.125838,0.239239,0.270929},
  {0.983784,1.556833,-1.426460,-0.506530,-0.758563,-1.618763,1.632871,-0.973074,-0.301749,1.305118,1.738902,1.317742,0.240946,-0.977385,-1.749870,1.621727,0.761297,0.413926,1.438100,-1.806846,1.160518,-0.099881,-1.103847,-1.682176,-1.462626,-0.592435,1.276698,-1.509947,-1.001069,0.006878,-0.897288,1.306930,-1.241267,0.484472,0.329587,-1.081031,-1.244694,-0.857013,-0.140750,0.553719,-1.005570,-0.949512,0.466337,-0.093043,0.510586,-0.850458,0.739477,-0.496913,-0.073464,-0.577380,-0.899552,-0.895212,1.223238,0.270506,0.930729,1.655518,-1.513876,-0.667196,-0.471344,1.524976,-1.707348,1.192643,0.040431,-1.119007,-1.727820,-1.489189,-0.510766,-0.664306,-1.578356,1.780227,1.055757,0.232526,-1.253666,1.773899,-1.296551,-0.276840,0.845213,1.538442,0.812441,0.274467,1.134366,-1.392572,-1.072299,0.339393,0.651491,-1.177425,1.274908,-0.658490,0.163932,0.870947,1.153004,0.928612,-0.277808,0.365406,-0.737460,-0.847487,0.698166,-0.173633,-0.260647,0.734877,-0.808243,-0.639791,-0.193018,0.381462},
  {-0.405967,-0.075696,-0.276351,-0.480943,0.446508,0.197354,0.148803,-0.430775,0.457386,-0.238580,0.110323,0.360715,0.364368,0.148957,-0.111327,0.228190,0.168569,-0.031470,0.057310,-0.040290,-0.042914,0.050581,0.021869,0.130763,0.159884,0.066702,-0.188619,0.169136,0.071934,0.026054,0.089282,-0.122014,0.126135,-0.132885,0.069183,0.056431,0.224608,0.317307,0.236194,-0.016981,0.307706,0.471011,-0.386162,-0.061173,-0.337698,0.567408,-0.514774,0.157091,0.297959,0.623500,0.617500,0.262833,0.343308,0.501555,-0.438613,-0.156453,-0.214521,-0.461103,0.453621,-0.245502,-0.137375,0.389477,0.418183,0.193167,-0.124075,-0.321463,-0.291733,0.077413,-0.103649,0.125902,0.049655,0.010720,-0.031712,-0.071812,0.104223,0.056757,-0.075996,-0.190575,-0.082295,-0.083920,-0.165905,0.136855,0.083451,-0.051486,-0.026179,0.075104,-0.189322,0.214274,0.147804,-0.049285,-0.288444,-0.417946,0.301714,0.005348,0.318985,0.517554,-0.459307,0.093870,0.310084,-0.616034,0.558140,0.204995,-0.289943,-0.653648},
  {-0.806250,-1.333610,1.146199,0.349508,0.605903,1.196126,-1.136306,0.522551,0.298088,-0.888756,-1.010172,-0.663956,-0.062280,0.509414,0.820137,-0.763004,-0.390470,-0.133220,-0.590805,0.780524,-0.602905,0.157115,0.355815,0.674007,0.656349,0.335963,-0.440627,0.542659,0.403788,-0.133307,0.129280,-0.301395,0.374627,-0.337923,0.214503,0.005243,0.263923,0.469144,0.503427,0.302805,0.083548,0.476982,-0.672897,-0.556610,0.162872,0.339606,-0.695644,0.749353,-0.452014,0.061656,0.577426,0.866147,-1.083917,-0.245418,-0.715740,-1.283839,1.163903,0.441478,0.465041,-1.053894,1.091738,-0.592758,0.121861,0.707670,0.925239,0.728294,0.242858,0.319076,0.712316,-0.780618,-0.513036,0.027131,0.479240,-0.736565,0.655595,0.263188,-0.225659,-0.566763,-0.376281,0.021709,-0.287840,0.438425,0.402539,-0.240407,0.048758,0.161829,-0.321889,0.420469,0.371970,0.156362,-0.175147,-0.483372,0.610150,0.442009,-0.027950,0.429294,-0.701652,0.666756,-0.297477,-0.209576,0.657096,0.818379,0.618537,0.123759},
  {0.346661,0.368837,-0.270010,-0.003773,-0.344233,-0.567281,0.521025,-0.249648,-0.243999,0.609981,0.710813,0.443973,-0.063815,-0.556491,-0.792269,0.637284,0.215483,0.284747,0.697786,-0.846009,0.570219,-0.055191,-0.597074,-1.002036,-0.945476,-0.393640,1.052092,-1.184258,-0.660352,-0.255839,-1.027402,1.233451,-0.838437,-0.032550,0.809459,-1.191913,-0.935844,-0.233126,0.537647,0.988733,-0.946832,-0.426752,-0.280603,-0.771160,0.823151,-0.527729,-0.024553,0.444211,-0.650842,-0.526008,-0.209956,0.128726,0.123029,-0.111649,0.369680,0.491540,-0.386845,-0.097959,-0.273468,0.619748,-0.630972,0.366094,-0.136287,-0.589677,-0.754090,-0.542659,-0.062835,-0.423347,-0.741695,0.757761,0.416722,0.149994,-0.637211,0.930199,-0.750631,-0.201018,0.522327,1.055747,0.538715,0.353589,1.072976,-1.214588,-0.730772,-0.119262,0.947983,-1.213659,0.897592,-0.086852,0.708532,1.115704,0.953946,0.339752,0.422245,0.902572,-0.884220,-0.461220,-0.118143,0.627600,-0.733727,0.539431,-0.085279,0.314480,0.522363,0.492577},
  {0.238658,-0.325713,0.683345,0.662153,-0.312328,0.141670,-0.456018,0.510445,-0.324706,0.052322,-0.177136,-0.293793,-0.302740,-0.231678,-0.095955,-0.085653,-0.269588,0.366868,0.294596,-0.059700,-0.215871,0.389114,-0.349504,-0.137773,0.115732,0.271103,0.171429,-0.048183,0.038409,-0.099424,-0.171836,0.244441,-0.241386,0.110709,0.148972,-0.405193,-0.499803,-0.324211,0.074044,0.497013,-0.696389,-0.533115,0.059684,-0.491867,0.819731,-0.717715,0.227709,0.414348,-0.853401,-0.853297,-0.399362,0.273118,-0.756228,-0.689755,0.294501,-0.224113,0.588340,0.605501,-0.316897,-0.035234,0.332269,-0.396094,-0.307853,-0.135109,0.045199,0.196384,0.298826,-0.299606,-0.200201,0.006069,-0.238977,0.402876,-0.330796,0.118065,0.183378,0.355515,0.336493,0.168582,-0.153907,0.204345,0.184338,-0.136303,-0.092242,0.011477,0.175090,-0.322196,0.388068,-0.207925,0.126672,0.472077,0.618646,0.441952,0.023331,0.515193,-0.758266,-0.621777,0.148940,0.471662,-0.837462,0.804731,-0.304741,0.358140,0.851089,0.907117},
  {0.048610,-0.110494,0.161952,0.104133,-0.001653,0.067138,-0.050357,-0.046022,0.097975,-0.068261,0.061294,0.192122,0.215505,0.085758,-0.138676,0.316159,0.338182,-0.166906,0.134026,-0.403023,0.459298,-0.279844,-0.089086,-0.434291,-0.569133,-0.402236,0.406136,-0.620071,-0.499177,0.105813,-0.336121,0.593289,-0.558578,0.228328,0.193425,-0.527099,-0.591496,-0.368104,0.034128,0.420211,-0.606770,-0.480808,0.098621,-0.332593,0.584005,-0.539846,0.194590,0.229479,-0.529677,-0.529340,-0.255256,0.127279,-0.199577,-0.146581,0.055198,-0.062419,0.129692,0.059416,0.071647,-0.041495,0.009760,0.143853,0.182784,0.094636,-0.084542,-0.241038,-0.258113,0.143029,-0.121875,0.388281,0.426809,-0.192657,-0.094628,0.442962,-0.495748,-0.315194,0.066355,0.449901,0.473774,-0.032059,0.401613,-0.592549,-0.506050,0.192309,0.293185,-0.542600,0.595817,-0.275576,0.141363,0.497229,0.619993,0.447497,-0.014098,0.398390,-0.577660,-0.491641,0.179962,0.304297,-0.540904,0.561377,-0.206707,0.206660,0.497090,0.520459},
  {0.329631,0.085390,0.155279,0.337096,-0.397070,-0.289100,0.061754,0.147131,-0.325702,0.357417,0.282875,0.097735,-0.157737,-0.400313,-0.510154,0.371058,0.025076,0.374781,0.629449,-0.570720,0.168341,0.296227,-0.624190,-0.609227,-0.309871,0.092575,0.526477,-0.461676,-0.221213,-0.127714,-0.450916,0.611878,-0.539786,0.150159,0.336933,-0.727767,-0.746973,-0.377574,0.192283,0.661710,-0.809532,-0.548728,0.020535,-0.494559,0.764032,-0.712381,0.294084,0.248128,-0.720438,-0.833681,-0.526110,0.056150,-0.275982,-0.398969,0.393178,0.217031,0.059998,0.277007,-0.351863,0.350550,-0.164735,-0.015207,-0.223929,-0.366894,-0.383750,-0.231598,0.070989,-0.376111,-0.568332,0.504240,0.127211,0.373605,-0.633865,0.615253,-0.221558,0.236737,0.550874,0.592268,0.063415,0.287845,0.505213,-0.522479,-0.363050,0.044043,0.412669,-0.668234,0.669803,-0.255234,0.299490,0.731509,0.802104,0.472809,0.112637,0.606930,-0.776904,-0.606672,0.183021,0.386953,-0.728488,0.790952,-0.407226,0.170366,0.686128,0.861443},
  {-0.205897,0.252484,-0.580302,-0.664168,0.443766,-0.044282,0.555088,-0.721213,0.596571,-0.096317,0.423579,0.741274,0.696865,0.314701,-0.209880,0.652469,0.730744,-0.413340,0.067249,-0.463104,0.684334,-0.492822,0.149348,-0.269219,-0.522752,-0.508115,0.106369,-0.361471,-0.463765,0.378190,0.095820,0.237619,-0.355402,0.359657,-0.131707,-0.042496,-0.174771,-0.187778,-0.127107,-0.062684,0.063610,0.017036,0.116463,0.238525,-0.265181,0.229049,0.045807,-0.285323,0.483283,0.395986,0.087480,-0.281311,0.617901,0.635509,-0.320488,0.159880,-0.567450,-0.714589,0.514543,-0.015900,-0.466596,0.749433,0.642310,0.217104,-0.310824,-0.674958,-0.693469,0.379604,-0.129499,0.573749,0.706208,-0.472957,0.052257,0.400056,-0.602150,-0.519795,-0.198019,0.194913,0.523104,-0.317541,0.005606,-0.289358,-0.429924,0.371655,-0.116149,-0.129657,0.303820,-0.277437,-0.149511,-0.001653,0.090067,0.120402,-0.116261,-0.144532,0.177375,0.114616,0.071210,-0.261714,0.395453,-0.290076,0.025977,-0.308698,-0.501019,-0.428071},
  {0.228806,0.651783,-0.754705,-0.517031,0.062580,-0.411345,0.705079,-0.683916,0.364773,0.141923,0.602395,0.795936,0.607027,0.109331,-0.452224,0.790783,0.724613,-0.298801,0.246814,-0.635109,0.708056,-0.453235,0.034625,-0.368320,-0.596854,-0.576354,0.076665,-0.449106,-0.634676,0.531761,0.169110,0.277702,-0.571522,0.586118,-0.319995,-0.055086,-0.363684,-0.483366,-0.405648,-0.197033,-0.054913,-0.289301,0.443924,0.448225,-0.265156,-0.058602,0.415683,-0.613272,0.538309,0.180101,-0.300809,-0.665298,0.762240,0.430393,0.094952,0.546996,-0.731466,-0.601206,0.220080,0.283023,-0.650139,0.756707,0.502353,-0.003862,-0.527534,-0.802239,-0.675130,0.216591,-0.352577,0.737253,0.735186,-0.375675,-0.106342,0.519971,-0.653876,-0.515724,-0.175068,0.226279,0.625668,-0.435662,-0.050284,-0.361423,-0.617166,0.583888,-0.248704,-0.166177,0.492949,-0.544774,-0.365867,-0.061979,0.225350,0.402474,-0.425012,-0.321972,0.114743,-0.171994,0.443082,-0.537773,0.417754,-0.052098,-0.362808,-0.650595,-0.632503,-0.290084},
  {0.234684,-1.286283,2.206141,2.092103,-1.010357,0.500657,-1.724246,2.130249,-1.541226,0.318233,-0.978226,-1.775102,-1.776654,-1.041213,0.087825,-1.133222,-1.702359,1.580861,0.805370,0.316018,-1.306220,1.790491,-1.516206,-0.594869,0.626331,1.643451,1.484296,-0.242598,1.197625,-2.167747,-2.168794,1.121477,0.548180,-2.000482,2.533283,-1.822274,-0.229824,1.476226,2.475947,2.310839,-1.071689,0.641138,-2.049422,-2.537783,1.878652,-0.323051,-1.402105,2.527348,-2.456168,-1.207371,0.648581,2.205867,-2.338876,-1.937363,0.632588,-0.916141,1.986708,2.140091,-1.332996,-0.104819,1.368383,-2.013155,-1.718309,-0.713125,0.525300,1.472468,1.767566,-1.361495,-0.387968,-0.757854,-1.565957,1.708922,-1.204312,0.123670,0.981440,1.738187,1.775768,1.035684,-1.463563,2.107421,1.843681,-0.710106,0.871389,-2.151452,2.384277,-1.515045,-0.183232,1.766193,2.534075,2.080269,0.636321,-1.099282,2.283646,2.438078,-1.506817,0.140190,-1.767755,2.550543,-2.221210,0.775069,1.018298,2.385389,2.608988,1.558061},
  {-0.959177,-1.471207,1.270402,0.524939,0.452798,1.325594,-1.657842,1.065884,-0.056598,-1.146273,-1.759732,-1.536708,-0.576077,0.650923,1.542735,-1.743675,-1.057250,-0.178515,-1.263294,1.688329,-1.441643,0.384453,0.723169,1.531216,1.573595,0.834685,-1.275086,1.524208,1.081294,-0.221115,0.710648,-1.282782,1.111317,-0.618207,-0.185626,0.705053,0.966971,0.845928,0.405451,-0.202684,0.692404,0.985824,-0.935464,-0.411337,-0.382448,0.909112,-1.175789,0.784540,-0.157210,0.614208,1.108562,1.097607,-1.109332,-0.284067,-0.737664,-1.438134,1.469316,0.827189,0.222093,-1.275474,1.685271,-1.340811,-0.299061,0.901014,1.664158,1.611143,0.770857,0.407520,1.406718,-1.755813,-1.247095,0.128243,0.983850,-1.684786,1.518376,0.650196,-0.530757,-1.441931,-1.039755,-0.054483,-1.028383,1.416535,1.140602,-0.409460,-0.472630,0.993306,-1.111330,0.730504,0.138331,-0.472396,-0.897820,-0.993930,0.676707,0.096123,0.532760,0.995468,-1.066037,0.595097,0.103193,-0.839992,1.153386,0.979271,0.351490,-0.455747},
  {-0.392950,0.081548,-0.427969,-0.568011,0.451823,0.063929,0.382398,-0.489760,0.455247,-0.067167,0.295966,0.509348,0.457502,0.169386,-0.190831,0.482274,0.435893,-0.082336,0.263553,-0.388254,0.383572,-0.028863,-0.213744,-0.355534,-0.246509,0.034052,0.393620,-0.185057,0.091444,-0.261026,-0.312903,0.213898,0.141384,-0.301932,0.399164,-0.131569,0.182404,0.425362,0.445392,0.217181,0.206560,0.484650,-0.447473,-0.197464,-0.138701,0.542328,-0.536949,0.340636,0.191891,0.596032,0.697800,0.416301,0.513771,0.643656,-0.423455,0.007835,-0.406962,-0.563187,0.415080,-0.071212,-0.301747,0.493019,0.420881,0.121941,-0.239822,-0.462540,-0.418926,0.129096,-0.226457,0.433361,0.375856,-0.095517,-0.240774,0.404388,-0.318280,-0.034449,0.255734,0.370518,-0.031994,0.278138,0.347252,-0.199057,0.080100,-0.316634,0.349508,-0.171935,-0.131638,0.359713,0.381713,0.167644,-0.165437,-0.423211,0.440897,0.200635,0.172743,0.476651,-0.527761,0.264334,0.163787,-0.538183,0.615933,0.343019,-0.150622,-0.587408},
  {-1.119290,-1.613206,1.276560,0.309049,0.779192,1.448411,-1.384289,0.633587,0.369647,-1.156361,-1.340328,-0.878953,-0.033247,0.768334,1.147885,-0.968151,-0.351243,-0.371072,-0.840947,0.876960,-0.546071,0.016757,0.431338,0.653949,0.594987,0.319254,-0.352418,0.496111,0.458484,-0.278497,-0.021240,-0.230852,0.397280,-0.481957,0.415708,-0.201029,0.174601,0.584639,0.815860,0.668554,-0.123437,0.609327,-1.130383,-1.083196,0.422841,0.509786,-1.241604,1.329363,-0.740880,0.244100,1.112551,1.432438,-1.155684,-0.116011,-0.944937,-1.534876,1.367174,0.501252,0.602001,-1.298055,1.393305,-0.753098,0.184291,0.986575,1.279786,0.958457,0.219886,0.588633,1.027363,-0.925063,-0.442460,-0.148741,0.659888,-0.765964,0.606693,0.206384,-0.212791,-0.493171,-0.399565,0.149285,-0.153291,0.403466,0.474881,-0.370636,0.233224,0.047148,-0.287408,0.561647,0.643493,0.454188,-0.016038,-0.595653,1.009981,0.909634,-0.255522,0.601013,-1.192177,1.245035,-0.562645,-0.384895,1.222685,1.420168,0.913907,-0.037675},
  {0.399592,0.411910,-0.216824,0.039096,-0.214285,-0.261875,0.210851,-0.103335,0.021113,0.073427,0.163257,0.236284,0.238153,0.127831,-0.072412,0.281507,0.371988,-0.283754,-0.060787,-0.200171,0.407213,-0.431468,0.281025,-0.024149,-0.356434,-0.561690,-0.196749,-0.261383,-0.648618,0.742596,0.441007,0.132014,-0.663377,0.891901,-0.638229,0.045852,-0.602415,-0.945610,-0.787051,-0.202392,-0.484825,-0.913312,0.853430,0.338027,0.335404,-0.774993,0.798306,-0.404104,-0.127704,-0.537070,-0.641686,-0.447131,0.235116,-0.072295,0.347078,0.377742,-0.190543,-0.007099,-0.075214,0.199086,-0.156555,0.204715,0.161257,0.059308,-0.094694,-0.238576,-0.284061,0.237785,0.014116,0.284898,0.425328,-0.334847,0.192603,0.156077,-0.360661,-0.475565,-0.368675,-0.054013,0.646349,-0.606499,-0.291701,-0.172699,-0.641668,0.851736,-0.515903,-0.016235,0.675041,-0.901079,-0.697623,-0.098061,0.582974,0.975714,-0.804705,-0.247742,-0.385995,-0.833453,0.864102,-0.347765,-0.207515,0.700191,-0.699490,-0.403723,0.049250,0.427822},
  {1.158625,1.663211,-1.437350,-0.595004,-0.490673,-1.354083,1.645523,-1.262459,0.297953,0.824776,1.643299,1.746410,1.034848,-0.202372,-1.395483,1.953207,1.602015,-0.491260,0.873921,-1.846647,1.939889,-1.147606,-0.199395,-1.448400,-2.030491,-1.673834,0.838734,-1.835695,-1.969097,1.182327,-0.135240,1.370082,-1.984243,1.666802,-0.609902,-0.738547,-1.735587,-1.935812,-1.245558,0.016902,-1.272961,-1.916691,1.651682,0.635558,0.636465,-1.594675,1.780114,-1.187290,0.080857,-1.011270,-1.640743,-1.561711,1.226734,0.213153,0.826278,1.517251,-1.589124,-0.958222,-0.116456,1.086118,-1.702230,1.512336,0.664853,-0.545956,-1.575010,-1.917934,-1.372205,0.120048,-1.185419,1.916905,1.784856,-0.845591,-0.573279,1.650232,-2.041114,-1.450867,-0.196506,1.141044,1.827359,-0.900825,0.473650,-1.654633,-2.028863,1.432549,-0.264018,-1.093213,1.862341,-1.855251,-0.964987,0.356022,1.500038,1.935902,-1.504386,-0.343335,-0.994220,-1.809832,1.736282,-0.952041,-0.307754,1.301989,-1.764213,-1.414856,-0.480979,0.629363},
  {-0.157663,-0.235785,0.224823,0.142054,-0.003462,0.168170,-0.297426,0.276786,-0.159792,-0.073130,-0.285531,-0.393893,-0.328166,-0.090696,0.222839,-0.468229,-0.470340,0.199838,-0.186885,0.472485,-0.527731,0.265879,0.099751,0.398426,0.463200,0.291842,-0.247262,0.351962,0.320860,-0.185023,0.032317,-0.257972,0.357691,-0.328810,0.106458,0.152895,0.353276,0.368019,0.193419,-0.067190,0.258830,0.324955,-0.262611,-0.096592,-0.104096,0.235485,-0.317213,0.247637,-0.087037,0.154041,0.341628,0.361200,-0.176368,-0.062818,-0.073926,-0.204927,0.274243,0.226701,-0.067507,-0.124055,0.294288,-0.334619,-0.231845,-0.003764,0.259797,0.430996,0.402141,-0.147685,0.209254,-0.476077,-0.500467,0.252331,0.151759,-0.452955,0.511194,0.292949,-0.050747,-0.327892,-0.308423,0.096485,-0.134557,0.305904,0.352472,-0.252463,0.049622,0.207958,-0.368827,0.365801,0.169209,-0.110754,-0.322520,-0.360702,0.233108,0.012855,0.191156,0.293799,-0.277271,0.177692,0.007742,-0.196340,0.338148,0.327792,0.148970,-0.123849},
  {-0.459748,-0.558133,0.347615,-0.057391,0.406073,0.464913,-0.214410,-0.121135,0.371752,-0.309352,-0.032781,0.266112,0.360149,0.171929,-0.164696,0.415728,0.356234,-0.005063,0.379902,-0.526990,0.359915,0.092680,-0.485030,-0.611258,-0.368916,0.100714,0.668423,-0.438844,0.006661,-0.434767,-0.659433,0.572043,-0.166145,-0.302619,0.674029,-0.691052,-0.369813,0.169031,0.658437,0.832137,-0.554145,0.024453,-0.601753,-0.884496,0.703605,-0.101737,-0.528679,0.902485,-0.750589,-0.208461,0.437367,0.833270,-0.349020,0.083750,-0.408765,-0.495584,0.309237,-0.070038,0.394563,-0.371372,0.158786,0.206832,0.373914,0.260793,-0.045789,-0.312698,-0.329489,0.103987,-0.259468,0.494958,0.366034,0.062614,-0.425272,0.603598,-0.341168,0.119165,0.537310,0.663626,-0.037585,0.509134,0.685284,-0.481746,-0.062911,-0.363903,0.686848,-0.611939,0.295673,0.255113,0.677820,0.784933,0.495241,-0.066573,0.652739,0.885449,-0.617877,-0.031466,-0.560403,0.921703,-0.716306,0.185701,0.506042,0.885088,0.788361,0.282618},
  {-0.597135,0.082841,-0.738105,-1.060444,0.876985,0.251104,0.519678,-1.038474,1.031313,-0.487843,0.300636,0.912317,1.026476,0.605428,-0.093845,0.682450,0.863294,-0.594043,-0.080360,-0.378461,0.573494,-0.471387,0.207278,-0.054167,-0.211120,-0.262744,-0.226415,0.150128,-0.003892,0.218607,0.403421,-0.441412,0.270781,0.070290,-0.426773,0.623161,0.536846,0.181178,-0.298494,-0.682559,0.775382,0.495495,0.061965,0.645450,-0.956855,0.805533,-0.217716,-0.526210,1.042597,1.033985,0.481865,-0.334268,0.809932,1.004322,-0.782660,-0.126618,-0.663348,-1.096282,0.938296,-0.417313,-0.442109,0.955376,1.015152,0.528963,-0.228308,-0.841769,-0.996216,0.581357,-0.035481,0.503130,0.696830,-0.579831,0.117879,0.182354,-0.430623,-0.410089,-0.276913,-0.129265,0.104385,-0.284910,-0.365399,0.274269,0.098854,0.123716,-0.468872,0.514008,-0.438928,0.010584,-0.414412,-0.700518,-0.693811,-0.366890,-0.223517,-0.708527,0.841841,0.621679,-0.111336,-0.628668,0.981425,-0.967046,0.320800,-0.474133,-1.066529,-1.132578},
  {0.087460,-0.149559,0.361398,0.503148,-0.478952,-0.207235,-0.244219,0.632546,-0.780522,0.504739,-0.057553,-0.639953,-0.927990,-0.757887,-0.209895,-0.457286,-0.898558,0.911586,0.517447,0.110432,-0.737762,1.027866,-0.876361,-0.276196,0.501911,1.076576,0.592321,0.262129,1.007719,-1.241887,-0.820816,-0.017588,0.784745,-1.146485,0.905763,-0.281723,0.432468,0.892466,0.921787,0.545432,0.034753,0.587819,-0.880837,-0.767645,0.299019,0.275796,-0.743165,0.830713,-0.552602,-0.012608,0.507966,0.761545,-0.401818,-0.403658,0.295464,0.036594,0.318555,0.597382,-0.628769,0.372361,0.159241,-0.648122,-0.860613,-0.632566,-0.058222,0.572030,0.935102,-0.833362,-0.347765,-0.289152,-0.813901,0.992204,-0.690983,0.084697,0.632294,1.079468,1.027588,0.455394,-1.058924,1.218637,0.730945,0.151823,0.931749,-1.200571,0.884280,-0.121107,-0.619227,1.041169,0.938859,0.426645,-0.231709,-0.742656,0.919359,0.678465,-0.134457,0.446477,-0.806829,0.826215,-0.432983,-0.125873,0.643427,0.830011,0.623839,0.140891},
  {-1.327593,-0.589403,-0.366904,-1.182466,1.497770,1.107985,-0.186876,-0.744080,1.409264,-1.359346,-0.726096,0.240092,1.099973,1.468348,1.185013,-0.339891,0.622587,-1.271828,-1.381328,0.900912,0.060168,-0.921121,1.440290,1.277101,0.546503,-0.423259,-1.424097,1.038057,0.139860,0.866892,1.452233,-1.333564,0.661059,0.396909,-1.187334,1.480572,1.046714,0.157411,-0.754172,-1.277595,1.255015,0.674314,0.194023,0.930026,-1.252742,1.142602,-0.470269,-0.371386,1.184160,1.474616,1.094232,0.167432,0.650161,1.337671,-1.467556,-0.897009,-0.117897,-1.030834,1.431374,-1.290708,0.458551,0.471585,1.229158,1.412456,0.944397,0.041988,-0.886721,1.366494,1.278714,-0.664013,0.295714,-1.169479,1.409415,-1.120017,0.217473,-0.737237,-1.373896,-1.405478,0.134054,-1.078665,-1.494012,1.180244,0.361526,0.589221,-1.376639,1.409607,-0.884243,-0.152696,-1.046739,-1.441989,-1.182682,-0.427237,-0.520169,-1.157059,1.243378,0.868335,-0.190019,-0.689637,1.206450,-1.341447,0.771173,-0.150238,-1.083166,-1.567593},
  {-0.522963,-0.227346,-0.174051,-0.480329,0.565783,0.433183,-0.150704,-0.209469,0.480977,-0.615638,-0.503441,-0.155057,0.320380,0.710005,0.790288,-0.480379,0.120609,-0.711108,-0.952613,0.706371,-0.127927,-0.533961,0.909809,0.863858,0.417997,-0.218740,-0.971486,0.727087,0.142366,0.524001,0.972112,-0.967512,0.461145,0.258340,-0.876847,1.039516,0.704751,0.034451,-0.640634,-1.001977,0.876689,0.352915,0.320677,0.847264,-0.975871,0.610214,0.023646,-0.653157,0.918369,0.733624,0.206805,-0.375483,0.272536,0.528391,-0.588503,-0.360833,-0.043695,-0.378202,0.520236,-0.553368,0.296918,0.007013,0.389841,0.650231,0.637240,0.296664,-0.255071,0.706267,0.870936,-0.628288,-0.013045,-0.660286,0.928553,-0.823462,0.244412,-0.405451,-0.871317,-0.948868,0.007607,-0.672160,-1.007851,0.839451,0.293777,0.379432,-0.964858,0.999165,-0.622125,-0.139736,-0.789210,-1.058351,-0.829451,-0.225732,-0.507470,-0.956747,0.916162,0.477876,0.150112,-0.781638,0.943045,-0.721064,0.075525,-0.540281,-0.866239,-0.767963},
  {0.554876,0.245149,0.154966,0.471382,-0.550374,-0.339454,-0.012655,0.236409,-0.397127,0.344010,0.218530,0.016278,-0.217389,-0.403884,-0.448370,0.261733,-0.037940,0.315306,0.487759,-0.465411,0.161299,0.155961,-0.477806,-0.567829,-0.416443,-0.076443,0.570577,-0.601697,-0.314683,-0.165711,-0.554263,0.660399,-0.522589,0.071518,0.357241,-0.700988,-0.702872,-0.380328,0.139578,0.618759,-0.843685,-0.611907,0.014556,-0.583526,0.846870,-0.712813,0.138160,0.410929,-0.757381,-0.658839,-0.268089,0.166292,-0.300299,-0.621255,0.505766,0.230398,0.027082,0.319664,-0.529832,0.275264,-0.186507,-0.176433,-0.355451,-0.446061,-0.411221,-0.233707,0.043281,-0.439184,-0.551610,0.306177,0.009757,0.200215,-0.562736,0.438390,-0.355541,-0.003660,0.335711,0.511768,0.113074,0.178506,0.509337,-0.710764,-0.470962,-0.102073,0.400844,-0.756650,0.530596,-0.291794,0.202030,0.596534,0.695748,0.422167,-0.011988,0.538834,-0.929647,-0.730832,0.035792,0.442101,-0.891585,0.617395,-0.269452,0.254665,0.545483,0.507975},
  {-0.820448,-0.349150,-0.335505,-0.825802,0.883965,0.563242,-0.025904,-0.597545,0.851027,-0.811979,-0.381198,0.205425,0.702750,0.894985,0.678615,-0.170145,0.493430,-0.992358,-0.980748,0.434586,0.257943,-0.910128,1.006125,0.630969,-0.046794,-0.665374,-0.761254,0.242655,-0.285124,0.607089,0.707443,-0.576639,0.138158,0.273917,-0.684711,0.732532,0.494218,-0.000532,-0.531601,-0.838982,0.712652,0.284166,0.236883,0.675015,-0.830461,0.520082,-0.076413,-0.473867,0.717127,0.685728,0.350148,-0.145642,0.427708,0.844915,-0.885743,-0.479181,-0.177186,-0.719502,0.894580,-0.710952,0.160263,0.396427,0.797643,0.847015,0.520594,-0.055648,-0.642760,0.941573,0.832302,-0.330142,0.387993,-0.960739,1.003721,-0.588708,-0.171406,-0.798439,-1.006885,-0.723932,0.447494,-0.797150,-0.758351,0.399109,-0.061902,0.452338,-0.720117,0.654337,-0.370488,-0.148533,-0.609740,-0.822408,-0.662711,-0.187346,-0.410469,-0.792473,0.774283,0.418835,0.095383,-0.603147,0.773623,-0.653772,0.201021,-0.305986,-0.682738,-0.772120},
  {-0.320539,-0.778765,0.941497,0.656537,-0.013008,0.673596,-1.076177,1.037805,-0.421501,-0.409690,-1.120654,-1.294240,-0.796539,0.149893,1.061014,-1.419268,-1.065815,0.184885,-0.797750,1.371773,-1.192027,0.489627,0.454003,1.103293,1.210923,0.776510,-0.679245,1.095684,1.006300,-0.454027,0.279853,-0.871259,1.116893,-0.786701,0.131455,0.632350,1.054915,0.964140,0.426050,-0.271781,0.813728,0.920969,-0.589796,-0.060333,-0.415147,0.723591,-0.670451,0.415668,0.029938,0.422901,0.652757,0.636582,-0.806529,-0.437275,-0.165267,-0.742764,1.021647,0.839252,-0.232003,-0.552551,1.127358,-1.183479,-0.633953,0.282520,1.107176,1.393502,0.961032,-0.018076,0.946703,-1.422769,-1.163012,0.322441,0.639917,-1.245355,1.215511,0.621339,-0.216759,-0.902644,-0.888905,0.251084,-0.479223,0.991464,1.064840,-0.656196,-0.066174,0.759431,-1.096074,0.899068,0.275261,-0.459933,-0.941519,-0.951620,0.519920,-0.107162,0.624345,0.822655,-0.660733,0.245741,0.221358,-0.569883,0.677178,0.527423,0.180736,-0.235242},
  {-0.706868,-0.105672,-0.558887,-0.945051,0.875800,0.415441,0.234307,-0.838260,0.986354,-0.695288,-0.037075,0.618083,0.938928,0.784747,0.264838,0.317570,0.739757,-0.838711,-0.553218,0.014703,0.478400,-0.820270,0.738595,0.319940,-0.278489,-0.751655,-0.498246,-0.103553,-0.577760,0.680709,0.454100,-0.085094,-0.277226,0.384022,-0.371952,0.219114,0.083059,-0.059425,-0.220476,-0.367737,0.387598,0.263369,-0.003042,0.338145,-0.591118,0.534384,-0.263605,-0.226374,0.610381,0.761600,0.536104,0.000178,0.693937,0.970986,-0.789189,-0.257940,-0.387586,-0.876967,0.969938,-0.563488,-0.101993,0.749162,1.006866,0.763334,0.158642,-0.487612,-0.860928,0.827319,0.417615,0.160350,0.632355,-0.811078,0.664939,-0.189158,-0.363181,-0.772886,-0.805611,-0.423784,0.674128,-0.778707,-0.485512,-0.002149,-0.418743,0.569420,-0.412551,0.160845,0.090510,-0.214101,-0.277555,-0.296243,-0.255739,-0.115565,-0.108181,-0.363431,0.514788,0.427107,-0.102403,-0.290029,0.621723,-0.660805,0.406835,-0.096112,-0.607010,-0.859124},
  {0.156245,0.331369,-0.424658,-0.212012,-0.198746,-0.431319,0.367329,-0.316290,-0.069506,0.223836,0.356076,0.305117,0.095241,-0.184117,-0.411222,0.372260,0.244580,-0.081665,0.206113,-0.480462,0.338704,-0.235031,-0.160418,-0.393963,-0.478886,-0.386240,0.130930,-0.464251,-0.525972,0.265359,-0.058996,0.308022,-0.624232,0.445721,-0.215853,-0.335965,-0.649594,-0.657266,-0.347151,0.116704,-0.593618,-0.672990,0.322211,-0.100589,0.364678,-0.605669,0.342953,-0.118408,-0.310782,-0.461757,-0.399293,-0.198212,0.322630,0.110835,0.193870,0.402585,-0.397275,-0.202434,-0.078852,0.344853,-0.413790,0.320550,0.073755,-0.198972,-0.380258,-0.390753,-0.220956,-0.042743,-0.306868,0.444932,0.362097,-0.096472,-0.182683,0.401785,-0.407651,-0.248644,0.016270,0.276716,0.413074,-0.203076,0.103496,-0.381858,-0.520251,0.425782,-0.073706,-0.318020,0.601290,-0.554185,-0.224413,0.237675,0.585178,0.629946,-0.333349,0.116813,-0.477516,-0.587006,0.403662,-0.003975,-0.333561,0.496801,-0.371990,-0.100143,0.173440,0.318776},
  {0.974717,0.764542,-0.239328,0.390170,-0.873197,-1.002698,0.690210,-0.028206,-0.673491,1.090684,0.986447,0.402630,-0.373393,-0.956423,-1.071209,0.693802,0.021850,0.627178,0.973165,-0.896487,0.463080,0.167390,-0.727240,-0.998934,-0.844142,-0.302205,0.953545,-1.070317,-0.693072,-0.007442,-0.711287,1.093223,-0.971093,0.425217,0.320169,-0.922771,-1.132133,-0.838050,-0.148596,0.642694,-1.164774,-1.157863,0.593715,-0.285022,1.052653,-1.308538,0.934347,-0.093216,-0.778980,-1.267138,-1.136182,-0.465574,-0.049921,-0.638057,0.893740,0.855498,-0.521751,0.131602,-0.832487,1.026586,-0.903636,0.180210,-0.583054,-1.095611,-1.099538,-0.599843,0.144481,-0.858181,-1.087433,0.762009,0.195317,0.358962,-0.907783,0.922054,-0.711930,-0.119767,0.530667,0.954282,0.469288,0.168824,0.811560,-1.151891,-0.893449,0.159461,0.487061,-1.071312,1.024992,-0.682576,0.041338,0.749714,1.124381,0.974026,-0.424345,0.425637,-1.172603,-1.303871,0.732360,0.053445,-0.977241,1.269759,-1.097502,-0.331092,0.558254,1.138291},
  {0.736832,0.461956,0.038459,0.568603,-0.870896,-0.756030,0.252970,0.373607,-0.851162,0.894895,0.513342,-0.109829,-0.668553,-0.906378,-0.732741,0.232018,-0.352442,0.774469,0.875059,-0.599675,0.016560,0.586696,-0.965709,-0.881943,-0.355766,0.366399,0.995916,-0.581492,0.118961,-0.734409,-0.945781,0.685352,-0.155758,-0.407899,0.718672,-0.722893,-0.431510,0.004943,0.418816,0.661513,-0.651335,-0.360009,-0.109603,-0.544836,0.743831,-0.627263,0.191625,0.323451,-0.713502,-0.760920,-0.456556,0.050664,-0.217075,-0.657858,0.802686,0.605890,-0.127285,0.470650,-0.891561,0.827962,-0.411977,-0.267970,-0.790348,-0.934971,-0.645923,-0.077265,0.500793,-0.868570,-0.827668,0.402643,-0.178929,0.675511,-0.948664,0.733679,-0.212772,0.469151,0.941182,0.945620,-0.268664,0.827185,0.977077,-0.662556,-0.026342,-0.595229,0.830972,-0.730421,0.274290,0.192346,0.564262,0.685125,0.530253,0.163818,0.247376,0.597074,-0.731298,-0.519465,0.034755,0.427346,-0.763721,0.689549,-0.348229,0.182285,0.616348,0.751804},
  {-0.030871,0.637505,-0.973625,-0.818810,0.277779,-0.360813,0.806952,-0.899934,0.552503,0.038885,0.634614,0.926213,0.750859,0.184543,-0.477191,0.864226,0.793233,-0.327953,0.268921,-0.671409,0.671623,-0.380933,-0.042320,-0.351490,-0.461475,-0.391750,-0.002240,-0.213857,-0.357792,0.374570,0.256371,-0.029722,-0.249732,0.409398,-0.417412,0.221938,-0.058059,-0.316337,-0.448451,-0.403180,0.183790,-0.108222,0.361831,0.493332,-0.436300,0.160802,0.190476,-0.520324,0.625886,0.459695,0.043939,-0.453790,1.006371,0.753263,-0.158494,0.497969,-0.906451,-0.866008,0.414558,0.185434,-0.736992,0.911307,0.663576,0.075543,-0.566945,-0.928428,-0.810739,0.258425,-0.388604,0.775682,0.746354,-0.365142,-0.170498,0.504140,-0.584199,-0.394514,-0.101004,0.160296,0.365437,-0.319870,-0.152990,-0.099250,-0.318396,0.406955,-0.362560,0.119059,0.146523,-0.388786,-0.450464,-0.328873,-0.076582,0.205510,-0.428006,-0.468669,0.302949,0.016903,0.283884,-0.528501,0.526639,-0.325216,-0.090348,-0.499167,-0.725205,-0.624933},
  {-1.205887,-1.178369,0.646525,-0.145275,0.840473,1.126855,-0.912974,0.362840,0.360266,-0.885005,-1.046642,-0.754998,-0.131446,0.555536,1.004441,-0.996139,-0.566867,-0.091701,-0.721372,1.050672,-0.890714,0.386835,0.319133,0.879150,1.077891,0.824642,-0.512611,1.062327,1.150907,-0.707976,0.071052,-0.851330,1.316191,-1.143192,0.444767,0.543228,1.293286,1.440516,0.888460,-0.105627,1.074192,1.507955,-1.197595,-0.334279,-0.658266,1.361147,-1.385728,0.808586,0.167566,1.045483,1.448461,1.190083,-0.459742,0.408054,-1.046600,-1.178708,0.789193,0.098458,0.590454,-1.029507,1.006362,-0.582583,0.094979,0.728543,1.045316,0.904213,0.363903,0.326156,0.880251,-1.056058,-0.762115,0.131505,0.530158,-0.985305,1.000067,0.599386,-0.065473,-0.720780,-1.001340,0.458848,-0.307651,0.970805,1.239574,-0.957118,0.182130,0.705355,-1.325194,1.309620,0.661549,-0.338671,-1.203825,-1.497948,1.053689,0.105664,0.879439,1.443256,-1.326099,0.569749,0.415689,-1.216089,1.429261,0.997058,0.105130,-0.842684},
  {0.154396,-0.024123,0.197132,0.283742,-0.223732,-0.027480,-0.194727,0.289944,-0.226120,0.021150,-0.176507,-0.257795,-0.187984,-0.025445,0.127454,-0.197977,-0.150974,0.024483,-0.098712,0.154724,-0.133246,0.018163,0.098630,0.160192,0.110050,-0.028497,-0.194391,0.076266,-0.109409,0.233684,0.209936,-0.039789,-0.189575,0.300652,-0.238323,0.004951,-0.243818,-0.363323,-0.272793,-0.013035,-0.279333,-0.419415,0.311269,0.013049,0.306343,-0.469351,0.339372,-0.011886,-0.340112,-0.479851,-0.331417,0.004745,-0.231590,-0.288365,0.179727,-0.006971,0.178566,0.280245,-0.244358,0.011326,0.168890,-0.294920,-0.221555,-0.037901,0.138026,0.207694,0.147500,-0.040412,0.093736,-0.187182,-0.152278,0.013027,0.075785,-0.172713,0.107160,-0.011619,-0.142310,-0.192505,0.046826,-0.214664,-0.219148,0.041740,-0.163965,0.257188,-0.239316,0.002881,0.200442,-0.348500,-0.265315,-0.022165,0.242806,0.371153,-0.307924,-0.029990,-0.308482,-0.459000,0.317704,-0.030891,-0.342091,0.462045,-0.357051,-0.014589,0.319538,0.441566},
  {0.097992,-0.117012,0.311491,0.338114,-0.182845,0.023130,-0.180913,0.314564,-0.240574,0.141272,-0.028561,-0.168325,-0.241018,-0.230676,-0.131577,-0.007512,-0.212372,0.389842,0.366503,-0.110716,-0.179031,0.475394,-0.461500,-0.212464,0.176929,0.479554,0.286170,0.105594,0.373319,-0.389874,-0.245606,0.056184,0.171055,-0.229686,0.276939,-0.184737,-0.071271,0.097527,0.279847,0.385309,-0.285841,-0.043751,-0.236637,-0.453013,0.463557,-0.148973,-0.194907,0.504940,-0.478212,-0.226625,0.142058,0.427683,-0.303596,-0.283547,0.163014,-0.054157,0.268633,0.333962,-0.223646,0.074531,0.145977,-0.235680,-0.250085,-0.170628,-0.032790,0.125112,0.262362,-0.297068,-0.237861,0.071096,-0.199294,0.436279,-0.410729,0.204129,0.195221,0.486625,0.521071,0.271689,-0.406521,0.482027,0.283475,0.046750,0.277775,-0.318118,0.275293,-0.102253,-0.016507,0.176851,0.274149,0.304188,0.219703,0.011760,0.276314,0.444379,-0.370410,-0.104092,-0.225271,0.506305,-0.466402,0.224655,0.189574,0.473020,0.508150,0.291307},
  {0.911307,0.328061,0.432915,0.966694,-1.019714,-0.618702,-0.035666,0.705680,-0.973741,0.849719,0.337790,-0.288010,-0.760369,-0.894797,-0.647835,0.153875,-0.437650,0.879078,0.921171,-0.526973,-0.062880,0.696265,-0.967037,-0.822552,-0.293709,0.378457,1.010377,-0.655813,-0.028407,-0.597306,-0.990028,0.964332,-0.438855,-0.244528,0.881621,-1.060047,-0.770939,-0.117761,0.593745,1.036285,-0.982366,-0.511706,-0.162586,-0.791507,1.096471,-0.854466,0.271638,0.508801,-1.015387,-1.077907,-0.620380,0.146453,-0.568815,-1.005086,1.008834,0.508872,0.258063,0.859998,-1.014457,0.771345,-0.114909,-0.487856,-0.879102,-0.865997,-0.479192,0.105172,0.645660,-0.881644,-0.780266,0.371856,-0.248293,0.811080,-0.946105,0.728136,-0.094515,0.558304,0.971769,0.955806,-0.144347,0.780024,1.039995,-0.803709,-0.233275,-0.423095,0.976315,-1.012854,0.655413,0.087279,0.760710,1.092046,0.929683,0.354396,0.409439,0.951733,-1.034174,-0.687856,0.061765,0.680286,-1.051833,1.022346,-0.436108,0.337034,0.974096,1.163059},
  {-0.426434,0.615254,-1.317257,-1.416053,0.913149,0.045370,0.813640,-1.299486,1.230228,-0.628482,0.236734,0.995518,1.317685,1.062187,0.342256,0.527039,1.156647,-1.272645,-0.835982,0.043068,0.769753,-1.242160,1.189335,0.624406,-0.215049,-0.979217,-1.123989,0.401037,-0.539651,1.280463,1.458531,-0.958722,-0.003781,0.998633,-1.536392,1.365720,0.554165,-0.512418,-1.339837,-1.556966,1.079594,0.117653,0.911250,1.555089,-1.518579,0.793303,0.346444,-1.381107,1.815545,1.379071,0.234916,-1.074087,1.535410,1.414777,-0.675001,0.292654,-1.068427,-1.373971,1.105559,-0.341819,-0.517803,1.180328,1.312996,0.879211,0.067640,-0.766290,-1.255934,1.206974,0.613538,0.259319,0.996617,-1.280183,1.044712,-0.325740,-0.497563,-1.129051,-1.280959,-0.880007,0.788491,-1.327808,-1.308398,0.704035,-0.270546,1.174467,-1.521979,1.196591,-0.264449,-0.768399,-1.463860,-1.478079,-0.812080,0.222402,-1.139623,-1.569052,1.323062,0.466026,0.645803,-1.476540,1.700556,-1.094224,-0.040732,-1.235539,-1.870171,-1.586342},
  {1.199620,1.254029,-0.622051,0.366531,-1.168010,-1.346369,0.816566,0.122827,-0.936605,1.241682,0.925050,0.209906,-0.534231,-0.983103,-0.981872,0.573181,-0.069947,0.684555,1.001390,-0.866024,0.330296,0.389438,-0.920763,-1.001392,-0.578980,0.122062,0.938568,-0.669100,-0.114428,-0.417806,-0.687967,0.622236,-0.305496,-0.057432,0.339543,-0.453870,-0.425044,-0.279702,-0.049585,0.222011,-0.450475,-0.539956,0.408509,0.058139,0.374189,-0.662694,0.663059,-0.329282,-0.169372,-0.609443,-0.775909,-0.592664,0.495619,-0.452542,1.213016,1.332602,-0.726983,0.257221,-1.076026,1.322145,-0.870469,0.039242,-0.749262,-1.119466,-0.953386,-0.384823,0.309242,-0.830526,-0.994914,0.739548,0.146759,0.535850,-0.970134,0.966145,-0.470521,0.254093,0.845953,0.999956,0.008280,0.589728,0.836422,-0.656666,-0.215223,-0.237960,0.527570,-0.544844,0.383594,-0.112801,0.146755,0.349834,0.458264,0.431568,-0.232936,0.088952,-0.421560,-0.619542,0.553266,-0.190078,-0.282022,0.667038,-0.732332,-0.460911,0.032546,0.522307},
  {-0.123275,0.611860,-1.049966,-1.022074,0.528790,-0.252117,0.941721,-1.114454,0.826282,-0.094357,0.635899,1.067276,1.017335,0.525189,-0.181608,0.830935,1.085673,-0.833452,-0.233299,-0.459607,1.029176,-1.068463,0.668866,-0.091004,-0.811753,-1.136538,-0.226453,-0.511806,-1.010075,1.046444,0.577818,0.151700,-0.710858,1.002305,-0.793240,0.322329,-0.308187,-0.802616,-0.949958,-0.672103,0.109694,-0.551221,1.001005,0.958325,-0.433828,-0.228136,0.839122,-0.981660,0.737101,0.145775,-0.474877,-0.856546,1.094715,0.950574,-0.311318,0.463237,-0.997106,-1.088496,0.691093,0.104176,-0.767151,1.132918,0.938639,0.332705,-0.397759,-0.925900,-1.027850,0.709865,0.047675,0.674122,1.074993,-0.966611,0.483869,0.315368,-0.915175,-1.124020,-0.783826,-0.050855,1.136866,-0.973825,-0.387682,-0.320549,-0.876558,1.043483,-0.674223,0.106189,0.556249,-0.894400,-0.884409,-0.488774,0.135269,0.726100,-0.975447,-0.816154,0.302698,-0.395638,0.944648,-0.973872,0.619373,0.084801,-0.654235,-0.938284,-0.789740,-0.300021},
  {-0.685053,-0.282160,-0.342027,-0.728243,0.674653,0.348597,0.078478,-0.618303,0.654365,-0.525237,-0.087966,0.318738,0.506625,0.431238,0.176902,0.029443,0.277773,-0.505136,-0.476630,0.174794,0.064480,-0.492353,0.536677,0.372566,-0.037563,-0.465255,-0.491005,0.002526,-0.361912,0.394080,0.264820,-0.120140,-0.155462,0.105307,-0.175498,0.070863,0.102123,0.101636,-0.009759,-0.220584,0.312686,0.332309,-0.223080,0.118157,-0.503041,0.471295,-0.362059,-0.114034,0.379821,0.543446,0.420571,0.060778,0.414799,0.746566,-0.651446,-0.285058,-0.170909,-0.596063,0.767717,-0.409528,-0.005856,0.519969,0.682611,0.524006,0.167801,-0.191536,-0.406365,0.506884,0.365992,-0.039456,0.250391,-0.410137,0.557181,-0.302770,0.000713,-0.397043,-0.577746,-0.415766,0.416861,-0.505920,-0.352709,0.098373,-0.182845,0.346342,-0.182225,0.130688,0.017547,0.042112,-0.000501,-0.109997,-0.228724,-0.238526,0.147433,-0.141454,0.463079,0.499360,-0.202967,-0.089108,0.493175,-0.523714,0.429148,0.054627,-0.343289,-0.569757},
  {-0.350390,1.126778,-2.114436,-2.058391,0.925718,-0.736814,2.042059,-2.249866,1.356246,0.213688,1.594348,2.151639,1.679032,0.464699,-0.894734,1.807456,1.860011,-1.063085,0.170766,-1.280717,1.826555,-1.497164,0.536825,-0.657273,-1.515881,-1.661529,0.005835,-1.005745,-1.538645,1.392717,0.632508,0.381301,-1.146250,1.431333,-1.074487,0.333602,-0.535731,-1.174832,-1.342907,-0.964598,0.181343,-0.750081,1.431600,1.483709,-0.817470,-0.245120,1.274242,-1.667263,1.288791,0.279410,-0.824456,-1.493588,2.010834,1.817118,-0.677767,0.930547,-2.149023,-2.231693,1.120861,0.472820,-1.868996,2.211165,1.497819,0.096590,-1.285990,-2.014894,-1.803818,0.755791,-0.555090,1.538526,1.840315,-1.344398,0.173484,0.968386,-1.725855,-1.649243,-0.841591,0.308585,1.623251,-1.278540,-0.350468,-0.727768,-1.407932,1.414547,-0.899726,-0.047605,0.850741,-1.356657,-1.267619,-0.683482,0.168664,0.966760,-1.436052,-1.275240,0.494599,-0.535981,1.349898,-1.642804,1.062141,-0.027741,-1.108517,-1.662633,-1.427402,-0.560913},
  {-0.052757,0.411957,-0.605953,-0.539164,0.286183,-0.083154,0.411448,-0.469256,0.440173,-0.173559,0.116936,0.387188,0.533279,0.475815,0.211133,0.210256,0.523367,-0.571657,-0.393097,0.063273,0.389401,-0.588189,0.612862,0.325675,-0.105892,-0.497212,-0.534755,0.176137,-0.327778,0.740239,0.776784,-0.399534,-0.102257,0.655937,-0.817062,0.667902,0.155863,-0.422959,-0.787400,-0.761987,0.409710,-0.169685,0.697278,0.851356,-0.566924,0.109839,0.468708,-0.732371,0.740489,0.380249,-0.130341,-0.563766,0.716084,0.571567,-0.166362,0.260811,-0.513632,-0.531321,0.350572,-0.040470,-0.235818,0.440544,0.479249,0.341787,0.058227,-0.274402,-0.513190,0.545931,0.315474,0.085717,0.453763,-0.612938,0.516637,-0.161579,-0.251097,-0.572006,-0.645043,-0.428264,0.450973,-0.711829,-0.660763,0.298354,-0.238560,0.693923,-0.805380,0.548194,0.005556,-0.544288,-0.834468,-0.719999,-0.255912,0.332416,-0.748679,-0.814206,0.503113,-0.048553,0.575116,-0.799522,0.670834,-0.217872,-0.298479,-0.675878,-0.740394,-0.472054},
  {0.705513,-0.566376,1.491469,1.713380,-1.140730,0.017989,-1.171283,1.588120,-1.359213,0.395805,-0.637578,-1.338200,-1.420802,-0.889265,-0.007702,-0.897078,-1.320865,1.088585,0.430339,0.341035,-1.047599,1.125765,-0.823728,-0.138072,0.531096,0.906380,0.507076,-0.035686,0.488336,-0.898442,-0.931519,0.541845,-0.017830,-0.708216,1.054751,-1.068158,-0.507481,0.321721,1.021514,1.236872,-0.919314,-0.107539,-0.813813,-1.308343,1.155589,-0.610031,-0.340347,1.029859,-1.406891,-1.106306,-0.303370,0.665631,-1.633219,-1.708065,0.956253,-0.280059,1.370418,1.730824,-1.217265,0.208389,0.897923,-1.466823,-1.357668,-0.639029,0.328929,1.108544,1.372755,-0.997188,-0.219464,-0.604137,-1.154492,1.191739,-0.635103,-0.117529,0.825812,1.098445,0.890963,0.346367,-0.734752,0.923694,0.750827,-0.279359,0.291026,-0.767408,1.034575,-0.811006,0.250777,0.546817,1.121399,1.199207,0.706343,-0.138669,0.963281,1.318017,-1.035133,-0.301756,-0.543927,1.208614,-1.282269,0.845978,0.040918,0.916116,1.421466,1.303793},
  {-1.480469,-1.096777,0.198423,-0.778531,1.404794,1.436343,-0.831680,-0.238092,1.173042,-1.635015,-1.305634,-0.358288,0.760398,1.517206,1.553779,-0.888247,0.212034,-1.233284,-1.654338,1.281873,-0.370672,-0.764066,1.476757,1.514118,0.837619,-0.216934,-1.521208,1.176491,0.354076,0.558219,1.219203,-1.371473,0.889497,-0.089309,-0.817119,1.332902,1.295703,0.657684,-0.315411,-1.174112,1.467732,1.092352,-0.228664,0.751168,-1.385128,1.317955,-0.723291,-0.223209,0.993052,1.349487,1.119321,0.396743,0.123406,1.025226,-1.441022,-1.261662,0.549657,-0.474537,1.353399,-1.540531,1.099692,-0.035658,1.028952,1.633279,1.481028,0.640809,-0.488540,1.425039,1.655817,-1.078283,-0.041732,-0.971549,1.618113,-1.417989,0.646165,-0.455424,-1.311865,-1.525897,-0.059248,-0.845090,-1.371677,1.320694,0.672309,0.278769,-1.006850,1.398962,-1.106305,0.413462,-0.528995,-1.252771,-1.406820,-0.890895,-0.017551,-0.962248,1.487112,1.272173,-0.439178,-0.477816,1.239393,-1.346886,0.959808,0.129204,-0.742525,-1.289751},
  {0.949319,1.958542,-2.086645,-1.145520,-0.381985,-1.601619,1.956018,-1.577989,0.335202,0.831044,1.662463,1.718610,0.999058,-0.171313,-1.278575,1.731920,1.478025,-0.627991,0.578949,-1.578241,1.656600,-1.153920,-0.017986,-1.051135,-1.596070,-1.457754,0.223972,-1.155497,-1.533369,1.208410,0.451817,0.449497,-1.377981,1.551562,-1.208114,0.114851,-0.985910,-1.679650,-1.633866,-0.862815,-0.382112,-1.383560,1.694927,1.332395,-0.447619,-0.837125,1.602300,-1.846592,1.071949,-0.151166,-1.378089,-2.027874,1.927508,0.802898,0.661587,1.796882,-2.072780,-1.349306,0.010445,1.221043,-1.903506,1.658814,0.716150,-0.518258,-1.504659,-1.821656,-1.335399,0.228938,-0.954927,1.674847,1.644120,-0.882669,-0.318398,1.281128,-1.682533,-1.299973,-0.383200,0.638970,1.458647,-1.011262,-0.134408,-0.831164,-1.450621,1.449537,-0.869176,-0.184699,1.145822,-1.673279,-1.419077,-0.510049,0.641259,1.503671,-1.712766,-1.127256,0.009218,-1.100440,1.713486,-1.629599,0.753761,0.439242,-1.532969,-1.935709,-1.455820,-0.275946},
  {0.342560,-0.376770,0.808083,0.818341,-0.410699,0.292153,-0.880047,0.804456,-0.429163,-0.338930,-0.847608,-0.901211,-0.466478,0.212474,0.744558,-0.906270,-0.471743,-0.299714,-0.818062,0.777424,-0.434663,-0.294972,0.666236,0.697042,0.311393,-0.245034,-0.717962,0.326348,-0.162737,0.488669,0.611518,-0.460068,-0.112114,0.474412,-0.718032,0.376850,-0.135252,-0.593038,-0.707131,-0.407081,-0.200520,-0.603966,0.558113,0.235727,0.147701,-0.576093,0.503881,-0.300780,-0.221565,-0.557245,-0.615526,-0.353027,-0.827137,-0.856773,0.384611,-0.331464,0.861440,0.866846,-0.357761,-0.306485,0.828796,-0.838576,-0.391852,0.283485,0.805702,0.873544,0.441966,0.264811,0.796657,-0.836925,-0.399500,-0.244028,0.760673,-0.773229,0.380550,-0.219594,-0.651830,-0.690522,0.171058,-0.554817,-0.645954,0.405273,-0.072368,0.530194,-0.652614,0.438451,0.081305,-0.520335,-0.662011,-0.387359,0.133693,0.570338,-0.624988,-0.307054,-0.169248,-0.536242,0.582341,-0.246077,-0.178044,0.527572,-0.535802,-0.262321,0.172567,0.538993},
  {0.541989,0.777160,-0.672731,-0.285101,-0.211712,-0.611871,0.756947,-0.588409,0.195416,0.295975,0.693021,0.835194,0.627077,0.106783,-0.526956,0.978590,0.981966,-0.483850,0.292303,-0.958648,1.175307,-0.800246,0.032431,-0.759189,-1.182708,-1.038333,0.425270,-1.046219,-1.177007,0.754129,-0.029955,0.798810,-1.169804,0.987774,-0.337691,-0.438072,-0.984740,-1.062316,-0.665024,0.007786,-0.653474,-1.010820,0.932706,0.437970,0.270462,-0.867019,1.081464,-0.772824,0.092054,-0.639342,-1.048085,-0.935619,0.531111,0.073723,0.347302,0.676586,-0.776432,-0.487130,-0.059662,0.428892,-0.778268,0.679866,0.370654,-0.138751,-0.661009,-0.961470,-0.859113,0.260735,-0.460523,0.950618,1.058353,-0.694805,-0.180483,0.842325,-1.241197,-0.973104,-0.254780,0.563487,1.084153,-0.627717,0.187745,-0.976856,-1.238097,0.846051,-0.199550,-0.671694,1.060825,-1.084916,-0.551184,0.188611,0.794088,1.011651,-0.850122,-0.261878,-0.503671,-0.992436,0.982200,-0.665240,-0.122770,0.725907,-1.130743,-0.921635,-0.284880,0.452006},
  {-1.235232,-0.221399,-0.878669,-1.578520,1.561053,0.818112,0.305415,-1.257160,1.664874,-1.287172,-0.334183,0.779656,1.545885,1.609215,0.934427,0.187609,1.213644,-1.666109,-1.358086,0.433471,0.715907,-1.496344,1.604140,0.956569,-0.117514,-1.111364,-1.294459,0.458217,-0.564489,1.310632,1.442218,-0.932183,0.068302,0.829168,-1.329457,1.289885,0.687472,-0.213695,-1.034467,-1.413771,1.182645,0.397409,0.600297,1.330028,-1.447743,0.931294,0.042976,-0.972316,1.492047,1.328623,0.572271,-0.442476,1.144506,1.677668,-1.407836,-0.511682,-0.590781,-1.437303,1.646432,-1.055931,0.037294,1.049880,1.639659,1.489221,0.661622,-0.468515,-1.382024,1.682713,1.183234,-0.112839,0.987190,-1.604346,1.524819,-0.688825,-0.407203,-1.321709,-1.604287,-1.136761,0.876341,-1.455097,-1.383302,0.724434,-0.246896,1.097292,-1.398763,1.147395,-0.364172,-0.515177,-1.197939,-1.365667,-0.934729,-0.074276,-0.819681,-1.388872,1.360087,0.684582,0.337754,-1.165110,1.515926,-1.127437,0.278855,-0.719218,-1.392368,-1.440716},
  {-0.196630,-0.265437,0.204814,0.070146,0.058964,0.127060,-0.139169,0.136640,-0.076090,-0.001373,-0.099238,-0.156484,-0.135693,-0.047916,0.052366,-0.101054,-0.106203,0.094240,0.069470,-0.023536,-0.038406,0.151174,-0.210852,-0.167779,0.007019,0.226303,0.255756,0.005325,0.263505,-0.353265,-0.240146,0.011594,0.208074,-0.268692,0.208465,-0.061696,0.062556,0.142535,0.182712,0.183850,-0.115832,0.013860,-0.170545,-0.288097,0.277763,-0.087636,-0.162284,0.369665,-0.370803,-0.173001,0.136516,0.389499,-0.220448,-0.023654,-0.119907,-0.185065,0.180201,0.109649,-0.009215,-0.046755,0.134097,-0.144380,-0.112477,-0.018775,0.091444,0.156473,0.145713,-0.060210,0.009497,-0.034870,-0.067112,0.124098,-0.128229,0.115652,0.027412,0.194540,0.296014,0.233452,-0.238320,0.372799,0.266914,0.011784,0.254253,-0.316377,0.235405,-0.018078,-0.128158,0.218239,0.197175,0.129291,0.042514,-0.059280,0.185651,0.249721,-0.192000,-0.034460,-0.163905,0.346220,-0.319704,0.147248,0.163329,0.390619,0.421488,0.226712},
  {-0.527977,-0.075099,-0.404506,-0.656091,0.600730,0.343054,0.011200,-0.431607,0.619321,-0.625091,-0.326499,0.126310,0.533602,0.699468,0.536478,-0.155457,0.323907,-0.683672,-0.711218,0.403542,0.007361,-0.490408,0.709773,0.661810,0.306970,-0.220030,-0.865064,0.608965,0.081103,0.471910,0.841901,-0.850778,0.397236,0.175340,-0.744765,0.919501,0.709294,0.152062,-0.514361,-0.979500,0.961871,0.495537,0.211633,0.864035,-1.118820,0.741462,-0.060783,-0.701074,1.026860,0.869266,0.298223,-0.388389,0.539301,0.713028,-0.578792,-0.215344,-0.213970,-0.535835,0.638206,-0.498906,0.143625,0.279128,0.607551,0.679692,0.442722,-0.008353,-0.466192,0.709499,0.634741,-0.282638,0.192109,-0.584246,0.719610,-0.561438,0.148486,-0.344631,-0.714180,-0.782127,0.050165,-0.597834,-0.876484,0.740328,0.254347,0.353323,-0.812105,0.893544,-0.577970,-0.017539,-0.620591,-0.962890,-0.869486,-0.354026,-0.367270,-0.938582,1.058366,0.649840,0.092615,-0.801232,1.091610,-0.841074,0.177221,-0.539014,-0.963307,-0.915701},
  {-0.298113,-0.481044,0.390510,0.084398,0.246507,0.413680,-0.362852,0.181156,0.066089,-0.253798,-0.355483,-0.326636,-0.156450,0.112880,0.370303,-0.465463,-0.333544,0.019461,-0.330131,0.523119,-0.430086,0.138106,0.229186,0.466226,0.480460,0.279275,-0.342313,0.503435,0.428839,-0.134958,0.238165,-0.505644,0.538924,-0.267784,-0.140142,0.494330,0.570480,0.335503,-0.072154,-0.417092,0.518967,0.324686,0.032528,0.323047,-0.390053,0.248728,0.014593,-0.191940,0.222135,0.106879,-0.022012,-0.055153,-0.376995,-0.054082,-0.283183,-0.454883,0.384391,0.124556,0.169267,-0.331294,0.367477,-0.243850,-0.044294,0.186656,0.370162,0.414919,0.265836,0.050451,0.364886,-0.501790,-0.389592,0.078754,0.296990,-0.494519,0.466003,0.207352,-0.133941,-0.400831,-0.344365,0.057003,-0.281108,0.513520,0.493717,-0.208566,-0.179459,0.512046,-0.554315,0.317408,-0.102342,-0.454877,-0.542956,-0.326904,-0.042862,-0.366713,0.468631,0.296786,0.020605,-0.252619,0.319622,-0.174277,-0.008289,-0.124076,-0.102277,-0.005082},
  {-0.016854,-0.072522,0.081754,-0.013328,0.161494,0.236605,-0.164692,-0.003998,0.222998,-0.317811,-0.253368,-0.040130,0.212763,0.369326,0.341251,-0.124893,0.150427,-0.341198,-0.368067,0.221589,0.049117,-0.262252,0.366174,0.294711,0.105654,-0.118020,-0.355124,0.284089,0.065155,0.229220,0.445850,-0.453686,0.239577,0.160378,-0.492902,0.601103,0.367417,-0.081791,-0.496910,-0.640278,0.442508,-0.001200,0.442742,0.626458,-0.465551,0.092334,0.330570,-0.538158,0.477585,0.166004,-0.205134,-0.434369,-0.083967,-0.051569,-0.156065,-0.220780,0.064701,-0.080663,0.136017,-0.344034,0.156726,-0.072324,0.159881,0.290584,0.240591,0.027802,-0.240048,0.302949,0.301163,-0.234155,0.038647,-0.376172,0.314597,-0.312265,-0.036588,-0.263301,-0.393108,-0.383619,-0.024670,-0.320502,-0.460166,0.312003,0.090555,0.127594,-0.533613,0.476827,-0.363656,-0.181436,-0.569651,-0.691249,-0.463995,-0.009170,-0.537507,-0.701057,0.398681,-0.020482,0.323600,-0.646139,0.417363,-0.187575,-0.325026,-0.555336,-0.511440,-0.235662},
  {-0.591909,-1.458903,1.661470,0.996381,0.173855,1.116061,-1.389662,1.155362,-0.240869,-0.527054,-1.030384,-0.986910,-0.501224,0.133884,0.620475,-0.703302,-0.592745,0.403116,0.056520,0.369659,-0.523878,0.724338,-0.499481,-0.122014,0.403192,0.854506,0.692577,0.044087,0.742061,-1.066605,-0.993340,0.527817,0.389964,-1.006561,1.379592,-0.957927,-0.135318,0.844416,1.526073,1.545436,-0.727275,0.441534,-1.404826,-1.801521,1.374610,-0.042007,-1.200212,2.048676,-1.697483,-0.543356,0.931001,1.967778,-1.615610,-0.779839,-0.363582,-1.285705,1.561141,1.065895,-0.087960,-0.813127,1.292218,-1.088650,-0.429576,0.338896,0.851595,0.929034,0.628250,-0.133405,0.295966,-0.538160,-0.615106,0.545587,-0.278628,-0.065447,0.493233,0.779953,0.780751,0.425147,-0.769544,1.069818,0.866190,-0.218920,0.555642,-1.102087,1.213700,-0.729930,-0.082379,0.958629,1.434967,1.274328,0.490564,-0.596512,1.499436,1.707151,-1.050891,0.168433,-1.362336,1.964820,-1.544828,0.354891,1.094884,1.999284,1.901708,0.841070},
  {-1.173645,-1.465979,0.948277,-0.000745,0.884914,1.357869,-1.190860,0.310318,0.569932,-1.257249,-1.247218,-0.649837,0.209577,0.899928,1.103913,-0.833304,-0.145621,-0.615706,-0.992314,0.837104,-0.436774,-0.255569,0.659730,0.783653,0.525685,0.039948,-0.654000,0.513206,0.235148,0.013752,0.243921,-0.413692,0.334202,-0.323428,0.091461,0.078592,0.349666,0.522614,0.461664,0.131492,0.268979,0.643470,-0.777200,-0.470994,-0.133641,0.562766,-0.867671,0.656065,-0.275906,0.301519,0.763856,0.900971,-0.864930,0.118574,-1.045653,-1.430959,1.081484,0.192084,0.771507,-1.324127,1.198000,-0.489337,0.427505,1.089923,1.190508,0.717057,-0.064721,0.762179,1.059331,-0.850683,-0.268201,-0.396239,0.832673,-0.864738,0.500482,-0.061231,-0.547101,-0.738533,-0.187271,-0.221884,-0.463959,0.479169,0.330790,-0.122927,-0.079364,0.251727,-0.389146,0.435855,0.323124,0.026589,-0.359997,-0.643204,0.637849,0.302504,0.217809,0.664034,-0.805340,0.563479,-0.057642,-0.487279,0.827334,0.816728,0.441531,-0.164174},
  {-1.175984,-1.377414,0.815653,-0.115598,0.876772,1.114480,-0.779296,0.077910,0.496865,-0.769685,-0.633595,-0.270879,0.104979,0.345096,0.407413,-0.353156,-0.197689,-0.004469,-0.169055,0.270776,-0.356079,0.297814,-0.173640,0.072377,0.341903,0.514410,0.192160,0.218423,0.606407,-0.762900,-0.536388,0.000322,0.543438,-0.912977,0.819245,-0.357612,0.339430,0.917071,1.073040,0.691833,0.049122,0.829490,-1.243673,-1.019703,0.250262,0.620342,-1.233813,1.194631,-0.610301,0.289054,1.043473,1.295081,-0.792593,0.216935,-1.027831,-1.252964,0.826908,0.009294,0.722657,-0.936556,0.717429,-0.165414,0.322999,0.571348,0.542785,0.330311,0.065589,0.183437,0.311711,-0.315641,-0.268527,0.183117,0.018107,-0.183536,0.382005,0.446494,0.343526,0.067929,-0.575380,0.646700,0.378867,0.138219,0.622212,-0.825863,0.697088,-0.155552,-0.452977,0.945137,0.983405,0.542076,-0.197937,-0.884599,1.190834,0.882353,-0.083114,0.768283,-1.232332,1.136413,-0.413759,-0.465374,1.170814,1.282765,0.783550,-0.086194},
  {-0.901220,-1.147233,0.922079,0.219391,0.621657,1.080499,-0.953699,0.533242,0.230730,-0.684575,-0.844713,-0.614727,-0.155457,0.311137,0.618237,-0.621912,-0.495855,0.286004,-0.104467,0.575544,-0.740170,0.768727,-0.287306,0.343058,0.918243,1.122800,0.048656,0.837908,1.284898,-1.041639,-0.330912,-0.498547,1.234679,-1.235923,0.786306,0.175748,0.993068,1.367088,1.127433,0.382106,0.612475,1.278093,-1.298533,-0.768116,-0.082997,1.060119,-1.405138,1.214113,-0.284618,0.731358,1.410001,1.415275,-0.772022,0.003875,-0.787844,-1.155541,0.944586,0.333897,0.367839,-0.922773,0.946512,-0.613964,-0.025297,0.491245,0.732547,0.656472,0.354223,-0.005392,0.351718,-0.633792,-0.693355,0.478026,-0.112326,-0.451018,0.830048,0.906741,0.530783,-0.175489,-1.210288,0.913388,0.165493,0.669150,1.225893,-1.216380,0.539601,0.331374,-1.115242,1.299389,0.904540,0.078899,-0.796126,-1.319711,1.207766,0.562292,0.331679,1.124256,-1.432824,0.988381,-0.125186,-0.888262,1.411374,1.277931,0.508667,-0.513807},
  {0.764988,1.086086,-0.894112,-0.226235,-0.589640,-1.089845,1.009913,-0.464949,-0.380383,0.958677,1.043549,0.566870,-0.192783,-0.810153,-0.964395,0.583360,-0.024582,0.508358,0.687928,-0.539250,0.127342,0.192633,-0.411817,-0.408294,-0.277694,-0.096649,0.219936,-0.318967,-0.281446,0.108379,-0.084009,0.215007,-0.316470,0.233592,-0.133806,-0.061658,-0.204714,-0.299883,-0.322256,-0.242710,0.013933,-0.256138,0.455125,0.505433,-0.319244,-0.150772,0.565378,-0.799560,0.558903,0.004360,-0.622627,-0.973093,0.777284,0.069704,0.681642,1.097291,-0.961549,-0.337053,-0.464318,1.035589,-1.059083,0.532690,-0.265010,-0.894023,-1.020715,-0.604272,0.091717,-0.666857,-0.837525,0.572313,0.072589,0.371028,-0.551409,0.463008,-0.207365,0.058061,0.242065,0.317906,0.190974,-0.023454,0.155646,-0.280404,-0.299957,0.202023,-0.021549,-0.149885,0.261986,-0.275555,-0.210147,-0.081574,0.090397,0.271476,-0.391746,-0.373046,0.165141,-0.191742,0.538052,-0.658757,0.443504,0.063655,-0.604530,-0.881052,-0.697929,-0.112063},
  {-1.172178,-1.036000,0.417729,-0.391754,1.007087,1.135263,-0.724854,-0.009115,0.712519,-1.048943,-0.887096,-0.334548,0.327046,0.794812,0.886382,-0.601174,-0.096697,-0.409052,-0.729197,0.758855,-0.492504,0.034347,0.455076,0.778885,0.791699,0.460747,-0.645841,0.933314,0.804767,-0.296343,0.370311,-0.891219,1.023087,-0.683593,0.018513,0.683800,1.094403,1.010734,0.448808,-0.348546,1.013765,1.217490,-0.840820,-0.047599,-0.787802,1.261541,-1.128104,0.451938,0.446581,1.127368,1.266673,0.805442,-0.240253,0.562922,-1.126308,-1.126817,0.568219,-0.218793,0.853881,-1.134029,0.808039,-0.189288,0.508263,0.922274,0.888166,0.461744,-0.134227,0.595015,0.806139,-0.714630,-0.322530,-0.209908,0.585708,-0.805292,0.639477,0.234243,-0.302507,-0.750644,-0.664478,0.078592,-0.543916,0.916041,0.911467,-0.514104,-0.205087,0.787343,-1.095899,0.839473,0.213237,-0.547166,-1.091026,-1.150350,0.635175,-0.173733,0.898567,1.241678,-1.021203,0.233664,0.610693,-1.234461,1.198695,0.617919,-0.261769,-1.016504},
  {0.364955,0.080699,0.262800,0.419487,-0.383034,-0.336077,0.245075,0.182702,-0.439143,0.737152,0.618263,0.180984,-0.382447,-0.779745,-0.786466,0.476708,-0.163194,0.831698,1.056469,-0.714980,0.190441,0.650874,-1.055357,-1.043416,-0.467423,0.420290,1.353154,-0.755569,0.171618,-0.928953,-1.262522,1.019400,-0.112835,-0.623686,1.186534,-0.992217,-0.430931,0.315039,0.910535,1.102839,-0.715430,-0.080748,-0.508607,-0.926636,0.972816,-0.379975,-0.198180,0.826051,-0.861078,-0.570485,-0.022385,0.517877,-0.389274,-0.460307,0.383890,0.211596,0.014990,0.259456,-0.467848,0.553964,-0.388893,-0.000181,-0.475879,-0.779372,-0.713258,-0.269900,0.347168,-0.824326,-0.928260,0.595186,-0.044309,0.705338,-1.061121,0.940103,-0.330911,0.491362,1.128315,1.223307,-0.245447,1.072106,1.337693,-0.898501,-0.011708,-0.842215,1.246431,-1.011029,0.323777,0.478531,1.008364,1.058965,0.636967,-0.055255,0.713768,1.031806,-0.861307,-0.291480,-0.401809,0.896037,-0.933948,0.540999,0.091313,0.634389,0.854998,0.684152},
  {0.850371,0.650198,-0.159438,0.399593,-0.768864,-0.775638,0.425754,0.097165,-0.555987,0.734386,0.585194,0.203378,-0.226069,-0.531107,-0.619619,0.483762,0.184793,0.190325,0.534358,-0.713033,0.603218,-0.202373,-0.368563,-0.837456,-0.942579,-0.575042,0.813727,-1.129626,-0.878843,0.168000,-0.644911,1.146945,-1.088857,0.483341,0.356509,-1.025586,-1.184564,-0.762891,0.023685,0.781392,-1.143432,-0.941598,0.296804,-0.455487,0.954280,-0.993409,0.574941,0.069490,-0.653880,-0.921962,-0.781068,-0.309163,-0.030246,-0.568251,0.798178,0.703029,-0.331417,0.224561,-0.704039,0.748797,-0.550941,0.026845,-0.430274,-0.680410,-0.645808,-0.377633,-0.002568,-0.400588,-0.617168,0.580082,0.372756,-0.030252,-0.488933,0.761551,-0.816153,-0.421015,0.226870,0.817512,0.707904,-0.044256,0.719070,-1.186109,-1.022765,0.300548,0.483124,-1.130322,1.122927,-0.659835,0.166063,0.888482,1.152678,0.837587,-0.168143,0.599956,-1.093944,-1.009777,0.417417,0.238290,-0.843613,0.942457,-0.717222,-0.150571,0.444885,0.816395},
  {0.311913,-0.381263,0.885363,0.978349,-0.639376,-0.048204,-0.527686,0.865515,-0.823666,0.465513,-0.070646,-0.571754,-0.850025,-0.792440,-0.402177,-0.178453,-0.723919,0.984089,0.805180,-0.241817,-0.444655,0.959875,-1.039221,-0.656685,0.028155,0.719225,1.038594,-0.482898,0.328325,-1.044953,-1.324695,0.982203,-0.110672,-0.866642,1.470526,-1.337267,-0.518473,0.583492,1.399002,1.508871,-0.862199,0.187801,-1.110234,-1.474604,1.134401,-0.266467,-0.682868,1.296873,-1.285622,-0.689173,0.209624,0.990117,-1.059168,-1.011320,0.437287,-0.221409,0.668148,0.888440,-0.809663,0.207803,0.256152,-0.791894,-0.914403,-0.697855,-0.224685,0.331383,0.753970,-0.966432,-0.674995,-0.024004,-0.661718,0.942164,-0.999075,0.400480,0.197193,0.805782,1.042780,0.799489,-0.588238,1.041092,1.140958,-0.797570,0.050577,-1.027521,1.366173,-1.236951,0.269528,0.684211,1.404672,1.393683,0.647163,-0.449181,1.223018,1.458737,-1.064404,-0.095242,-0.967069,1.347716,-1.281514,0.436032,0.392244,1.099103,1.257100,0.807444},
  {-1.165697,-0.993933,0.368569,-0.416198,1.023620,1.209060,-0.850026,0.008245,0.790388,-1.262441,-1.091639,-0.415651,0.412020,0.991593,1.082476,-0.729089,-0.077408,-0.586060,-0.958314,0.921994,-0.591358,-0.040774,0.626857,1.022356,0.999184,0.512858,-1.008586,1.293010,0.983170,-0.180296,0.786785,-1.417863,1.282403,-0.553532,-0.507581,1.232616,1.350188,0.807913,-0.080760,-0.871442,1.192447,1.013172,-0.462218,0.273934,-0.919690,1.146258,-0.964713,0.281783,0.526216,1.177788,1.288918,0.751771,-0.121801,0.611194,-1.120025,-1.136984,0.619360,-0.193569,0.929629,-1.280262,0.970083,-0.230762,0.623639,1.145302,1.100534,0.552133,-0.205440,0.796467,1.028525,-0.850889,-0.332801,-0.315485,0.795413,-1.018888,0.797672,0.245655,-0.468606,-1.046015,-0.792956,-0.055807,-0.926142,1.371753,1.163950,-0.371195,-0.674079,1.345044,-1.375598,0.680065,-0.302575,-1.091794,-1.324838,-0.948600,0.172422,-0.597895,1.056264,1.094159,-0.717511,-0.001193,0.712960,-1.207449,1.141730,0.543342,-0.373187,-1.162898},
  {0.058096,-0.773363,1.251754,1.205386,-0.633026,0.282850,-1.130829,1.416313,-1.119395,0.217016,-0.793415,-1.477024,-1.490906,-0.795455,0.304445,-1.323046,-1.691026,1.201220,0.134611,0.979004,-1.669517,1.458456,-0.601357,0.544783,1.367047,1.488986,-0.057654,0.896880,1.315935,-1.177326,-0.521772,-0.357721,0.999257,-1.276307,0.933048,-0.242602,0.594237,1.159784,1.186733,0.658717,0.135992,0.879924,-1.233766,-0.996911,0.301929,0.430026,-1.017783,1.090970,-0.771429,-0.102671,0.599873,1.044272,-1.239572,-1.019467,0.382019,-0.508319,1.250776,1.387515,-0.833204,-0.004227,0.997076,-1.435368,-1.269439,-0.477179,0.592491,1.436406,1.631604,-0.982050,0.117516,-1.133833,-1.656731,1.410845,-0.342535,-0.760421,1.582665,1.555629,0.800093,-0.274249,-1.408720,1.090527,0.271032,0.667676,1.225262,-1.192650,0.780904,0.083478,-0.789452,1.277399,1.142727,0.502837,-0.354159,-1.028810,1.275766,0.883007,-0.049163,0.725448,-1.096931,1.100277,-0.512485,-0.151479,0.859704,1.144331,0.960574,0.382033},
  {0.204322,-0.169277,0.495201,0.575207,-0.357787,0.031444,-0.408346,0.636779,-0.515075,0.165987,-0.294265,-0.608466,-0.612088,-0.303169,0.156785,-0.511870,-0.624157,0.453996,0.065655,0.353216,-0.562068,0.553594,-0.260143,0.135309,0.479887,0.611861,0.080139,0.359005,0.601322,-0.518455,-0.189727,-0.202523,0.501940,-0.490771,0.278617,0.073264,0.327492,0.401916,0.298591,0.097185,0.124432,0.250864,-0.253640,-0.185160,0.078948,0.084650,-0.174949,0.244361,-0.192135,-0.089486,0.058135,0.205984,-0.529702,-0.550583,0.245160,-0.140652,0.423044,0.566604,-0.487712,0.032129,0.332016,-0.668413,-0.619775,-0.273624,0.195636,0.547107,0.604042,-0.417868,0.014313,-0.476544,-0.646859,0.461408,-0.199608,-0.269867,0.488551,0.543052,0.332188,-0.056855,-0.641855,0.466351,0.108031,0.247251,0.516480,-0.563808,0.205509,0.103790,-0.446551,0.418337,0.247418,-0.021312,-0.250933,-0.354146,0.246510,0.113016,-0.017838,0.122629,-0.268334,0.189153,-0.177563,-0.023102,0.087688,0.187433,0.215567,0.151909},
  {-0.529242,-0.146810,-0.278832,-0.638572,0.796437,0.632251,-0.167568,-0.390177,0.880609,-0.981408,-0.642922,0.046774,0.781229,1.196313,1.060874,-0.388479,0.486272,-1.150140,-1.311095,0.875073,0.028268,-0.922181,1.458555,1.307512,0.520616,-0.557314,-1.592387,1.002549,-0.122066,1.222858,1.709677,-1.334274,0.340535,0.841528,-1.560388,1.552702,0.792465,-0.321801,-1.259333,-1.583873,1.170291,0.188860,0.887989,1.507416,-1.369537,0.603748,0.465961,-1.228391,1.390852,0.863081,-0.026233,-0.819103,0.504625,0.727510,-0.667857,-0.382303,-0.048548,-0.528039,0.864081,-0.809773,0.434531,0.244018,0.859227,1.129095,0.879931,0.188575,-0.633253,1.215371,1.217525,-0.616909,0.277129,-1.053916,1.417533,-1.076611,0.259011,-0.748204,-1.440278,-1.457712,0.369643,-1.324578,-1.665857,1.201621,0.111900,1.056045,-1.647054,1.476639,-0.546642,-0.576275,-1.422204,-1.572016,-0.971452,0.084850,-1.066192,-1.550888,1.308845,0.417439,0.682375,-1.374334,1.423212,-0.729959,-0.229769,-1.035813,-1.283169,-0.905905},
  {-0.866417,-1.296911,1.108140,0.452498,0.375312,1.064582,-1.303458,0.880580,-0.108331,-0.790379,-1.297884,-1.203571,-0.548161,0.354469,1.071970,-1.304052,-0.896800,0.055860,-0.762099,1.181556,-1.116007,0.482287,0.287185,0.931598,1.128785,0.806228,-0.584129,0.982684,0.966908,-0.570420,0.074913,-0.693940,0.945715,-0.871925,0.375170,0.215204,0.757375,0.984945,0.785712,0.224934,0.429697,0.946642,-1.083662,-0.704636,-0.036195,0.720205,-1.166396,1.027705,-0.474571,0.353547,1.043437,1.259146,-1.021251,-0.251681,-0.652682,-1.219585,1.201237,0.675416,0.127661,-0.962840,1.282336,-1.086318,-0.341413,0.558913,1.184796,1.236919,0.695263,0.129043,0.910616,-1.287567,-1.029360,0.272584,0.508590,-1.116382,1.123311,0.657499,-0.098916,-0.794965,-0.950130,0.337031,-0.359228,0.835077,0.974390,-0.741413,0.131346,0.441414,-0.911811,0.927613,0.591131,-0.017270,-0.649955,-1.031395,0.933698,0.449805,0.220159,0.850753,-1.151629,0.856679,-0.241141,-0.590820,1.102032,1.158238,0.661203,-0.182637},
  {-1.307681,-1.141360,0.493607,-0.366048,1.064008,1.276451,-0.925863,0.222840,0.649330,-1.225689,-1.299432,-0.763876,0.178075,1.096893,1.529570,-1.198637,-0.278187,-0.779724,-1.476590,1.457401,-0.674512,-0.368570,1.242878,1.470935,1.009140,0.116542,-1.265718,1.199480,0.594230,0.267786,0.968859,-1.212148,0.967921,-0.251129,-0.522282,1.100395,1.155151,0.696486,-0.055250,-0.751911,1.113509,0.959220,-0.383687,0.307209,-0.826373,1.046873,-0.796273,0.269792,0.433764,0.968580,1.125624,0.797995,-0.211281,0.676010,-1.176598,-1.193104,0.747642,-0.057739,0.888206,-1.234812,1.174916,-0.471091,0.434758,1.210621,1.473050,1.049611,0.101380,0.987470,1.566077,-1.322996,-0.466729,-0.568156,1.419591,-1.444452,0.887134,-0.111758,-0.993026,-1.357063,-0.316261,-0.492556,-1.099781,1.259285,0.818988,0.019661,-0.721915,1.212163,-1.042601,0.523242,-0.272633,-0.915351,-1.117501,-0.803258,0.200073,-0.512128,1.027116,1.043970,-0.581034,0.009880,0.677405,-0.981064,1.010958,0.562511,-0.145535,-0.828626},
  {-0.845342,-0.028887,-0.755710,-1.197518,1.100179,0.469352,0.395551,-1.008756,1.175177,-0.731066,0.015195,0.717629,1.053425,0.902815,0.377288,0.293516,0.779597,-0.895605,-0.655485,0.166888,0.435259,-0.792223,0.846096,0.506041,-0.038137,-0.537713,-0.689028,0.347559,-0.145124,0.607339,0.821285,-0.685080,0.288596,0.329940,-0.795135,0.957816,0.633039,-0.008316,-0.642478,-0.949616,0.823379,0.315759,0.315392,0.759339,-0.867393,0.695269,-0.195769,-0.376896,0.913388,1.078566,0.743047,-0.014888,0.978142,1.287237,-0.964167,-0.237883,-0.553902,-1.110233,1.169452,-0.597122,-0.168303,0.901624,1.145825,0.855665,0.206102,-0.478173,-0.894538,0.935404,0.550403,0.078809,0.619926,-0.853233,0.795696,-0.316564,-0.217257,-0.677018,-0.817256,-0.590968,0.390192,-0.688227,-0.745126,0.545656,0.083026,0.480482,-0.801443,0.865977,-0.442824,-0.148840,-0.734528,-0.963878,-0.711480,-0.111694,-0.482462,-0.858142,0.877303,0.507245,0.079574,-0.554524,0.916696,-0.857862,0.501113,-0.183056,-0.870253,-1.195937},
  {1.170374,1.404488,-0.986275,-0.128978,-0.757657,-1.260123,1.172367,-0.583193,-0.279594,0.978667,1.227951,0.903749,0.165764,-0.630272,-1.109026,1.049074,0.528301,0.184201,0.776747,-1.006868,0.781210,-0.275403,-0.335098,-0.780855,-0.913777,-0.686597,0.419548,-0.879123,-0.969401,0.621419,-0.018662,0.673154,-1.065839,0.950207,-0.408234,-0.357032,-0.952064,-1.109311,-0.760826,-0.077032,-0.638412,-1.051659,0.995747,0.526462,0.157768,-0.812556,1.121726,-0.982010,0.368853,-0.454104,-1.137334,-1.331297,0.853659,-0.107985,0.986791,1.357926,-1.083878,-0.348969,-0.502936,1.141652,-1.218019,0.773838,-0.032714,-0.805308,-1.183429,-0.998460,-0.355870,-0.404374,-0.954391,1.061677,0.686033,-0.030329,-0.557931,0.915931,-0.855846,-0.476123,0.087717,0.621928,0.851877,-0.401674,0.233132,-0.785335,-1.027059,0.821941,-0.189026,-0.519841,1.038826,-1.045052,-0.579391,0.158276,0.821705,1.109125,-0.883218,-0.290310,-0.403224,-0.935451,1.090318,-0.751126,0.112899,0.646883,-1.135168,-1.157307,-0.628230,0.257649},
  {0.273778,0.273606,-0.122001,0.070482,-0.202236,-0.243422,0.182202,-0.002814,-0.086085,0.150410,0.130743,0.112602,0.114830,0.092102,-0.014984,0.224754,0.368676,-0.301855,-0.030474,-0.322723,0.599611,-0.487617,0.104526,-0.404150,-0.694636,-0.578267,0.403562,-0.666416,-0.582628,0.233387,-0.213373,0.536437,-0.542470,0.369254,-0.010465,-0.289009,-0.495639,-0.496273,-0.269435,0.111289,-0.450838,-0.612194,0.484664,0.069162,0.418736,-0.637623,0.559934,-0.135574,-0.292075,-0.555279,-0.500225,-0.190795,0.056571,-0.126708,0.218512,0.246389,-0.191170,-0.008336,-0.195853,0.184526,-0.177074,0.027833,-0.036491,-0.063989,-0.100652,-0.177321,-0.251729,0.172259,-0.015384,0.248081,0.451640,-0.446189,0.043272,0.361000,-0.691602,-0.586481,-0.136919,0.393699,0.576351,-0.197251,0.297026,-0.640846,-0.606289,0.254820,0.081144,-0.442090,0.505927,-0.460614,-0.185746,0.168140,0.461064,0.550324,-0.416498,-0.013485,-0.465165,-0.679289,0.495785,-0.135471,-0.387841,0.596825,-0.568574,-0.207889,0.213532,0.466139},
  {0.593937,0.290581,0.174913,0.625767,-0.809879,-0.547987,-0.045477,0.574345,-0.870063,0.648094,0.119329,-0.459236,-0.784590,-0.712722,-0.318749,-0.210092,-0.571878,0.632639,0.455663,-0.130619,-0.306348,0.559748,-0.640544,-0.399970,0.037927,0.465770,0.506973,-0.133050,0.305185,-0.581521,-0.536073,0.242813,0.038079,-0.319213,0.408686,-0.439298,-0.300264,-0.029314,0.308913,0.563413,-0.597621,-0.278934,-0.260267,-0.672210,0.705631,-0.413915,-0.153303,0.550640,-0.693341,-0.459678,-0.053240,0.304091,-0.248838,-0.616577,0.732365,0.444999,0.128963,0.646746,-0.822225,0.628657,-0.037608,-0.512235,-0.810878,-0.675245,-0.200787,0.345774,0.690523,-0.661297,-0.369347,-0.024368,-0.404863,0.632729,-0.537400,0.276489,0.181870,0.552357,0.684253,0.490340,-0.397427,0.659293,0.555079,-0.170224,0.219930,-0.429541,0.495089,-0.320768,0.128015,0.160850,0.391356,0.523423,0.462265,0.167365,0.301541,0.651850,-0.658042,-0.325541,-0.178215,0.651075,-0.704222,0.444744,0.076253,0.478818,0.611733,0.464149},
  {-0.132110,-0.321099,0.365071,0.222826,0.043895,0.288509,-0.381296,0.291956,-0.010282,-0.261899,-0.391566,-0.280844,0.002096,0.274655,0.362188,-0.205302,0.057712,-0.241597,-0.248156,0.096498,0.116202,-0.191001,0.132323,-0.025950,-0.140666,-0.126633,0.132501,-0.160258,-0.075487,-0.063071,-0.176856,0.187531,-0.054639,-0.094342,0.213652,-0.188735,-0.069307,0.088837,0.202022,0.217559,-0.120940,0.019973,-0.145167,-0.224495,0.219923,-0.085821,-0.085965,0.266728,-0.308242,-0.196698,0.045701,0.295008,-0.367398,-0.190986,-0.105850,-0.321810,0.352309,0.235826,-0.018958,-0.292590,0.376989,-0.317468,-0.039369,0.247900,0.363813,0.237337,-0.041371,0.241065,0.290272,-0.174671,0.061166,-0.247197,0.170193,-0.047143,-0.152299,-0.186360,-0.084504,0.062752,0.083696,0.015170,0.138081,-0.194919,-0.088345,-0.112381,0.178598,-0.208958,0.043130,0.077063,0.184708,0.181981,0.076179,-0.074592,0.155951,0.199118,-0.187757,-0.057505,-0.143649,0.223700,-0.284985,0.128772,0.043250,0.254770,0.339723,0.228120},
  {0.100574,0.607187,-0.806016,-0.559664,0.025192,-0.441084,0.610818,-0.541859,0.136008,0.212818,0.443433,0.412839,0.171493,-0.127516,-0.322615,0.283850,0.135327,0.013384,0.139160,-0.183964,0.034471,0.030962,-0.113067,-0.043178,0.075119,0.137564,-0.122827,0.267216,0.311812,-0.179384,0.157101,-0.504733,0.515041,-0.294934,-0.229708,0.606132,0.713014,0.402857,-0.185972,-0.738672,0.887311,0.585364,0.034201,0.714986,-1.073090,0.767666,-0.101162,-0.734751,1.107697,0.908743,0.187185,-0.658149,0.876995,0.552738,0.062177,0.551867,-0.680958,-0.504764,0.143871,0.352276,-0.521940,0.515278,0.217265,-0.132687,-0.350809,-0.345660,-0.155065,-0.030483,-0.194190,0.264877,0.146697,0.064899,-0.086503,0.118492,0.044685,0.127968,0.111230,-0.012946,-0.211650,0.146303,-0.115281,0.419367,0.466401,-0.177558,-0.171106,0.593071,-0.609345,0.374961,-0.162448,-0.650199,-0.796975,-0.485130,-0.085692,-0.703351,1.016153,0.733083,0.022219,-0.700347,1.129698,-0.839107,0.176448,-0.648811,-1.111720,-0.945460},
  {-0.018024,-0.666943,1.024490,0.798889,-0.108097,0.597418,-0.956339,0.941631,-0.383825,-0.254244,-0.825887,-1.018621,-0.726335,-0.049182,0.717527,-1.135280,-1.032705,0.411771,-0.506794,1.221501,-1.186273,0.602547,0.386804,1.091396,1.197263,0.694868,-0.743176,1.005969,0.738241,-0.129598,0.428942,-0.701987,0.745421,-0.373504,-0.040616,0.508226,0.683005,0.550434,0.188777,-0.215149,0.521604,0.520179,-0.248104,0.048828,-0.224361,0.363358,-0.253228,0.179612,0.010075,0.117208,0.199579,0.265942,-0.910994,-0.653518,0.064235,-0.625372,1.039700,0.876023,-0.231715,-0.412353,0.957730,-0.950251,-0.549561,0.133128,0.801328,1.139484,0.949500,-0.213254,0.641408,-1.164964,-1.131595,0.524473,0.482284,-1.121694,1.244989,0.659922,-0.219935,-0.904051,-0.663141,0.045192,-0.558364,0.886082,0.750003,-0.260068,-0.194679,0.633471,-0.668205,0.510544,0.090936,-0.330638,-0.557431,-0.496196,0.262104,-0.098796,0.409827,0.457239,-0.262199,0.103999,0.147030,-0.192288,0.270789,0.237313,0.177467,0.088675},
  {-0.602698,-1.262469,1.291657,0.740368,0.137868,0.999415,-1.421244,1.064783,-0.292502,-0.697368,-1.298382,-1.291880,-0.702826,0.180542,0.952604,-1.322953,-1.048905,0.253460,-0.621597,1.167205,-1.250374,0.644115,0.166863,0.908338,1.172673,0.865549,-0.529575,0.909173,0.926667,-0.629377,-0.071874,-0.548212,0.878518,-0.968660,0.549313,0.062091,0.740644,1.093245,0.910824,0.259963,0.481712,1.015688,-1.089475,-0.622217,-0.130904,0.686708,-1.015185,0.830524,-0.415815,0.208231,0.758866,1.011016,-1.204522,-0.551441,-0.367324,-1.140905,1.389087,0.954629,-0.043195,-0.856763,1.367184,-1.188849,-0.467486,0.457147,1.150941,1.306711,0.870596,-0.032606,0.801487,-1.253951,-1.138961,0.501892,0.402802,-1.076683,1.251605,0.811976,0.016100,-0.730770,-0.930535,0.416396,-0.227882,0.747742,0.948336,-0.777177,0.331922,0.309381,-0.839485,1.067094,0.792639,0.116684,-0.646468,-1.106371,1.037878,0.456278,0.331801,0.912648,-1.038086,0.741628,-0.129150,-0.475255,0.908291,0.969600,0.642386,0.028649},
  {1.867194,0.840712,0.524176,1.707139,-2.151314,-1.526955,0.125706,1.196601,-2.082570,1.843911,0.796485,-0.624881,-1.737057,-2.022774,-1.378909,0.072551,-1.144614,1.723663,1.569854,-0.814290,-0.369808,1.206896,-1.657706,-1.373426,-0.550840,0.499057,1.670045,-1.305683,-0.251987,-1.044199,-1.847438,1.732720,-0.909611,-0.502727,1.538331,-1.959869,-1.392204,-0.219584,0.984012,1.677881,-1.672127,-0.898679,-0.287342,-1.272897,1.664380,-1.497044,0.542924,0.548000,-1.584488,-1.886778,-1.347494,-0.169951,-0.914473,-1.928946,2.037325,1.199907,0.194638,1.507673,-2.119058,1.712811,-0.518766,-0.927497,-1.910009,-1.978159,-1.119149,0.233548,1.425265,-1.918733,-1.511735,0.447016,-0.740985,1.530407,-1.649868,1.068432,-0.096074,0.901286,1.531938,1.545364,-0.162823,1.219759,1.792693,-1.564157,-0.565884,-0.756117,1.730905,-1.898097,1.132064,0.146151,1.330193,1.854685,1.514645,0.517842,0.648538,1.498029,-1.700425,-1.183007,0.164619,0.919612,-1.658713,1.681685,-0.971398,0.225725,1.374610,1.929345},
  {-1.029718,-0.939402,0.397688,-0.236520,0.700512,0.920251,-0.810429,0.236023,0.363059,-0.953690,-1.084821,-0.713837,0.017859,0.763100,1.138618,-0.997711,-0.306030,-0.586565,-1.132040,1.059843,-0.578549,-0.269273,0.835882,1.014459,0.694234,0.072619,-0.862446,0.750688,0.398334,0.022269,0.455203,-0.762989,0.677856,-0.436398,-0.129054,0.580273,0.860110,0.729968,0.208713,-0.461032,0.868646,0.888014,-0.517337,0.127118,-0.716305,0.834030,-0.696972,0.186345,0.255468,0.641144,0.780968,0.605650,-0.290992,0.390429,-0.915242,-0.973653,0.571576,-0.004448,0.531127,-0.983078,0.896445,-0.523734,0.184727,0.836816,1.098988,0.807889,0.081403,0.651975,1.122245,-1.085125,-0.455769,-0.438834,0.966811,-1.125650,0.615100,-0.102802,-0.734723,-0.994050,-0.306103,-0.320936,-0.706268,0.732153,0.541764,-0.216947,-0.326715,0.643110,-0.852522,0.567591,0.046028,-0.565226,-0.957527,-0.903829,0.338389,-0.343088,0.784771,0.880005,-0.617118,-0.017403,0.466709,-0.815355,0.707201,0.393268,-0.092012,-0.590108},
  {-0.468874,-0.396869,0.182235,-0.148728,0.464380,0.571657,-0.400676,0.083792,0.355644,-0.598735,-0.594250,-0.295519,0.168384,0.581150,0.741143,-0.527927,-0.074944,-0.410875,-0.741197,0.743741,-0.324409,-0.210443,0.706176,0.836324,0.566707,0.032350,-0.789413,0.724712,0.298808,0.290326,0.724027,-0.797408,0.543499,0.038280,-0.558411,0.858076,0.695700,0.183771,-0.400644,-0.741809,0.702662,0.293475,0.233954,0.553538,-0.542010,0.349455,-0.009574,-0.210354,0.370959,0.379806,0.285828,0.103991,-0.024781,0.281287,-0.462952,-0.479967,0.307989,-0.038305,0.416506,-0.585987,0.534265,-0.177251,0.267951,0.615187,0.690051,0.442618,-0.023198,0.517604,0.764556,-0.632585,-0.205604,-0.320174,0.748983,-0.775877,0.464184,-0.096857,-0.605598,-0.813374,-0.136866,-0.391072,-0.751706,0.780575,0.424714,0.156856,-0.631867,0.851614,-0.607792,0.095265,-0.486438,-0.804427,-0.690722,-0.220011,-0.311353,-0.651256,0.648405,0.322420,0.113121,-0.376266,0.472954,-0.339748,0.164431,-0.050724,-0.237042,-0.355412},
  {-0.294331,-0.001936,-0.322544,-0.442690,0.288542,0.002336,0.235525,-0.359687,0.243516,-0.082822,0.084716,0.170504,0.181836,0.150914,0.088045,-0.008057,0.134049,-0.280610,-0.293926,0.128054,0.090869,-0.339033,0.376673,0.232511,-0.049071,-0.317340,-0.334301,0.057157,-0.220774,0.367759,0.360874,-0.208944,-0.083062,0.288986,-0.408542,0.292244,0.058470,-0.210958,-0.387485,-0.384155,0.174572,-0.098302,0.297662,0.363638,-0.268111,0.003033,0.197563,-0.326756,0.244439,0.082591,-0.088837,-0.194047,0.304631,0.425611,-0.304337,-0.003126,-0.293114,-0.403552,0.282253,-0.039501,-0.185186,0.269035,0.222976,0.110660,-0.002388,-0.094692,-0.171232,0.215813,0.195293,-0.075720,0.124718,-0.307493,0.343579,-0.200201,-0.076814,-0.327813,-0.415266,-0.288383,0.261333,-0.407876,-0.352863,0.130614,-0.143565,0.343537,-0.391673,0.252508,-0.004578,-0.254355,-0.392581,-0.347078,-0.136594,0.139075,-0.349658,-0.384201,0.226575,-0.034162,0.262959,-0.356373,0.262512,-0.060790,-0.149780,-0.257359,-0.237395,-0.131426},
  {-2.494321,-1.745487,0.175821,-1.479504,2.458462,2.317524,-1.107158,-0.650388,2.111594,-2.613446,-1.879686,-0.254787,1.489186,2.519058,2.352374,-1.097835,0.645542,-2.059591,-2.497221,1.791035,-0.309461,-1.303548,2.297882,2.255467,1.188035,-0.418885,-2.378278,1.821725,0.451182,1.073798,2.064611,-2.106933,1.217394,0.136627,-1.396642,2.024958,1.810947,0.838303,-0.507652,-1.674736,2.137755,1.662676,-0.414911,1.072531,-2.104138,2.156094,-1.222766,-0.290423,1.648118,2.257112,1.848950,0.619028,0.300987,1.834525,-2.501331,-2.044510,0.667250,-1.060318,2.344445,-2.490002,1.536181,0.215501,1.854497,2.633779,2.176010,0.702330,-1.076412,2.351538,2.485823,-1.449506,0.194357,-1.685808,2.453900,-2.046492,0.787760,-0.844800,-2.078125,-2.349070,-0.011152,-1.461532,-2.256096,2.028732,0.873688,0.644726,-1.751093,2.123933,-1.527273,0.375386,-0.944016,-1.863672,-2.001102,-1.269599,-0.021482,-1.382883,2.189794,1.979879,-0.814893,-0.684984,1.942330,-2.241279,1.578540,0.179808,-1.280730,-2.157191},
  {1.060260,0.363042,0.495351,1.151149,-1.271483,-0.727802,-0.200323,0.930262,-1.292737,0.953449,0.207571,-0.644091,-1.204282,-1.205732,-0.638623,-0.280604,-1.026006,1.222109,0.845540,-0.098777,-0.749436,1.099409,-0.981962,-0.380791,0.324620,0.801771,0.564311,-0.094143,0.415062,-0.771264,-0.765150,0.401836,0.041654,-0.551948,0.722123,-0.652548,-0.259838,0.211652,0.546517,0.617771,-0.480744,-0.140521,-0.267845,-0.530496,0.569947,-0.497544,0.130502,0.240086,-0.650695,-0.775629,-0.566418,-0.075849,-0.699630,-1.268650,1.138970,0.504062,0.314152,1.039484,-1.318527,0.801469,-0.070674,-0.841491,-1.280725,-1.137576,-0.478501,0.390529,1.056192,-1.280628,-0.807639,-0.130262,-0.921375,1.164992,-0.980197,0.175191,0.502129,0.947855,0.897183,0.434328,-0.682919,0.786098,0.633336,-0.308062,0.201112,-0.690427,0.719978,-0.595818,0.049161,0.345661,0.636520,0.611923,0.309779,-0.111130,0.376408,0.544454,-0.581969,-0.344116,-0.092101,0.350571,-0.671583,0.581003,-0.399154,0.069942,0.544393,0.794533},
  {0.608902,-0.006315,0.659774,0.841668,-0.450474,0.145550,-0.559249,0.718347,-0.309700,-0.122749,-0.471122,-0.468739,-0.165257,0.210919,0.421679,-0.294957,-0.057276,-0.116672,-0.228924,0.243305,-0.006959,-0.076174,0.223958,0.195906,0.093818,-0.034469,-0.163707,0.156873,-0.016602,0.275917,0.352345,-0.160818,-0.046300,0.405332,-0.419403,0.284793,-0.123591,-0.477701,-0.529536,-0.215408,-0.209916,-0.579488,0.652808,0.275945,0.321087,-0.602355,0.661337,-0.223124,-0.202840,-0.565635,-0.605687,-0.308153,-0.615041,-0.834301,0.539031,-0.075993,0.616804,0.751861,-0.421573,-0.138863,0.558001,-0.597549,-0.272764,0.170923,0.447524,0.414513,0.141132,0.166515,0.321481,-0.261662,-0.062009,-0.135682,0.218781,-0.172482,0.041951,-0.091854,-0.171817,-0.169751,0.056974,-0.197529,-0.252030,0.159005,-0.062455,0.297026,-0.387156,0.227541,0.116676,-0.444186,-0.519079,-0.255932,0.205430,0.573580,-0.599518,-0.245535,-0.275641,-0.638676,0.621404,-0.243092,-0.272869,0.624443,-0.630077,-0.295712,0.191657,0.578423},
  {-0.954084,-0.733672,0.202400,-0.431933,0.866950,0.846005,-0.388957,-0.179872,0.691392,-0.773968,-0.496873,0.003537,0.457794,0.651086,0.527925,-0.160376,0.195849,-0.381171,-0.400205,0.288540,-0.036205,-0.121078,0.264167,0.280265,0.227744,0.133433,-0.133163,0.301887,0.362972,-0.247442,-0.009524,-0.268020,0.528678,-0.484162,0.239675,0.220936,0.574025,0.664024,0.437886,0.003600,0.469226,0.712635,-0.616057,-0.262642,-0.213930,0.701502,-0.836276,0.629831,-0.007767,0.657139,1.041943,0.901384,-0.030028,0.601457,-0.901109,-0.786308,0.323464,-0.303172,0.784686,-0.810629,0.490762,0.101784,0.579036,0.741109,0.540340,0.118032,-0.294186,0.537628,0.489546,-0.220034,0.070481,-0.253681,0.357087,-0.265537,0.158113,0.005992,-0.118755,-0.202635,-0.220270,0.144101,-0.051191,0.309434,0.455354,-0.376574,0.139701,0.271859,-0.536736,0.602666,0.335911,-0.107793,-0.507063,-0.665756,0.539963,0.138179,0.366894,0.710036,-0.729633,0.462973,0.117858,-0.650742,0.965732,0.776995,0.159931,-0.585699},
  {-0.144185,0.099966,-0.203940,-0.241308,0.242610,0.144872,0.029754,-0.110298,0.268331,-0.242989,-0.151361,0.038639,0.243511,0.357684,0.316614,-0.084686,0.148095,-0.273323,-0.317802,0.266137,-0.007569,-0.168444,0.375747,0.387700,0.236440,-0.026168,-0.415980,0.388874,0.125847,0.250275,0.474247,-0.431013,0.269630,0.110937,-0.343841,0.503171,0.390802,0.117548,-0.190622,-0.400414,0.477031,0.307216,0.041588,0.345057,-0.470758,0.482094,-0.168941,-0.158570,0.528291,0.612922,0.396282,-0.029240,0.378949,0.367804,-0.159032,0.011222,-0.078508,-0.165316,0.269553,-0.167131,0.130075,0.109258,0.273777,0.348229,0.278053,0.083676,-0.143398,0.362120,0.359350,-0.139362,0.085576,-0.217981,0.387636,-0.268390,0.157881,-0.090245,-0.301419,-0.373773,0.011495,-0.239527,-0.420043,0.454192,0.209420,0.196244,-0.383940,0.512052,-0.272503,0.035582,-0.265414,-0.424515,-0.377456,-0.151087,-0.084337,-0.342658,0.514594,0.407997,-0.055412,-0.217608,0.539848,-0.493569,0.325397,-0.081605,-0.455508,-0.590471},
  {-0.815925,-0.535950,0.031123,-0.514026,0.871163,0.855607,-0.442962,-0.188026,0.798404,-1.046715,-0.801411,-0.137323,0.625909,1.092735,1.013959,-0.423869,0.344981,-0.900021,-1.008172,0.667620,-0.053421,-0.517281,0.870185,0.869304,0.529739,-0.043062,-1.011871,0.938452,0.380076,0.425893,1.051248,-1.145691,0.667522,0.164963,-0.869877,1.129988,0.827243,0.170230,-0.503907,-0.903710,0.907444,0.533655,0.054388,0.610241,-0.910280,0.840554,-0.367767,-0.276091,0.828750,0.988435,0.678825,0.051083,0.170832,0.642004,-0.871032,-0.717735,0.227799,-0.373961,0.831354,-0.979098,0.630341,0.010462,0.707993,1.083298,0.920437,0.282264,-0.506304,1.013495,1.023558,-0.562164,0.142760,-0.745289,0.941648,-0.777969,0.278315,-0.298881,-0.772370,-0.961662,-0.188443,-0.548355,-1.064166,1.060651,0.525629,0.285431,-0.999065,1.155787,-0.766296,-0.017005,-0.723296,-1.045517,-0.881084,-0.357922,-0.293576,-0.773596,0.907550,0.684878,-0.184935,-0.455012,0.874546,-0.944840,0.529529,-0.129480,-0.736135,-0.993150},
  {0.753797,0.339658,0.113800,0.527575,-0.739282,-0.553594,0.081905,0.230975,-0.586517,0.517509,0.293854,-0.073054,-0.411382,-0.561315,-0.461506,0.092145,-0.207567,0.295025,0.303250,-0.279644,0.032473,0.021759,-0.238565,-0.336206,-0.363731,-0.263865,0.253455,-0.521939,-0.473349,0.109126,-0.255111,0.434700,-0.575181,0.299521,-0.061607,-0.371389,-0.599707,-0.620488,-0.393589,0.032334,-0.588125,-0.857430,0.649478,0.136966,0.453267,-1.026459,0.917793,-0.457791,-0.441728,-1.065500,-1.153250,-0.648978,-0.302392,-0.709982,0.762160,0.460818,0.018347,0.430383,-0.613631,0.553114,-0.240159,-0.135285,-0.448671,-0.547390,-0.389532,-0.058505,0.275719,-0.436659,-0.390782,0.199548,-0.038308,0.219075,-0.270016,0.273740,-0.195352,-0.072960,0.111588,0.310666,0.343450,-0.061610,0.277266,-0.492608,-0.483971,0.252699,0.121021,-0.412703,0.555640,-0.448394,-0.166221,0.215281,0.558673,0.703912,-0.519026,-0.047364,-0.518893,-0.902464,0.850593,-0.294947,-0.449357,1.025716,-1.044422,-0.505350,0.323990,0.993342},
  {0.170205,0.334620,-0.343630,-0.264634,0.106920,-0.163578,0.428360,-0.417893,0.316628,0.033974,0.341578,0.524227,0.496945,0.260714,-0.096765,0.484145,0.638894,-0.465774,-0.094531,-0.322977,0.720890,-0.685830,0.393884,-0.164892,-0.653089,-0.810583,0.009799,-0.522220,-0.819554,0.761329,0.298657,0.346106,-0.732624,0.873271,-0.503653,-0.017892,-0.585581,-0.865363,-0.707364,-0.178656,-0.403088,-0.820079,0.857173,0.421147,0.250935,-0.671692,0.828036,-0.477662,0.018681,-0.443138,-0.639004,-0.508833,0.310736,0.177080,0.025703,0.251762,-0.406173,-0.386815,0.181329,0.100719,-0.378446,0.477675,0.377437,0.101798,-0.235901,-0.492899,-0.552418,0.358001,-0.010495,0.404323,0.655975,-0.618262,0.241221,0.271404,-0.707153,-0.795960,-0.481943,0.087711,0.850246,-0.665674,-0.146651,-0.449884,-0.819318,0.790459,-0.410201,-0.189150,0.685821,-0.885320,-0.649950,-0.092667,0.519115,0.876808,-0.803979,-0.315296,-0.335561,-0.791660,0.824027,-0.465338,-0.121587,0.585953,-0.750891,-0.537062,-0.098076,0.334492},
  {-0.226075,-0.045917,-0.206808,-0.307910,0.218955,0.101803,-0.000265,-0.250897,0.238250,-0.254712,-0.089385,0.085122,0.180618,0.163420,0.065701,-0.033522,0.050727,-0.177306,-0.191777,0.094270,-0.114726,-0.084843,0.140708,0.224349,0.181760,0.005893,-0.376389,0.277994,0.093315,0.080603,0.275295,-0.397379,0.189608,-0.047329,-0.259402,0.310150,0.298277,0.137892,-0.117798,-0.365529,0.401789,0.310681,-0.108916,0.240295,-0.551899,0.439252,-0.228939,-0.260166,0.475841,0.497766,0.230797,-0.174806,0.249180,0.301124,-0.215200,-0.067946,-0.086841,-0.228155,0.291058,-0.175659,0.020741,0.184640,0.273303,0.230957,0.092897,-0.058879,-0.151752,0.188198,0.142468,-0.050097,0.022990,-0.078185,0.181069,-0.192704,0.165757,0.015155,-0.174984,-0.297897,-0.077998,-0.147791,-0.324671,0.356857,0.193448,0.078229,-0.262889,0.370097,-0.271675,0.102090,-0.137526,-0.327317,-0.381176,-0.256042,0.009866,-0.292473,0.495783,0.436384,-0.119204,-0.240502,0.535038,-0.506716,0.247181,-0.166472,-0.481426,-0.527005},
  {0.077989,0.016649,-0.003389,0.032823,-0.069528,-0.011827,-0.080687,-0.015766,0.033760,-0.143933,-0.100178,0.022894,0.135410,0.142124,0.025741,0.072671,0.163513,-0.193016,-0.078141,-0.095670,0.090139,-0.156970,0.081102,0.046503,-0.037969,-0.174774,-0.277049,0.019164,-0.267081,0.385999,0.305937,-0.050261,-0.360749,0.442512,-0.344557,-0.061740,-0.359514,-0.433690,-0.275559,-0.017886,-0.244085,-0.308402,0.187694,0.058840,0.028934,-0.219433,0.220917,-0.233840,0.011821,-0.189811,-0.315424,-0.280837,0.016059,-0.039505,0.123498,0.066455,0.081617,0.087317,0.055121,-0.020205,0.109240,0.063649,0.165799,0.197139,0.112268,-0.039371,-0.147121,0.221276,0.092744,0.144275,0.214155,-0.096401,0.113379,0.049959,-0.016708,-0.078984,-0.133123,-0.119733,0.229655,-0.299656,-0.260187,0.089208,-0.244026,0.507527,-0.291110,0.036320,0.391092,-0.405311,-0.232951,0.079887,0.328235,0.386676,-0.177014,0.014877,-0.088831,-0.179236,0.275999,-0.104949,0.047271,0.214480,-0.227029,-0.191667,-0.018065,0.198789},
  {-0.413233,-1.237375,1.516565,1.038144,-0.033921,0.933208,-1.395704,1.267079,-0.488824,-0.378342,-1.047136,-1.210461,-0.858369,-0.186558,0.524888,-0.978892,-1.103898,0.849525,0.201303,0.629027,-1.191615,1.361213,-0.819035,0.143536,1.141728,1.662389,0.406243,0.858108,1.689410,-1.651354,-0.825527,-0.366770,1.439859,-1.716402,1.248877,-0.133392,0.971491,1.603680,1.497926,0.730259,0.381380,1.265006,-1.530863,-1.137947,0.269257,0.793759,-1.405534,1.450027,-0.753915,0.239296,1.116487,1.484429,-1.470073,-0.859380,-0.229629,-1.148790,1.450120,1.118198,-0.333162,-0.714049,1.235108,-1.309761,-0.750625,0.062229,0.766619,1.100838,0.980389,-0.565156,0.126807,-0.861116,-1.233171,1.061943,-0.561735,-0.411358,1.149354,1.479573,1.086421,0.091859,-1.730328,1.509111,0.582851,0.588523,1.533031,-1.777597,1.009545,0.082693,-1.246013,1.644415,1.328370,0.396513,-0.703338,-1.472398,1.497054,0.911493,0.010567,0.979137,-1.558676,1.280204,-0.566723,-0.542119,1.244754,1.433289,0.951685,0.033339},
  {-0.546586,-0.721544,0.559349,0.070344,0.524883,0.889023,-0.801983,0.314434,0.428127,-0.962653,-1.027619,-0.524697,0.302719,1.005831,1.181764,-0.694312,0.161339,-0.906996,-1.161698,0.801626,0.001271,-0.719936,1.054014,0.815122,0.198753,-0.450977,-0.758784,0.371622,-0.164848,0.596868,0.707531,-0.468573,0.065492,0.375203,-0.567440,0.506599,0.193890,-0.169185,-0.393019,-0.385538,0.214872,-0.023374,0.197383,0.217255,-0.128442,0.076121,-0.021460,0.033244,0.023641,0.110243,0.212812,0.252933,-0.412246,0.055314,-0.538396,-0.805011,0.687784,0.185341,0.476509,-0.927751,0.939351,-0.419002,0.362738,1.000723,1.125056,0.635761,-0.217655,0.975796,1.194849,-0.752723,0.078973,-0.831503,1.127861,-0.799580,0.102858,-0.597320,-0.936874,-0.786176,0.321542,-0.701010,-0.732423,0.435947,-0.043912,0.476836,-0.638511,0.507858,-0.127368,-0.261731,-0.492122,-0.454191,-0.200503,0.107576,-0.292863,-0.304088,0.186357,0.028130,0.079929,-0.087976,0.088021,-0.086417,0.131756,0.141776,0.072752,-0.080264},
  {-1.715273,-1.989830,1.289434,-0.022756,1.288622,1.890118,-1.557834,0.494359,0.749668,-1.565094,-1.595179,-0.888362,0.163344,1.051057,1.400851,-1.121108,-0.397390,-0.430792,-1.025558,1.171805,-0.837725,0.175899,0.540486,1.016934,1.060309,0.661379,-0.645150,1.011030,0.966217,-0.542211,0.095371,-0.712302,1.076297,-1.023415,0.530559,0.246262,0.991025,1.348231,1.097797,0.297770,0.705997,1.430660,-1.501147,-0.851082,-0.232573,1.243854,-1.696991,1.361356,-0.368650,0.834764,1.686191,1.762602,-1.114996,0.273524,-1.551749,-2.000339,1.418593,0.215542,0.997297,-1.786129,1.575468,-0.741496,0.426560,1.296124,1.493118,0.994871,0.094215,0.715459,1.199710,-1.202190,-0.670901,-0.149947,0.761216,-1.152864,0.949627,0.407072,-0.306261,-0.888910,-0.869430,0.241715,-0.419109,0.856979,1.013819,-0.827882,0.184909,0.462657,-1.089768,1.179990,0.797587,-0.010673,-0.904997,-1.454647,1.292534,0.544925,0.458833,1.337776,-1.657381,1.083690,-0.089526,-1.093342,1.685053,1.548565,0.653313,-0.606072},
  {-0.477121,0.758991,-1.732603,-1.876103,1.127573,-0.044597,1.138715,-1.922165,1.691666,-0.866188,0.451354,1.573377,1.974250,1.448286,0.222771,1.042814,1.908733,-1.976612,-1.073732,-0.383120,1.494105,-2.113985,1.630550,0.494246,-0.908776,-1.966843,-1.432921,-0.101119,-1.573523,2.274338,1.975490,-0.784332,-0.977100,2.107339,-2.387902,1.353487,-0.233144,-1.694740,-2.349717,-1.926758,0.566392,-0.936601,1.904051,2.071306,-1.386417,-0.077234,1.320565,-2.129788,1.801485,0.732584,-0.682879,-1.796217,1.863238,1.723214,-0.788753,0.440690,-1.436001,-1.859046,1.516808,-0.389622,-0.830629,1.814021,1.951194,1.211980,-0.088471,-1.359004,-2.005458,1.777503,0.685371,0.765678,1.819567,-2.004826,1.399783,-0.067669,-1.197154,-1.996083,-1.910202,-0.949293,1.779828,-2.243034,-1.709294,0.381289,-1.220054,2.313771,-2.196507,1.118765,0.600412,-1.910221,-2.333962,-1.637130,-0.185676,1.319784,-2.131651,-2.001798,1.024520,-0.431881,1.714140,-2.107765,1.657528,-0.360680,-0.985511,-1.921472,-1.963717,-1.098860},
  {-1.715997,-1.536625,0.559637,-0.696774,1.562440,1.592739,-0.821393,-0.287086,1.192881,-1.454167,-1.030260,-0.168156,0.711717,1.221919,1.162186,-0.577985,0.236855,-0.904859,-1.135369,0.836813,-0.153118,-0.539771,0.944956,0.881797,0.440437,-0.134232,-0.734083,0.598516,0.255425,0.150359,0.468249,-0.605223,0.546467,-0.275895,-0.091813,0.464243,0.676362,0.636050,0.328050,-0.153341,0.630130,0.870634,-0.729757,-0.236403,-0.416338,0.949178,-1.053730,0.670418,0.083538,0.842089,1.244738,1.073141,-0.384792,0.876188,-1.657963,-1.579968,0.708766,-0.497640,1.405076,-1.531021,0.948808,0.070705,0.964662,1.358701,1.120535,0.402139,-0.452392,1.081149,1.180478,-0.721535,0.034781,-0.722979,1.073543,-0.870038,0.321614,-0.333465,-0.767048,-0.817528,-0.052834,-0.357932,-0.604719,0.631989,0.424310,-0.062735,-0.278915,0.566197,-0.618803,0.478664,0.120946,-0.314683,-0.659744,-0.755548,0.545349,0.044503,0.552104,0.937941,-0.900887,0.464240,0.276036,-0.904622,1.178966,0.882879,0.144802,-0.705658},
  {0.851483,1.167877,-0.986300,-0.286561,-0.632630,-1.267943,1.282097,-0.733921,-0.302726,1.151482,1.473284,1.032081,0.045950,-0.971218,-1.494683,1.228001,0.404788,0.542230,1.222032,-1.336897,0.753024,0.072361,-0.917641,-1.287045,-1.066947,-0.367372,1.065042,-1.166876,-0.685060,-0.123038,-0.789155,1.015394,-0.855665,0.265474,0.308611,-0.792952,-0.893914,-0.639558,-0.141906,0.397388,-0.801810,-0.825165,0.455595,-0.069881,0.515140,-0.806336,0.670665,-0.350157,-0.178696,-0.593321,-0.791131,-0.695129,0.757128,0.025092,0.746879,1.224122,-1.155159,-0.502610,-0.456866,1.219080,-1.433006,0.892449,-0.114887,-1.090383,-1.520248,-1.179477,-0.255406,-0.781786,-1.387654,1.289130,0.598302,0.326007,-1.087575,1.295140,-0.933943,-0.143557,0.691699,1.185560,0.513606,0.292127,0.936934,-1.123903,-0.773205,0.089497,0.549987,-0.927554,0.859490,-0.472912,0.092839,0.592634,0.834217,0.724364,-0.323200,0.226635,-0.685949,-0.827721,0.596702,-0.149202,-0.369809,0.689486,-0.755272,-0.514819,-0.076820,0.404353},
  {0.121832,0.080437,0.050128,0.146287,-0.135334,-0.061801,-0.028595,0.158720,-0.101849,0.042017,-0.050758,-0.062789,-0.001150,0.061674,0.062860,0.032066,0.081533,-0.033851,0.023908,-0.040082,0.093317,-0.026409,0.030483,0.001683,-0.030371,-0.072243,-0.044775,-0.046032,-0.187981,0.264137,0.129242,0.154622,-0.304113,0.334991,-0.076939,-0.170352,-0.340164,-0.290832,-0.067171,0.187249,-0.293255,-0.272328,0.154488,-0.058648,0.273380,-0.290924,0.234666,0.022852,-0.213039,-0.320767,-0.230668,0.008522,-0.043301,-0.107551,0.139529,0.086809,0.036413,0.141724,-0.147900,0.060741,0.067006,-0.116953,-0.072384,0.017309,0.065996,0.037923,-0.024864,0.056999,0.019561,0.049474,0.078707,-0.045105,-0.005573,0.052144,-0.058481,-0.056677,-0.050436,-0.020827,0.146998,-0.179089,-0.092436,-0.093772,-0.269378,0.292958,-0.104858,-0.166709,0.357500,-0.316776,-0.084311,0.192852,0.346368,0.301565,-0.100345,0.129540,-0.277318,-0.293937,0.177758,0.037070,-0.235255,0.331665,-0.239692,-0.009008,0.234909,0.339971},
  {-0.595135,-0.052396,-0.533253,-0.826659,0.717668,0.356683,0.090577,-0.578411,0.753653,-0.736406,-0.383113,0.155237,0.682583,0.954863,0.790304,-0.246845,0.526884,-1.138264,-1.163877,0.551917,0.275373,-1.064365,1.236144,0.838588,0.035556,-0.775936,-1.113957,0.465672,-0.355057,0.984804,1.210842,-0.910329,0.076224,0.725877,-1.272506,1.105926,0.431168,-0.454119,-1.099995,-1.198601,0.687087,-0.073010,0.705837,1.014030,-0.899903,0.324653,0.268822,-0.811347,0.908732,0.656888,0.114323,-0.486829,0.655613,0.855459,-0.677161,-0.209397,-0.329076,-0.701351,0.773204,-0.554125,0.113143,0.373654,0.751237,0.854146,0.593357,0.020145,-0.643284,1.065703,0.996837,-0.410905,0.436472,-1.107995,1.223104,-0.731310,-0.135864,-0.921794,-1.251506,-0.987007,0.546435,-1.117327,-1.178208,0.697218,-0.111898,0.884857,-1.265614,1.029074,-0.293953,-0.601199,-1.188482,-1.180603,-0.599101,0.241582,-0.923646,-1.127917,0.802068,0.150268,0.514429,-0.926972,0.916089,-0.532371,-0.074646,-0.634321,-0.917529,-0.801737},
  {-0.227657,0.252087,-0.581232,-0.623543,0.385082,-0.001110,0.343506,-0.490602,0.431776,-0.219354,0.031355,0.246444,0.384790,0.418107,0.314536,-0.059142,0.280044,-0.556997,-0.607733,0.348169,0.143054,-0.603169,0.784250,0.555837,0.033097,-0.506621,-0.670717,0.251806,-0.262852,0.639306,0.723516,-0.498495,0.073791,0.398033,-0.709961,0.731991,0.415582,-0.119354,-0.633177,-0.867500,0.687207,0.153228,0.477262,0.880141,-0.848375,0.406327,0.239905,-0.755935,0.907610,0.618541,0.041251,-0.542159,0.660725,0.630093,-0.331029,0.112543,-0.484495,-0.587699,0.407635,-0.124448,-0.204416,0.368152,0.403749,0.311185,0.129815,-0.105845,-0.347353,0.484309,0.460024,-0.222786,0.200966,-0.609728,0.703660,-0.473343,-0.072358,-0.588568,-0.817349,-0.635553,0.391086,-0.739242,-0.716706,0.361652,-0.115068,0.511939,-0.736145,0.610309,-0.259460,-0.272060,-0.695375,-0.826601,-0.573332,-0.028348,-0.578083,-0.903127,0.769762,0.269099,0.352348,-0.844412,0.879392,-0.529296,-0.113099,-0.672256,-0.905596,-0.709615},
  {0.675861,0.359863,0.099527,0.522137,-0.726362,-0.598131,0.190162,0.280131,-0.681230,0.755336,0.494472,-0.024832,-0.567821,-0.864469,-0.749241,0.240566,-0.387091,0.817529,0.859337,-0.490831,-0.149024,0.671573,-0.892149,-0.666740,-0.139011,0.429860,0.748140,-0.399954,0.130101,-0.601756,-0.780135,0.593237,-0.177563,-0.350600,0.684175,-0.737499,-0.432627,0.069079,0.526633,0.718831,-0.578898,-0.161123,-0.316822,-0.596327,0.569868,-0.338848,-0.031211,0.309649,-0.480351,-0.461227,-0.293282,-0.022274,-0.230915,-0.610267,0.723786,0.493686,-0.029167,0.430549,-0.690638,0.696984,-0.345072,-0.141323,-0.611158,-0.811154,-0.621386,-0.108511,0.487998,-0.844293,-0.806518,0.383399,-0.252060,0.780245,-0.878129,0.589318,0.018696,0.582478,0.858610,0.730043,-0.282034,0.710212,0.787641,-0.493012,-0.004507,-0.458819,0.754989,-0.666680,0.317936,0.220257,0.636828,0.757590,0.524386,0.054255,0.442159,0.687497,-0.579224,-0.235059,-0.157559,0.477870,-0.525390,0.409383,-0.119959,0.168598,0.397561,0.502685},
  {-0.009701,-0.148408,0.219401,0.075812,0.178738,0.279185,-0.155678,0.039199,0.182151,-0.185503,-0.138959,-0.032041,0.085688,0.184173,0.235991,-0.147081,-0.017863,-0.107742,-0.243408,0.291266,-0.064346,-0.106833,0.315004,0.299365,0.141631,-0.056726,-0.217719,0.196323,0.048133,0.175267,0.289261,-0.224672,0.132661,0.155854,-0.269807,0.322154,0.131885,-0.115498,-0.251949,-0.198037,0.076990,-0.084801,0.189158,0.133849,-0.004139,0.033635,0.029807,-0.004153,0.128523,0.164992,0.107032,-0.029519,-0.191511,-0.106006,-0.133812,-0.260264,0.164495,-0.010269,0.136464,-0.272400,0.141344,-0.054114,0.081512,0.151270,0.149275,0.085617,-0.030222,0.109451,0.210697,-0.258805,-0.108354,-0.169521,0.258972,-0.305449,0.071235,-0.150489,-0.291712,-0.287974,0.006183,-0.210649,-0.277812,0.179859,0.038758,0.097258,-0.311479,0.254236,-0.145006,-0.166663,-0.333077,-0.303508,-0.106949,0.109724,-0.262702,-0.196981,-0.000291,-0.094274,0.046628,-0.087628,0.027854,-0.107161,0.023845,-0.066793,-0.173041,-0.197809},
  {0.574683,1.217955,-1.292565,-0.661789,-0.342290,-1.095235,1.215743,-0.834519,-0.061989,0.756120,1.070608,0.811956,0.160406,-0.517822,-0.880541,0.720020,0.287283,0.147113,0.465433,-0.564590,0.308341,-0.124188,-0.142169,-0.255567,-0.313624,-0.332854,-0.126451,-0.188177,-0.421221,0.439491,0.308336,-0.074427,-0.327533,0.472745,-0.550353,0.288379,-0.041514,-0.405144,-0.673804,-0.711219,0.363955,-0.179330,0.691947,0.988210,-0.835434,0.065632,0.706728,-1.283754,1.070142,0.312366,-0.661400,-1.323209,1.234302,0.524176,0.483890,1.194598,-1.246166,-0.702755,-0.137071,0.959398,-1.167011,0.866057,0.119581,-0.612389,-0.962063,-0.791687,-0.245414,-0.303827,-0.655868,0.683171,0.370657,0.066576,-0.279191,0.407946,-0.293482,-0.178888,-0.055114,0.086113,0.388350,-0.357224,-0.201378,-0.040724,-0.339176,0.541084,-0.411492,0.196129,0.197808,-0.429591,-0.556055,-0.468269,-0.161683,0.289934,-0.662353,-0.831608,0.633682,0.003624,0.772529,-1.130646,0.994834,-0.196034,-0.676619,-1.267667,-1.181492,-0.449633},
  {-0.526164,-0.301385,-0.109032,-0.464736,0.605201,0.518922,-0.212933,-0.316034,0.649063,-0.773340,-0.476595,0.068730,0.595010,0.828339,0.638743,-0.163158,0.432676,-0.852942,-0.823473,0.366587,0.172915,-0.712088,0.835796,0.612272,0.093013,-0.489212,-0.853685,0.395290,-0.227453,0.714475,0.893903,-0.671131,0.036295,0.522213,-0.894959,0.739407,0.272226,-0.309296,-0.721815,-0.785579,0.451700,-0.024725,0.415723,0.629602,-0.594856,0.228286,0.124932,-0.484916,0.538816,0.404477,0.102991,-0.235828,0.233686,0.512370,-0.550649,-0.389927,0.074527,-0.349597,0.687074,-0.631919,0.349787,0.221942,0.683864,0.840526,0.590805,0.044460,-0.526823,0.881292,0.765316,-0.238893,0.361702,-0.746730,0.863746,-0.492044,-0.018254,-0.559500,-0.836557,-0.718374,0.361251,-0.776997,-0.865031,0.570214,-0.045202,0.677504,-0.887102,0.744862,-0.158915,-0.397381,-0.773425,-0.752172,-0.370267,0.167071,-0.551505,-0.695044,0.559971,0.157632,0.319928,-0.541664,0.604839,-0.327491,0.018163,-0.316607,-0.494762,-0.454290},
  {0.470848,0.728030,-0.630928,-0.356563,-0.014891,-0.507917,0.910587,-0.760991,0.393358,0.395638,0.988422,1.146401,0.744664,-0.036748,-0.798992,1.240800,1.001808,-0.211677,0.597535,-1.048949,1.184433,-0.615679,-0.077695,-0.832242,-1.203741,-0.990774,0.653797,-1.195915,-1.215715,0.693030,-0.239558,1.099942,-1.230482,0.926622,-0.045582,-0.644709,-1.072792,-0.981438,-0.438971,0.303116,-0.822815,-1.033728,0.837411,0.180896,0.619659,-0.939347,0.961516,-0.372999,-0.183605,-0.672060,-0.798692,-0.556679,0.515915,0.154141,0.215451,0.590875,-0.821450,-0.652794,0.103604,0.418571,-0.960718,0.934232,0.493070,-0.264991,-0.959418,-1.214006,-0.878066,0.036656,-0.761667,1.124593,1.013616,-0.497206,-0.386932,0.956577,-1.245298,-0.902102,-0.138430,0.707788,1.134429,-0.530733,0.413398,-1.212894,-1.336320,0.734445,0.062836,-0.929755,1.174426,-1.004556,-0.333371,0.434546,0.961425,1.028689,-0.696844,0.009391,-0.766978,-1.095306,0.837754,-0.331247,-0.448028,0.832358,-0.942109,-0.563867,0.004125,0.493191},
  {-0.137075,0.239620,-0.452637,-0.535581,0.463315,0.158485,0.270519,-0.496773,0.629664,-0.385196,-0.010844,0.396286,0.659881,0.659320,0.380064,0.134526,0.574998,-0.734274,-0.603302,0.213443,0.412151,-0.750876,0.828839,0.453275,-0.119448,-0.597674,-0.565004,0.193903,-0.274631,0.665664,0.752347,-0.499707,0.130989,0.451280,-0.784134,0.884624,0.492509,-0.180574,-0.793929,-1.002980,0.732318,0.031120,0.724049,1.050446,-0.798595,0.273221,0.456823,-0.834394,0.913930,0.529878,-0.071006,-0.612905,0.602910,0.565464,-0.290770,0.054637,-0.349135,-0.542328,0.550493,-0.262889,-0.087256,0.479649,0.649341,0.548966,0.211650,-0.226864,-0.581754,0.725885,0.518074,-0.024087,0.489723,-0.773135,0.753582,-0.294818,-0.257783,-0.709710,-0.799327,-0.498952,0.501242,-0.708901,-0.644906,0.362384,-0.086290,0.548322,-0.756885,0.722137,-0.276722,-0.296688,-0.815671,-0.949521,-0.581493,0.124412,-0.760728,-1.031746,0.794427,0.135479,0.591922,-0.937691,0.880759,-0.356079,-0.247042,-0.739984,-0.872772,-0.593663},
  {-0.306469,-0.019639,-0.317654,-0.460466,0.352556,0.144229,0.083643,-0.411003,0.429217,-0.365054,-0.064038,0.256311,0.434183,0.379796,0.122343,0.137035,0.375335,-0.477319,-0.291009,-0.085870,0.284141,-0.448752,0.257026,-0.001763,-0.247717,-0.350782,-0.107518,-0.117042,-0.180749,0.093829,0.056752,-0.109524,0.023934,-0.035968,-0.146591,0.184508,0.198556,0.072336,-0.144669,-0.330150,0.299455,0.163225,0.008452,0.233446,-0.405233,0.268598,-0.132316,-0.202411,0.341411,0.390738,0.232085,-0.082605,0.380070,0.458665,-0.314860,-0.067930,-0.182807,-0.387179,0.450507,-0.245807,-0.025959,0.355451,0.493009,0.397078,0.112405,-0.218205,-0.429386,0.451877,0.228818,0.125553,0.383902,-0.418783,0.300551,0.019074,-0.251367,-0.357466,-0.261954,-0.040678,0.254951,-0.175168,-0.065936,0.010995,-0.026967,0.079388,-0.085341,0.168741,-0.137354,0.074329,-0.099182,-0.252654,-0.277456,-0.136341,-0.069888,-0.277482,0.374964,0.264647,-0.002345,-0.207157,0.391661,-0.348027,0.199642,-0.089787,-0.358751,-0.463538},
  {0.086929,0.918234,-1.361549,-1.043988,0.119683,-0.811907,1.257155,-1.179366,0.410724,0.384360,0.997016,1.104617,0.709098,0.019440,-0.664524,0.999076,0.966155,-0.571328,0.146291,-0.881635,1.111050,-0.949763,0.196908,-0.618091,-1.161502,-1.153805,0.225236,-0.964359,-1.156481,0.736136,0.052071,0.546481,-0.969535,0.816165,-0.456851,-0.176273,-0.641172,-0.846851,-0.733680,-0.345919,-0.249723,-0.709283,0.828396,0.636556,-0.192815,-0.485590,0.820605,-0.892653,0.423670,-0.169029,-0.671933,-0.873580,1.216496,0.845614,-0.047936,0.856129,-1.373217,-1.128714,0.265913,0.585983,-1.218900,1.124358,0.564038,-0.223205,-0.874662,-1.130587,-0.914921,0.269601,-0.437791,0.917830,1.059728,-0.776004,0.000869,0.690902,-1.191082,-1.073293,-0.442044,0.394843,1.112686,-0.714631,0.054980,-0.803688,-1.081593,0.795284,-0.291159,-0.400907,0.750901,-0.877518,-0.602514,-0.122040,0.380075,0.721302,-0.831273,-0.541148,-0.054120,-0.605395,0.852581,-0.822520,0.285857,0.271772,-0.805361,-0.904528,-0.613264,-0.092880},
  {-0.732930,-0.521555,0.041987,-0.456813,0.732417,0.674726,-0.310495,-0.228558,0.610700,-0.733331,-0.508754,-0.077827,0.362835,0.632096,0.629324,-0.380107,0.049273,-0.485318,-0.707066,0.603176,-0.254984,-0.256081,0.621302,0.717325,0.481965,0.030248,-0.703159,0.660668,0.356333,0.090979,0.537349,-0.791698,0.668213,-0.255345,-0.353745,0.799568,0.889042,0.525525,-0.126753,-0.735894,0.962119,0.716722,-0.132854,0.513800,-0.900940,0.805536,-0.370263,-0.246031,0.680466,0.797487,0.548437,0.067042,0.084771,0.533190,-0.751345,-0.616057,0.180061,-0.343147,0.697413,-0.722774,0.404424,0.079018,0.507605,0.693658,0.575261,0.219379,-0.221216,0.565458,0.679080,-0.506087,-0.100022,-0.370040,0.680069,-0.690901,0.375082,-0.111695,-0.545240,-0.729440,-0.202622,-0.271877,-0.632631,0.733158,0.526747,-0.076701,-0.451812,0.805915,-0.806398,0.399352,-0.234261,-0.784907,-0.957561,-0.646149,0.000007,-0.640502,0.947294,0.781420,-0.245705,-0.389005,0.800891,-0.825467,0.465268,-0.080872,-0.560863,-0.768294},
  {-0.190572,-0.446718,0.494808,0.371729,-0.095474,0.312257,-0.645771,0.569336,-0.304133,-0.229253,-0.614521,-0.715337,-0.485019,-0.041169,0.402678,-0.701542,-0.633963,0.233126,-0.231263,0.551000,-0.726339,0.461900,-0.079855,0.391448,0.669145,0.618882,-0.228621,0.568602,0.689178,-0.535180,-0.086153,-0.452385,0.680421,-0.691163,0.265730,0.188583,0.594874,0.691629,0.434349,-0.038688,0.425976,0.630204,-0.573848,-0.222487,-0.243350,0.467615,-0.579777,0.344026,-0.079483,0.254842,0.463706,0.458632,-0.438559,-0.264542,-0.041403,-0.381146,0.589256,0.517995,-0.168550,-0.274432,0.623006,-0.650871,-0.363282,0.107305,0.527180,0.695772,0.540687,-0.130364,0.328348,-0.629532,-0.654816,0.388771,0.081347,-0.503279,0.716183,0.585861,0.179692,-0.311356,-0.688335,0.409800,-0.067228,0.522436,0.728895,-0.588048,0.187396,0.327445,-0.671454,0.711268,0.395525,-0.107809,-0.544727,-0.699632,0.520141,0.098579,0.346977,0.593412,-0.550337,0.293668,0.085993,-0.387912,0.535271,0.447574,0.174765,-0.168332},
  {-0.439368,-0.347390,0.064036,-0.293357,0.525861,0.476556,-0.173381,-0.178667,0.475231,-0.517513,-0.339631,0.000856,0.359649,0.574440,0.530358,-0.205313,0.229993,-0.556147,-0.619938,0.375187,0.098179,-0.479783,0.634896,0.450505,0.063768,-0.314346,-0.440776,0.208843,-0.094887,0.338703,0.409546,-0.303134,0.126683,0.118740,-0.281323,0.377358,0.318746,0.131121,-0.130088,-0.362792,0.468172,0.335964,0.000950,0.355913,-0.531869,0.459359,-0.100102,-0.278927,0.524324,0.460789,0.170206,-0.158576,-0.011084,0.306982,-0.511339,-0.433296,0.102096,-0.271070,0.490998,-0.512946,0.249575,0.083775,0.399963,0.536345,0.426137,0.103130,-0.297687,0.560256,0.575001,-0.311762,0.143268,-0.551168,0.630224,-0.424791,-0.031033,-0.428622,-0.592977,-0.465401,0.205158,-0.439700,-0.444875,0.250011,-0.003375,0.209981,-0.364710,0.335576,-0.230135,-0.005647,-0.230286,-0.387236,-0.402539,-0.242864,-0.074042,-0.374631,0.498609,0.389621,-0.078541,-0.335259,0.531989,-0.478779,0.127331,-0.250162,-0.463690,-0.420523},
  {-0.986676,-0.803301,0.241939,-0.361363,0.757805,0.874252,-0.653550,0.032016,0.502365,-0.916312,-0.869137,-0.447054,0.154054,0.667690,0.875820,-0.752698,-0.252877,-0.418382,-0.877998,0.908981,-0.626139,-0.068427,0.640279,0.961066,0.815257,0.280431,-0.866939,0.916487,0.622538,-0.116116,0.496042,-0.966898,0.928069,-0.569644,-0.197207,0.813682,1.108882,0.841563,0.126865,-0.667907,1.070276,0.978190,-0.473269,0.254895,-0.860835,0.953273,-0.751323,0.149798,0.399867,0.845659,0.937115,0.599012,-0.094601,0.505965,-0.908222,-0.878671,0.435624,-0.156779,0.645946,-0.942405,0.725675,-0.270367,0.343710,0.786367,0.864244,0.552239,-0.008284,0.527452,0.865850,-0.871801,-0.445979,-0.240159,0.750136,-1.015058,0.714294,0.111211,-0.554260,-0.964364,-0.508039,-0.168286,-0.720121,0.927356,0.788650,-0.345448,-0.371078,0.876030,-1.096146,0.702565,-0.024501,-0.783241,-1.175678,-0.989558,0.277223,-0.505382,0.964946,0.985289,-0.608487,-0.085421,0.612688,-0.961124,0.827645,0.390318,-0.248068,-0.829240},
  {-0.098658,-0.694655,0.928181,0.667797,-0.096971,0.423157,-0.652013,0.612219,-0.319382,0.018222,-0.266205,-0.465450,-0.535162,-0.416690,-0.093604,-0.314690,-0.654575,0.726788,0.422787,0.123516,-0.583213,0.817196,-0.638471,-0.196320,0.341567,0.754478,0.605065,-0.021852,0.608832,-0.983192,-0.916425,0.395646,0.401593,-0.984719,1.124946,-0.659372,0.114829,0.831035,1.142067,0.911165,-0.237487,0.520747,-1.011077,-1.042883,0.600051,0.168881,-0.809865,1.095468,-0.809701,-0.167080,0.531638,0.956145,-0.979217,-0.649962,-0.018066,-0.597186,0.795416,0.622552,-0.237542,-0.231605,0.459608,-0.562112,-0.463546,-0.245842,0.059628,0.387091,0.606633,-0.614550,-0.288125,-0.250150,-0.677014,0.764401,-0.555524,0.015968,0.462933,0.768803,0.737538,0.379485,-0.696573,0.917891,0.755461,-0.234645,0.482633,-1.036922,1.023401,-0.554927,-0.276256,0.910008,1.121052,0.773096,0.049383,-0.694250,1.069857,0.969496,-0.446273,0.313702,-0.953382,1.069566,-0.741192,-0.005213,0.664695,1.015462,0.867224,0.319277},
  {0.524508,0.479630,-0.249245,0.123374,-0.491542,-0.660926,0.531061,-0.172398,-0.316203,0.665421,0.743917,0.482931,-0.024159,-0.564839,-0.887697,0.799098,0.319885,0.350535,0.907014,-1.047473,0.632993,0.097375,-0.822215,-1.130752,-0.879407,-0.201815,1.034858,-1.025965,-0.530140,-0.215455,-0.847386,1.076700,-0.827824,0.157868,0.571197,-1.053836,-1.011180,-0.476110,0.278974,0.871811,-1.029477,-0.678128,0.019294,-0.594164,0.884393,-0.784185,0.321659,0.229107,-0.675016,-0.794717,-0.562716,-0.094245,0.033558,-0.300422,0.486325,0.550956,-0.436422,-0.049571,-0.450022,0.645521,-0.691618,0.288840,-0.211334,-0.665522,-0.862895,-0.689657,-0.190387,-0.502152,-0.947966,0.902087,0.455081,0.200259,-0.919918,1.066947,-0.803953,-0.076263,0.671792,1.065047,0.321400,0.358986,0.915466,-1.098703,-0.717639,-0.054073,0.677542,-1.116676,0.894810,-0.365624,0.398650,0.943547,0.997930,0.546315,0.094817,0.709039,-1.008937,-0.772065,0.145642,0.376884,-0.824177,0.758857,-0.492908,0.029740,0.500856,0.713777},
  {0.256817,0.470126,-0.494538,-0.318490,0.008707,-0.317997,0.536179,-0.550926,0.331802,0.066129,0.493750,0.748118,0.662594,0.217783,-0.402788,0.876737,0.916513,-0.457003,0.276191,-0.881841,1.019508,-0.614047,-0.100050,-0.729660,-0.954132,-0.695109,0.445013,-0.762965,-0.718527,0.372548,-0.103126,0.507423,-0.683050,0.568419,-0.214506,-0.228705,-0.571911,-0.663856,-0.461266,-0.051617,-0.383256,-0.648206,0.621146,0.309524,0.148220,-0.540902,0.682903,-0.502638,0.086208,-0.364342,-0.630999,-0.592784,0.407735,0.165063,0.106146,0.382741,-0.554524,-0.464994,0.138451,0.174576,-0.549432,0.628694,0.474473,0.050566,-0.479245,-0.850675,-0.831117,0.320012,-0.371040,0.871424,0.962968,-0.572825,-0.221704,0.799045,-1.032765,-0.689335,-0.035187,0.573411,0.687083,-0.278579,0.249119,-0.666476,-0.735771,0.453951,-0.089100,-0.395887,0.611368,-0.656889,-0.374838,0.061132,0.459674,0.642693,-0.579124,-0.212236,-0.295115,-0.631031,0.638621,-0.443506,-0.054638,0.433840,-0.698380,-0.588698,-0.217329,0.228611},
  {-0.000634,0.070503,-0.091578,-0.116591,0.163865,0.185942,-0.122384,-0.032239,0.259144,-0.401753,-0.361352,-0.100553,0.272771,0.558970,0.579692,-0.281728,0.190682,-0.596401,-0.725292,0.490803,0.024831,-0.537984,0.812457,0.677933,0.199129,-0.389344,-0.807530,0.430722,-0.166809,0.695301,0.887086,-0.647169,0.104249,0.517324,-0.890348,0.850883,0.377530,-0.303777,-0.852189,-0.973337,0.592805,-0.113141,0.768422,1.004418,-0.696452,0.045287,0.610429,-0.892121,0.705998,0.174087,-0.385163,-0.685801,0.163922,0.114962,-0.108333,-0.077116,-0.009769,-0.106467,0.196525,-0.319955,0.227423,-0.047854,0.253793,0.472575,0.456572,0.171509,-0.259236,0.571550,0.641105,-0.405268,0.092683,-0.603167,0.759620,-0.604132,0.063623,-0.497688,-0.834397,-0.770244,0.270521,-0.774902,-0.875265,0.521325,-0.058716,0.589124,-0.915021,0.734850,-0.259920,-0.430585,-0.901018,-0.942698,-0.511594,0.189240,-0.837545,-1.024130,0.639342,-0.053579,0.674325,-0.983342,0.694220,-0.128743,-0.522981,-0.822239,-0.688434,-0.242765},
  {-0.310306,-0.630260,0.607439,0.335558,0.028534,0.359541,-0.524405,0.397713,-0.189776,-0.114841,-0.309403,-0.377422,-0.326241,-0.194637,-0.021411,-0.198764,-0.362876,0.409526,0.332045,-0.098908,-0.318513,0.602642,-0.685027,-0.374660,0.177999,0.687610,0.573499,0.001461,0.615892,-0.951607,-0.792155,0.223205,0.392936,-0.888268,0.913547,-0.567702,0.091425,0.729148,1.028411,0.813239,-0.195850,0.570947,-1.082049,-1.007278,0.384879,0.362687,-0.955136,0.982091,-0.584378,0.086760,0.656761,0.874713,-0.667625,-0.314468,-0.198087,-0.532568,0.550625,0.367731,-0.099834,-0.267799,0.382391,-0.432289,-0.282293,-0.070846,0.124144,0.256671,0.310639,-0.335506,-0.203271,-0.085041,-0.360969,0.504023,-0.546212,0.194021,0.227111,0.650558,0.761521,0.452123,-0.718483,0.895288,0.658769,-0.129864,0.508218,-0.943140,0.827237,-0.422020,-0.291584,0.784598,0.966910,0.671797,0.012886,-0.700231,1.042436,0.900185,-0.327781,0.463091,-1.050009,0.983830,-0.518931,-0.278366,0.790815,0.927336,0.607208,0.022890},
  {-0.617008,-0.470103,0.032735,-0.415771,0.616147,0.489915,-0.115775,-0.348339,0.547540,-0.482609,-0.156996,0.198747,0.395850,0.364505,0.167951,0.037477,0.197484,-0.272893,-0.229043,0.102928,-0.002776,-0.155964,0.227667,0.240202,0.132476,-0.068164,-0.338503,0.205609,-0.026224,0.216712,0.286687,-0.204315,-0.021388,0.142892,-0.184689,0.068706,-0.021535,-0.034506,0.015060,0.040216,0.000396,0.133144,-0.245231,-0.178923,-0.062171,0.270199,-0.387897,0.226950,0.038540,0.318154,0.421661,0.292739,-0.033766,0.390594,-0.654663,-0.517891,0.050305,-0.402499,0.580233,-0.522172,0.096791,0.252992,0.466635,0.401838,0.135721,-0.161515,-0.340195,0.293321,0.172273,-0.061197,0.081195,-0.225954,0.202796,-0.218005,0.048867,-0.120454,-0.275681,-0.326734,0.000870,-0.272793,-0.352895,0.190348,-0.034380,0.174095,-0.274645,0.116721,-0.017332,-0.122574,-0.103461,-0.040845,-0.026614,-0.089168,0.107370,0.087546,0.004957,0.196316,-0.340291,0.179503,0.030601,-0.347913,0.387259,0.244972,-0.054166,-0.342917},
  {-1.213767,-1.279313,0.768745,-0.198166,1.129996,1.428598,-0.955584,0.179528,0.788022,-1.196072,-1.095576,-0.492355,0.317057,0.975960,1.211106,-0.846977,-0.170191,-0.523756,-1.046456,1.146861,-0.560895,-0.139731,0.903701,1.157957,0.882435,0.236340,-0.887219,0.966412,0.567267,0.112280,0.645525,-0.816500,0.784260,-0.284724,-0.164694,0.672191,0.826771,0.667058,0.269260,-0.214055,0.692487,0.853311,-0.613761,-0.160962,-0.353049,0.921015,-0.956715,0.678762,0.115207,0.841875,1.208603,1.009231,-0.543992,0.415136,-1.196326,-1.385031,0.876866,-0.057070,0.935867,-1.339690,1.078529,-0.338837,0.518379,1.096538,1.163398,0.719035,-0.029033,0.750991,1.142163,-1.022747,-0.426879,-0.376122,0.991222,-1.141160,0.738700,0.006601,-0.698094,-1.047063,-0.372774,-0.290305,-0.781771,0.907925,0.650520,-0.139788,-0.414399,0.761787,-0.790691,0.487079,0.005650,-0.461823,-0.740711,-0.735867,0.443474,-0.033402,0.530945,0.858965,-0.845937,0.426227,0.236852,-0.863810,1.105878,0.815632,0.098767,-0.697914},
  {0.085193,0.744435,-0.994473,-0.680240,-0.022331,-0.704448,0.964134,-0.652403,0.001042,0.607346,0.817151,0.556282,0.025290,-0.448124,-0.613014,0.430046,0.043474,0.306530,0.427465,-0.287959,0.021412,0.212956,-0.261719,-0.134952,0.060901,0.178938,-0.015643,0.168477,0.190661,-0.056835,0.140097,-0.268366,0.249035,-0.059281,-0.185763,0.370520,0.367136,0.155448,-0.178890,-0.465176,0.533198,0.296294,0.152087,0.564149,-0.687435,0.431221,0.102742,-0.597697,0.784739,0.538435,0.000207,-0.535831,0.994460,0.679100,0.072248,0.757251,-0.969600,-0.656236,0.013639,0.690448,-0.873128,0.635567,0.035318,-0.505247,-0.691501,-0.466042,-0.008780,-0.347041,-0.491269,0.386361,0.062261,0.274684,-0.314914,0.241877,0.039324,0.212325,0.221968,0.083536,-0.151195,0.115993,-0.059531,0.245563,0.236044,-0.023574,-0.146144,0.345428,-0.271923,0.123368,-0.164587,-0.391410,-0.418334,-0.194938,-0.141435,-0.492149,0.641166,0.390074,0.153756,-0.565742,0.772691,-0.459079,-0.034218,-0.557583,-0.769763,-0.560534},
  {-0.381771,-0.262115,0.067268,-0.138770,0.298332,0.358995,-0.295608,0.126503,0.144331,-0.383658,-0.490018,-0.371172,-0.051224,0.332384,0.592650,-0.580608,-0.293330,-0.153919,-0.573528,0.757556,-0.566067,0.083798,0.505091,0.875772,0.813229,0.312507,-0.890616,0.938795,0.482526,0.223972,0.783829,-0.913648,0.599538,-0.004681,-0.533910,0.803589,0.687936,0.273974,-0.243404,-0.635460,0.737179,0.487746,-0.003386,0.467248,-0.691124,0.585322,-0.190523,-0.248579,0.545503,0.560341,0.333729,-0.002459,0.055851,0.264846,-0.344378,-0.309684,0.188234,-0.006686,0.228713,-0.374240,0.413097,-0.247369,0.053743,0.378034,0.561733,0.491969,0.176797,0.261833,0.600337,-0.667814,-0.427036,-0.037007,0.551186,-0.814601,0.705444,0.205514,-0.441375,-0.892424,-0.395205,-0.303696,-0.849422,0.948938,0.547662,0.118912,-0.664734,0.873342,-0.636332,0.145766,-0.386996,-0.715746,-0.709599,-0.381692,-0.105869,-0.547934,0.734191,0.555016,-0.103290,-0.357139,0.638592,-0.575447,0.273345,-0.126367,-0.422093,-0.505512},
  {-1.386128,-1.469027,0.835964,-0.135023,0.985271,1.397396,-1.209450,0.425867,0.469490,-1.223206,-1.406821,-0.966963,-0.086948,0.839729,1.379766,-1.305847,-0.585709,-0.437989,-1.214261,1.374995,-0.956176,0.047476,0.774076,1.231514,1.112380,0.515331,-0.898109,1.106528,0.901757,-0.381119,0.322256,-0.951968,1.159032,-0.959773,0.244155,0.585979,1.253467,1.362359,0.793423,-0.223622,1.153967,1.564977,-1.224542,-0.242420,-0.877263,1.478197,-1.419609,0.637446,0.330663,1.131442,1.395358,1.043041,-0.673374,0.357904,-1.236606,-1.483898,1.011812,0.139026,0.733212,-1.354862,1.284242,-0.736173,0.183236,1.020402,1.393917,1.118073,0.304306,0.622703,1.298641,-1.396940,-0.796778,-0.203608,0.991007,-1.378299,1.033211,0.281512,-0.558892,-1.115695,-0.766424,0.029645,-0.650884,1.024794,1.042488,-0.687156,-0.065147,0.756523,-1.272801,1.159864,0.526709,-0.435671,-1.274077,-1.542542,1.007452,-0.017688,1.017333,1.551630,-1.353161,0.415372,0.599005,-1.376508,1.402482,0.840693,-0.073114,-0.934522},
  {-0.042571,-0.325948,0.463867,0.381772,-0.124744,0.158941,-0.340598,0.390343,-0.218922,-0.000494,-0.199510,-0.265615,-0.199115,-0.075076,0.026115,-0.058712,-0.096153,0.170831,0.219860,-0.173449,0.042459,0.220074,-0.397991,-0.405091,-0.166071,0.218575,0.592809,-0.307851,0.147713,-0.529763,-0.658487,0.460013,0.014415,-0.443828,0.682026,-0.542135,-0.157481,0.295784,0.600158,0.622582,-0.345445,0.065253,-0.427409,-0.617938,0.550362,-0.188763,-0.243029,0.621635,-0.677151,-0.408680,0.090652,0.568031,-0.500723,-0.340248,0.045186,-0.241238,0.401294,0.383743,-0.200944,-0.077520,0.282651,-0.347048,-0.236976,-0.045177,0.114873,0.178538,0.161182,-0.129431,-0.100362,0.051859,-0.043543,0.185268,-0.320348,0.301704,-0.108599,0.212610,0.475843,0.504258,-0.185756,0.542503,0.631733,-0.390411,0.072799,-0.513007,0.676705,-0.510073,0.074530,0.374817,0.636544,0.583962,0.256865,-0.180122,0.516423,0.620781,-0.454211,-0.076835,-0.351087,0.619416,-0.625266,0.313104,0.159107,0.585662,0.729193,0.494220},
  {1.225877,1.196380,-0.617979,0.333287,-1.201692,-1.478981,1.005600,-0.110236,-0.919855,1.429735,1.290517,0.542670,-0.448508,-1.226043,-1.452116,0.999256,0.140045,0.755263,1.366389,-1.411975,0.732561,0.239685,-1.217935,-1.614827,-1.250503,-0.274270,1.544783,-1.519814,-0.723266,-0.436439,-1.319080,1.512375,-1.068797,0.082897,0.816833,-1.383009,-1.280596,-0.629307,0.265999,1.010099,-1.326311,-1.016517,0.225637,-0.619819,1.136904,-1.206737,0.658293,0.089260,-0.842736,-1.163282,-0.978218,-0.398336,0.370287,-0.523331,1.267913,1.393696,-0.799946,0.167287,-1.038097,1.513487,-1.162699,0.352666,-0.655580,-1.328051,-1.364821,-0.771420,0.168222,-0.980458,-1.401242,1.248769,0.492674,0.551354,-1.282879,1.544723,-0.985643,0.026765,1.074768,1.638124,0.515430,0.679997,1.487721,-1.517357,-0.861909,-0.131829,1.113594,-1.443458,1.199115,-0.337063,0.594866,1.240079,1.331929,0.849027,0.039389,0.852126,-1.229069,-1.090806,0.507791,0.385429,-0.984841,1.220231,-0.812574,-0.109229,0.619027,1.061928},
  {0.748858,0.733008,-0.342038,0.202051,-0.646850,-0.822815,0.636720,-0.091483,-0.478824,0.897622,0.882508,0.439529,-0.241047,-0.834867,-1.036221,0.743050,0.034460,0.745169,1.152052,-0.955274,0.300427,0.570873,-1.106402,-1.082362,-0.487347,0.353745,1.101253,-0.631488,0.103626,-0.715579,-0.953510,0.739448,-0.151212,-0.417348,0.794373,-0.731214,-0.348871,0.177663,0.586133,0.683202,-0.418400,0.000791,-0.334769,-0.458043,0.355837,-0.084261,-0.082556,0.169740,-0.119114,-0.108866,-0.153887,-0.190101,0.227917,-0.310677,0.708153,0.781950,-0.491413,0.046233,-0.588809,0.867466,-0.755329,0.262283,-0.382897,-0.879852,-0.972154,-0.586025,0.115659,-0.801448,-1.109333,0.857652,0.155948,0.648227,-1.146740,1.045426,-0.405005,0.451297,1.061265,1.105673,-0.221442,0.861306,1.036065,-0.695508,-0.042186,-0.583358,0.875916,-0.747232,0.272344,0.286051,0.676087,0.718474,0.413401,-0.066287,0.460591,0.584360,-0.408858,-0.067349,-0.227905,0.322494,-0.250961,0.112505,-0.040004,-0.026508,0.002416,0.116309},
  {0.414604,0.034868,0.364214,0.553219,-0.485940,-0.278704,-0.007746,0.416560,-0.612529,0.641894,0.305271,-0.234280,-0.707283,-0.829836,-0.489895,-0.106347,-0.701479,0.958419,0.667232,-0.000453,-0.554196,0.880242,-0.675647,-0.201232,0.339811,0.700184,0.465773,0.041375,0.485200,-0.670858,-0.584690,0.259648,0.274472,-0.588112,0.692349,-0.371756,0.081544,0.478233,0.624734,0.472820,-0.083681,0.257950,-0.395284,-0.374818,0.254441,0.005404,-0.131595,0.286001,-0.277674,-0.244869,-0.119589,0.098541,-0.456241,-0.578757,0.452833,0.152047,0.197088,0.466935,-0.569703,0.467440,-0.126870,-0.319742,-0.688244,-0.748109,-0.406892,0.199026,0.748635,-0.911795,-0.586493,-0.054642,-0.665702,0.916371,-0.674125,0.123512,0.460963,0.778224,0.715825,0.339090,-0.566014,0.715470,0.539548,-0.114927,0.357965,-0.658709,0.657955,-0.324980,-0.147519,0.546200,0.654058,0.439496,0.033189,-0.346436,0.526386,0.439876,-0.171407,0.113445,-0.291357,0.343320,-0.268775,0.150085,0.010575,0.175437,0.322040,0.384627},
  {0.680042,0.556451,-0.225232,0.255427,-0.669477,-0.743216,0.442849,-0.044161,-0.475205,0.689186,0.646202,0.305965,-0.188203,-0.623603,-0.806389,0.589889,0.142833,0.344948,0.739104,-0.847807,0.461519,0.057545,-0.666184,-0.928897,-0.765711,-0.247873,0.808503,-0.899152,-0.529626,-0.117787,-0.655939,0.847201,-0.759469,0.239911,0.287530,-0.795903,-0.916603,-0.636264,-0.060468,0.557520,-0.976044,-0.888267,0.315631,-0.383187,0.854336,-0.994097,0.541919,0.065139,-0.707477,-0.935924,-0.725047,-0.213174,0.066677,-0.389769,0.714340,0.688020,-0.318599,0.160995,-0.536523,0.754482,-0.560923,0.198202,-0.290441,-0.648631,-0.717918,-0.460972,0.019126,-0.472826,-0.765507,0.753952,0.357459,0.256501,-0.694582,0.899817,-0.603544,-0.045760,0.555732,0.909762,0.388113,0.277842,0.770800,-0.866695,-0.602320,0.109011,0.503106,-0.811100,0.842827,-0.422482,0.163142,0.706225,0.954691,0.771957,-0.174291,0.497297,-0.910070,-0.911654,0.490964,0.249638,-0.775190,0.979083,-0.623568,-0.023611,0.555685,0.846616},
  {-0.390293,0.370757,-1.015911,-1.155789,0.707181,-0.056382,0.758797,-1.156408,0.950660,-0.379983,0.377773,0.947989,1.081536,0.721079,0.026671,0.653531,1.063401,-1.013852,-0.475389,-0.299507,0.864748,-1.097820,0.780058,0.152428,-0.545108,-1.013126,-0.627928,-0.109630,-0.784662,1.087495,0.925315,-0.365590,-0.426931,0.964146,-1.132462,0.733863,0.034545,-0.701404,-1.154397,-1.110280,0.521108,-0.320498,1.028000,1.291696,-0.943235,0.042442,0.827916,-1.333401,1.092504,0.346776,-0.525042,-1.082774,1.012042,1.036709,-0.581735,0.203556,-0.930878,-1.182450,0.841190,-0.177476,-0.618801,1.051423,1.031070,0.541229,-0.195192,-0.850324,-1.130353,0.868665,0.239427,0.468490,0.985973,-1.079062,0.620120,0.041291,-0.739070,-1.075694,-0.949137,-0.416426,0.879259,-1.109766,-0.813603,0.112192,-0.621982,1.050276,-1.068314,0.536948,0.169347,-0.868652,-1.160370,-0.951280,-0.318476,0.477735,-1.122504,-1.240509,0.733996,-0.133202,0.942476,-1.362344,1.027608,-0.238010,-0.713861,-1.240110,-1.138484,-0.518446},
  {0.916578,0.804361,-0.307170,0.279713,-0.681925,-0.762960,0.505729,0.010161,-0.473516,0.730984,0.607965,0.188903,-0.303039,-0.605011,-0.565068,0.249648,-0.168560,0.450635,0.437692,-0.187444,-0.066606,0.236496,-0.193590,-0.070084,0.029326,0.031119,-0.079323,0.034387,-0.125126,0.291944,0.295746,-0.081859,-0.211304,0.478548,-0.469513,0.216118,-0.212468,-0.562137,-0.626743,-0.351615,-0.112863,-0.559348,0.756784,0.566293,-0.066084,-0.463887,0.832370,-0.769971,0.339759,-0.320803,-0.859943,-0.971879,0.209546,-0.425805,0.791737,0.775988,-0.422014,0.117737,-0.593825,0.741804,-0.571166,0.093428,-0.403165,-0.686746,-0.613685,-0.234560,0.231204,-0.545728,-0.524857,0.219336,-0.133020,0.325732,-0.332202,0.135810,0.030770,0.109747,0.068196,-0.009756,0.054167,-0.178871,-0.196089,0.040853,-0.197797,0.373601,-0.395697,0.133504,0.222941,-0.543083,-0.573887,-0.289180,0.175250,0.573469,-0.707459,-0.464301,-0.044413,-0.540786,0.778096,-0.677115,0.189896,0.394428,-0.860716,-0.897884,-0.465700,0.245265},
  {0.125072,0.388314,-0.403634,-0.296207,0.144501,-0.084913,0.334919,-0.383297,0.395561,-0.119028,0.218879,0.517986,0.598127,0.375788,-0.058496,0.530849,0.692984,-0.447370,-0.006337,-0.393346,0.682550,-0.524470,0.206555,-0.244179,-0.546684,-0.557339,0.133523,-0.418965,-0.522326,0.410289,0.077633,0.298116,-0.402099,0.412544,-0.159629,-0.027394,-0.220647,-0.306311,-0.267131,-0.120107,-0.028901,-0.215633,0.361182,0.310731,-0.084990,-0.072355,0.296400,-0.300943,0.294177,0.129085,-0.089887,-0.289921,0.512388,0.319353,0.030634,0.275385,-0.339517,-0.334780,0.273596,0.009961,-0.215104,0.486384,0.511008,0.288220,-0.107773,-0.476491,-0.601054,0.450615,0.001500,0.504504,0.701869,-0.487958,0.136143,0.383236,-0.590092,-0.544417,-0.217689,0.219542,0.609338,-0.323748,0.057027,-0.333643,-0.469393,0.422480,-0.089854,-0.134094,0.375150,-0.333523,-0.216154,-0.020633,0.182337,0.325590,-0.294550,-0.195478,0.062256,-0.148602,0.345101,-0.284645,0.221816,0.036877,-0.169250,-0.296704,-0.308660,-0.181686},
  {0.337407,-0.155715,0.639014,0.829735,-0.663345,-0.299066,-0.178308,0.816188,-1.014204,0.892634,0.216059,-0.639990,-1.221153,-1.171529,-0.470429,-0.442495,-1.194796,1.386129,0.815887,0.189795,-0.906269,1.298930,-0.946394,-0.266508,0.510740,1.070299,0.825752,-0.012303,0.779214,-1.180323,-1.095080,0.530452,0.455021,-1.074345,1.298398,-0.739723,0.089510,0.846133,1.180337,0.981429,-0.309254,0.384783,-0.812302,-0.952142,0.765694,-0.114632,-0.448059,0.981918,-0.946048,-0.540536,0.151484,0.810012,-0.729691,-0.741500,0.524641,0.088478,0.437999,0.813105,-0.870599,0.628389,0.039836,-0.717502,-1.161755,-1.036304,-0.331625,0.619163,1.303565,-1.287773,-0.629915,-0.312933,-1.101062,1.346103,-0.864773,0.090029,0.745237,1.176638,1.099669,0.573832,-0.866937,1.226052,1.005872,-0.266634,0.601565,-1.172695,1.249808,-0.632150,-0.215510,1.005713,1.246093,0.896397,0.170590,-0.565521,1.032660,1.000606,-0.524599,0.112272,-0.655148,1.002430,-0.853692,0.404776,0.320012,0.891433,1.075276,0.764150},
  {-1.582562,-0.197161,-1.298690,-2.149763,1.935032,0.775460,0.736419,-1.851040,2.079713,-1.328909,0.014174,1.334212,2.035800,1.801275,0.728544,0.704743,1.819472,-2.070071,-1.322070,-0.072005,1.436161,-2.066288,1.677468,0.479556,-0.892894,-1.757234,-0.907506,-0.253664,-1.199296,1.539925,1.192233,-0.377099,-0.514165,1.143407,-1.266302,0.885608,0.158164,-0.610363,-1.108605,-1.138270,0.703040,-0.014988,0.714148,1.104925,-1.044042,0.583523,0.116600,-0.775967,1.169228,1.113837,0.593281,-0.236679,1.514346,2.207289,-1.767796,-0.467939,-1.027590,-2.021411,2.045466,-1.042001,-0.367747,1.629808,2.093346,1.598808,0.381357,-1.006302,-1.929639,1.982091,1.067171,0.398703,1.661727,-2.093245,1.551374,-0.197273,-1.165626,-1.935075,-1.724618,-0.694273,1.521839,-1.649304,-1.055698,0.086294,-0.850431,1.375355,-1.240871,0.672165,0.187306,-0.873114,-1.205266,-1.031253,-0.432993,0.336299,-0.923942,-1.143286,0.917150,0.301481,0.448527,-0.956631,1.151631,-0.842778,0.248155,-0.514176,-1.124919,-1.311703},
  {-0.392487,-0.596298,0.518561,0.136724,0.309175,0.474442,-0.305024,0.117419,0.162173,-0.158764,-0.090061,0.002195,0.031340,-0.003262,-0.036206,0.073167,-0.017184,0.182398,0.230685,-0.129091,0.075949,0.159352,-0.258404,-0.333113,-0.236232,0.048860,0.661475,-0.519058,-0.086055,-0.439554,-0.843685,0.844212,-0.223551,-0.473764,1.071880,-0.979727,-0.375829,0.486655,1.129175,1.184262,-0.541345,0.360903,-1.028367,-1.186566,0.748577,0.199646,-0.907465,1.218758,-0.761614,0.024003,0.762250,1.073656,-0.510217,-0.081938,-0.348858,-0.546041,0.426283,0.102579,0.203831,-0.319785,0.232780,-0.058982,0.059128,0.068701,0.020194,-0.001298,0.041030,-0.110139,-0.140317,0.092342,-0.021953,0.153873,-0.245766,0.253630,-0.142864,0.078312,0.337349,0.494337,0.051159,0.432245,0.760112,-0.687581,-0.186224,-0.498582,0.971295,-0.919407,0.330112,0.491694,1.081003,1.090132,0.491590,-0.397580,1.089841,1.196411,-0.650545,0.250451,-1.011102,1.217340,-0.763933,-0.080405,0.846297,1.126779,0.807387,0.102086},
  {0.796868,0.773432,-0.465831,-0.037716,-0.354438,-0.602679,0.665653,-0.543033,0.156128,0.354946,0.818533,0.951450,0.603858,-0.115612,-0.853720,1.184945,0.919632,-0.175805,0.679785,-1.199342,1.088696,-0.477205,-0.364644,-0.992228,-1.145017,-0.780939,0.638813,-1.084798,-1.034702,0.498751,-0.271316,0.921879,-1.169965,0.825538,-0.098645,-0.699043,-1.126564,-0.992494,-0.390443,0.351701,-0.880590,-0.954772,0.600163,0.049534,0.451244,-0.768178,0.766437,-0.513016,0.024467,-0.507065,-0.884422,-0.901622,0.367403,-0.190489,0.612110,0.718735,-0.547742,-0.263463,-0.068825,0.503826,-0.740000,0.786970,0.422502,-0.216016,-0.835079,-1.082180,-0.766042,0.048392,-0.768557,1.242801,1.050726,-0.295096,-0.518875,1.131902,-1.109446,-0.602464,0.169526,0.847964,0.932470,-0.275943,0.477021,-0.992519,-1.092460,0.709652,0.101416,-0.800497,1.187503,-0.911613,-0.224359,0.558830,1.042528,1.010226,-0.481525,0.181034,-0.660781,-0.846819,0.719227,-0.260537,-0.193740,0.656289,-0.813134,-0.692821,-0.245232,0.385485},
  {0.402415,0.241162,-0.002875,0.180535,-0.257532,-0.252410,0.186245,-0.045131,-0.102898,0.251188,0.303903,0.231190,0.051097,-0.159962,-0.305981,0.331815,0.209507,0.011266,0.227078,-0.352738,0.359587,-0.192858,-0.054860,-0.313068,-0.453730,-0.397949,0.202805,-0.491443,-0.587551,0.411807,-0.009296,0.493947,-0.760274,0.662312,-0.160951,-0.464966,-0.886016,-0.820083,-0.274550,0.443282,-0.897828,-0.839658,0.324528,-0.335293,0.757387,-0.718057,0.344992,0.145425,-0.464179,-0.536820,-0.388526,-0.120541,-0.100290,-0.309414,0.311603,0.225232,-0.120986,0.035527,-0.209850,0.233985,-0.275058,0.122985,-0.055599,-0.240084,-0.343247,-0.309519,-0.148604,-0.118338,-0.301694,0.326410,0.258155,-0.117821,-0.172425,0.323779,-0.438772,-0.326607,-0.064863,0.243843,0.475768,-0.300760,0.086428,-0.520023,-0.706315,0.512292,-0.105113,-0.503752,0.813885,-0.780982,-0.257937,0.434237,0.891718,0.831324,-0.330470,0.376876,-0.872457,-0.822040,0.303251,0.228859,-0.645806,0.609797,-0.385744,-0.014603,0.287018,0.433453},
  {0.698311,0.544032,-0.104380,0.379987,-0.682056,-0.692295,0.386397,0.178330,-0.622255,0.819522,0.582128,0.053203,-0.494563,-0.775300,-0.648614,0.225539,-0.303882,0.667402,0.659332,-0.323585,-0.066033,0.423002,-0.504610,-0.398136,-0.156595,0.114684,0.441753,-0.381194,-0.201879,-0.058900,-0.361735,0.566760,-0.470517,0.184031,0.283230,-0.593126,-0.644266,-0.358616,0.128294,0.565176,-0.694337,-0.498244,0.087681,-0.367623,0.647913,-0.562901,0.284647,0.148663,-0.439334,-0.554592,-0.432946,-0.131704,-0.005186,-0.447288,0.705336,0.631529,-0.243652,0.272013,-0.670465,0.773542,-0.474146,-0.054956,-0.576309,-0.807353,-0.624123,-0.123852,0.426848,-0.731066,-0.662954,0.286099,-0.198799,0.546723,-0.588343,0.388415,-0.040629,0.263893,0.431263,0.433278,0.066548,0.203411,0.414952,-0.479434,-0.355046,0.055545,0.334524,-0.588310,0.591944,-0.272770,0.201070,0.599041,0.705966,0.457915,0.028478,0.484299,-0.680608,-0.549589,0.176776,0.270968,-0.548667,0.587918,-0.358045,-0.000842,0.344627,0.544756},
  {0.128608,0.296419,-0.392220,-0.415167,0.286041,-0.071902,0.527841,-0.742251,0.671661,-0.148132,0.504858,0.979472,0.989760,0.485962,-0.299014,1.003428,1.198968,-0.767659,0.034074,-0.815744,1.284023,-1.066716,0.387365,-0.529113,-1.201281,-1.292942,0.193983,-1.029548,-1.405035,1.121648,0.246753,0.795615,-1.390824,1.361488,-0.577996,-0.437875,-1.259474,-1.422782,-0.845574,0.160983,-1.023389,-1.351813,1.004614,0.151106,0.735553,-1.114765,0.977436,-0.332077,-0.321608,-0.762994,-0.795606,-0.473890,0.355886,0.277199,-0.042176,0.225250,-0.443323,-0.578978,0.494221,-0.001646,-0.484934,0.910707,0.853545,0.342776,-0.390722,-0.965869,-1.060732,0.656159,-0.151063,0.959302,1.268472,-0.911959,0.200671,0.735023,-1.229311,-1.181129,-0.538728,0.398762,1.413298,-0.912655,0.003376,-0.892497,-1.402434,1.267760,-0.391252,-0.589391,1.387520,-1.382254,-0.717130,0.325740,1.202384,1.457918,-0.914812,0.028509,-0.859275,-1.240964,1.019076,-0.219704,-0.501351,0.996945,-0.868920,-0.403685,0.184693,0.618157},
  {0.210076,0.161108,0.052034,0.196064,-0.187610,-0.139059,0.061075,0.217145,-0.250291,0.294756,0.106214,-0.136009,-0.296675,-0.278164,-0.079540,-0.114367,-0.319949,0.419161,0.226987,0.159115,-0.324118,0.460863,-0.198524,0.116760,0.391832,0.470665,0.009721,0.342985,0.434288,-0.229853,0.018248,-0.168916,0.360198,-0.224837,0.141962,0.138291,0.281330,0.314027,0.221655,0.040606,0.229603,0.323316,-0.181284,0.003799,-0.125120,0.308089,-0.158570,0.060461,0.195913,0.248658,0.161177,0.011758,-0.009867,-0.133447,0.202881,0.152677,0.003367,0.171927,-0.256442,0.222214,-0.034958,-0.174116,-0.312789,-0.282207,-0.086167,0.175238,0.358180,-0.344690,-0.147794,-0.132658,-0.360644,0.406315,-0.209790,-0.090626,0.366426,0.434490,0.264031,-0.048791,-0.411290,0.278267,-0.001464,0.266144,0.363804,-0.263226,0.064950,0.159558,-0.271803,0.273155,0.147211,-0.038242,-0.203882,-0.272618,0.213877,0.031872,0.179912,0.284135,-0.215149,0.039603,0.166559,-0.236797,0.170482,0.001046,-0.138172,-0.158057},
  {-0.016917,0.424720,-0.590804,-0.489622,0.216775,-0.122970,0.377239,-0.379356,0.321234,-0.120577,0.059395,0.232807,0.368342,0.407651,0.292202,0.016070,0.344526,-0.528870,-0.503234,0.243531,0.236746,-0.563214,0.692146,0.449425,-0.013510,-0.468549,-0.576366,0.220487,-0.262636,0.649960,0.712351,-0.429038,0.024935,0.463377,-0.692181,0.693106,0.350542,-0.167125,-0.635855,-0.826038,0.653508,0.109625,0.554375,0.941174,-0.832251,0.358511,0.375492,-0.854688,0.963106,0.557713,-0.104143,-0.682367,0.670032,0.497849,-0.148393,0.254333,-0.520206,-0.489818,0.232803,-0.023204,-0.227191,0.288458,0.309524,0.248006,0.097281,-0.131305,-0.371306,0.458443,0.384516,-0.138359,0.258279,-0.605635,0.587234,-0.354746,-0.157375,-0.574275,-0.730525,-0.543763,0.372987,-0.709303,-0.677999,0.301376,-0.169783,0.525385,-0.736216,0.541705,-0.191344,-0.345037,-0.715563,-0.792781,-0.513979,0.022796,-0.626558,-0.921764,0.732964,0.196507,0.429266,-0.938519,0.889958,-0.469662,-0.269622,-0.825190,-0.967566,-0.642110},
  {0.764949,0.257723,0.510623,1.045782,-1.071254,-0.667531,-0.049212,1.036124,-1.393559,1.251242,0.342963,-0.785433,-1.536519,-1.484486,-0.625611,-0.497495,-1.462300,1.767282,1.096071,0.203163,-1.197760,1.772120,-1.272206,-0.237495,0.913269,1.610658,0.739048,0.452358,1.292485,-1.395500,-0.918304,0.128011,0.859891,-1.211527,1.180604,-0.431155,0.394087,1.021141,1.174998,0.810570,-0.017953,0.647235,-0.880153,-0.775010,0.432693,0.227947,-0.525818,0.762670,-0.510077,-0.191253,0.181973,0.501582,-0.583445,-0.940687,0.936452,0.473405,0.301348,1.014226,-1.291700,0.984336,-0.078097,-0.916160,-1.533108,-1.375199,-0.473337,0.726159,1.593251,-1.634626,-0.854221,-0.347956,-1.391952,1.748911,-1.184894,0.085238,1.080224,1.670333,1.433597,0.511350,-1.402511,1.496732,0.856684,0.172265,1.044412,-1.362637,1.080391,-0.279509,-0.558222,1.140495,1.157676,0.655842,-0.109928,-0.774612,1.063282,0.831512,-0.227371,0.399509,-0.762694,0.803153,-0.473888,0.052994,0.372464,0.603756,0.623277,0.443552},
  {-0.264242,-0.181439,-0.002565,-0.218731,0.346289,0.281202,-0.048143,-0.192498,0.381381,-0.351966,-0.153831,0.142288,0.391252,0.460449,0.298612,0.047381,0.380559,-0.521218,-0.403898,0.070581,0.355344,-0.574561,0.515059,0.150224,-0.303183,-0.585741,-0.171754,-0.261387,-0.539990,0.511154,0.186878,0.223280,-0.433753,0.408709,-0.138775,-0.128299,-0.285415,-0.258168,-0.106144,0.059136,-0.134495,-0.137275,0.099719,0.030033,0.042409,-0.052349,0.072793,-0.034560,0.022048,-0.002422,-0.007196,0.003885,-0.005867,0.185819,-0.345563,-0.266851,-0.018992,-0.257422,0.321442,-0.352508,0.069717,0.135208,0.343396,0.370114,0.188333,-0.124347,-0.415593,0.456457,0.316655,-0.049170,0.323537,-0.597914,0.428526,-0.141847,-0.366742,-0.632268,-0.568526,-0.203299,0.543160,-0.567144,-0.220693,-0.281338,-0.539679,0.420423,-0.201215,-0.214837,0.335280,-0.371087,-0.167456,0.057062,0.179922,0.166711,-0.138778,-0.026301,-0.117869,-0.135628,0.041920,-0.076385,-0.038437,-0.003595,-0.080014,-0.068544,-0.048997,-0.041595},
  {-0.545823,-0.804825,0.618659,0.084827,0.498727,0.806237,-0.664281,0.150137,0.413021,-0.727654,-0.625288,-0.203535,0.279050,0.562460,0.528563,-0.247175,0.113791,-0.373525,-0.425077,0.280468,-0.044705,-0.192522,0.315231,0.295297,0.143917,-0.064200,-0.263633,0.159908,-0.005227,0.128537,0.152138,-0.086614,-0.008595,0.033090,0.004254,-0.065726,-0.053695,0.050493,0.181648,0.227115,-0.121632,0.108397,-0.327271,-0.376544,0.200097,0.104969,-0.389275,0.468736,-0.310549,0.022598,0.356344,0.522298,-0.586109,-0.060330,-0.543400,-0.833239,0.635820,0.107139,0.448503,-0.794447,0.634096,-0.194421,0.337998,0.635961,0.564832,0.206176,-0.217624,0.452903,0.460815,-0.281641,0.017194,-0.292019,0.352392,-0.311938,0.087324,-0.133695,-0.286416,-0.303944,0.006735,-0.194245,-0.232862,0.117716,-0.013828,0.067486,-0.095378,-0.000258,0.008058,-0.005660,0.080783,0.130540,0.066295,-0.104588,0.245810,0.290355,-0.175131,0.102372,-0.383063,0.412342,-0.268743,-0.093113,0.366971,0.486711,0.352990,0.027670},
  {-0.495494,-0.836877,0.762230,0.268454,0.375100,0.781309,-0.751479,0.405195,0.175676,-0.575798,-0.691048,-0.460487,-0.028117,0.380895,0.581353,-0.478603,-0.208041,-0.088125,-0.338531,0.462398,-0.347485,0.166261,0.136495,0.363771,0.454673,0.359160,-0.191442,0.428650,0.442428,-0.233598,0.040275,-0.253622,0.410218,-0.344954,0.212650,0.061444,0.299905,0.445692,0.421757,0.208380,0.154377,0.448576,-0.517620,-0.360264,0.046751,0.349891,-0.520703,0.509156,-0.215969,0.138903,0.442577,0.576867,-0.714916,-0.187161,-0.456278,-0.834407,0.754581,0.311733,0.249203,-0.699739,0.735423,-0.453437,0.042877,0.471150,0.633435,0.482552,0.125937,0.223982,0.453551,-0.490567,-0.313218,0.013746,0.224626,-0.414489,0.398691,0.244842,-0.021890,-0.295575,-0.412309,0.164304,-0.134335,0.342139,0.409888,-0.323841,0.070973,0.151195,-0.357919,0.388671,0.293607,0.064084,-0.226076,-0.453804,0.470990,0.280409,0.044470,0.384497,-0.564815,0.429773,-0.139192,-0.253245,0.480314,0.518137,0.334150,0.001049},
  {0.216294,-0.169868,0.476921,0.555081,-0.388590,-0.084104,-0.245400,0.531165,-0.553525,0.364322,-0.031671,-0.429309,-0.628676,-0.520321,-0.150460,-0.276539,-0.589272,0.639831,0.371594,0.087001,-0.461092,0.661591,-0.507722,-0.130871,0.312130,0.603928,0.318879,0.116813,0.447708,-0.527312,-0.386662,0.122295,0.200214,-0.375443,0.447056,-0.314286,-0.081461,0.204874,0.436911,0.501869,-0.319747,0.009702,-0.335542,-0.531002,0.494871,-0.183211,-0.169317,0.485843,-0.543091,-0.380225,-0.039755,0.337628,-0.547968,-0.536361,0.306546,-0.041234,0.368021,0.540048,-0.487164,0.235129,0.153459,-0.484918,-0.613428,-0.449587,-0.056445,0.378392,0.638456,-0.586157,-0.259282,-0.182775,-0.541675,0.651368,-0.443620,0.041430,0.393807,0.635665,0.573249,0.237651,-0.523021,0.584025,0.364867,0.003123,0.324591,-0.468893,0.426302,-0.217074,-0.042831,0.295688,0.440194,0.422548,0.225860,-0.090599,0.400309,0.536219,-0.414952,-0.094535,-0.271835,0.525742,-0.523263,0.297635,0.073297,0.409405,0.574047,0.489077},
  {0.578994,-0.061842,0.605346,0.893097,-0.817225,-0.345091,-0.319902,0.764755,-0.954680,0.613449,0.006260,-0.630085,-0.979443,-0.861330,-0.333360,-0.384519,-0.860722,0.870106,0.502387,0.043573,-0.621593,0.799833,-0.690093,-0.244057,0.273067,0.628569,0.415105,-0.027355,0.382323,-0.639458,-0.573604,0.233868,0.096243,-0.449089,0.514383,-0.454028,-0.180551,0.140864,0.383856,0.461376,-0.402312,-0.156385,-0.188631,-0.436964,0.501107,-0.468243,0.140286,0.213758,-0.627351,-0.761027,-0.538276,-0.007196,-0.791763,-0.975839,0.685691,0.125427,0.450362,0.844207,-0.887612,0.474839,0.112900,-0.720252,-0.975452,-0.770237,-0.192235,0.475498,0.898259,-0.898551,-0.441637,-0.232761,-0.744115,0.858038,-0.622968,0.065454,0.435476,0.734050,0.682499,0.326074,-0.552551,0.657355,0.493911,-0.154088,0.250225,-0.546569,0.543752,-0.371978,0.007017,0.285974,0.472686,0.458381,0.260743,-0.034983,0.284044,0.449187,-0.476413,-0.303219,-0.022871,0.319578,-0.587652,0.580646,-0.357376,0.114152,0.602491,0.842486},
  {0.826063,0.446138,0.200160,0.746886,-0.906484,-0.625011,0.043402,0.600210,-0.895627,0.786131,0.281369,-0.333464,-0.761424,-0.815891,-0.494042,-0.019626,-0.533115,0.825995,0.731045,-0.278883,-0.276789,0.761827,-0.843119,-0.520961,0.074652,0.632477,0.645725,-0.112901,0.404980,-0.653308,-0.593028,0.313619,0.085016,-0.358617,0.524150,-0.460614,-0.248650,0.083014,0.417250,0.596078,-0.480560,-0.137857,-0.263250,-0.544130,0.561641,-0.270382,-0.068926,0.367770,-0.433555,-0.353195,-0.173280,0.044759,-0.264055,-0.752185,0.895375,0.557247,0.098427,0.690130,-0.912734,0.731553,-0.133853,-0.462124,-0.839457,-0.795232,-0.372970,0.210372,0.683201,-0.812017,-0.602201,0.149798,-0.400175,0.804011,-0.785401,0.443008,0.185878,0.711304,0.887797,0.617907,-0.504437,0.791158,0.647810,-0.197245,0.257073,-0.509999,0.578095,-0.374047,0.115166,0.230495,0.475371,0.556809,0.411567,0.067466,0.361523,0.607258,-0.528331,-0.209344,-0.172299,0.492038,-0.498092,0.343347,-0.029557,0.219606,0.370561,0.412823},
  {0.477954,0.111407,0.272772,0.576380,-0.670766,-0.428996,-0.073301,0.516126,-0.863108,0.722112,0.209103,-0.513637,-1.058817,-1.075383,-0.487025,-0.464247,-1.167711,1.198229,0.588580,0.317209,-1.122049,1.214257,-0.737670,0.137094,0.879111,1.115728,0.048938,0.606723,0.958094,-0.859686,-0.316201,-0.385593,0.773644,-0.839923,0.403389,0.120697,0.575804,0.688482,0.429209,-0.031734,0.381602,0.514165,-0.394624,-0.063932,-0.264207,0.291679,-0.213748,-0.032204,0.090492,0.042482,-0.086786,-0.149566,-0.388540,-0.631043,0.556546,0.243842,0.172306,0.560134,-0.749281,0.561088,-0.106390,-0.524349,-0.953024,-0.922366,-0.369700,0.455270,1.093546,-1.168447,-0.558242,-0.411767,-1.152964,1.236927,-0.678741,-0.273423,1.003997,1.188333,0.742587,-0.058642,-1.077781,0.807046,0.177762,0.480079,0.881009,-0.846920,0.361059,0.232755,-0.711795,0.762748,0.443229,-0.077223,-0.512926,-0.645029,0.413301,0.016394,0.306396,0.420332,-0.302452,0.015181,0.160402,-0.205207,0.057875,-0.072029,-0.078946,0.047501},
  {0.480290,-0.297003,0.876487,1.035857,-0.727049,-0.080267,-0.578021,0.861765,-0.809204,0.363806,-0.157968,-0.574305,-0.745989,-0.642476,-0.321404,-0.144344,-0.548141,0.746486,0.692254,-0.352380,-0.268811,0.773946,-1.018331,-0.737629,-0.066982,0.662470,0.927641,-0.365584,0.376310,-0.936167,-1.023942,0.642175,-0.073975,-0.579499,0.943303,-0.997903,-0.588729,0.125493,0.848291,1.212353,-1.012703,-0.239529,-0.727375,-1.314029,1.193170,-0.521445,-0.453587,1.093752,-1.227702,-0.755240,0.011036,0.704940,-1.008722,-1.074256,0.618366,-0.109887,0.742002,0.987369,-0.767726,0.228421,0.356211,-0.734776,-0.778424,-0.515407,-0.082588,0.350618,0.643093,-0.708146,-0.516054,0.106236,-0.396643,0.793052,-0.876114,0.542735,0.100586,0.755821,1.072009,0.854774,-0.560716,1.030436,0.993311,-0.501495,0.185317,-0.756728,0.991888,-0.822487,0.314384,0.351218,0.918793,1.120748,0.803131,0.049452,0.798576,1.292345,-1.132513,-0.371655,-0.590260,1.234706,-1.234474,0.623479,0.246090,0.935724,1.148789,0.844852},
  {0.214632,0.229349,-0.151973,0.097304,-0.404971,-0.516858,0.316384,0.034751,-0.484184,0.638336,0.484008,0.049741,-0.441949,-0.736127,-0.677690,0.247426,-0.296094,0.689622,0.786334,-0.515683,-0.104083,0.633810,-0.923991,-0.709955,-0.126219,0.524185,0.787121,-0.300722,0.358632,-0.844630,-0.856363,0.403624,0.169359,-0.692271,0.769645,-0.515093,0.006415,0.467052,0.632754,0.452334,-0.106721,0.249700,-0.445746,-0.379864,0.149177,0.008372,-0.177118,0.203055,-0.254454,-0.209858,-0.088939,0.089530,0.012459,-0.147294,0.306054,0.373101,-0.247040,0.081846,-0.447049,0.583093,-0.430241,-0.010184,-0.467546,-0.705966,-0.589044,-0.167549,0.351725,-0.727272,-0.742659,0.373927,-0.191147,0.678725,-0.872221,0.594092,-0.020548,0.597590,0.914240,0.751485,-0.474192,0.872198,0.823853,-0.366013,0.274839,-0.762989,0.815339,-0.478219,-0.108996,0.575316,0.724029,0.488627,0.029079,-0.389299,0.540867,0.415980,-0.138105,0.141402,-0.300939,0.282878,-0.211596,0.081482,0.025674,0.152737,0.250769,0.258114},
  {-0.059072,-0.375324,0.476718,0.324972,-0.046561,0.154093,-0.187863,0.150774,-0.049966,0.064070,0.115536,0.137025,0.039122,-0.171534,-0.370882,0.419536,0.193002,0.224253,0.572536,-0.636812,0.404790,0.111848,-0.576465,-0.807449,-0.646982,-0.146504,0.924554,-0.940224,-0.506394,-0.211110,-0.914825,1.233590,-0.894022,0.092618,0.871644,-1.403430,-1.236024,-0.381954,0.734116,1.509914,-1.475136,-0.652382,-0.525155,-1.445121,1.595281,-0.837291,-0.316892,1.302606,-1.507617,-0.915594,0.125839,1.026039,-0.590635,-0.366845,-0.005413,-0.274570,0.323315,0.225020,-0.090147,-0.054705,0.033402,-0.029986,-0.042733,-0.143858,-0.267389,-0.284801,-0.113196,-0.229721,-0.504636,0.519721,0.263647,0.159217,-0.610756,0.727212,-0.536264,-0.028781,0.527036,0.859596,0.313666,0.338287,0.913659,-1.109602,-0.729588,-0.091705,0.886869,-1.346927,1.070340,-0.255633,0.782553,1.455539,1.366935,0.521115,0.617747,1.477148,-1.570964,-0.785490,-0.450590,1.372883,-1.587684,0.885506,0.205251,1.148317,1.414120,0.912058},
  {-1.972542,-0.791272,-0.674775,-1.782276,2.076387,1.454393,-0.213042,-1.076227,1.906462,-1.873089,-1.018081,0.293462,1.469758,1.977834,1.596969,-0.505183,0.775589,-1.683448,-1.863021,1.256540,-0.091355,-1.107686,1.881051,1.841723,0.972448,-0.382263,-2.130456,1.653832,0.367160,1.116233,2.059506,-2.017479,1.064735,0.371927,-1.581257,2.080819,1.648732,0.508883,-0.841732,-1.827030,2.032606,1.332644,-0.010367,1.342292,-2.112147,1.957526,-0.873713,-0.621368,1.889583,2.300045,1.647262,0.205240,1.085105,2.045973,-2.079955,-1.164169,-0.253135,-1.476418,1.995415,-1.722168,0.622206,0.667059,1.693295,1.950334,1.320208,0.093023,-1.168093,1.852411,1.743303,-0.915469,0.325883,-1.452424,1.882182,-1.592358,0.521808,-0.783316,-1.803411,-2.052081,-0.011382,-1.420951,-2.168271,1.854622,0.697282,0.739689,-1.885755,2.065760,-1.391858,0.040398,-1.265080,-2.010449,-1.888192,-0.953483,-0.444992,-1.636965,2.090628,1.648348,-0.477412,-1.026397,2.017933,-2.182618,1.257096,-0.243167,-1.679362,-2.373462},
  {-0.008400,-1.318353,1.965712,1.608628,-0.465131,0.822532,-1.620485,1.652293,-0.868014,-0.201011,-1.109145,-1.442957,-1.117534,-0.340933,0.517796,-1.073307,-1.174417,0.819215,0.132929,0.599287,-1.014165,1.059808,-0.627516,0.026164,0.666079,1.041522,0.579740,0.117468,0.774929,-1.129593,-1.056034,0.536608,0.326592,-1.068991,1.430669,-1.086080,-0.211448,0.834651,1.540904,1.533632,-0.755471,0.389879,-1.349975,-1.701286,1.271787,-0.189888,-0.939388,1.695101,-1.624787,-0.821996,0.388991,1.458585,-2.037189,-1.504366,0.218665,-1.102290,1.803431,1.627094,-0.715146,-0.533065,1.380650,-1.592252,-1.047134,-0.096996,0.802489,1.274702,1.168157,-0.619360,0.167803,-0.867187,-1.154610,0.937594,-0.416072,-0.321377,0.847495,1.051470,0.824345,0.262618,-0.939975,1.077466,0.814119,-0.225612,0.535454,-1.157684,1.250466,-0.843190,-0.066895,0.958135,1.486439,1.316969,0.483245,-0.636699,1.461380,1.628863,-1.042014,0.080116,-1.204180,1.707708,-1.482697,0.501990,0.660650,1.567004,1.756766,1.120546},
  {-1.625395,-1.163307,0.162158,-0.912445,1.538881,1.389061,-0.549961,-0.499944,1.313022,-1.422814,-0.852978,0.108549,0.974525,1.332257,1.041450,-0.261375,0.574249,-1.065305,-1.036081,0.542514,0.193689,-0.728105,0.899725,0.627693,0.128283,-0.326230,-0.508326,0.334443,0.103015,0.126275,0.306117,-0.422693,0.476475,-0.306065,-0.005962,0.423481,0.682994,0.647453,0.304594,-0.198094,0.655344,0.831016,-0.641342,-0.175858,-0.403098,0.918397,-1.035949,0.699371,0.093179,0.940810,1.406299,1.167045,0.036415,1.082294,-1.630634,-1.325711,0.331450,-0.753413,1.396195,-1.461511,0.693769,0.267741,1.110902,1.362795,0.930701,0.061771,-0.800823,1.178231,1.024684,-0.454791,0.331695,-0.951166,0.956447,-0.632925,-0.055202,-0.578687,-0.777022,-0.622784,0.087395,-0.377689,-0.452242,0.357443,0.258741,-0.143850,-0.194373,0.408543,-0.630439,0.460113,0.099670,-0.370461,-0.722611,-0.778203,0.431915,-0.066251,0.514684,0.838678,-0.882523,0.398396,0.219348,-0.961655,1.199950,0.901210,0.055082,-0.944984},
  {-0.060024,0.163803,-0.344377,-0.278124,0.013968,-0.189942,0.224843,-0.262134,0.076793,-0.005983,0.106827,0.176379,0.188165,0.118732,-0.040656,0.177630,0.321830,-0.362384,-0.134489,-0.261096,0.431115,-0.482122,0.129080,-0.267305,-0.535143,-0.510724,0.165083,-0.468938,-0.444277,0.143355,-0.135153,0.238150,-0.315799,0.148121,-0.085602,-0.093982,-0.183609,-0.247266,-0.252020,-0.156628,-0.098528,-0.291413,0.296967,0.180587,0.003372,-0.302628,0.300389,-0.233060,-0.065616,-0.237145,-0.256520,-0.152614,0.305128,0.244226,-0.028425,0.193812,-0.290563,-0.233951,0.077722,0.106540,-0.199457,0.222703,0.166178,0.064349,-0.067533,-0.202755,-0.283380,0.249746,0.057074,0.223877,0.421535,-0.393258,0.143043,0.238904,-0.489597,-0.470094,-0.171193,0.228250,0.459650,-0.174674,0.163507,-0.358447,-0.345623,0.181723,0.035099,-0.162400,0.217833,-0.189178,-0.132357,-0.034513,0.104833,0.241656,-0.280334,-0.177274,-0.039989,-0.265603,0.352883,-0.213457,-0.029693,0.252469,-0.285611,-0.158272,0.027588,0.143731},
  {-0.223808,0.211572,-0.503994,-0.492815,0.216281,-0.132929,0.355982,-0.370075,0.194451,0.028673,0.191375,0.228750,0.156040,0.036853,-0.060022,0.092458,0.078090,-0.054680,-0.044718,0.045512,-0.037247,-0.028068,0.114888,0.174900,0.140576,0.007630,-0.242115,0.198374,0.058275,0.095447,0.196826,-0.219329,0.161847,-0.062005,-0.087934,0.238157,0.329256,0.267026,0.025082,-0.297995,0.503572,0.437293,-0.097481,0.336917,-0.600621,0.514957,-0.146176,-0.303117,0.565045,0.526570,0.229090,-0.161439,0.549138,0.533431,-0.222236,0.178211,-0.434514,-0.431188,0.211090,0.082454,-0.272685,0.301428,0.183298,0.012690,-0.118482,-0.161343,-0.123239,0.054946,-0.001847,0.026250,0.027595,-0.039450,0.085101,-0.115093,0.095472,-0.005978,-0.139705,-0.218174,-0.029153,-0.135518,-0.230011,0.213433,0.105910,0.032791,-0.145008,0.227056,-0.239805,0.165823,-0.022427,-0.263149,-0.421541,-0.362455,0.069058,-0.321428,0.569043,0.492351,-0.115787,-0.331412,0.599434,-0.525217,0.182347,-0.238460,-0.514942,-0.528397},
  {0.252690,0.132384,0.046579,0.141988,-0.127490,-0.089191,0.058007,0.043977,-0.039930,0.074455,0.053151,0.043691,0.060085,0.080473,0.059565,0.065244,0.183409,-0.206301,-0.129521,-0.042579,0.311458,-0.368636,0.270444,-0.046735,-0.367032,-0.490074,0.055828,-0.397915,-0.560566,0.444284,0.051134,0.406726,-0.586197,0.516755,-0.103890,-0.298038,-0.563292,-0.514514,-0.187930,0.230145,-0.477405,-0.493083,0.294730,-0.050608,0.367701,-0.426141,0.357476,-0.076522,-0.157517,-0.346724,-0.374086,-0.221364,-0.062889,-0.172616,0.204345,0.128804,0.001103,0.082190,-0.088827,0.103501,-0.032712,0.019232,0.002570,0.009129,0.010349,-0.023365,-0.086332,0.154332,0.107329,0.068335,0.244411,-0.295476,0.215847,0.080188,-0.331929,-0.440566,-0.283745,0.070586,0.564207,-0.369944,0.020815,-0.394647,-0.583568,0.478503,-0.062750,-0.342726,0.614573,-0.508005,-0.152619,0.282582,0.561739,0.543887,-0.228736,0.158808,-0.414716,-0.468143,0.321674,0.001882,-0.248339,0.418903,-0.353999,-0.159636,0.111618,0.342808},
  {0.962274,-0.051666,1.100424,1.596732,-1.274919,-0.343569,-0.731919,1.509286,-1.445724,0.740167,-0.333132,-1.181864,-1.405027,-0.941714,-0.066278,-0.740541,-1.186978,1.114329,0.533374,0.276294,-0.852846,1.114147,-0.810328,-0.195398,0.497235,0.960604,0.601514,0.072407,0.652448,-0.891515,-0.774607,0.375972,0.233002,-0.647637,0.864792,-0.655647,-0.221328,0.310090,0.731958,0.876217,-0.632958,-0.151632,-0.388205,-0.835684,0.985786,-0.627822,0.030791,0.714179,-1.107208,-1.037278,-0.447645,0.412595,-1.196197,-1.536835,1.149025,0.164840,0.938075,1.567858,-1.396570,0.566400,0.573346,-1.357616,-1.460734,-0.843417,0.147435,1.008915,1.347426,-1.031350,-0.295715,-0.498438,-1.040610,1.122151,-0.678744,0.002440,0.692143,1.047658,0.939631,0.426625,-0.791247,0.980160,0.719560,-0.146303,0.442391,-0.799716,0.853359,-0.518930,0.027966,0.504199,0.811045,0.798480,0.469633,-0.052603,0.590432,0.889663,-0.813497,-0.402633,-0.198841,0.805671,-1.055608,0.879176,-0.227649,0.568614,1.156116,1.224717},
  {1.619740,0.598606,0.644322,1.620397,-1.891091,-1.261023,0.023584,1.122458,-1.849517,1.641382,0.730274,-0.522706,-1.547656,-1.878688,-1.366637,0.193189,-1.023770,1.730655,1.689339,-0.919494,-0.363085,1.381705,-1.857285,-1.436045,-0.370653,0.838878,1.646551,-0.957553,0.178111,-1.233585,-1.666444,1.319341,-0.515542,-0.574361,1.304279,-1.575440,-1.143155,-0.231428,0.791505,1.491668,-1.597793,-0.942627,-0.213407,-1.274066,1.738797,-1.500859,0.457175,0.728961,-1.691709,-1.837572,-1.140910,0.083321,-0.999668,-1.812257,1.787326,0.946573,0.316664,1.423508,-1.876135,1.479292,-0.412093,-0.835816,-1.702410,-1.793661,-1.069126,0.140273,1.283176,-1.838413,-1.557197,0.569494,-0.676181,1.612165,-1.807728,1.178115,-0.008272,1.157379,1.780704,1.577917,-0.544213,1.464148,1.694493,-1.162482,-0.143020,-0.896390,1.516736,-1.474827,0.818299,0.175314,1.095435,1.564227,1.372413,0.574049,0.512840,1.413319,-1.703817,-1.218790,0.149206,1.026810,-1.751051,1.673523,-0.808699,0.446710,1.511465,1.885937},
  {-0.307409,0.273327,-0.673248,-0.707210,0.400935,-0.053660,0.426945,-0.570636,0.459484,-0.176461,0.152828,0.402020,0.479579,0.353928,0.073219,0.239339,0.436249,-0.420375,-0.205043,-0.088326,0.303577,-0.349821,0.238469,0.062614,-0.085754,-0.169705,-0.211694,0.175423,0.062367,0.129643,0.330382,-0.416302,0.291288,0.023516,-0.382541,0.580034,0.483028,0.115977,-0.338740,-0.639927,0.621760,0.287515,0.196305,0.589837,-0.700679,0.474895,-0.022245,-0.448316,0.715822,0.653202,0.278187,-0.245770,0.793247,0.776502,-0.329637,0.197115,-0.528739,-0.616132,0.464241,-0.033915,-0.259141,0.516930,0.505489,0.305554,-0.000167,-0.289627,-0.438487,0.433561,0.181888,0.192726,0.411804,-0.371587,0.262092,0.042564,-0.173856,-0.240192,-0.198482,-0.108927,0.085667,-0.141674,-0.247429,0.332075,0.209872,0.110586,-0.337497,0.539808,-0.363749,0.071521,-0.343369,-0.594207,-0.530256,-0.169152,-0.249265,-0.598211,0.698718,0.410623,0.124529,-0.499344,0.745574,-0.537594,0.178090,-0.322021,-0.672323,-0.700556},
  {-0.272655,-0.435012,0.446981,0.169603,0.266837,0.530569,-0.480318,0.315634,0.122207,-0.375630,-0.506801,-0.390232,-0.076846,0.297634,0.562679,-0.514230,-0.264803,-0.074452,-0.437414,0.632643,-0.385192,0.073563,0.378306,0.573959,0.508221,0.237224,-0.368901,0.528903,0.408970,-0.051153,0.288730,-0.453639,0.527317,-0.215338,-0.082676,0.450693,0.526578,0.360000,0.062869,-0.205627,0.406167,0.379911,-0.169206,0.030111,-0.165537,0.385153,-0.338671,0.262275,0.084465,0.363206,0.489549,0.385488,-0.305111,-0.035980,-0.258129,-0.478737,0.494289,0.227519,0.187621,-0.446337,0.554030,-0.334335,0.009858,0.358912,0.557366,0.511505,0.230367,0.203444,0.525812,-0.567473,-0.351047,-0.017191,0.437309,-0.562681,0.471690,0.136381,-0.229261,-0.458368,-0.271352,-0.004287,-0.308796,0.515029,0.463591,-0.160501,-0.165902,0.482530,-0.490336,0.316443,-0.029504,-0.322213,-0.424489,-0.319949,0.131586,-0.102825,0.305464,0.367445,-0.275775,0.143798,0.138907,-0.327053,0.448706,0.322142,0.031537,-0.271939},
  {-0.162311,0.469064,-0.844542,-0.789756,0.345891,-0.257217,0.707178,-0.768431,0.455797,0.065509,0.500354,0.648417,0.475320,0.113382,-0.236451,0.429099,0.413475,-0.247191,-0.033396,-0.156695,0.300063,-0.341160,0.279095,0.093712,-0.155683,-0.362991,-0.273199,-0.004623,-0.290172,0.441982,0.381384,-0.148037,-0.125112,0.340182,-0.395424,0.306565,0.099710,-0.143893,-0.341023,-0.417896,0.337347,0.097544,0.222798,0.479717,-0.540128,0.357651,0.038995,-0.454451,0.698490,0.602848,0.185106,-0.365754,0.932916,0.808173,-0.220241,0.403894,-0.744436,-0.755049,0.448052,0.198659,-0.568200,0.761432,0.513665,0.067399,-0.333562,-0.505244,-0.409960,0.224664,-0.060999,0.334662,0.397851,-0.264740,0.204568,0.068806,-0.190082,-0.326228,-0.323170,-0.153647,0.381982,-0.406153,-0.298128,0.111069,-0.181103,0.441067,-0.358309,0.269471,0.060265,-0.210890,-0.340643,-0.328701,-0.176854,0.070443,-0.250493,-0.418007,0.484156,0.263896,0.173711,-0.436609,0.667633,-0.441445,0.110694,-0.381467,-0.703569,-0.665250},
  {-1.369614,-0.844404,-0.030070,-0.911957,1.386170,1.147009,-0.317476,-0.548572,1.261274,-1.248875,-0.669500,0.254441,1.055173,1.327508,0.947305,-0.069795,0.748374,-1.105480,-0.957574,0.424084,0.368868,-0.825849,0.985931,0.648969,0.058018,-0.505524,-0.673485,0.313937,-0.189868,0.592923,0.639172,-0.365969,0.112036,0.225703,-0.320018,0.425722,0.375517,0.237063,0.011159,-0.258728,0.531758,0.560328,-0.286737,0.102915,-0.446913,0.745686,-0.617032,0.307030,0.308429,0.806861,0.998482,0.729862,0.263164,1.112795,-1.378708,-0.989460,0.154551,-0.754595,1.311687,-1.201537,0.549945,0.408485,1.149141,1.321151,0.838226,-0.045857,-0.871822,1.247230,0.978814,-0.241113,0.542286,-0.996383,0.994649,-0.506368,-0.136043,-0.687591,-0.889142,-0.672014,0.388665,-0.694780,-0.668968,0.367664,-0.057552,0.398884,-0.483918,0.419569,-0.209540,0.019439,-0.179353,-0.344225,-0.429848,-0.371460,0.160868,-0.186111,0.524693,0.650006,-0.473543,0.098205,0.407535,-0.746539,0.821675,0.494318,-0.120174,-0.761830},
  {0.740979,0.517740,-0.069286,0.377810,-0.639280,-0.639493,0.384228,0.059385,-0.462274,0.700524,0.626197,0.272690,-0.212015,-0.613334,-0.747149,0.557987,0.097493,0.437677,0.785474,-0.773515,0.417828,0.183529,-0.699862,-0.901810,-0.657980,-0.080252,0.889153,-0.789458,-0.332722,-0.241121,-0.683718,0.816349,-0.574403,0.124026,0.400233,-0.739964,-0.780111,-0.464398,0.091930,0.637627,-0.882032,-0.703516,0.181682,-0.434727,0.828772,-0.781294,0.394481,0.163889,-0.580629,-0.728492,-0.565989,-0.182004,-0.098305,-0.535338,0.678413,0.562489,-0.254391,0.190405,-0.592011,0.658700,-0.534717,0.084639,-0.377503,-0.697789,-0.725947,-0.438640,0.044704,-0.562328,-0.803837,0.650120,0.229332,0.283119,-0.779294,0.835980,-0.575690,0.018979,0.608835,0.892319,0.189864,0.379206,0.780124,-0.840065,-0.486985,-0.095593,0.524424,-0.809967,0.667275,-0.327484,0.210673,0.671114,0.831048,0.585207,-0.076835,0.522669,-0.903282,-0.793748,0.260781,0.286030,-0.746958,0.749363,-0.508370,-0.037892,0.405077,0.654340},
  {-1.588509,-1.686175,0.957977,-0.236214,1.298005,1.698143,-1.253309,0.217070,0.866083,-1.465333,-1.333187,-0.604140,0.322912,1.016591,1.215225,-0.902908,-0.258897,-0.447497,-0.954770,1.079034,-0.765226,0.118338,0.603556,1.080932,1.077394,0.574955,-0.867806,1.123798,0.864409,-0.239951,0.447856,-0.905348,0.971952,-0.659276,0.106386,0.483265,0.904645,0.995058,0.685854,0.051335,0.678007,1.180061,-1.180212,-0.608863,-0.318485,1.169895,-1.504471,1.107407,-0.132533,0.955872,1.609287,1.482314,-0.718510,0.500316,-1.439049,-1.699204,1.154100,0.020107,1.121567,-1.589384,1.343020,-0.397437,0.627997,1.286061,1.318699,0.788800,-0.007727,0.762308,1.121979,-0.986495,-0.506456,-0.133623,0.810731,-1.082449,0.974460,0.388096,-0.382645,-0.979407,-0.719605,0.043271,-0.657665,1.067724,0.963710,-0.432549,-0.158357,0.737134,-0.936680,0.864927,0.423260,-0.201440,-0.787279,-1.087309,0.972576,0.355454,0.535458,1.223730,-1.344549,0.892788,0.123910,-1.064853,1.608711,1.336589,0.397700,-0.756505},
  {-0.269557,0.481032,-0.993026,-1.088493,0.714131,-0.021248,0.776862,-1.104547,0.970589,-0.328045,0.414751,0.940847,1.029925,0.681250,0.078653,0.554087,0.922202,-0.895434,-0.533129,-0.045157,0.708477,-1.036340,0.965402,0.397779,-0.382834,-0.993839,-0.709830,-0.002815,-0.719522,1.119270,0.995805,-0.425896,-0.257355,0.905754,-1.128352,0.930690,0.265918,-0.566977,-1.180525,-1.245904,0.720145,-0.215718,1.094444,1.411860,-1.005486,0.174486,0.781274,-1.277891,1.220694,0.577548,-0.298717,-1.003941,1.103257,1.040045,-0.493603,0.261619,-0.887016,-1.127108,0.860818,-0.149059,-0.580062,1.061950,1.019329,0.524957,-0.165514,-0.736660,-0.963579,0.810324,0.321010,0.314671,0.820322,-0.988953,0.781104,-0.156682,-0.543465,-1.047890,-1.062601,-0.554777,0.914855,-1.136714,-0.851324,0.216154,-0.510409,1.023390,-1.061221,0.697118,0.023641,-0.731606,-1.177704,-1.099041,-0.478175,0.425878,-1.149891,-1.347039,0.892862,-0.030118,0.954867,-1.359009,1.142068,-0.348529,-0.538564,-1.163506,-1.230694,-0.733248},
  {0.172230,-0.380033,0.741253,0.708127,-0.344033,0.087997,-0.396847,0.588173,-0.497277,0.318234,0.000738,-0.335099,-0.578134,-0.608676,-0.362335,-0.063685,-0.551942,0.854926,0.730469,-0.202293,-0.393882,0.895752,-0.910378,-0.511818,0.152158,0.763618,0.824123,-0.203885,0.486386,-0.930459,-0.982487,0.612731,0.116179,-0.743508,1.110930,-0.897081,-0.275326,0.512335,1.085129,1.146896,-0.609772,0.210838,-0.899507,-1.160076,0.866520,-0.090674,-0.628844,1.070779,-0.916238,-0.378537,0.296673,0.799945,-0.832426,-0.712712,0.250011,-0.257769,0.570628,0.629056,-0.462216,0.099486,0.207498,-0.485836,-0.582894,-0.489111,-0.201634,0.208481,0.584331,-0.765984,-0.573548,0.051407,-0.523858,0.863399,-0.851520,0.362339,0.270817,0.816054,0.972849,0.660041,-0.636662,0.982436,0.900078,-0.425652,0.274660,-0.884564,1.045645,-0.780138,0.085648,0.619695,1.078776,1.024197,0.457893,-0.359303,0.992681,1.160560,-0.769908,0.024841,-0.813100,1.121623,-0.922177,0.240744,0.456887,0.915000,0.921025,0.516167},
  {-0.183866,-0.808239,1.000394,0.651564,0.010787,0.576256,-0.782425,0.664215,-0.191061,-0.265154,-0.586740,-0.602516,-0.323733,0.098333,0.444451,-0.505826,-0.327732,0.040680,-0.227944,0.341525,-0.199603,0.072600,0.059729,0.059741,0.036772,0.075796,0.254235,-0.159147,0.048577,-0.263159,-0.398917,0.356171,-0.052794,-0.231224,0.484294,-0.459470,-0.257806,0.081805,0.428147,0.630720,-0.534824,-0.192546,-0.275066,-0.702110,0.841838,-0.478019,-0.118083,0.774768,-1.000234,-0.730267,-0.040454,0.716430,-1.045650,-0.610960,-0.096929,-0.696244,0.898920,0.645582,-0.110636,-0.414167,0.703354,-0.637589,-0.286858,0.171323,0.515662,0.586116,0.363985,0.018988,0.340416,-0.435044,-0.293829,0.045981,0.148761,-0.186246,0.123869,0.060200,0.066198,0.106204,-0.048047,0.238852,0.344551,-0.259917,-0.006207,-0.284646,0.459476,-0.406863,0.162922,0.174653,0.449955,0.548038,0.411928,0.069824,0.359090,0.674487,-0.692414,-0.353934,-0.217806,0.751778,-0.931139,0.629866,0.045031,0.740705,1.080472,0.858275},
  {-0.566931,-0.614400,0.320533,-0.065723,0.376324,0.588286,-0.579700,0.122967,0.253673,-0.658755,-0.669617,-0.369431,0.089453,0.480582,0.613597,-0.508834,-0.084026,-0.450022,-0.688594,0.502207,-0.203893,-0.336807,0.520820,0.471699,0.162563,-0.204576,-0.426376,0.175003,-0.031511,0.102700,0.184651,-0.282074,0.134887,-0.089900,-0.161786,0.193936,0.192925,0.072235,-0.084093,-0.175319,0.084090,0.041470,-0.122194,-0.153299,0.049701,0.005495,-0.315896,0.367682,-0.342158,0.020567,0.425866,0.589657,-0.269622,0.117658,-0.486231,-0.622676,0.445388,0.062281,0.348303,-0.649438,0.576418,-0.263025,0.204805,0.561738,0.632319,0.385130,-0.057701,0.450721,0.642510,-0.531427,-0.125060,-0.364799,0.601525,-0.560101,0.176346,-0.246862,-0.500741,-0.472476,0.064285,-0.281265,-0.317348,0.212773,0.087158,0.022520,-0.180753,0.231019,-0.241304,0.083014,-0.094638,-0.216661,-0.216575,-0.121782,-0.005054,-0.040488,0.008978,0.047076,-0.183300,0.247067,-0.219762,-0.065029,0.363565,0.524751,0.352245,-0.094575},
  {-0.723915,-0.650283,0.273538,-0.216601,0.602198,0.730179,-0.538253,0.071303,0.424910,-0.765374,-0.745291,-0.362143,0.218426,0.712857,0.857959,-0.571807,0.025733,-0.618110,-0.868451,0.650963,-0.134213,-0.428863,0.703815,0.617553,0.257968,-0.159403,-0.510566,0.375899,0.139671,0.116873,0.341918,-0.460391,0.379642,-0.152657,-0.179892,0.422531,0.485619,0.325451,0.022826,-0.279590,0.443142,0.434672,-0.270353,0.008285,-0.308453,0.488548,-0.504103,0.269044,0.103652,0.484225,0.660782,0.513363,-0.113139,0.375662,-0.640498,-0.666367,0.442315,-0.036036,0.558773,-0.723483,0.675932,-0.188834,0.361083,0.779414,0.847294,0.505850,-0.091877,0.707336,0.914100,-0.595229,-0.019479,-0.495820,0.837189,-0.621713,0.230771,-0.263562,-0.551559,-0.538801,0.034918,-0.246383,-0.396140,0.459582,0.311484,0.011418,-0.230814,0.489365,-0.425470,0.282513,-0.044304,-0.334537,-0.454662,-0.361491,0.176232,-0.120400,0.417524,0.506702,-0.352389,0.164443,0.241418,-0.468442,0.627176,0.439137,0.024172,-0.426655},
  {-0.036044,0.188964,-0.346388,-0.354713,0.219145,0.026654,0.168187,-0.372764,0.368520,-0.251233,0.017515,0.278126,0.403851,0.338459,0.120147,0.116893,0.326686,-0.432955,-0.344733,0.085468,0.176023,-0.455265,0.500615,0.336772,-0.029603,-0.437599,-0.578032,0.143828,-0.370134,0.686237,0.669936,-0.321899,-0.249439,0.623344,-0.718227,0.391370,-0.083096,-0.483281,-0.623939,-0.475004,0.115293,-0.224384,0.411718,0.453631,-0.357202,0.072099,0.196808,-0.472034,0.508605,0.335108,-0.035930,-0.435030,0.408417,0.320291,-0.123579,0.084955,-0.249719,-0.347417,0.330015,-0.140281,-0.102539,0.345372,0.425422,0.311173,0.055857,-0.217632,-0.385749,0.399236,0.238368,0.029515,0.281398,-0.424796,0.433691,-0.221306,-0.096115,-0.428141,-0.587119,-0.458045,0.402257,-0.683844,-0.628712,0.245266,-0.292289,0.692892,-0.700505,0.370666,0.162883,-0.558345,-0.660154,-0.431440,-0.021455,0.353917,-0.518069,-0.460529,0.244454,-0.052842,0.328738,-0.457488,0.447086,-0.220868,-0.102971,-0.433432,-0.582220,-0.440013},
  {1.034563,0.919088,-0.369961,0.314758,-0.813136,-0.932403,0.642181,-0.057216,-0.497291,0.837493,0.794371,0.420641,-0.115214,-0.589700,-0.810941,0.702242,0.275636,0.299536,0.751377,-0.863108,0.596679,-0.004326,-0.576729,-0.887749,-0.751083,-0.245314,0.737730,-0.727709,-0.408169,-0.018143,-0.374162,0.554317,-0.514895,0.361158,-0.067755,-0.263118,-0.580108,-0.710068,-0.517311,-0.012028,-0.578639,-0.957542,0.875230,0.303416,0.478209,-1.016722,1.071247,-0.554683,-0.214248,-0.885397,-1.116706,-0.805869,0.205604,-0.501358,0.923970,0.927174,-0.533015,0.105397,-0.689988,0.885954,-0.741473,0.228879,-0.334996,-0.742627,-0.833365,-0.580457,-0.091931,-0.465278,-0.808903,0.782599,0.426780,0.119165,-0.689739,0.888974,-0.712849,-0.158445,0.459466,0.821591,0.327203,0.179887,0.559760,-0.673369,-0.490467,0.144013,0.143905,-0.430260,0.544905,-0.559798,-0.324379,0.108412,0.582345,0.845886,-0.729646,-0.175493,-0.561115,-1.036139,0.968049,-0.445847,-0.377697,0.963928,-1.125264,-0.707511,0.042341,0.756169},
  {0.457800,0.489656,-0.297652,0.017936,-0.342404,-0.576536,0.581785,-0.236034,-0.191376,0.612953,0.727193,0.502629,0.039705,-0.446686,-0.729509,0.705947,0.321970,0.256182,0.708042,-0.809890,0.583745,-0.007475,-0.519645,-0.825239,-0.730031,-0.288548,0.731175,-0.825815,-0.585419,0.104116,-0.478232,0.903988,-0.862987,0.448632,0.292681,-0.867961,-1.034521,-0.637610,0.118451,0.810030,-1.016876,-0.696715,0.068108,-0.548187,0.840786,-0.637835,0.238100,0.246357,-0.490467,-0.533266,-0.374799,-0.094924,0.175376,-0.122390,0.416119,0.552930,-0.442309,-0.120378,-0.285757,0.620085,-0.643732,0.380284,-0.094452,-0.536968,-0.732691,-0.584003,-0.153162,-0.351183,-0.721908,0.777786,0.451159,0.117816,-0.619452,0.861061,-0.660674,-0.154903,0.424688,0.802563,0.461056,0.104623,0.618374,-0.861647,-0.740249,0.276230,0.388982,-0.885499,0.993521,-0.555214,0.190894,0.862149,1.077249,0.711674,0.033603,0.704618,-0.941011,-0.686131,0.140993,0.413639,-0.663403,0.613373,-0.302275,0.059532,0.353392,0.498839},
  {-0.238881,-0.327919,0.246660,-0.002134,0.284868,0.412481,-0.295984,0.023511,0.283524,-0.406017,-0.307156,-0.044283,0.226855,0.362229,0.306652,-0.097081,0.133134,-0.272890,-0.281600,0.164271,0.046368,-0.205397,0.272686,0.187082,0.010721,-0.153950,-0.144603,0.013751,-0.105076,0.143726,0.082310,0.016912,-0.051568,0.044529,0.016637,-0.031076,-0.003697,0.056607,0.096782,0.073409,0.023200,0.120270,-0.151097,-0.100232,-0.013091,0.153528,-0.196528,0.149462,0.004458,0.151024,0.219626,0.175730,-0.173843,0.043125,-0.247522,-0.360944,0.295040,0.022510,0.301577,-0.401619,0.328737,-0.014928,0.272821,0.406272,0.324577,0.090778,-0.159760,0.334447,0.310635,-0.115872,0.097024,-0.225858,0.295843,-0.159484,0.004837,-0.167432,-0.231157,-0.155962,0.152386,-0.166014,-0.100436,0.016476,-0.067685,0.105497,-0.016221,-0.006920,0.048183,0.025272,0.069228,0.067934,0.009336,-0.069788,0.142576,0.102762,0.037759,0.151780,-0.166122,0.142347,0.027864,-0.135072,0.229868,0.175307,0.035739,-0.110391},
  {0.993476,1.109076,-0.750320,-0.033676,-0.675976,-0.965976,0.783997,-0.471404,-0.153418,0.581180,0.875170,0.796974,0.319698,-0.380074,-0.964312,1.026260,0.629928,0.024975,0.714355,-1.087671,0.778116,-0.274042,-0.452574,-0.865286,-0.901394,-0.581796,0.460946,-0.845741,-0.805459,0.353801,-0.184233,0.572961,-0.859585,0.630795,-0.290550,-0.319650,-0.741917,-0.890011,-0.685642,-0.181319,-0.514907,-0.959507,0.914411,0.486654,0.142458,-0.875986,1.049807,-0.866700,0.125783,-0.605574,-1.075433,-1.079521,0.627053,-0.205140,0.852821,1.048862,-0.776762,-0.211601,-0.384023,0.768607,-0.882918,0.641269,0.134312,-0.483206,-0.943074,-0.989828,-0.545823,-0.210330,-0.870554,1.081176,0.756156,-0.084837,-0.608038,0.946747,-0.857335,-0.396276,0.193192,0.663589,0.662631,-0.222782,0.319970,-0.735043,-0.820841,0.541163,-0.056135,-0.468993,0.770691,-0.778844,-0.456536,0.065848,0.589645,0.891978,-0.823702,-0.349937,-0.342139,-0.905102,1.043028,-0.695436,-0.023488,0.715039,-1.090184,-0.946372,-0.373995,0.364943},
  {0.546713,1.342518,-1.537842,-0.956869,-0.123175,-1.103796,1.503850,-1.253310,0.349598,0.599256,1.263533,1.328582,0.805732,-0.054829,-0.886936,1.303314,1.190504,-0.575214,0.359408,-1.189218,1.396322,-1.013281,0.066009,-0.865937,-1.370848,-1.228815,0.317398,-1.030280,-1.246078,0.912723,0.249046,0.488750,-1.123729,1.218507,-0.846970,-0.018397,-0.878964,-1.355240,-1.197275,-0.477164,-0.488978,-1.165765,1.252287,0.813828,-0.080226,-0.733957,1.144726,-1.155884,0.605608,-0.182881,-0.934345,-1.315079,1.409501,0.710464,0.325970,1.234272,-1.564445,-1.117976,0.124072,0.860917,-1.446004,1.299755,0.591929,-0.348018,-1.102131,-1.365437,-1.046338,0.258681,-0.636174,1.252601,1.333420,-0.809757,-0.154447,1.017354,-1.432375,-1.139057,-0.322825,0.600604,1.224831,-0.749757,0.026741,-0.781289,-1.189648,1.095126,-0.577538,-0.260254,0.984393,-1.331620,-1.043238,-0.250321,0.669810,1.262650,-1.266406,-0.665791,-0.229129,-0.963251,1.230083,-1.009208,0.334384,0.431411,-1.067143,-1.247651,-0.896319,-0.131773},
  {-0.308946,0.416609,-0.987552,-1.124216,0.703424,-0.140187,0.976954,-1.284420,0.990835,-0.138701,0.760770,1.286064,1.188682,0.532101,-0.360537,1.100994,1.305528,-0.878881,-0.053860,-0.794908,1.337818,-1.188089,0.495406,-0.487437,-1.232633,-1.345864,0.214994,-1.030231,-1.306260,0.927007,0.089347,0.742786,-1.078462,0.906328,-0.282996,-0.329129,-0.713909,-0.720485,-0.428218,-0.024651,-0.284459,-0.464708,0.503304,0.369146,-0.102233,-0.154287,0.436942,-0.524992,0.461914,0.165456,-0.224843,-0.537387,0.992610,1.022704,-0.486330,0.313082,-0.976056,-1.215252,0.870676,0.035656,-0.849090,1.335186,1.112678,0.357172,-0.548967,-1.167400,-1.214952,0.735343,-0.128855,0.982174,1.345611,-1.035406,0.312005,0.684187,-1.273300,-1.277834,-0.618962,0.376130,1.393354,-0.836906,0.085116,-0.871478,-1.201176,0.947581,-0.167189,-0.513222,0.950997,-0.801290,-0.354747,0.174879,0.544402,0.644339,-0.452126,-0.182445,-0.057558,-0.301131,0.496711,-0.439428,0.323976,0.035063,-0.318320,-0.542325,-0.534712,-0.275936},
  {1.215640,0.780625,0.039418,0.731008,-0.966439,-0.767135,0.304625,0.290585,-0.611130,0.753801,0.586770,0.225186,-0.220969,-0.596127,-0.731250,0.578057,0.105310,0.464958,0.773109,-0.670679,0.352895,0.165896,-0.478750,-0.611013,-0.515251,-0.251010,0.487945,-0.698039,-0.684846,0.372614,-0.230009,0.839824,-0.993037,0.723158,0.029279,-0.715150,-1.091315,-0.915774,-0.282048,0.493596,-0.994724,-1.067825,0.685287,-0.053401,0.816679,-1.132311,1.008164,-0.315531,-0.463648,-1.076682,-1.170799,-0.687680,-0.152752,-0.872252,1.127630,0.801733,-0.120628,0.510339,-0.813087,0.780192,-0.415044,-0.015508,-0.424477,-0.668827,-0.665400,-0.388804,0.082379,-0.530663,-0.770312,0.664725,0.224902,0.320758,-0.642291,0.696559,-0.424595,-0.043856,0.319631,0.569328,0.510564,-0.124222,0.374184,-0.773881,-0.874077,0.550329,0.148114,-0.790552,1.105169,-0.820157,-0.129841,0.637668,1.099080,1.037301,-0.470125,0.294394,-0.905984,-1.124539,0.844827,-0.121646,-0.636702,1.157154,-1.094906,-0.521350,0.323237,1.032675},
  {0.974400,0.949590,-0.431513,0.286647,-0.845412,-1.002541,0.682280,0.012546,-0.639290,0.984816,0.832103,0.301015,-0.345340,-0.807771,-0.883435,0.571549,-0.024120,0.629160,0.915549,-0.737085,0.240221,0.415598,-0.800077,-0.783526,-0.369395,0.198931,0.694700,-0.423998,-0.030160,-0.283455,-0.445678,0.441835,-0.247586,0.038524,0.220564,-0.356334,-0.384924,-0.256292,-0.013226,0.243022,-0.376738,-0.378818,0.259148,0.026258,0.243508,-0.398531,0.474488,-0.316513,0.034189,-0.350628,-0.629617,-0.624352,0.301237,-0.411116,0.911398,0.979116,-0.576452,0.128147,-0.779375,0.998173,-0.765020,0.132625,-0.524765,-0.917920,-0.877390,-0.439735,0.184680,-0.732733,-0.920517,0.657721,0.095624,0.498061,-0.883041,0.783033,-0.330405,0.284315,0.712248,0.746190,-0.083794,0.446858,0.567372,-0.450088,-0.168067,-0.142117,0.321323,-0.417804,0.333096,-0.172682,0.076708,0.300870,0.403038,0.334521,-0.147930,0.109869,-0.337568,-0.423189,0.343932,-0.177828,-0.122416,0.383564,-0.571044,-0.501340,-0.169098,0.306784},
  {0.384773,0.746757,-0.795217,-0.419323,-0.190079,-0.654781,0.777320,-0.672637,0.170424,0.313203,0.734384,0.834366,0.534078,-0.059897,-0.675640,0.941273,0.797525,-0.305070,0.383893,-0.932822,0.933992,-0.611448,-0.095160,-0.717315,-1.039867,-0.906601,0.384446,-1.013138,-1.110378,0.600460,-0.177293,0.815481,-1.129406,0.763928,-0.150794,-0.588067,-0.949834,-0.869262,-0.436325,0.130680,-0.656801,-0.847453,0.632805,0.191597,0.293553,-0.755756,0.756588,-0.505576,-0.076113,-0.541726,-0.737094,-0.609248,0.662706,0.230051,0.272065,0.690837,-0.832181,-0.548389,-0.019913,0.461287,-0.826740,0.729822,0.357477,-0.218424,-0.748641,-0.970056,-0.744540,0.091304,-0.578099,0.927269,0.877953,-0.459389,-0.283470,0.775853,-1.028003,-0.766072,-0.163942,0.520323,0.964258,-0.525223,0.247035,-0.963933,-1.148560,0.698317,-0.017021,-0.752711,0.998481,-0.859810,-0.294293,0.334244,0.747772,0.802744,-0.576372,-0.073193,-0.504328,-0.815326,0.715741,-0.400800,-0.214965,0.604629,-0.804953,-0.575569,-0.123891,0.317842},
  {-0.302356,-0.366732,0.268720,-0.013120,0.369158,0.582474,-0.479772,0.079041,0.453269,-0.758852,-0.637575,-0.113895,0.512384,0.858782,0.708491,-0.141988,0.486683,-0.814115,-0.687323,0.208952,0.359947,-0.685478,0.659394,0.306390,-0.166136,-0.525882,-0.396914,0.004563,-0.383365,0.572651,0.455502,-0.099977,-0.273103,0.492495,-0.414317,0.135281,-0.191334,-0.366425,-0.308510,-0.085080,-0.134497,-0.228691,0.165057,0.008731,0.111562,-0.091247,-0.003049,0.106689,-0.089764,0.024567,0.159036,0.201657,-0.152493,0.078940,-0.329716,-0.470915,0.378915,0.035354,0.406591,-0.677329,0.575944,-0.100324,0.486499,0.825252,0.685857,0.132695,-0.506740,0.852511,0.705135,-0.168801,0.430760,-0.761389,0.675227,-0.248201,-0.264734,-0.609475,-0.634472,-0.353744,0.456708,-0.593835,-0.434226,0.063303,-0.327950,0.533702,-0.444221,0.128190,0.234894,-0.432287,-0.372908,-0.116125,0.165706,0.304740,-0.239625,-0.050020,-0.119017,-0.162316,0.077084,0.049434,-0.097432,0.035032,0.087442,0.153798,0.095493,-0.060179}
};


const float train_sym[2*52] = {
  1.000000,1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,1.000000,-1.000000,1.000000,1.000000,
  1.000000,1.000000,1.000000,1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,1.000000,-1.000000,
  1.000000,1.000000,1.000000,1.000000,1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,1.000000,
  -1.000000,1.000000,-1.000000,-1.000000,-1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,-1.000000,
  1.000000,-1.000000,1.000000,-1.000000,1.000000,1.000000,1.000000,1.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000
};


const float actin[200][2*52] = {
  {-0.008434,0.151371,0.228741,0.198247,0.083501,-0.064639,-0.189017,-0.238026,-0.178624,-0.018624,0.176077,0.298063,0.258409,0.056778,-0.197062,-0.342874,-0.278917,-0.040064,0.219758,0.333146,0.234863,0.001516,-0.209945,-0.272742,-0.167278,0.022410,0.210104,0.119567,-0.034920,-0.162573,-0.188440,-0.092435,0.072967,0.202997,0.201222,0.050602,-0.158238,-0.276879,-0.204488,0.027376,0.263363,0.331182,0.170540,-0.116169,-0.334008,-0.334655,-0.119640,0.166538,0.341328,0.305083,0.094587,-0.155686,0.248063,0.186485,0.042728,-0.110162,-0.207494,-0.214818,-0.129995,0.019718,0.177715,0.267019,0.223599,0.045108,-0.183659,-0.325393,-0.277702,-0.053940,0.210942,0.345936,0.263144,0.020667,-0.219669,-0.306867,-0.200660,0.013241,0.193393,0.238153,-0.028092,-0.163431,-0.193212,-0.105288,0.048407,0.176043,0.192964,0.075649,-0.110234,-0.238916,-0.206794,-0.015653,0.211700,0.309540,0.191992,-0.073547,-0.305934,-0.339215,-0.144443,0.148691,0.345376,0.321474,0.101798,-0.168263,-0.325866,-0.290464},
  {0.003366,0.067047,0.119748,0.135627,0.096421,0.010586,-0.086287,-0.151241,-0.156970,-0.101135,-0.001426,0.111504,0.196461,0.207989,0.118059,-0.053492,-0.228071,-0.301750,-0.212775,0.004793,0.230119,0.330743,0.251229,0.047380,-0.159145,-0.266026,-0.139981,-0.001610,0.133461,0.241826,0.284686,0.210760,0.004643,-0.262041,-0.440210,-0.391879,-0.100788,0.286814,0.539062,0.489210,0.153123,-0.273969,-0.541159,-0.499461,-0.187383,0.205001,0.459004,0.452866,0.216759,-0.102620,-0.334121,-0.373483,0.118046,0.102924,0.051695,-0.028993,-0.109853,-0.151809,-0.130837,-0.053474,0.048550,0.136302,0.177917,0.153475,0.059115,-0.082301,-0.213682,-0.259662,-0.171241,0.027755,0.235496,0.327262,0.239387,0.018579,-0.206030,-0.309821,-0.251729,-0.086734,0.204622,0.241624,0.207211,0.104720,-0.061196,-0.249075,-0.365338,-0.309411,-0.059162,0.276540,0.500416,0.452459,0.130979,-0.287245,-0.552581,-0.503620,-0.171009,0.245916,0.508188,0.481254,0.203051,-0.155463,-0.399362,-0.416674,-0.225838,0.051475},
  {1.079709,1.232465,0.778731,-0.063500,-0.876732,-1.269033,-1.067977,-0.383777,0.466257,1.108629,1.265080,0.857644,0.045303,-0.823063,-1.343351,-1.243305,-0.536379,0.455218,1.246518,1.439218,0.934432,-0.015981,-0.946039,-1.415529,-1.219258,-0.466538,1.210196,1.377353,0.913030,0.025181,-0.878818,-1.373940,-1.221195,-0.491712,0.461842,1.180016,1.326656,0.850912,-0.000720,-0.818236,-1.229421,-1.067428,-0.432886,0.366501,0.964235,1.103177,0.747904,0.088921,-0.561831,-0.926747,-0.884224,-0.496392,0.597766,-0.254650,-1.008114,-1.279483,-0.934929,-0.151199,0.692091,1.208827,1.178627,0.623944,-0.214914,-0.977732,-1.322419,-1.069069,-0.299486,0.648451,1.320047,1.368834,0.749082,-0.243830,-1.120763,-1.453533,-1.091417,-0.223639,0.730853,1.331885,0.700867,-0.231023,-1.057355,-1.398399,-1.089933,-0.269043,0.678898,1.300942,1.300638,0.687116,-0.233178,-1.016140,-1.301437,-0.979175,-0.225261,0.597723,1.115589,1.110470,0.610343,-0.135027,-0.778653,-1.042011,-0.839634,-0.300399,0.317852,0.761746},
  {-0.016255,-0.150748,-0.219666,-0.199997,-0.104023,0.029749,0.152779,0.220870,0.205084,0.102385,-0.055389,-0.204109,-0.270751,-0.212157,-0.046214,0.149582,0.277297,0.272864,0.140647,-0.052577,-0.216489,-0.281784,-0.226241,-0.076260,0.107583,0.251425,0.204895,0.018010,-0.188116,-0.315996,-0.299748,-0.141678,0.086753,0.280265,0.350013,0.262269,0.050896,-0.195928,-0.367819,-0.376080,-0.198471,0.095791,0.364414,0.459312,0.313422,-0.007625,-0.331741,-0.477986,-0.366109,-0.065056,0.252431,0.416916,-0.233762,-0.172425,-0.045907,0.093248,0.191851,0.215637,0.157589,0.036851,-0.106030,-0.216903,-0.243892,-0.162206,0.003986,0.181982,0.282561,0.249404,0.094437,-0.106289,-0.254698,-0.283109,-0.184822,-0.009491,0.166042,0.270776,0.263078,0.143014,-0.224074,-0.311083,-0.257916,-0.080407,0.142537,0.305608,0.330016,0.202225,-0.021451,-0.242370,-0.361922,-0.320999,-0.126028,0.145634,0.368785,0.423722,0.262532,-0.049390,-0.352913,-0.478438,-0.348180,-0.030004,0.298596,0.456984,0.368619,0.099188},
  {-1.263854,-0.574731,0.393381,1.169992,1.378811,0.932275,0.068426,-0.786591,-1.242851,-1.127682,-0.536026,0.249094,0.898065,1.162267,0.948797,0.340928,-0.427346,-1.042838,-1.227819,-0.867239,-0.087288,0.773339,1.308321,1.242872,0.582652,-0.373578,-1.424926,-1.003298,-0.102741,0.849306,1.400017,1.289864,0.576439,-0.396964,-1.170861,-1.390900,-0.970765,-0.120571,0.763823,1.287818,1.230468,0.630167,-0.242358,-1.003578,-1.319122,-1.046456,-0.301322,0.585529,1.211842,1.288617,0.778377,-0.084702,0.609325,1.286171,1.352697,0.772828,-0.165976,-1.002072,-1.341022,-1.050607,-0.304655,0.531680,1.091806,1.164518,0.754050,0.046867,-0.672913,-1.121623,-1.109886,-0.618534,0.171165,0.926285,1.295325,1.077516,0.340803,-0.587233,-1.266286,-1.359378,0.140340,1.030700,1.438537,1.167043,0.345104,-0.635424,-1.310083,-1.365750,-0.787540,0.142078,0.986537,1.364309,1.120028,0.381477,-0.511995,-1.165648,-1.298010,-0.855503,-0.032769,0.808052,1.290945,1.193257,0.552666,-0.342287,-1.082247,-1.328712},
  {0.288608,0.829083,0.973657,0.613629,-0.079970,-0.738743,-1.009775,-0.762307,-0.152243,0.489430,0.855584,0.813751,0.430946,-0.103678,-0.577705,-0.819227,-0.729692,-0.316191,0.278565,0.794587,0.959077,0.644447,-0.023244,-0.702582,-1.023415,-0.809140,0.501688,0.892309,0.817270,0.364459,-0.204843,-0.616262,-0.714244,-0.504897,-0.116147,0.279000,0.532556,0.564879,0.379764,0.055403,-0.284467,-0.512255,-0.539680,-0.349825,-0.008112,0.353963,0.583295,0.568471,0.297596,-0.122145,-0.504095,-0.669032,0.886814,0.493505,-0.185544,-0.802028,-1.016447,-0.702927,-0.031252,0.634611,0.954028,0.796845,0.285740,-0.308723,-0.725602,-0.819833,-0.582314,-0.110310,0.425193,0.812081,0.859863,0.498204,-0.144011,-0.760340,-1.015875,-0.748411,-0.085394,0.616618,0.830107,0.277959,-0.361723,-0.767177,-0.776956,-0.441791,0.041789,0.450465,0.632273,0.547714,0.259075,-0.108749,-0.416051,-0.553173,-0.473938,-0.209588,0.141258,0.444484,0.576312,0.471315,0.156757,-0.245235,-0.559638,-0.635758,-0.424777,-0.012656},
  {-0.080430,0.133089,0.265849,0.282421,0.208328,0.076596,-0.097588,-0.286599,-0.411465,-0.363015,-0.091762,0.308350,0.615466,0.612303,0.247443,-0.301617,-0.723069,-0.763383,-0.385848,0.208170,0.699759,0.830913,0.536460,-0.031713,-0.586548,-0.847737,-0.163409,0.437244,0.809139,0.758605,0.319873,-0.265574,-0.688676,-0.744602,-0.432678,0.065223,0.497140,0.668109,0.518506,0.134124,-0.298928,-0.574115,-0.557566,-0.260186,0.156121,0.461297,0.493574,0.261459,-0.067316,-0.288243,-0.302074,-0.165843,0.310393,0.280870,0.133591,-0.044579,-0.190479,-0.282164,-0.303468,-0.217632,0.000273,0.296808,0.520084,0.498123,0.174063,-0.312988,-0.685590,-0.700555,-0.316293,0.267415,0.726457,0.805049,0.459406,-0.127064,-0.650413,-0.844867,-0.612378,-0.068137,0.837198,0.730367,0.248011,-0.354832,-0.759926,-0.762498,-0.380414,0.168461,0.598641,0.710814,0.478911,0.038604,-0.393991,-0.621916,-0.547149,-0.210991,0.218890,0.522399,0.541691,0.276744,-0.107787,-0.384577,-0.412027,-0.220932,0.027069,0.173102},
  {-1.546005,-1.367203,-0.507857,0.625267,1.465307,1.582892,0.918668,-0.186624,-1.178680,-1.579249,-1.217555,-0.293042,0.740798,1.398456,1.384624,0.723623,-0.256970,-1.084163,-1.370163,-1.002506,-0.191260,0.653518,1.140975,1.086912,0.571523,-0.139815,-1.005862,-0.855243,-0.360725,0.279015,0.800156,0.973801,0.716195,0.145076,-0.470220,-0.849474,-0.846426,-0.504118,0.002940,0.477704,0.774980,0.811302,0.553021,0.036928,-0.583988,-1.041989,-1.062709,-0.543929,0.323066,1.108927,1.376919,0.948213,-0.264161,0.817373,1.531287,1.503055,0.726884,-0.414418,-1.346318,-1.606699,-1.082594,-0.052526,0.972341,1.507589,1.320212,0.521549,-0.498262,-1.256538,-1.403432,-0.886691,0.025521,0.882459,1.281845,1.068403,0.390992,-0.402648,-0.956065,-1.063891,-0.120435,0.509899,0.917494,0.940739,0.563857,-0.058797,-0.652094,-0.944891,-0.810368,-0.331928,0.252925,0.690253,0.831039,0.664064,0.270796,-0.228630,-0.689688,-0.940621,-0.823969,-0.299548,0.462031,1.102371,1.251054,0.761018,-0.163103,-1.052623},
  {-0.283423,0.058710,0.343569,0.424063,0.276718,0.000495,-0.249895,-0.349416,-0.260871,-0.044152,0.179686,0.290807,0.232956,0.045853,-0.154719,-0.245481,-0.174678,0.002365,0.160956,0.194795,0.090037,-0.069719,-0.169082,-0.144104,-0.020434,0.115055,0.134373,0.009849,-0.133380,-0.223337,-0.202852,-0.056713,0.162489,0.336228,0.335020,0.111081,-0.236671,-0.494380,-0.466384,-0.125375,0.338994,0.628490,0.537545,0.103415,-0.408740,-0.679384,-0.543882,-0.092665,0.398097,0.645874,0.526837,0.129577,0.388556,0.459671,0.282176,-0.028378,-0.296060,-0.385894,-0.269428,-0.025853,0.209772,0.317509,0.249613,0.051634,-0.161586,-0.267742,-0.208306,-0.026867,0.155950,0.221437,0.133753,-0.036589,-0.165914,-0.167470,-0.050005,0.096683,0.171701,0.131012,-0.125876,-0.193251,-0.158214,-0.028509,0.143629,0.271227,0.264321,0.086753,-0.193550,-0.413405,-0.405425,-0.124452,0.287631,0.569163,0.511296,0.116441,-0.381980,-0.665964,-0.546762,-0.093403,0.414378,0.670880,0.535313,0.104760,-0.363168,-0.611230},
  {-0.575937,-0.407830,-0.023836,0.439763,0.759822,0.731607,0.305908,-0.339489,-0.867058,-0.966112,-0.546826,0.187920,0.847169,1.072237,0.738927,0.023474,-0.699044,-1.058383,-0.880206,-0.267170,0.463422,0.946125,0.950882,0.492202,-0.187795,-0.749386,-0.657366,-0.091364,0.488290,0.811656,0.743623,0.335490,-0.208780,-0.630817,-0.737695,-0.492086,-0.029334,0.412764,0.620132,0.515399,0.189482,-0.167209,-0.385143,-0.404295,-0.276303,-0.095531,0.073122,0.211138,0.309456,0.332003,0.229510,-0.002865,0.119694,0.476599,0.673211,0.576192,0.168222,-0.394675,-0.827071,-0.863844,-0.432599,0.271337,0.874382,1.035462,0.648790,-0.088883,-0.787179,-1.078847,-0.816729,-0.144321,0.588975,1.013524,0.926121,0.385147,-0.328119,-0.857524,-0.951711,-0.583871,0.624677,0.879869,0.711055,0.220823,-0.347018,-0.727248,-0.753322,-0.428216,0.081299,0.525452,0.693981,0.521872,0.119723,-0.293228,-0.516128,-0.474371,-0.240637,0.036296,0.234068,0.313449,0.299043,0.221406,0.085478,-0.105701,-0.305498,-0.416908},
  {0.124677,-0.116077,-0.279191,-0.287618,-0.157459,0.026703,0.171166,0.222795,0.181612,0.081290,-0.037294,-0.139092,-0.194419,-0.179411,-0.087641,0.054102,0.184920,0.235764,0.171532,0.019789,-0.139543,-0.221858,-0.190906,-0.078107,0.045956,0.123751,0.128791,0.098080,0.042148,-0.057979,-0.186257,-0.271048,-0.224187,-0.020136,0.252114,0.423335,0.356799,0.059543,-0.300269,-0.496432,-0.399501,-0.068829,0.288173,0.458641,0.362117,0.086589,-0.191119,-0.328601,-0.292246,-0.143430,0.028901,0.163659,-0.313157,-0.305656,-0.142506,0.075122,0.230583,0.258914,0.170500,0.026576,-0.105261,-0.182068,-0.190012,-0.133578,-0.028398,0.095861,0.193283,0.214760,0.136508,-0.015232,-0.167580,-0.238992,-0.190088,-0.050699,0.099311,0.183178,0.174545,0.103471,-0.046765,-0.102832,-0.156014,-0.183486,-0.135356,0.015263,0.219091,0.353619,0.300239,0.045158,-0.281024,-0.472808,-0.390008,-0.065863,0.304157,0.491467,0.388319,0.074056,-0.250175,-0.402088,-0.327847,-0.109578,0.115133,0.246398,0.260481,0.185643},
  {-0.239276,-0.414467,-0.415696,-0.251410,0.013997,0.276238,0.423338,0.384018,0.170221,-0.118972,-0.345381,-0.406612,-0.288795,-0.062943,0.166284,0.316770,0.352124,0.270367,0.087989,-0.155306,-0.380301,-0.476143,-0.354273,-0.023316,0.376791,0.628747,0.182215,-0.326116,-0.679906,-0.675072,-0.309892,0.213380,0.610291,0.679167,0.406695,-0.042771,-0.434209,-0.590892,-0.470782,-0.160751,0.188034,0.434789,0.496590,0.361511,0.081605,-0.241457,-0.479948,-0.521510,-0.323844,0.045222,0.418502,0.604001,-0.389940,-0.157223,0.124576,0.348009,0.428212,0.329365,0.085745,-0.200080,-0.396806,-0.410418,-0.237675,0.031624,0.267954,0.373954,0.325951,0.164389,-0.045176,-0.241465,-0.369827,-0.376370,-0.224236,0.065189,0.383200,0.562566,0.469726,0.106445,-0.669064,-0.633153,-0.249997,0.277801,0.659993,0.689917,0.362134,-0.134140,-0.533632,-0.645192,-0.443150,-0.056986,0.317119,0.519544,0.488808,0.263847,-0.053012,-0.340650,-0.493718,-0.448974,-0.209339,0.141617,0.455024,0.574557,0.419359,0.044412},
  {1.630106,1.192820,0.187888,-0.877684,-1.493326,-1.400765,-0.689955,0.287571,1.104566,1.434312,1.155559,0.380945,-0.579104,-1.316690,-1.485489,-0.970627,0.021862,1.033537,1.571777,1.366327,0.514656,-0.570162,-1.374465,-1.535734,-1.000226,-0.025383,1.497461,1.375365,0.632062,-0.406146,-1.268429,-1.551395,-1.115705,-0.163084,0.857000,1.467825,1.396268,0.694195,-0.302406,-1.141093,-1.457277,-1.124944,-0.300324,0.649882,1.305757,1.376709,0.832811,-0.078857,-0.947217,-1.387349,-1.213274,-0.511148,-0.060942,-1.103700,-1.598547,-1.320977,-0.439380,0.601545,1.323940,1.437071,0.932434,0.046739,-0.851267,-1.394523,-1.344979,-0.694680,0.299990,1.197542,1.563911,1.196609,0.250687,-0.823369,-1.507061,-1.478630,-0.766473,0.282604,1.184257,1.541061,0.336373,-0.686316,-1.406419,-1.493523,-0.896003,0.120243,1.084321,1.543011,1.283525,0.436895,-0.592875,-1.330777,-1.453796,-0.926788,-0.000530,0.910263,1.407778,1.278142,0.581893,-0.370056,-1.151637,-1.413846,-1.044675,-0.217080,0.697362,1.300393},
  {0.405409,0.222114,-0.035897,-0.278762,-0.415501,-0.387560,-0.201291,0.067286,0.306691,0.423338,0.378933,0.193492,-0.073531,-0.339593,-0.507310,-0.484188,-0.230114,0.187685,0.585444,0.738409,0.516131,-0.010414,-0.578547,-0.874189,-0.719786,-0.185927,0.852212,0.830775,0.408489,-0.198030,-0.699653,-0.869624,-0.636309,-0.107255,0.476948,0.844064,0.813586,0.389723,-0.228590,-0.738767,-0.887240,-0.601823,-0.028633,0.546450,0.845330,0.733405,0.277056,-0.297126,-0.714401,-0.781260,-0.475006,0.046865,-0.171985,-0.367835,-0.423193,-0.319248,-0.089913,0.178909,0.377572,0.422449,0.297202,0.057082,-0.203667,-0.393619,-0.448572,-0.338247,-0.074840,0.268713,0.554142,0.621320,0.380551,-0.101011,-0.595607,-0.825139,-0.630139,-0.084696,0.529642,0.882625,0.294238,-0.334668,-0.788599,-0.858059,-0.524706,0.047158,0.593513,0.865547,0.735235,0.255376,-0.354500,-0.802516,-0.865289,-0.505806,0.100435,0.652581,0.879622,0.677628,0.155976,-0.425593,-0.788759,-0.768559,-0.385680,0.168666,0.625747,0.768788},
  {0.259255,-0.201739,-0.567483,-0.670797,-0.462637,-0.027711,0.444640,0.730776,0.672303,0.267462,-0.301988,-0.745440,-0.816471,-0.459511,0.145264,0.676250,0.851410,0.585884,0.032293,-0.513801,-0.779262,-0.651611,-0.220089,0.288167,0.630031,0.660154,-0.047410,-0.437371,-0.610894,-0.499987,-0.165445,0.233876,0.512804,0.543327,0.314796,-0.057797,-0.386935,-0.507423,-0.366128,-0.053429,0.249404,0.380520,0.295613,0.085819,-0.098251,-0.159190,-0.114712,-0.061093,-0.072330,-0.125322,-0.120548,0.016209,-0.610262,-0.634250,-0.355824,0.093200,0.510210,0.703924,0.571339,0.150833,-0.374738,-0.746475,-0.756385,-0.371450,0.225934,0.722917,0.848449,0.530779,-0.059049,-0.605575,-0.827153,-0.625909,-0.126581,0.405950,0.712095,0.663121,0.308254,-0.166736,-0.642557,-0.451333,-0.064802,0.334755,0.566784,0.530990,0.250235,-0.139819,-0.451964,-0.535948,-0.354725,-0.007625,0.319340,0.456060,0.346484,0.078888,-0.176166,-0.280789,-0.216361,-0.078188,0.015014,0.021045,-0.000831,0.039369,0.159953,0.269372},
  {-0.276770,-0.554627,-0.530653,-0.220755,0.200345,0.506910,0.546536,0.310463,-0.074996,-0.416579,-0.545060,-0.394511,-0.039588,0.333034,0.519194,0.415641,0.088896,-0.261127,-0.428993,-0.337140,-0.077615,0.167186,0.259561,0.190983,0.057822,-0.036277,-0.053819,-0.064564,-0.090684,-0.088124,-0.025189,0.074919,0.147668,0.142104,0.062854,-0.038379,-0.107996,-0.126344,-0.104930,-0.059050,0.007669,0.090215,0.161135,0.174063,0.098060,-0.047028,-0.190496,-0.251716,-0.191061,-0.032796,0.151542,0.280062,-0.506720,-0.181515,0.246735,0.539637,0.542258,0.263873,-0.140789,-0.463384,-0.547207,-0.356392,0.011977,0.372312,0.537460,0.416554,0.073751,-0.297393,-0.484408,-0.388573,-0.088027,0.219011,0.352597,0.267978,0.065398,-0.105082,-0.158424,-0.116747,-0.032016,-0.024717,0.006643,0.072586,0.131144,0.126741,0.046167,-0.064852,-0.138887,-0.139601,-0.081330,-0.004373,0.061610,0.108692,0.133012,0.118325,0.046910,-0.070786,-0.182555,-0.219650,-0.145284,0.013955,0.180422,0.270694,0.239187,0.094917},
  {0.466694,-0.217732,-0.876137,-1.157618,-0.865171,-0.083804,0.824951,1.384067,1.253353,0.439567,-0.668702,-1.486312,-1.549650,-0.787845,0.417853,1.431228,1.707304,1.091649,-0.094798,-1.229359,-1.720764,-1.320565,-0.248904,0.927910,1.600036,1.435198,-0.577758,-1.351769,-1.401666,-0.752589,0.214621,0.992852,1.221761,0.851625,0.126295,-0.576377,-0.940772,-0.845824,-0.388287,0.189265,0.619412,0.727676,0.502314,0.087445,-0.299509,-0.485567,-0.428414,-0.218427,0.001391,0.136603,0.188014,0.213829,-0.856727,-1.013338,-0.661774,0.078460,0.864590,1.283244,1.066089,0.259385,-0.759255,-1.453599,-1.417020,-0.617415,0.554305,1.478924,1.646899,0.947062,-0.262814,-1.346200,-1.731435,-1.217729,-0.078654,1.087602,1.676679,1.394784,0.407444,-0.756363,-1.437961,-0.663012,0.395934,1.183862,1.328012,0.815305,-0.038451,-0.786833,-1.089983,-0.861949,-0.271583,0.373352,0.781841,0.801747,0.467526,-0.033587,-0.457759,-0.622140,-0.489054,-0.171252,0.146581,0.321406,0.325318,0.231568,0.132131,0.058770},
  {0.241252,0.600952,0.648909,0.327046,-0.186988,-0.592510,-0.664779,-0.390350,0.050939,0.421418,0.563939,0.454819,0.171206,-0.167317,-0.436546,-0.529938,-0.392506,-0.063612,0.313382,0.549853,0.517986,0.232049,-0.157820,-0.455993,-0.529830,-0.365794,0.270901,0.477089,0.480209,0.269457,-0.073939,-0.394196,-0.529577,-0.405062,-0.085454,0.258761,0.455286,0.428676,0.224750,-0.043229,-0.268773,-0.387793,-0.370372,-0.210060,0.058759,0.337371,0.484165,0.395957,0.094585,-0.262921,-0.477589,-0.440314,0.576761,0.273458,-0.220247,-0.618134,-0.676890,-0.362527,0.131975,0.524285,0.622837,0.419633,0.053297,-0.297356,-0.499551,-0.494078,-0.289031,0.044345,0.375867,0.551859,0.470587,0.154703,-0.242535,-0.517894,-0.535759,-0.300994,0.057807,0.370244,0.426955,0.166392,-0.169182,-0.439677,-0.517490,-0.351394,-0.010632,0.335719,0.509470,0.429261,0.155072,-0.160487,-0.371611,-0.411835,-0.297233,-0.084663,0.160211,0.362684,0.436543,0.318077,0.026924,-0.307034,-0.500910,-0.436562,-0.148505,0.195704},
  {0.530899,1.053949,1.082734,0.594085,-0.185764,-0.884539,-1.161221,-0.875419,-0.164304,0.619484,1.086206,1.012502,0.456036,-0.285533,-0.844298,-0.975626,-0.663620,-0.093585,0.466862,0.794330,0.783219,0.458940,-0.044972,-0.529083,-0.791849,-0.711913,0.217989,0.642601,0.769370,0.561979,0.137256,-0.315225,-0.628224,-0.706580,-0.527479,-0.131566,0.367464,0.778980,0.887802,0.572355,-0.080225,-0.766223,-1.110243,-0.890539,-0.193656,0.618169,1.114609,1.044569,0.465820,-0.310871,-0.906193,-1.062166,0.991649,0.418769,-0.363634,-0.983633,-1.139832,-0.749074,0.006723,0.761846,1.144266,0.965160,0.320036,-0.460019,-0.985663,-1.015293,-0.570590,0.099125,0.667973,0.899309,0.735040,0.283621,-0.254362,-0.668807,-0.804166,-0.605949,-0.148250,0.378607,0.767601,0.453698,-0.046230,-0.499629,-0.720039,-0.644638,-0.330502,0.099773,0.506286,0.751283,0.717795,0.361245,-0.223022,-0.786110,-1.022873,-0.751468,-0.058292,0.712065,1.141587,0.987362,0.328760,-0.483134,-1.033200,-1.067574,-0.604336,0.110447},
  {0.914473,0.938559,0.531374,-0.093668,-0.637386,-0.858399,-0.681648,-0.219514,0.299794,0.650406,0.706432,0.475340,0.069650,-0.349378,-0.625658,-0.651978,-0.406898,0.023393,0.461573,0.707769,0.637510,0.273637,-0.217513,-0.608796,-0.725138,-0.522132,0.372700,0.685344,0.708124,0.419331,-0.070289,-0.548598,-0.789165,-0.664851,-0.225016,0.320046,0.708561,0.765744,0.485205,0.010806,-0.451908,-0.727275,-0.718533,-0.419481,0.082336,0.606493,0.916569,0.819088,0.291862,-0.449188,-1.025060,-1.098429,0.414344,-0.265809,-0.784341,-0.914485,-0.622076,-0.069187,0.475110,0.769456,0.709074,0.355522,-0.115838,-0.507501,-0.677415,-0.575792,-0.247310,0.185305,0.553490,0.697873,0.539147,0.130623,-0.349560,-0.678067,-0.699191,-0.404416,0.067546,0.504286,0.624785,0.261095,-0.224498,-0.627980,-0.765554,-0.557435,-0.081297,0.446611,0.771657,0.734844,0.359283,-0.167306,-0.600079,-0.760890,-0.604729,-0.209507,0.274708,0.673326,0.824385,0.627646,0.110704,-0.531413,-0.986602,-0.979647,-0.452451,0.357978},
  {0.125564,-0.230125,-0.471378,-0.443740,-0.157833,0.218208,0.467333,0.455819,0.203814,-0.140745,-0.395201,-0.439604,-0.267628,0.023859,0.289787,0.406248,0.325151,0.093105,-0.173444,-0.346219,-0.348019,-0.187726,0.050121,0.252054,0.330360,0.258146,-0.139469,-0.287484,-0.302458,-0.174158,0.039111,0.232362,0.305991,0.222345,0.030212,-0.162988,-0.255850,-0.211589,-0.072110,0.077432,0.163752,0.161669,0.093835,0.005140,-0.064517,-0.094335,-0.084117,-0.049481,-0.012923,0.009443,0.019497,0.035052,-0.441389,-0.419056,-0.141354,0.232610,0.479701,0.454871,0.178103,-0.186758,-0.437622,-0.449966,-0.234504,0.084655,0.344717,0.425353,0.299252,0.036626,-0.232478,-0.380437,-0.341967,-0.143617,0.112613,0.303032,0.343555,0.225806,0.012872,-0.196192,-0.284227,-0.128946,0.086028,0.261286,0.310488,0.205935,-0.000377,-0.199890,-0.287633,-0.223531,-0.053878,0.121647,0.213150,0.189825,0.085658,-0.033648,-0.112672,-0.129578,-0.094403,-0.034121,0.022358,0.054985,0.059782,0.049488,0.042608,0.044398},
  {-0.507312,-0.426918,-0.157899,0.203163,0.493974,0.559729,0.347872,-0.044331,-0.414633,-0.571275,-0.442828,-0.110619,0.249956,0.470946,0.469873,0.269049,-0.033852,-0.312774,-0.456346,-0.403305,-0.169049,0.149213,0.404982,0.470342,0.306978,-0.005180,-0.445175,-0.360360,-0.111404,0.163665,0.330265,0.328127,0.190334,0.006269,-0.140084,-0.212641,-0.221312,-0.186550,-0.108202,0.028215,0.210564,0.366108,0.381549,0.182647,-0.180646,-0.522348,-0.617755,-0.358924,0.144269,0.606930,0.743814,0.459595,-0.030039,0.290972,0.506048,0.506447,0.265165,-0.121788,-0.464932,-0.581587,-0.406071,-0.032400,0.342050,0.532233,0.462652,0.190357,-0.144478,-0.395275,-0.467426,-0.341968,-0.073211,0.229444,0.436018,0.447493,0.248061,-0.074147,-0.361938,-0.469650,-0.057018,0.239764,0.398095,0.354856,0.156416,-0.080840,-0.243636,-0.280420,-0.211965,-0.095819,0.021762,0.127124,0.219907,0.277283,0.244963,0.077665,-0.196589,-0.449586,-0.509087,-0.278652,0.163674,0.577359,0.698306,0.419420,-0.118815,-0.604277},
  {1.151955,0.903765,0.211589,-0.607816,-1.166265,-1.181424,-0.617459,0.278670,1.076891,1.368348,0.979988,0.082675,-0.879228,-1.412556,-1.237079,-0.438331,0.576121,1.292699,1.359197,0.758872,-0.194784,-1.028009,-1.344561,-1.011019,-0.206966,0.672487,1.154926,0.551232,-0.298964,-0.976531,-1.154464,-0.762436,-0.020556,0.680682,0.992159,0.791197,0.233451,-0.355838,-0.679606,-0.630250,-0.318015,0.036889,0.260488,0.317036,0.282488,0.239769,0.193502,0.077985,-0.151978,-0.432806,-0.595171,-0.473879,0.018133,-0.744039,-1.171944,-1.050076,-0.414984,0.450270,1.134789,1.289966,0.808742,-0.099305,-0.991812,-1.410543,-1.124328,-0.263090,0.739879,1.372884,1.315643,0.604877,-0.392292,-1.175742,-1.368307,-0.895901,-0.008165,0.857267,1.290311,1.099028,-0.483221,-1.102624,-1.174429,-0.677411,0.128525,0.834428,1.093569,0.801165,0.142471,-0.519697,-0.852673,-0.733074,-0.291853,0.193435,0.479444,0.488820,0.313881,0.109174,-0.032551,-0.124630,-0.227365,-0.349519,-0.406385,-0.280573,0.059316,0.484141},
  {0.024348,-0.265116,-0.390929,-0.352347,-0.206635,-0.018089,0.162129,0.289084,0.319891,0.230692,0.042455,-0.173098,-0.322102,-0.336732,-0.210854,-0.000634,0.206552,0.332251,0.333932,0.211967,0.003776,-0.225507,-0.394499,-0.425253,-0.274775,0.030590,0.607944,0.566368,0.220532,-0.299257,-0.733907,-0.824979,-0.473616,0.172089,0.773836,0.988452,0.674827,-0.010667,-0.697652,-1.015283,-0.802356,-0.187228,0.499754,0.914145,0.870358,0.413816,-0.223030,-0.738927,-0.897138,-0.625698,-0.051876,0.547503,-0.503991,-0.368815,-0.120623,0.118488,0.275054,0.326318,0.275197,0.136403,-0.055707,-0.238516,-0.336198,-0.297800,-0.131558,0.092784,0.278073,0.347880,0.279005,0.103715,-0.111200,-0.291013,-0.373159,-0.320619,-0.133978,0.137660,0.396782,0.522104,0.090948,-0.346898,-0.679680,-0.703726,-0.350625,0.240269,0.766696,0.922130,0.583073,-0.095637,-0.751567,-1.019750,-0.747512,-0.083572,0.612470,0.978031,0.842250,0.298697,-0.366658,-0.831681,-0.888698,-0.525749,0.079987,0.642761,0.893142,0.704303},
  {0.318399,0.180977,-0.038906,-0.262220,-0.392984,-0.354358,-0.136902,0.173535,0.422512,0.468478,0.272591,-0.067297,-0.369586,-0.477347,-0.348714,-0.069566,0.212103,0.375425,0.377250,0.243494,0.030545,-0.200061,-0.380265,-0.432865,-0.299047,0.007810,0.591582,0.522641,0.154639,-0.335409,-0.673003,-0.650660,-0.264754,0.271135,0.651834,0.666023,0.321235,-0.170344,-0.530113,-0.580399,-0.334325,0.038491,0.332245,0.423689,0.317437,0.107413,-0.098994,-0.234912,-0.280153,-0.238053,-0.119103,0.051948,-0.126866,-0.299278,-0.359316,-0.271299,-0.051397,0.219792,0.415667,0.422404,0.211846,-0.123231,-0.408497,-0.487549,-0.317903,0.003595,0.303823,0.438719,0.367472,0.152491,-0.098407,-0.293460,-0.380873,-0.338787,-0.166144,0.102629,0.376160,0.519280,0.079144,-0.355081,-0.644188,-0.600456,-0.216707,0.307748,0.675721,0.672242,0.299218,-0.225224,-0.602462,-0.634279,-0.332358,0.107520,0.438473,0.508602,0.328856,0.034252,-0.217004,-0.330768,-0.301090,-0.176915,-0.015192,0.140736,0.254136,0.285827},
  {1.021313,1.594362,1.388931,0.469001,-0.721033,-1.581234,-1.670400,-0.935544,0.264220,1.342647,1.776431,1.355271,0.278475,-0.939856,-1.712341,-1.659256,-0.798827,0.451455,1.475629,1.769316,1.198047,0.062351,-1.066318,-1.644647,-1.425097,-0.554906,1.314227,1.472418,0.963540,0.044407,-0.859759,-1.344460,-1.203738,-0.522002,0.367116,1.043502,1.207165,0.819484,0.103221,-0.591249,-0.968040,-0.911983,-0.503866,0.055513,0.548115,0.812929,0.777006,0.459384,-0.035934,-0.539851,-0.862023,-0.857683,1.185547,0.232815,-0.893038,-1.617826,-1.551568,-0.704887,0.509036,1.487285,1.745039,1.154952,0.002739,-1.156699,-1.765512,-1.526880,-0.548457,0.701997,1.616048,1.742535,1.018065,-0.194834,-1.291357,-1.736208,-1.334243,-0.314531,0.807522,1.500750,0.774749,-0.236775,-1.096674,-1.430264,-1.109991,-0.301701,0.613800,1.215116,1.237216,0.696181,-0.126240,-0.833255,-1.115312,-0.890921,-0.315500,0.327715,0.775151,0.885178,0.660475,0.211325,-0.298339,-0.697186,-0.845934,-0.677482,-0.230709,0.343771},
  {-0.401749,-0.071478,0.272133,0.476725,0.450726,0.201572,-0.153021,-0.426557,-0.461604,-0.234362,0.114541,0.364933,0.368586,0.153175,-0.107109,-0.232408,-0.172787,-0.027252,0.061528,0.036071,-0.038696,-0.054799,0.026087,0.134982,0.164102,0.070920,-0.184401,-0.173354,-0.076152,0.030272,0.093500,0.117796,0.130353,0.128667,0.073401,-0.060650,-0.228826,-0.321525,-0.240412,0.012763,0.311924,0.475229,0.381944,0.056955,-0.333480,-0.571627,-0.510556,-0.161309,0.302177,0.627718,0.621718,0.267051,0.355426,0.513674,0.426494,0.144335,-0.202403,-0.448984,-0.465740,-0.233384,0.125256,0.401595,0.430301,0.205286,-0.111956,-0.309345,-0.279615,-0.089531,0.091530,0.138020,0.061773,-0.022838,-0.019594,0.059693,0.116342,0.068876,-0.063878,-0.178456,-0.070177,0.071801,0.153786,0.148973,0.095570,0.039368,-0.014060,-0.087222,-0.177204,-0.226393,-0.159922,0.037166,0.276325,0.405828,0.313832,0.017466,-0.331104,-0.529672,-0.447189,-0.105989,0.322202,0.603916,0.570259,0.217113,-0.277824,-0.641529},
  {-0.808502,-1.335862,-1.143948,-0.347257,0.603652,1.193874,1.138557,0.520299,-0.295837,-0.891008,-1.012424,-0.666208,-0.064532,0.507162,0.817886,0.765255,0.392722,-0.135472,-0.593057,-0.778272,-0.605156,-0.154863,0.353563,0.671756,0.654098,0.333711,-0.442879,-0.540408,-0.401537,-0.135558,0.127028,0.303647,0.372375,0.340174,0.212251,-0.002991,-0.261671,-0.466892,-0.501176,-0.300553,0.081297,0.474730,0.675148,0.558861,0.160620,-0.337355,-0.697895,-0.747102,-0.454266,0.059404,0.575175,0.863895,-1.088395,-0.249896,0.720219,1.288318,1.159424,0.436999,-0.460563,-1.058373,-1.087259,-0.597236,0.117382,0.703191,0.920761,0.723816,0.238380,-0.314597,-0.707837,-0.785097,-0.517515,-0.022652,0.474762,0.741044,0.651116,0.258709,-0.230138,-0.571242,-0.380759,-0.017230,0.292318,0.433946,0.398061,0.244886,0.044280,-0.157351,-0.326368,-0.415990,-0.367491,-0.151883,0.179626,0.487851,0.605672,0.437530,0.032429,-0.424815,-0.706130,-0.662277,-0.301956,0.214055,0.652618,0.813900,0.614059,0.119280},
  {0.360986,0.383163,0.255685,-0.010553,-0.329908,-0.552956,-0.535350,-0.235322,0.229674,0.624306,0.725138,0.458298,-0.049490,-0.542166,-0.777943,-0.651609,-0.229808,0.299073,0.712112,0.831684,0.584544,0.040865,-0.582748,-0.987711,-0.931150,-0.379315,1.066417,1.169933,0.646026,-0.241514,-1.013077,-1.247777,-0.824112,0.018225,0.823785,1.177588,0.921519,0.218801,-0.551972,-1.003058,-0.932507,-0.412427,0.266277,0.756835,0.837476,0.513403,-0.010228,-0.458536,-0.636517,-0.511683,-0.195631,0.143051,0.108127,-0.126552,-0.354777,-0.476638,-0.401748,-0.112861,0.288370,0.604846,0.645875,0.351191,-0.151190,-0.604580,-0.768993,-0.557562,-0.077738,0.438250,0.756598,0.742858,0.401819,-0.135091,-0.652113,-0.915297,-0.765534,-0.215921,0.507424,1.040844,0.523812,-0.338687,-1.058074,-1.229491,-0.745675,0.134165,0.933080,1.228562,0.882689,0.101755,-0.693629,-1.100801,-0.939044,-0.324850,0.407342,0.887670,0.899123,0.476123,-0.133046,-0.612697,-0.748630,-0.524528,-0.100182,0.299577,0.507460,0.477674},
  {0.236960,-0.327411,-0.681646,-0.660454,-0.314026,0.139972,0.457716,0.508747,0.326404,0.050624,-0.178834,-0.295491,-0.304439,-0.233376,-0.097653,0.087351,0.271286,0.365170,0.292898,0.061398,-0.217569,-0.387416,-0.351202,-0.139471,0.114034,0.269405,0.169730,0.049881,-0.036711,-0.101122,-0.173534,-0.242742,-0.243084,-0.109011,0.147273,0.406891,0.501501,0.325910,-0.072345,-0.495315,-0.698087,-0.534813,-0.057986,0.493565,0.818033,0.719413,0.226011,-0.412650,-0.855099,-0.854995,-0.401060,0.271420,-0.766029,-0.699557,-0.284700,0.233914,0.578539,0.595699,0.326699,-0.045035,-0.322468,-0.405896,-0.317654,-0.144911,0.035397,0.186582,0.289025,0.309408,0.210002,-0.003732,-0.248779,-0.393075,-0.340597,-0.108264,0.173577,0.345714,0.326692,0.158780,-0.163709,-0.194544,-0.174537,-0.146104,-0.102044,-0.001676,0.165288,0.331998,0.378267,0.217727,-0.116870,-0.462275,-0.608845,-0.432150,0.013530,0.505392,0.768068,0.631579,0.139138,-0.461860,-0.847264,-0.794929,-0.314543,0.348338,0.841288,0.897316},
  {0.052971,-0.106134,-0.166313,-0.108493,0.002707,0.071499,0.045997,-0.041662,-0.102335,-0.063901,0.065654,0.196482,0.219865,0.090118,-0.134315,-0.320519,-0.342543,-0.162545,0.138387,0.398663,0.463659,0.275484,-0.084725,-0.429930,-0.564772,-0.397875,0.410497,0.615711,0.494817,0.110174,-0.331760,-0.597650,-0.554218,-0.232689,0.197785,0.522739,0.587136,0.363744,-0.038488,-0.424571,-0.602409,-0.476448,-0.102982,0.328232,0.588365,0.535485,0.198951,-0.233839,-0.525317,-0.524980,-0.250896,0.131640,-0.222354,-0.169358,-0.032422,0.085196,0.106915,0.036639,-0.048870,-0.064271,0.013017,0.121077,0.160007,0.071859,-0.107319,-0.263815,-0.280890,-0.120252,0.144652,0.365504,0.404033,0.215433,-0.117405,-0.420185,-0.518525,-0.337971,0.043578,0.427124,0.450997,0.054836,-0.378837,-0.615326,-0.528827,-0.169532,0.270408,0.565377,0.573040,0.298353,-0.118586,-0.474453,-0.597217,-0.424720,-0.036875,0.375613,0.600436,0.514418,0.157186,-0.281521,-0.563681,-0.538600,-0.229484,0.183884,0.474313,0.497682},
  {0.338311,0.094071,-0.163959,-0.345776,-0.388389,-0.280419,-0.070434,0.155811,0.317022,0.366098,0.291555,0.106415,-0.149057,-0.391633,-0.501473,-0.379738,-0.033756,0.383461,0.638130,0.562040,0.177021,-0.304908,-0.615510,-0.600547,-0.301191,0.101255,0.535157,0.452996,0.212533,-0.119033,-0.442236,-0.620559,-0.531106,-0.158839,0.345613,0.719086,0.738293,0.368894,-0.200964,-0.670391,-0.800852,-0.540047,-0.029215,0.485879,0.772712,0.703701,0.302764,-0.256808,-0.711758,-0.825000,-0.517429,0.064830,-0.292507,-0.415495,-0.376652,-0.200506,0.043473,0.260482,0.368388,0.334024,0.181261,-0.031733,-0.240454,-0.383420,-0.400275,-0.248123,0.054464,0.392636,0.584858,0.487714,0.110686,-0.357079,-0.650390,-0.598728,-0.238083,0.220212,0.534348,0.575743,0.046890,-0.271319,-0.488688,-0.539004,-0.379576,-0.027518,0.396144,0.684760,0.653278,0.271760,-0.282964,-0.714983,-0.785578,-0.456284,0.096112,0.590404,0.793429,0.623198,0.166495,-0.370428,-0.745014,-0.774426,-0.423752,0.153840,0.669602,0.844918},
  {-0.226589,0.231791,0.600995,0.684861,0.423073,-0.064975,-0.534395,-0.741906,-0.575878,-0.117010,0.402886,0.720581,0.676172,0.294008,-0.230573,-0.631776,-0.710051,-0.434033,0.046557,0.483797,0.663641,0.513515,0.128655,-0.289912,-0.543445,-0.528808,0.085676,0.382164,0.484458,0.357497,0.075128,-0.216926,-0.376095,-0.338964,-0.152400,0.063189,0.195464,0.208470,0.147800,0.083377,0.042917,-0.003657,-0.095770,-0.217833,-0.285874,-0.208357,0.025115,0.306016,0.462590,0.375293,0.066787,-0.302003,0.608857,0.626464,0.329532,-0.150835,-0.576494,-0.723633,-0.505499,-0.024944,0.475640,0.740389,0.633266,0.208060,-0.319868,-0.684002,-0.702513,-0.370560,0.138543,0.564705,0.697163,0.482001,0.043212,-0.391012,-0.611194,-0.528839,-0.207064,0.185869,0.514060,0.326585,0.003438,-0.298402,-0.438968,-0.362611,-0.125193,0.138702,0.294776,0.286481,0.158555,0.010697,-0.081023,-0.111358,-0.125305,-0.153576,-0.168331,-0.105571,0.062166,0.270758,0.386409,0.299120,0.016932,-0.317743,-0.510063,-0.437115},
  {0.226592,0.649569,0.756919,0.519245,0.060365,-0.413560,-0.702864,-0.686130,-0.362559,0.139708,0.600181,0.793721,0.604812,0.107117,-0.454438,-0.788568,-0.722399,-0.301015,0.244600,0.637323,0.705842,0.455449,0.032411,-0.370535,-0.599068,-0.578568,0.074451,0.451321,0.636891,0.529547,0.166895,-0.275487,-0.573737,-0.583904,-0.322210,0.057301,0.365898,0.485581,0.407863,0.199248,-0.057127,-0.291516,-0.441709,-0.446010,-0.267370,0.060817,0.413469,0.615486,0.536095,0.177887,-0.303023,-0.667513,0.756014,0.424166,-0.088726,-0.540770,-0.737692,-0.607432,-0.213853,0.276797,0.656365,0.750480,0.496127,-0.010088,-0.533760,-0.808465,-0.681356,-0.210365,0.358803,0.731027,0.728960,0.381901,-0.112569,-0.513745,-0.660102,-0.521950,-0.181294,0.220053,0.619441,0.441888,0.056510,-0.367650,-0.623393,-0.577662,-0.254931,0.172404,0.486723,0.551001,0.372093,0.068205,-0.219124,-0.396247,-0.431238,-0.328198,-0.108517,0.178220,0.436856,0.543999,0.411528,0.058324,-0.369034,-0.656821,-0.638729,-0.296310},
  {0.229747,-1.291220,-2.201204,-2.087167,-1.015293,0.495720,1.729183,2.125312,1.546163,0.313296,-0.983163,-1.780039,-1.781591,-1.046150,0.082888,1.138158,1.707296,1.575924,0.800433,-0.311081,-1.311157,-1.785554,-1.521143,-0.599806,0.621394,1.638514,1.479359,0.247534,-1.192688,-2.172684,-2.173731,-1.116540,0.543243,2.005419,2.528346,1.827211,0.234761,-1.471289,-2.471010,-2.305903,-1.076626,0.636201,2.054359,2.542720,1.873715,0.327988,-1.407042,-2.522411,-2.461105,-1.212308,0.643644,2.200930,-2.322283,-1.920771,-0.649181,0.899548,2.003300,2.156683,1.316404,-0.088227,-1.384975,-1.996563,-1.701717,-0.696533,0.541892,1.489061,1.784159,1.344902,0.371375,-0.741261,-1.549365,-1.725514,-1.187719,-0.140262,0.998032,1.754779,1.792360,1.052276,-1.446970,-2.124013,-1.860273,-0.693513,0.887981,2.134860,2.400870,1.498453,-0.166640,-1.782785,-2.550667,-2.096862,-0.652913,1.082689,2.300239,2.454670,1.490225,-0.156782,-1.751163,-2.567135,-2.204618,-0.791661,1.034890,2.401981,2.625580,1.574654},
  {-0.922754,-1.434783,-1.306826,-0.561363,0.489222,1.362018,1.621418,1.102307,0.020174,-1.109850,-1.723309,-1.500285,-0.539653,0.687346,1.579159,1.707252,1.020827,-0.142092,-1.226870,-1.724752,-1.405220,-0.420877,0.759593,1.567639,1.610019,0.871109,-1.238662,-1.560631,-1.117718,-0.184691,0.747071,1.246358,1.147740,0.581783,-0.149203,-0.741476,-1.003395,-0.882351,-0.441874,0.166260,0.728828,1.022247,0.899040,0.374913,-0.346025,-0.945536,-1.139365,-0.820964,-0.120786,0.650632,1.144985,1.134030,-1.092106,-0.266841,0.720438,1.420908,1.486542,0.844415,-0.239318,-1.258248,-1.702497,-1.323586,-0.281835,0.918240,1.681383,1.628369,0.788083,-0.424746,-1.423944,-1.738587,-1.229870,-0.145469,1.001076,1.667561,1.535601,0.667421,-0.513531,-1.424706,-1.022529,0.037257,1.011158,1.433761,1.157827,0.392234,-0.455404,-1.010532,-1.094104,-0.747730,-0.155557,0.455170,0.880595,0.976704,0.693933,0.113349,-0.549986,-1.012694,-1.048812,-0.612322,0.120419,0.822766,1.170612,0.996496,0.368716,-0.438521},
  {-0.427420,0.047078,0.462438,0.602481,0.417354,0.029460,-0.347928,-0.524230,-0.420777,-0.101637,0.261497,0.474879,0.423032,0.134917,-0.225301,-0.447804,-0.401424,-0.116806,0.229083,0.422724,0.349102,0.063333,-0.248214,-0.390004,-0.280979,-0.000418,0.359150,0.219527,-0.056974,-0.295496,-0.347373,-0.179428,0.106914,0.336402,0.364694,0.166038,-0.147934,-0.390892,-0.410922,-0.182711,0.172090,0.450180,0.481943,0.231934,-0.173171,-0.507858,-0.571418,-0.306167,0.157421,0.561562,0.663331,0.381832,0.516493,0.646378,0.420734,-0.010556,-0.404241,-0.560466,-0.417801,-0.068491,0.299025,0.495740,0.423602,0.124663,-0.237101,-0.459819,-0.416205,-0.131818,0.223736,0.436083,0.378577,0.092796,-0.238052,-0.407109,-0.315559,-0.031727,0.258455,0.373239,-0.029273,-0.280860,-0.349973,-0.196335,0.082821,0.313913,0.352230,0.169213,-0.128917,-0.362434,-0.384435,-0.170366,0.162716,0.420490,0.443618,0.203356,-0.175464,-0.479372,-0.525040,-0.267055,0.166508,0.535462,0.618655,0.345741,-0.147901,-0.584686},
  {-1.114825,-1.608741,-1.281025,-0.313514,0.783657,1.452876,1.379824,0.638051,-0.374111,-1.151896,-1.335863,-0.874489,-0.028782,0.772798,1.152350,0.963686,0.346778,-0.366607,-0.836482,-0.881425,-0.541606,-0.021222,0.435802,0.658414,0.599452,0.323719,-0.347953,-0.500576,-0.462949,-0.274033,-0.016776,0.226388,0.401745,0.477492,0.420173,0.196565,-0.179066,-0.589104,-0.820324,-0.673019,-0.118972,0.613792,1.125919,1.078732,0.427306,-0.514251,-1.237139,-1.333827,-0.736416,0.248565,1.117016,1.436903,-1.173812,-0.134138,0.963065,1.553004,1.349047,0.483124,-0.583873,-1.316183,-1.375177,-0.771225,0.166163,0.968447,1.261658,0.940329,0.201758,-0.570506,-1.009235,-0.943191,-0.460588,0.166869,0.641760,0.784092,0.588565,0.188256,-0.230918,-0.511299,-0.417693,-0.131157,0.171419,0.385338,0.456753,0.388763,0.215096,-0.029020,-0.305535,-0.543519,-0.625365,-0.436061,0.034166,0.613780,0.991853,0.891507,0.273650,-0.582886,-1.210305,-1.226907,-0.580773,0.403023,1.204558,1.402040,0.895780,-0.055803},
  {0.394943,0.407261,0.221472,-0.034447,-0.218934,-0.266524,-0.206202,-0.107984,-0.016464,0.068779,0.158608,0.231635,0.233505,0.123182,-0.077061,-0.276858,-0.367339,-0.288403,-0.065436,0.204820,0.402564,0.436117,0.276376,-0.028798,-0.361083,-0.566339,-0.201398,0.266032,0.653266,0.737947,0.436358,-0.127365,-0.668026,-0.887252,-0.642878,-0.041203,0.607064,0.950259,0.791700,0.207041,-0.489474,-0.917960,-0.848781,-0.333379,0.330755,0.779642,0.793657,0.408753,-0.132353,-0.541719,-0.646335,-0.451780,0.206142,-0.101270,-0.318103,-0.348768,-0.219518,-0.036073,0.104189,0.170111,0.185530,0.175740,0.132282,0.030333,-0.123669,-0.267550,-0.313036,-0.208810,0.014859,0.255923,0.396353,0.363822,0.163628,-0.127102,-0.389636,-0.504540,-0.397650,-0.082987,0.617374,0.635474,0.320676,-0.201674,-0.670643,-0.822761,-0.544878,0.045209,0.646067,0.930053,0.726597,0.127036,-0.553999,-0.946739,-0.833680,-0.276717,0.414970,0.862428,0.835127,0.376740,-0.236490,-0.671216,-0.728464,-0.432698,0.020275,0.398847},
  {1.164029,1.668615,1.431946,0.589600,-0.485269,-1.348679,-1.650927,-1.257055,-0.303357,0.830180,1.648703,1.751814,1.040252,-0.196968,-1.390079,-1.958611,-1.607419,-0.485855,0.879325,1.841242,1.945293,1.142202,-0.193991,-1.442996,-2.025087,-1.668430,0.844138,1.830291,1.963693,1.187731,-0.129836,-1.375486,-1.978839,-1.672206,-0.604498,0.733143,1.730183,1.930408,1.240154,-0.022306,-1.267557,-1.911287,-1.657086,-0.640962,0.641869,1.589271,1.785518,1.181886,0.086261,-1.005866,-1.635339,-1.556307,1.249025,0.235444,-0.848568,-1.539541,-1.566833,-0.935932,0.094166,1.108409,1.679939,1.534626,0.687144,-0.523665,-1.552719,-1.895643,-1.349915,-0.142338,1.163128,1.939196,1.807146,0.823301,-0.550988,-1.672523,-2.018824,-1.428577,-0.174216,1.163335,1.849649,0.878534,-0.495940,-1.632343,-2.006573,-1.454839,-0.241728,1.070922,1.884631,1.832961,0.942696,-0.378313,-1.522329,-1.958193,-1.482096,-0.321045,0.971930,1.787541,1.758572,0.929751,-0.285463,-1.324280,-1.741922,-1.392566,-0.458688,0.651653},
  {-0.149558,-0.227679,-0.232928,-0.150160,0.004644,0.176275,0.289321,0.284892,0.151686,-0.065024,-0.277425,-0.385787,-0.320060,-0.082590,0.230945,0.460123,0.462234,0.207943,-0.178779,-0.480590,-0.519625,-0.273985,0.107856,0.406532,0.471306,0.299948,-0.239156,-0.360068,-0.328966,-0.176917,0.040423,0.249867,0.365797,0.320705,0.114564,-0.161000,-0.361381,-0.376125,-0.201525,0.059085,0.266935,0.333060,0.254506,0.088487,-0.095991,-0.243590,-0.309108,-0.255743,-0.078931,0.162147,0.349734,0.369306,-0.180257,-0.066706,0.077814,0.208815,0.270354,0.222813,0.071396,-0.127944,-0.290400,-0.338508,-0.235734,-0.007653,0.255908,0.427107,0.398253,0.151573,-0.205365,-0.479966,-0.504355,-0.248443,0.147871,0.456843,0.507305,0.289060,-0.054636,-0.331781,-0.312312,-0.092597,0.138445,0.302015,0.348583,0.256352,0.045734,-0.204069,-0.372715,-0.361912,-0.165321,0.114642,0.326408,0.364590,0.229219,0.008966,-0.187267,-0.289910,-0.281160,-0.173803,0.003853,0.200229,0.334260,0.323903,0.145081,-0.127738},
  {-0.469025,-0.567410,-0.338338,0.066667,0.396796,0.455636,0.223686,-0.130411,-0.362476,-0.318628,-0.042058,0.256836,0.350872,0.162653,-0.173973,-0.406452,-0.346958,-0.014339,0.370625,0.536267,0.350639,-0.083403,-0.494307,-0.620535,-0.378193,0.091437,0.659147,0.448120,0.002615,-0.444043,-0.668709,-0.562767,-0.175422,0.311895,0.664753,0.700328,0.379090,-0.159755,-0.649160,-0.822860,-0.563421,0.015177,0.611029,0.893772,0.694329,0.111014,-0.537955,-0.893209,-0.759865,-0.217737,0.428090,0.823993,-0.367944,0.064825,0.427690,0.514509,0.290312,-0.088963,-0.375639,-0.390296,-0.139862,0.187907,0.354990,0.241868,-0.064714,-0.331622,-0.348414,-0.085062,0.278392,0.476034,0.347109,-0.043689,-0.444197,-0.584673,-0.360093,0.100241,0.518385,0.644702,-0.056510,-0.490210,-0.666359,-0.500671,-0.081836,0.382828,0.667924,0.630863,0.276749,-0.236188,-0.658895,-0.766008,-0.476317,0.085498,0.633814,0.866524,0.636801,0.050391,-0.579328,-0.902778,-0.735231,-0.166776,0.487118,0.866163,0.769436,0.263693},
  {-0.597893,0.082083,0.738862,1.061202,0.876227,0.250346,-0.518920,-1.039232,-1.030555,-0.488601,0.299879,0.911559,1.025719,0.604670,-0.094603,-0.681692,-0.862536,-0.594801,-0.081117,0.379219,0.572736,0.472145,0.206520,-0.054924,-0.211878,-0.263502,-0.227173,-0.149371,0.004650,0.217849,0.402663,0.442170,0.270023,-0.069533,-0.427531,-0.622403,-0.536088,-0.180421,0.299252,0.683317,0.774625,0.494738,-0.061207,-0.644692,-0.957612,-0.804775,-0.218474,0.526968,1.041840,1.033228,0.481108,-0.335026,0.843574,1.037964,0.749019,0.092976,-0.629706,-1.062640,-0.971938,-0.383671,0.408467,0.989018,1.048794,0.562605,-0.194667,-0.808127,-0.962574,-0.614999,0.001839,0.536772,0.730472,0.546189,0.151521,-0.215995,-0.396981,-0.376448,-0.243271,-0.095623,0.138027,0.251268,0.331757,0.307911,0.132496,-0.157358,-0.435230,-0.547650,-0.405286,-0.044225,0.380770,0.666876,0.660169,0.333248,-0.189875,-0.674885,-0.875483,-0.655321,-0.077694,0.595026,1.015067,0.933404,0.354442,-0.440491,-1.032887,-1.098936},
  {0.094881,-0.142138,-0.368819,-0.510569,-0.471531,-0.199814,0.236798,0.639967,0.773101,0.512160,-0.050132,-0.632532,-0.920569,-0.750466,-0.202474,0.449865,0.891137,0.919007,0.524868,-0.117852,-0.730341,-1.035287,-0.868940,-0.268775,0.509332,1.083997,0.599742,-0.269550,-1.015140,-1.234467,-0.813396,0.010167,0.792165,1.139064,0.913184,0.274302,-0.439888,-0.899887,-0.929208,-0.552853,0.042174,0.595240,0.873416,0.760224,0.306439,-0.283217,-0.735744,-0.838134,-0.545181,-0.005187,0.515386,0.768966,-0.410482,-0.412322,-0.286800,-0.027929,0.309891,0.588717,0.637433,0.363697,-0.150577,-0.656786,-0.869277,-0.641230,-0.066886,0.563366,0.926438,0.842027,0.356429,-0.297816,-0.822565,-0.983539,-0.699647,-0.076033,0.623629,1.070803,1.018924,0.446730,-1.067588,-1.209973,-0.722281,0.143159,0.923084,1.209236,0.875616,0.129771,-0.627891,-1.032505,-0.930195,-0.417981,0.240373,0.751320,0.910695,0.669801,0.143122,-0.437813,-0.815493,-0.817551,-0.441647,0.134537,0.634762,0.821347,0.615174,0.132227},
  {-1.348373,-0.610183,0.387684,1.203247,1.476990,1.087205,0.207656,-0.764860,-1.388484,-1.380126,-0.746876,0.219312,1.079193,1.447568,1.164233,0.360671,-0.601807,-1.292608,-1.402108,-0.880132,0.039388,0.941901,1.419510,1.256321,0.525723,-0.444039,-1.444877,-1.017276,-0.119080,0.846112,1.431453,1.354344,0.640279,-0.376129,-1.208114,-1.459792,-1.025934,-0.136631,0.774952,1.298375,1.234235,0.653534,-0.173243,-0.909246,-1.273522,-1.121822,-0.491049,0.392166,1.163380,1.453836,1.073452,0.146652,0.680295,1.367805,1.437421,0.866875,-0.087763,-1.000700,-1.461509,-1.260574,-0.488685,0.501720,1.259293,1.442590,0.974532,0.072122,-0.856586,-1.396629,-1.308849,-0.633878,0.325848,1.139344,1.439549,1.089882,0.247607,-0.707103,-1.343761,-1.375344,0.164189,1.048530,1.463878,1.210379,0.391660,-0.619355,-1.346505,-1.439741,-0.854109,0.122561,1.016605,1.411855,1.152548,0.397103,-0.490034,-1.126924,-1.273512,-0.898470,-0.159885,0.659503,1.236585,1.311313,0.801308,-0.120103,-1.053031,-1.537458},
  {-0.516434,-0.220817,0.167522,0.473800,0.572312,0.439711,0.144175,-0.202940,-0.487506,-0.609109,-0.496912,-0.148528,0.326909,0.716534,0.796817,0.473850,-0.127137,-0.704579,-0.946084,-0.712900,-0.121399,0.527432,0.916338,0.870387,0.424525,-0.212211,-0.964957,-0.733616,-0.148894,0.530530,0.978641,0.960984,0.467674,-0.264869,-0.870318,-1.046045,-0.711280,-0.040979,0.634105,0.995449,0.883218,0.359444,-0.327206,-0.853792,-0.969342,-0.616743,0.030175,0.646629,0.924898,0.740153,0.213334,-0.368955,0.295814,0.551668,0.565225,0.337555,-0.020418,-0.354924,-0.543514,-0.530091,-0.320196,0.030291,0.413119,0.673509,0.660517,0.319942,-0.231793,-0.729545,-0.894214,-0.605010,0.010233,0.637008,0.951831,0.800184,0.267690,-0.382173,-0.848039,-0.925590,0.030885,0.648882,0.984573,0.862729,0.317055,-0.402709,-0.941581,-1.022443,-0.598848,0.116458,0.765932,1.035073,0.806174,0.202454,-0.484192,-0.933469,-0.939440,-0.501154,0.173390,0.758360,0.966323,0.697786,0.098803,-0.517003,-0.842962,-0.744686},
  {0.573368,0.263642,-0.173458,-0.489874,-0.531881,-0.320962,-0.005837,0.254901,0.378634,0.362502,0.237022,0.034770,-0.198896,-0.385391,-0.429877,-0.280226,0.019448,0.333799,0.506251,0.446918,0.179792,-0.174454,-0.459314,-0.549336,-0.397951,-0.057950,0.589070,0.583205,0.296191,-0.147218,-0.535770,-0.678892,-0.504096,-0.090011,0.375734,0.682496,0.684379,0.361836,-0.158071,-0.637252,-0.825193,-0.593414,-0.033048,0.565034,0.865363,0.694320,0.156652,-0.429422,-0.738889,-0.640346,-0.249596,0.184784,-0.233543,-0.554498,-0.572522,-0.297154,0.093839,0.386421,0.463076,0.342021,0.119750,-0.109676,-0.288695,-0.379305,-0.344465,-0.166950,0.110038,0.372428,0.484853,0.372933,0.076513,-0.266971,-0.495979,-0.505146,-0.288785,0.063096,0.402467,0.578524,0.179831,-0.245262,-0.576093,-0.644008,-0.404206,0.035317,0.467600,0.689894,0.597353,0.225038,-0.268786,-0.663291,-0.762504,-0.488923,0.054769,0.605590,0.862891,0.664076,0.102548,-0.508857,-0.824828,-0.684151,-0.202695,0.321421,0.612240,0.574732},
  {-0.795551,-0.324254,0.310608,0.800905,0.908861,0.588139,0.001007,-0.572649,-0.875924,-0.787082,-0.356301,0.230322,0.727647,0.919882,0.703512,0.145248,-0.518326,-0.967461,-0.955851,-0.459483,0.282840,0.885232,1.031022,0.655865,-0.021897,-0.640477,-0.736357,-0.267552,0.260227,0.631986,0.732339,0.551742,0.163055,-0.298814,-0.659814,-0.757428,-0.519115,-0.024365,0.506704,0.814085,0.737549,0.309062,-0.261780,-0.699912,-0.805564,-0.544979,-0.051516,0.448970,0.742024,0.710625,0.375045,-0.120745,0.442897,0.860104,0.870554,0.463992,-0.161997,-0.704313,-0.909769,-0.695763,-0.175452,0.411616,0.812832,0.862204,0.535783,-0.040459,-0.627571,-0.956762,-0.847491,-0.314953,0.403182,0.945550,1.018910,0.573519,-0.156217,-0.783250,-0.991696,-0.708743,0.462683,0.781961,0.743162,0.414298,-0.046713,-0.467527,-0.704928,-0.669526,-0.355299,0.133344,0.594551,0.807219,0.647522,0.172157,-0.395280,-0.777284,-0.789473,-0.434024,0.110573,0.587958,0.788812,0.638583,0.216210,-0.290797,-0.667549,-0.756931},
  {-0.335007,-0.793233,-0.927029,-0.642069,-0.027476,0.659128,1.090644,1.023337,0.435969,-0.424158,-1.135123,-1.308708,-0.811007,0.135425,1.046546,1.433736,1.080283,0.170417,-0.812218,-1.357305,-1.206495,-0.475159,0.439535,1.088825,1.196455,0.762042,-0.693713,-1.081216,-0.991832,-0.468495,0.265385,0.885727,1.102425,0.801169,0.116987,-0.617882,-1.040447,-0.949671,-0.411582,0.286249,0.799260,0.906501,0.604264,0.074801,-0.429615,-0.709123,-0.684919,-0.401199,0.015470,0.408434,0.638289,0.622114,-0.805291,-0.436036,0.164028,0.741525,1.022887,0.840491,0.230764,-0.551312,-1.128597,-1.182240,-0.632714,0.283759,1.108415,1.394741,0.962271,0.016838,-0.947941,-1.421530,-1.161773,-0.323680,0.641156,1.244116,1.216750,0.622578,-0.215520,-0.901406,-0.887666,-0.252323,0.477984,0.992703,1.066079,0.654957,-0.064935,-0.760669,-1.094835,-0.900307,-0.276500,0.458694,0.940280,0.950381,0.521159,-0.105923,-0.625584,-0.823894,-0.659494,-0.246980,0.222597,0.568644,0.678417,0.528662,0.181975,-0.234003},
  {-0.692177,-0.090981,0.544195,0.930360,0.890491,0.430132,-0.248998,-0.823568,-1.001046,-0.680596,-0.022384,0.632774,0.953620,0.799439,0.279529,-0.332262,-0.754449,-0.824019,-0.538527,-0.029395,0.493092,0.805579,0.753287,0.334631,-0.263797,-0.736963,-0.483554,0.088862,0.563069,0.695400,0.468792,0.070402,-0.262535,-0.398714,-0.357260,-0.233806,-0.097751,0.044733,0.205784,0.353045,0.402290,0.278061,-0.011650,-0.352836,-0.576427,-0.549075,-0.248914,0.211682,0.625072,0.776292,0.550796,0.014870,0.686151,0.963200,0.796975,0.265727,-0.395372,-0.884753,-0.962152,-0.571275,0.109780,0.741376,0.999080,0.755548,0.150856,-0.495399,-0.868714,-0.819532,-0.409829,0.152564,0.624568,0.818864,0.657152,0.196944,-0.370967,-0.780672,-0.813398,-0.431570,0.666342,0.786493,0.493298,-0.009935,-0.426530,-0.561634,-0.420338,-0.153058,0.082723,0.221888,0.285342,0.304029,0.263526,0.123351,-0.115967,-0.371217,-0.507001,-0.419321,-0.110189,0.297816,0.613936,0.668591,0.399048,-0.103899,-0.614797,-0.866910},
  {0.210387,0.385512,0.370516,0.157869,-0.144604,-0.377177,-0.421472,-0.262147,0.015364,0.277979,0.410218,0.359260,0.149383,-0.129974,-0.357079,-0.426403,-0.298723,-0.027523,0.260255,0.426319,0.392847,0.180889,-0.106276,-0.339821,-0.424743,-0.332097,0.185072,0.410109,0.471830,0.319501,-0.004853,-0.362165,-0.570090,-0.499863,-0.161710,0.281822,0.595452,0.603124,0.293008,-0.170846,-0.539475,-0.618848,-0.376354,0.046446,0.418820,0.551526,0.397095,0.064266,-0.256639,-0.407615,-0.345150,-0.144069,0.314460,0.102664,-0.185699,-0.394414,-0.405446,-0.210605,0.087023,0.336682,0.421961,0.312379,0.065584,-0.207142,-0.388429,-0.398924,-0.229127,0.050914,0.315039,0.436761,0.353926,0.104643,-0.190854,-0.393614,-0.415821,-0.256815,0.008099,0.268545,0.404903,0.211246,-0.095325,-0.390028,-0.528422,-0.417611,-0.081877,0.326191,0.593119,0.562355,0.232584,-0.229504,-0.577007,-0.621775,-0.341520,0.108642,0.485686,0.595177,0.395492,0.012145,-0.341732,-0.488630,-0.380160,-0.108314,0.165269,0.310606},
  {0.972067,0.761892,0.241979,-0.387520,-0.875847,-1.005348,-0.687560,-0.030856,0.676142,1.088034,0.983797,0.399980,-0.376043,-0.959073,-1.073859,-0.691152,-0.019200,0.624528,0.970515,0.899137,0.460430,-0.164740,-0.729890,-1.001584,-0.846792,-0.304855,0.950895,1.072967,0.695722,-0.010092,-0.713937,-1.090573,-0.973743,-0.422567,0.317519,0.925421,1.134783,0.840701,0.151246,-0.640043,-1.167424,-1.160513,-0.591065,0.287672,1.050003,1.311188,0.931697,0.095866,-0.781630,-1.269788,-1.138832,-0.468224,-0.005753,-0.593889,-0.937908,-0.899666,-0.477583,0.175770,0.788318,1.070754,0.859468,0.224379,-0.538886,-1.051443,-1.055370,-0.555675,0.188649,0.814013,1.043265,0.806178,0.239485,-0.403131,-0.863615,-0.966222,-0.667762,-0.075599,0.574836,0.998450,0.513456,-0.212993,-0.855728,-1.107722,-0.849280,-0.203629,0.531229,1.027143,1.069160,0.638407,-0.085506,-0.793883,-1.168550,-1.018194,-0.380177,0.469805,1.128435,1.259703,0.776528,-0.097613,-0.933073,-1.313927,-1.053334,-0.286923,0.602422,1.182459},
  {0.742682,0.467805,-0.044308,-0.574453,-0.865047,-0.750181,-0.258820,0.379457,0.845312,0.900745,0.519191,-0.103979,-0.662704,-0.900528,-0.726891,-0.237868,0.346593,0.780319,0.880909,0.593826,0.022410,-0.592546,-0.959859,-0.876094,-0.349917,0.372248,1.001766,0.575643,-0.124811,-0.728560,-0.939931,-0.691202,-0.149909,0.402049,0.724521,0.717043,0.425661,-0.010792,-0.424666,-0.667363,-0.645486,-0.354160,0.103753,0.538987,0.749680,0.621413,0.197474,-0.329300,-0.707652,-0.755071,-0.450707,0.056514,-0.200652,-0.641435,-0.819110,-0.622314,-0.110862,0.487073,0.875137,0.844385,0.395554,-0.251547,-0.773924,-0.918548,-0.629499,-0.060842,0.517217,0.852146,0.811245,0.419066,-0.162506,-0.691935,-0.932241,-0.750103,-0.196348,0.485574,0.957606,0.962044,-0.252241,-0.843608,-0.993500,-0.646132,-0.009918,0.578805,0.847395,0.713998,0.290713,-0.208769,-0.580685,-0.701548,-0.546677,-0.180241,0.263800,0.613498,0.714874,0.503041,0.051178,-0.443770,-0.747298,-0.705973,-0.331805,0.198708,0.632772,0.768228},
  {-0.024443,0.643933,0.967197,0.812382,0.284207,-0.354385,-0.813380,-0.893506,-0.558931,0.045313,0.641042,0.932641,0.757287,0.190971,-0.470763,-0.870654,-0.799661,-0.321525,0.275350,0.664981,0.678051,0.374505,-0.035892,-0.345062,-0.455047,-0.385322,0.004188,0.207429,0.351364,0.380998,0.262799,0.023294,-0.243304,-0.415826,-0.410984,-0.228366,0.051631,0.309909,0.442023,0.396752,0.190218,-0.101794,-0.368259,-0.499760,-0.429872,-0.167230,0.196904,0.513896,0.632314,0.466123,0.050367,-0.447362,1.016598,0.763490,0.148266,-0.508196,-0.896223,-0.855781,-0.424785,0.195661,0.726765,0.921534,0.673804,0.085770,-0.556718,-0.918201,-0.800512,-0.268652,0.378377,0.785909,0.756581,0.354915,-0.160271,-0.514367,-0.573972,-0.384286,-0.090777,0.170523,0.375664,0.309642,0.142763,-0.089023,-0.308169,-0.417182,-0.352332,-0.129286,0.156750,0.378559,0.440237,0.318646,0.066355,-0.215737,-0.417779,-0.458442,-0.313177,-0.027130,0.294111,0.518274,0.536866,0.314989,-0.080121,-0.488940,-0.714978,-0.614706},
  {-1.216036,-1.188518,-0.636376,0.155424,0.830324,1.116706,0.923123,0.352691,-0.350116,-0.895154,-1.056791,-0.765147,-0.141595,0.545387,0.994291,1.006288,0.577016,-0.101850,-0.731521,-1.040523,-0.900863,-0.376686,0.308984,0.869001,1.067742,0.814492,-0.522760,-1.052178,-1.140758,-0.718125,0.060902,0.861480,1.306042,1.153341,0.434617,-0.533079,-1.283137,-1.430367,-0.878311,0.115776,1.064043,1.497805,1.207744,0.344429,-0.668415,-1.350998,-1.395877,-0.798437,0.157417,1.035334,1.438311,1.179934,-0.453638,0.414157,1.040497,1.172605,0.795296,0.104562,-0.596557,-1.023404,-1.012465,-0.576479,0.101082,0.734646,1.051419,0.910317,0.370006,-0.332259,-0.886355,-1.049955,-0.756011,-0.137609,0.536262,0.979201,1.006171,0.605490,-0.059370,-0.714677,-0.995237,-0.464952,0.301547,0.976909,1.245677,0.951015,0.188234,-0.711458,-1.319091,-1.315724,-0.667652,0.332568,1.197722,1.491845,1.059792,0.111767,-0.885542,-1.449359,-1.319995,-0.575852,0.421793,1.209986,1.435365,1.003162,0.111233,-0.836581},
  {0.158220,-0.020299,-0.200956,-0.287566,-0.219908,-0.023656,0.190903,0.293768,0.222296,0.024974,-0.172683,-0.253971,-0.184161,-0.021621,0.131278,0.194153,0.147150,0.028307,-0.094888,-0.158548,-0.129422,-0.021987,0.102454,0.164016,0.113874,-0.024673,-0.190567,-0.080090,0.105585,0.237508,0.213760,0.035965,-0.185751,-0.304476,-0.234499,-0.008775,0.239994,0.359499,0.268969,0.009211,-0.275509,-0.415591,-0.315093,-0.016873,0.310167,0.465527,0.343196,0.008062,-0.336288,-0.476027,-0.327593,0.008569,-0.215663,-0.272438,-0.195654,-0.008956,0.194493,0.296172,0.228431,0.027253,-0.184817,-0.278993,-0.205627,-0.021974,0.153953,0.223621,0.163427,0.024485,-0.109663,-0.171255,-0.136351,-0.028954,0.091712,0.156786,0.123088,0.004308,-0.126383,-0.176578,0.062753,0.198737,0.203221,0.057667,-0.148037,-0.273116,-0.223389,-0.018808,0.216369,0.332573,0.249388,0.006238,-0.258733,-0.387080,-0.291997,-0.014063,0.292555,0.443073,0.333631,0.014964,-0.326163,-0.477972,-0.341124,0.001338,0.335465,0.457493},
  {0.079181,-0.135823,-0.292681,-0.319303,-0.201655,0.004320,0.199724,0.295753,0.259385,0.122461,-0.047371,-0.187136,-0.259829,-0.249487,-0.150387,0.026323,0.231183,0.371031,0.347692,0.129527,-0.197842,-0.456584,-0.480311,-0.231274,0.158119,0.460744,0.267359,-0.086784,-0.354508,-0.408685,-0.264417,-0.037374,0.152245,0.248497,0.258128,0.203547,0.090082,-0.078716,-0.261036,-0.366498,-0.304651,-0.062561,0.255448,0.471824,0.444747,0.167784,-0.213717,-0.486130,-0.497023,-0.245436,0.123247,0.408873,-0.318771,-0.298722,-0.147839,0.069332,0.253458,0.318787,0.238821,0.059356,-0.130802,-0.250855,-0.265260,-0.185803,-0.047965,0.109937,0.247188,0.312243,0.253036,0.055921,-0.214469,-0.421104,-0.425904,-0.188954,0.180046,0.471450,0.505896,0.256514,-0.421696,-0.466852,-0.268300,0.031575,0.262600,0.333293,0.260118,0.117428,-0.031682,-0.161676,-0.258973,-0.289013,-0.204528,0.003415,0.261139,0.429204,0.385585,0.119267,-0.240446,-0.491130,-0.481577,-0.209480,0.174399,0.457845,0.492975,0.276133},
  {0.895662,0.312415,-0.417270,-0.951049,-1.035359,-0.634347,0.051311,0.690035,0.989386,0.834074,0.322145,-0.303655,-0.776014,-0.910442,-0.663480,-0.138230,0.453295,0.863433,0.905526,0.542618,-0.078525,-0.680620,-0.982683,-0.838197,-0.309354,0.362812,0.994731,0.671458,0.044052,-0.612951,-1.005673,-0.948687,-0.454500,0.260173,0.865976,1.075692,0.786584,0.133406,-0.578100,-1.020640,-0.998012,-0.527351,0.178231,0.807152,1.080826,0.870112,0.255993,-0.493156,-1.031032,-1.093552,-0.636025,0.130808,-0.590159,-1.026431,-0.987490,-0.487528,0.236719,0.838654,1.035801,0.750000,0.136254,-0.509200,-0.900446,-0.887342,-0.500536,0.083828,0.624315,0.902989,0.801610,0.350512,-0.269638,-0.789736,-0.967450,-0.706791,-0.115859,0.536960,0.950425,0.934462,-0.165692,-0.758679,-1.018651,-0.825054,-0.254619,0.444440,0.954970,1.034198,0.634069,-0.065934,-0.739366,-1.070702,-0.908339,-0.333052,0.388095,0.930389,1.055519,0.709201,0.040421,-0.658942,-1.073177,-1.001002,-0.457452,0.315689,0.952752,1.141714},
  {-0.428272,0.613416,1.319095,1.417891,0.911311,0.043532,-0.811802,-1.301324,-1.228390,-0.630320,0.234896,0.993680,1.315847,1.060349,0.340418,-0.525201,-1.154809,-1.274483,-0.837820,-0.041230,0.767915,1.243998,1.187497,0.622568,-0.216887,-0.981055,-1.125827,-0.399199,0.541489,1.278625,1.456693,0.960560,-0.005619,-0.996795,-1.538230,-1.363882,-0.552327,0.514256,1.341676,1.558804,1.077756,0.115815,-0.909412,-1.553251,-1.520417,-0.791465,0.344606,1.382945,1.813707,1.377233,0.233078,-1.075925,1.525454,1.404820,0.684958,-0.282698,-1.078383,-1.383927,-1.095603,-0.351775,0.527760,1.170372,1.303040,0.869255,0.057684,-0.776246,-1.265890,-1.197017,-0.603581,0.249362,0.986661,1.290140,1.034755,0.335697,-0.507519,-1.139007,-1.290915,-0.889963,0.778535,1.337764,1.318354,0.694079,-0.280502,-1.164511,-1.531936,-1.186634,-0.274405,0.778355,1.473816,1.488035,0.822036,-0.212446,-1.149579,-1.579009,-1.313106,-0.456070,0.635846,1.486497,1.690599,1.104181,-0.050689,-1.245495,-1.880128,-1.596298},
  {1.196726,1.251135,0.624946,-0.363637,-1.170904,-1.349263,-0.813671,0.119933,0.939499,1.238788,0.922156,0.207012,-0.537125,-0.985997,-0.984766,-0.570287,0.072841,0.681661,0.998496,0.868918,0.327402,-0.386544,-0.923657,-1.004286,-0.581874,0.119168,0.935674,0.671994,0.117322,-0.420700,-0.690861,-0.619342,-0.308390,0.060326,0.336649,0.456764,0.427939,0.282596,0.052479,-0.219117,-0.453369,-0.542850,-0.405615,-0.055245,0.371295,0.665588,0.660165,0.332176,-0.172266,-0.612337,-0.778803,-0.595558,0.490776,-0.457385,-1.208174,-1.327759,-0.731826,0.252378,1.080869,1.317302,0.875312,0.034399,-0.754104,-1.124309,-0.958229,-0.389666,0.304399,0.835369,0.999756,0.734705,0.141916,-0.531008,-0.974976,-0.961303,-0.475364,0.249250,0.841110,0.995113,0.003438,-0.584885,-0.831579,-0.661509,-0.220066,0.242803,0.522728,0.549687,0.378752,0.117644,-0.141912,-0.344992,-0.453421,-0.426725,-0.237779,0.084109,0.426403,0.624385,0.548423,0.194921,-0.286864,-0.662196,-0.737174,-0.465753,0.027704,0.517464},
  {-0.141909,0.593226,1.068599,1.040708,0.510157,-0.270751,-0.923087,-1.133087,-0.807648,-0.112991,0.617266,1.048643,0.998702,0.506555,-0.200241,-0.812302,-1.067040,-0.852085,-0.251932,0.478240,1.010543,1.087097,0.650232,-0.109638,-0.830386,-1.155171,-0.245087,0.530440,1.028708,1.027811,0.559184,-0.133066,-0.729491,-0.983671,-0.811874,-0.303696,0.326821,0.821250,0.968591,0.690736,0.091061,-0.569855,-0.982371,-0.939691,-0.452462,0.246770,0.820489,1.000293,0.718468,0.127141,-0.493511,-0.875180,1.074027,0.929886,0.332006,-0.442549,-1.017793,-1.109184,-0.670405,0.083488,0.787839,1.112230,0.917951,0.312017,-0.418447,-0.946588,-1.048537,-0.689177,-0.026987,0.653434,1.054305,0.987299,0.463181,-0.294680,-0.935863,-1.144708,-0.804513,-0.071543,1.116179,0.994513,0.408370,-0.341237,-0.897246,-1.022795,-0.694911,-0.085501,0.535562,0.915088,0.905097,0.509462,-0.114581,-0.705412,-0.996135,-0.836842,-0.282011,0.416326,0.923960,0.994560,0.598685,-0.064113,-0.674923,-0.958972,-0.810428,-0.320709},
  {-0.636589,-0.233696,0.293563,0.679778,0.723117,0.397062,-0.126943,-0.569839,-0.702829,-0.476772,-0.039501,0.367203,0.555089,0.479703,0.225367,-0.077907,-0.326237,-0.456672,-0.428165,-0.223259,0.112944,0.443888,0.585141,0.421031,0.010901,-0.416790,-0.442540,-0.050990,0.313448,0.442545,0.313285,0.071675,-0.106997,-0.153771,-0.127033,-0.119327,-0.150588,-0.150100,-0.038705,0.172120,0.361150,0.380773,0.174616,-0.166621,-0.454576,-0.519759,-0.313594,0.065569,0.428285,0.591910,0.469035,0.109242,0.375939,0.707706,0.690306,0.323918,-0.209768,-0.634923,-0.728858,-0.448388,0.044716,0.481110,0.643751,0.485146,0.128942,-0.230396,-0.445225,-0.468024,-0.327132,-0.078316,0.211531,0.448997,0.518321,0.341630,-0.038147,-0.435903,-0.616606,-0.454626,0.378001,0.544780,0.391569,0.059513,-0.221705,-0.307482,-0.221085,-0.091828,-0.021313,-0.003252,0.039361,0.148857,0.267583,0.277386,0.108573,-0.180314,-0.424219,-0.460501,-0.241827,0.127968,0.454315,0.562573,0.390288,0.015767,-0.382149,-0.608617},
  {-0.361249,1.115919,2.125295,2.069250,0.914859,-0.747673,-2.031200,-2.260725,-1.345387,0.202829,1.583489,2.140780,1.668173,0.453840,-0.905593,-1.796598,-1.849152,-1.073944,0.159907,1.291575,1.815696,1.508022,0.525966,-0.668131,-1.526740,-1.672388,-0.005023,1.016604,1.549503,1.381859,0.621649,-0.370442,-1.157109,-1.420474,-1.085346,-0.322743,0.546590,1.185691,1.353766,0.975457,0.170484,-0.760940,-1.420741,-1.472851,-0.828329,0.255979,1.263384,1.678122,1.277932,0.268551,-0.835315,-1.504446,2.033899,1.840183,0.654702,-0.953612,-2.125958,-2.208628,-1.143926,0.495885,1.845931,2.234230,1.520884,0.119654,-1.262926,-1.991829,-1.780754,-0.778856,0.532026,1.561591,1.863380,1.321334,0.196549,-0.991450,-1.702791,-1.626179,-0.818526,0.331650,1.646316,1.255475,0.327404,-0.704703,-1.384867,-1.437612,-0.876662,0.024541,0.873805,1.333592,1.244555,0.660417,-0.191728,-0.989825,-1.412988,-1.252176,-0.517664,0.512917,1.372963,1.619739,1.085206,0.004676,-1.085452,-1.639568,-1.404338,-0.537849},
  {-0.076761,0.387953,0.629956,0.563167,0.262179,-0.107157,-0.387445,-0.493260,-0.416169,-0.197562,0.092932,0.363185,0.509276,0.451812,0.187129,-0.186252,-0.499364,-0.595660,-0.417101,-0.039269,0.365398,0.612192,0.588858,0.301671,-0.129895,-0.521215,-0.558759,-0.152133,0.351781,0.716236,0.752780,0.423538,-0.126261,-0.631933,-0.841066,-0.643898,-0.131860,0.446962,0.811403,0.785990,0.385706,-0.193689,-0.673274,-0.827353,-0.590927,-0.085836,0.444704,0.756375,0.716485,0.356246,-0.154345,-0.587770,0.709859,0.565343,0.172587,-0.254586,-0.519857,-0.537546,-0.344347,-0.046695,0.242043,0.434320,0.473025,0.335562,0.052002,-0.280627,-0.519415,-0.539706,-0.309249,0.079492,0.447539,0.619163,0.510413,0.167804,-0.257321,-0.578231,-0.651268,-0.434489,0.444748,0.718054,0.666988,0.292129,-0.244785,-0.687698,-0.811604,-0.541970,-0.000669,0.550512,0.840692,0.726224,0.262136,-0.326191,-0.754904,-0.820431,-0.496889,0.054778,0.568891,0.805747,0.664609,0.224097,-0.304704,-0.682102,-0.746619,-0.478278},
  {0.741009,-0.530879,-1.526966,-1.748876,-1.105233,0.053486,1.135786,1.623617,1.323716,0.431302,-0.602081,-1.302703,-1.385305,-0.853768,0.027795,0.861581,1.285368,1.124082,0.465836,-0.376531,-1.012103,-1.161262,-0.788231,-0.102575,0.566593,0.941877,0.542573,0.000189,-0.523832,-0.862945,-0.896022,-0.577342,0.017667,0.672720,1.090248,1.032661,0.471984,-0.357218,-1.057011,-1.272369,-0.883818,-0.072042,0.778317,1.272847,1.191085,0.574535,-0.304850,-1.065356,-1.371395,-1.070809,-0.267873,0.701128,-1.649816,-1.724663,-0.939656,0.296656,1.353821,1.714227,1.233862,0.191792,-0.881326,-1.483420,-1.374265,-0.655626,0.312332,1.091947,1.356158,1.013785,0.236062,-0.620734,-1.171089,-1.175142,-0.651700,0.134127,0.809214,1.081848,0.874366,0.329770,-0.751349,-0.907097,-0.734230,-0.295956,0.274429,0.784005,1.017978,0.827603,0.234180,-0.530220,-1.104802,-1.182610,-0.689746,0.155266,0.946684,1.301420,1.051731,0.318353,-0.560524,-1.192017,-1.298866,-0.829381,0.024321,0.899519,1.404869,1.287196},
  {-1.464647,-1.080956,-0.214244,0.762709,1.420616,1.452165,0.815858,-0.222270,-1.188864,-1.619193,-1.289813,-0.342466,0.776219,1.533028,1.569600,0.872425,-0.227856,-1.217463,-1.638517,-1.297694,-0.354850,0.748245,1.492579,1.529940,0.853441,-0.201112,-1.505387,-1.192312,-0.369897,0.574041,1.235025,1.355652,0.905318,0.073488,-0.801298,-1.348723,-1.311525,-0.673505,0.299589,1.158291,1.483553,1.108174,0.212843,-0.766989,-1.369307,-1.333776,-0.707469,0.207388,1.008874,1.365308,1.135142,0.412564,0.098157,0.999977,1.466271,1.286911,0.524408,-0.499786,-1.328150,-1.565780,-1.074443,-0.060907,1.003703,1.608030,1.455779,0.615560,-0.513789,-1.399790,-1.630568,-1.103532,-0.066981,0.996798,1.592864,1.443238,0.620916,-0.480673,-1.337114,-1.551146,-0.084497,0.870339,1.396926,1.295445,0.647060,-0.253520,-1.032099,-1.373713,-1.131554,-0.388213,0.554244,1.278021,1.432069,0.916144,-0.042800,-0.987497,-1.461863,-1.246924,-0.464427,0.503065,1.214144,1.372135,0.934559,0.103955,-0.767774,-1.315000},
  {0.999250,2.008473,2.036714,1.095589,-0.332054,-1.551688,-2.005949,-1.528058,-0.385133,0.880975,1.712394,1.768541,1.048989,-0.121382,-1.228644,-1.781852,-1.527956,-0.578060,0.628880,1.528310,1.706531,1.103989,0.031945,-1.001204,-1.546139,-1.407822,0.273903,1.105566,1.483438,1.258341,0.501748,-0.499428,-1.328050,-1.601493,-1.158183,-0.164782,0.935979,1.629719,1.583935,0.812884,-0.332181,-1.333629,-1.744858,-1.382326,-0.397688,0.787194,1.652231,1.796661,1.121880,-0.101235,-1.328158,-1.977943,1.942953,0.818343,-0.677032,-1.812327,-2.057335,-1.333861,-0.025890,1.236488,1.888061,1.674259,0.731595,-0.502814,-1.489215,-1.806211,-1.319954,-0.244383,0.939482,1.690292,1.659565,0.867224,-0.302953,-1.296573,-1.667088,-1.284528,-0.367755,0.654415,1.474091,0.995818,0.118963,-0.815719,-1.435176,-1.464982,-0.853731,0.169255,1.161267,1.657834,1.403632,0.494604,-0.656704,-1.519116,-1.697321,-1.111811,-0.024663,1.084995,1.728931,1.614154,0.769205,-0.454686,-1.517524,-1.920264,-1.440375,-0.260501},
  {0.387739,-0.331590,-0.853263,-0.863521,-0.365519,0.337333,0.834867,0.849636,0.383983,-0.293750,-0.802428,-0.856032,-0.421298,0.257654,0.789738,0.861090,0.426563,-0.254534,-0.772883,-0.822604,-0.389483,0.249793,0.711416,0.742222,0.356572,-0.199855,-0.672782,-0.371528,0.117557,0.533849,0.656698,0.414888,-0.066934,-0.519592,-0.672852,-0.422030,0.090073,0.547858,0.661951,0.361901,-0.155341,-0.558786,-0.603293,-0.280907,0.192881,0.530913,0.549060,0.255600,-0.176385,-0.512065,-0.570347,-0.307847,-0.838943,-0.868578,-0.372806,0.343269,0.849634,0.855041,0.369566,-0.318290,-0.816991,-0.850381,-0.403657,0.271680,0.793896,0.861738,0.430161,-0.253006,-0.784852,-0.848730,-0.411305,0.255833,0.748868,0.785034,0.368745,-0.231400,-0.663635,-0.702327,0.159253,0.566622,0.657759,0.393468,-0.084173,-0.518389,-0.664419,-0.426646,0.069500,0.532140,0.673817,0.399164,-0.121888,-0.558532,-0.636793,-0.318859,0.181053,0.548047,0.570536,0.257882,-0.189850,-0.515767,-0.547608,-0.274127,0.160762,0.527188},
  {0.539535,0.774707,0.675184,0.287554,-0.214166,-0.614324,-0.754494,-0.590862,-0.192963,0.293521,0.690568,0.832740,0.624624,0.104330,-0.529409,-0.976137,-0.979513,-0.486304,0.289850,0.961101,1.172853,0.802699,0.029978,-0.761643,-1.185161,-1.040786,0.422816,1.048672,1.179460,0.751676,-0.032409,-0.796357,-1.172257,-0.985320,-0.340145,0.440525,0.987193,1.064769,0.667477,-0.005333,-0.655927,-1.013273,-0.930253,-0.435517,0.268009,0.869472,1.079010,0.775277,0.089601,-0.641795,-1.050538,-0.938072,0.572054,0.114666,-0.388245,-0.717529,-0.735490,-0.446187,0.018719,0.469835,0.737325,0.720808,0.411597,-0.097808,-0.620066,-0.920528,-0.818171,-0.301678,0.419581,0.991560,1.099296,0.653862,-0.139541,-0.883268,-1.200255,-0.932161,-0.213837,0.604429,1.125095,0.586774,-0.228688,-0.935913,-1.197154,-0.886993,-0.158607,0.630751,1.101768,1.043973,0.510241,-0.229553,-0.835031,-1.052594,-0.809179,-0.220935,0.462728,0.951493,1.023143,0.624297,-0.081827,-0.766849,-1.089800,-0.880692,-0.243937,0.492949},
  {-1.243300,-0.229468,0.886738,1.586588,1.552985,0.810043,-0.297347,-1.265229,-1.656806,-1.295240,-0.342252,0.771587,1.537816,1.601147,0.926358,-0.179540,-1.205575,-1.674178,-1.366155,-0.425402,0.707839,1.504412,1.596071,0.948500,-0.125583,-1.119433,-1.302528,-0.450149,0.572558,1.302564,1.434149,0.940252,0.060233,-0.821099,-1.337526,-1.281816,-0.679404,0.221763,1.042535,1.421839,1.174576,0.389341,-0.592228,-1.321960,-1.455812,-0.923225,0.034908,0.980384,1.483978,1.320555,0.564202,-0.450544,1.130212,1.663374,1.422130,0.525976,-0.605075,-1.451597,-1.632138,-1.070225,-0.022999,1.035586,1.625365,1.474927,0.647328,-0.482809,-1.396318,-1.668419,-1.168940,-0.127133,0.972896,1.618640,1.510525,0.703119,-0.421498,-1.336004,-1.618581,-1.151055,0.862047,1.469391,1.397596,0.710140,-0.261190,-1.082997,-1.413057,-1.133101,-0.378466,0.529471,1.212233,1.379961,0.949023,0.088570,-0.833975,-1.403166,-1.345793,-0.670287,0.323460,1.179404,1.501631,1.141732,0.264561,-0.733512,-1.406662,-1.455010},
  {-0.201752,-0.270559,-0.199692,-0.065025,0.053842,0.121938,0.144290,0.131518,0.081212,-0.006495,-0.104360,-0.161606,-0.140815,-0.053038,0.047244,0.106176,0.111325,0.089118,0.064348,0.028658,-0.043528,-0.146052,-0.215974,-0.172901,0.001897,0.221182,0.250634,-0.000203,-0.258383,-0.358386,-0.245267,-0.006472,0.202952,0.273814,0.203344,0.066818,-0.057435,-0.137413,-0.177591,-0.178728,-0.120954,0.008738,0.175667,0.293219,0.272641,0.092758,-0.167406,-0.364543,-0.375925,-0.178123,0.131394,0.384377,-0.230950,-0.034156,0.130409,0.195567,0.169700,0.099147,0.019717,-0.057256,-0.123595,-0.154882,-0.122979,-0.029276,0.080942,0.145971,0.135212,0.070712,0.001004,-0.045372,-0.077614,-0.113597,-0.138731,-0.105150,0.016910,0.184039,0.285513,0.222950,-0.248822,-0.362297,-0.256412,0.001282,0.243752,0.326879,0.224903,0.028580,-0.138659,-0.207737,-0.186673,-0.118789,-0.032012,0.069782,0.175149,0.239219,0.202502,0.044961,-0.174407,-0.335718,-0.330205,-0.136746,0.152827,0.380117,0.410986,0.216211},
  {-0.508890,-0.056012,0.385420,0.637005,0.619817,0.362140,-0.030287,-0.412520,-0.638407,-0.606004,-0.307412,0.145396,0.552689,0.718555,0.555565,0.136370,-0.342994,-0.664586,-0.692132,-0.422629,0.026448,0.471321,0.728860,0.680897,0.326057,-0.200944,-0.845977,-0.628052,-0.100189,0.490996,0.860988,0.831691,0.416322,-0.194426,-0.725679,-0.938587,-0.728381,-0.171149,0.495275,0.960414,0.980957,0.514624,-0.230719,-0.883122,-1.099734,-0.760548,-0.041696,0.681988,1.045946,0.888352,0.317310,-0.369303,0.541890,0.715617,0.576203,0.212755,-0.211381,-0.533246,-0.640795,-0.496317,-0.146214,0.281717,0.610139,0.682281,0.445311,-0.005764,-0.463603,-0.712087,-0.637329,-0.280049,0.194698,0.581658,0.722199,0.558849,0.151075,-0.342043,-0.711591,-0.779538,0.052754,0.595245,0.873895,0.742917,0.256936,-0.355912,-0.809516,-0.896132,-0.575381,0.014950,0.618002,0.960302,0.866897,0.351437,-0.364681,-0.935993,-1.060955,-0.652429,0.095204,0.798643,1.094199,0.838485,0.179810,-0.536425,-0.960718,-0.913112},
  {-0.302885,-0.485815,-0.385738,-0.079627,0.241735,0.408909,0.367624,0.176385,-0.061317,-0.258570,-0.360255,-0.331408,-0.161222,0.108108,0.365531,0.470234,0.338315,0.014689,-0.334902,-0.518348,-0.434858,-0.133334,0.224414,0.461454,0.475688,0.274504,-0.347085,-0.498663,-0.424067,-0.139729,0.233393,0.510416,0.534152,0.272556,-0.144914,-0.489558,-0.565708,-0.330732,0.076926,0.421863,0.514196,0.319914,-0.027757,-0.318275,-0.394825,-0.243956,0.009821,0.196712,0.217363,0.102107,-0.026784,-0.059925,-0.383517,-0.060605,0.289705,0.461405,0.377868,0.118034,-0.162744,-0.337816,-0.360955,-0.250372,-0.050816,0.180133,0.363640,0.408397,0.259314,-0.043929,-0.358364,-0.508313,-0.396115,-0.072232,0.290467,0.501041,0.459481,0.200829,-0.140463,-0.407354,-0.350887,-0.050481,0.287631,0.506998,0.487195,0.215088,-0.185981,-0.505524,-0.560837,-0.310885,0.108865,0.461399,0.549479,0.333427,-0.049385,-0.373236,-0.462108,-0.290264,0.014083,0.259142,0.313099,0.180800,-0.014811,-0.130598,-0.108799,-0.011604},
  {-0.023215,-0.078882,-0.075393,0.019688,0.155133,0.230244,0.171053,-0.010359,-0.216638,-0.324171,-0.259729,-0.046490,0.206403,0.362965,0.334890,0.131253,-0.144067,-0.347559,-0.374428,-0.215229,0.042756,0.268612,0.359814,0.288351,0.099293,-0.124380,-0.361485,-0.277729,-0.058795,0.222860,0.439489,0.460047,0.233216,-0.154018,-0.499262,-0.594742,-0.361057,0.088151,0.503270,0.646639,0.436147,-0.007561,-0.436382,-0.620097,-0.471911,-0.085974,0.324210,0.544519,0.471224,0.159643,-0.211495,-0.440729,-0.024430,0.007969,0.096528,0.161243,0.124238,-0.021126,-0.195555,-0.284496,-0.216263,-0.012787,0.219419,0.350121,0.300129,0.087339,-0.180511,-0.362487,-0.360701,-0.174618,0.098185,0.316635,0.374134,0.252728,0.022949,-0.203763,-0.333571,-0.324082,0.034868,0.260965,0.400628,0.371540,0.150092,-0.187132,-0.474075,-0.536364,-0.304118,0.121899,0.510114,0.631712,0.404457,-0.050368,-0.477970,-0.641519,-0.458218,-0.039056,0.383138,0.586601,0.476901,0.128038,-0.265489,-0.495798,-0.451903,-0.176124},
  {-0.640887,-1.507881,-1.612492,-0.947403,0.124877,1.067083,1.438640,1.106384,0.289847,-0.576032,-1.079362,-1.035888,-0.550202,0.084906,0.571497,0.752280,0.641723,0.354138,0.007542,-0.320681,-0.572856,-0.675360,-0.548459,-0.170992,0.354214,0.805528,0.643599,0.004891,-0.693083,-1.115583,-1.042318,-0.478839,0.340986,1.055539,1.330614,1.006905,0.184296,-0.795438,-1.477095,-1.496458,-0.776253,0.392556,1.453804,1.850499,1.325632,0.090985,-1.249189,-1.999699,-1.746461,-0.592334,0.882023,1.918800,-1.627066,-0.791295,0.375037,1.297161,1.549685,1.054440,0.099415,-0.824582,-1.280763,-1.100105,-0.441031,0.327440,0.840139,0.917578,0.616794,0.144861,-0.284511,-0.549615,-0.626561,-0.534131,-0.290083,0.076903,0.481777,0.768498,0.769296,0.413692,-0.781000,-1.058363,-0.854734,-0.230376,0.544187,1.113542,1.202245,0.741386,-0.093835,-0.947173,-1.423511,-1.262873,-0.479108,0.607968,1.487981,1.695696,1.062346,-0.156977,-1.373792,-1.953364,-1.556284,-0.343435,1.083429,1.987828,1.890252,0.829614},
  {-1.137675,-1.430008,-0.984247,-0.035225,0.920884,1.393839,1.154890,0.346288,-0.605902,-1.221279,-1.211248,-0.613866,0.245547,0.935898,1.139883,0.797334,0.109650,-0.579736,-0.956344,-0.873074,-0.400804,0.219599,0.695701,0.819623,0.561655,0.075918,-0.618030,-0.549176,-0.271118,0.049722,0.279892,0.377722,0.370172,0.287458,0.127431,-0.114562,-0.385636,-0.558584,-0.497634,-0.167462,0.304949,0.679440,0.741230,0.435024,-0.097671,-0.598736,-0.831701,-0.692035,-0.239936,0.337489,0.799825,0.936941,-0.864161,0.119344,1.044884,1.430190,1.082253,0.192854,-0.772276,-1.323357,-1.198769,-0.488568,0.428274,1.090693,1.191277,0.717827,-0.063952,-0.762948,-1.060101,-0.849913,-0.267432,0.395470,0.833443,0.863968,0.501251,-0.060462,-0.546332,-0.737764,-0.186502,0.221114,0.463190,0.479938,0.331559,0.122158,-0.078594,-0.252497,-0.388377,-0.436624,-0.323893,-0.027358,0.359228,0.642435,0.638618,0.303273,-0.218579,-0.664804,-0.804570,-0.564249,-0.056873,0.486510,0.828104,0.817497,0.442300,-0.163405},
  {-1.163830,-1.365261,-0.827807,0.103444,0.888926,1.126634,0.767143,0.090064,-0.509019,-0.757532,-0.621441,-0.258726,0.117133,0.357250,0.419567,0.341002,0.185536,0.007685,-0.156901,-0.282930,-0.343925,-0.309968,-0.161486,0.084531,0.354056,0.526564,0.204314,-0.230577,-0.618561,-0.750747,-0.524234,-0.012476,0.555592,0.900823,0.831399,0.345458,-0.351584,-0.929225,-1.085194,-0.703987,0.061276,0.841644,1.231520,1.007550,0.262416,-0.632495,-1.221659,-1.206785,-0.598147,0.301208,1.055626,1.307235,-0.807961,0.201567,1.043199,1.268333,0.811539,-0.006075,-0.707288,-0.951925,-0.702060,-0.180783,0.307631,0.555979,0.527416,0.314942,0.050220,-0.168069,-0.296342,-0.331009,-0.283896,-0.167748,0.002738,0.198905,0.366636,0.431125,0.328157,0.052561,-0.590748,-0.631332,-0.363498,0.122851,0.606843,0.841231,0.681720,0.170921,-0.468346,-0.929768,-0.968037,-0.526707,0.213306,0.899968,1.175465,0.866985,0.098483,-0.752914,-1.247701,-1.121044,-0.429128,0.480743,1.155445,1.267396,0.768181,-0.101563},
  {-0.941158,-1.187172,-0.882140,-0.179452,0.581719,1.040560,0.993637,0.493303,-0.190792,-0.724513,-0.884652,-0.654665,-0.195395,0.271199,0.578299,0.661850,0.535793,0.246065,-0.144405,-0.535606,-0.780108,-0.728789,-0.327245,0.303119,0.878305,1.082862,0.008718,-0.797969,-1.244959,-1.081577,-0.370850,0.538485,1.194741,1.275862,0.746367,-0.135809,-0.953130,-1.327150,-1.087495,-0.342167,0.572537,1.238155,1.338471,0.808055,-0.122935,-1.020181,-1.445077,-1.174174,-0.324556,0.691420,1.370063,1.375337,-0.751955,0.023942,0.767777,1.135474,0.964653,0.353964,-0.387906,-0.902705,-0.966579,-0.593897,-0.005229,0.511312,0.752614,0.676539,0.374291,-0.014675,-0.371785,-0.613725,-0.673288,-0.498093,-0.092259,0.430951,0.850115,0.926809,0.550851,-0.155422,-1.190220,-0.933455,-0.185560,0.689218,1.245960,1.196313,0.559668,-0.351441,-1.095175,-1.319456,-0.924607,-0.098966,0.776059,1.299644,1.227833,0.582360,-0.351746,-1.144323,-1.412757,-1.008448,-0.105119,0.868195,1.431441,1.297999,0.528734,-0.493740},
  {0.781840,1.102937,0.877260,0.209384,-0.572789,-1.072994,-1.026765,-0.448098,0.363532,0.975529,1.060400,0.583722,-0.175932,-0.793302,-0.947543,-0.600211,0.007730,0.525209,0.704780,0.522399,0.144194,-0.209484,-0.394965,-0.391442,-0.260842,-0.079798,0.236787,0.302116,0.264594,0.125231,-0.067158,-0.231859,-0.299619,-0.250444,-0.116955,0.044806,0.187863,0.283032,0.305404,0.225858,0.030784,-0.239286,-0.471977,-0.522285,-0.302393,0.133920,0.582229,0.782708,0.575755,0.021211,-0.605776,-0.956241,0.775493,0.067913,-0.679851,-1.095500,-0.963340,-0.338844,0.466108,1.033798,1.060874,0.530899,-0.266800,-0.895814,-1.022506,-0.606063,0.089926,0.668648,0.839316,0.570522,0.070798,-0.369237,-0.553200,-0.461218,-0.209155,0.056270,0.240274,0.316115,0.189183,0.025245,-0.153855,-0.282194,-0.301748,-0.200232,-0.023340,0.151676,0.260195,0.277346,0.211938,0.083365,-0.088606,-0.269686,-0.393537,-0.374837,-0.163350,0.193533,0.536261,0.660548,0.441713,-0.061865,-0.606321,-0.882843,-0.699720,-0.113854},
  {-1.173082,-1.036904,-0.416826,0.392657,1.006183,1.134359,0.725758,-0.010019,-0.711615,-1.049847,-0.888000,-0.335452,0.326143,0.793909,0.885478,0.602077,0.097601,-0.409956,-0.730101,-0.757952,-0.493407,-0.033443,0.454172,0.777981,0.790795,0.459843,-0.646745,-0.932411,-0.803863,-0.297247,0.369407,0.892123,1.022183,0.684497,0.017609,-0.682896,-1.093499,-1.009831,-0.447904,0.349449,1.012861,1.216586,0.841723,0.048503,-0.788706,-1.260637,-1.129008,-0.451034,0.445677,1.126464,1.265769,0.804539,-0.221197,0.581977,1.107253,1.107762,0.587275,-0.199738,-0.872937,-1.114974,-0.827094,-0.170233,0.527318,0.941329,0.907222,0.480799,-0.115172,-0.614070,-0.825195,-0.695574,-0.303475,0.190853,0.604764,0.786237,0.658532,0.253299,-0.283452,-0.731589,-0.645423,-0.097647,0.524861,0.935096,0.930522,0.495048,-0.186031,-0.806398,-1.076844,-0.858528,-0.232292,0.528111,1.071971,1.131295,0.654230,-0.154678,-0.917622,-1.260733,-1.002148,-0.252719,0.629748,1.215406,1.217750,0.636974,-0.242714,-0.997449},
  {0.314864,0.030607,-0.212709,-0.369395,-0.433126,-0.386169,-0.194984,0.132610,0.489234,0.687060,0.568172,0.130892,-0.432539,-0.829837,-0.836557,-0.426616,0.213286,0.781607,1.006378,0.765072,0.140349,-0.600782,-1.105449,-1.093508,-0.517515,0.370198,1.303062,0.805661,-0.121526,-0.979045,-1.312614,-0.969308,-0.162927,0.673778,1.136442,1.042309,0.481023,-0.264947,-0.860444,-1.052747,-0.765521,-0.130839,0.558698,0.976728,0.922724,0.430067,-0.248271,-0.775959,-0.911170,-0.620576,-0.072477,0.467785,-0.392567,-0.463601,-0.380596,-0.208302,0.011696,0.256162,0.471141,0.550671,0.392187,-0.003474,-0.479173,-0.782665,-0.716552,-0.273194,0.343874,0.827619,0.931554,0.591892,-0.047603,-0.702044,-1.064415,-0.936810,-0.334204,0.488068,1.125022,1.220013,-0.248741,-1.068812,-1.334399,-0.901795,-0.015002,0.845508,1.243137,1.014323,0.320483,-0.475237,-1.005071,-1.055672,-0.633673,0.058549,0.710474,1.028512,0.864601,0.294774,-0.405102,-0.892743,-0.937242,-0.537705,0.088019,0.631095,0.851704,0.680859},
  {0.852138,0.651965,0.157670,-0.401360,-0.767096,-0.773870,-0.427522,0.098932,0.554219,0.736154,0.586961,0.205146,-0.224301,-0.529340,-0.617851,-0.485530,-0.186561,0.192093,0.536126,0.711266,0.604986,0.200606,-0.366796,-0.835688,-0.940812,-0.573275,0.815495,1.127858,0.877075,0.169767,-0.643143,-1.148713,-1.087090,-0.485108,0.358276,1.023819,1.182797,0.761124,-0.025453,-0.783160,-1.141664,-0.939831,-0.298571,0.453719,0.956048,0.991641,0.576709,-0.071258,-0.652113,-0.920194,-0.779300,-0.307396,-0.002471,-0.540475,-0.825954,-0.730804,-0.303642,0.252336,0.676264,0.776572,0.523166,0.054620,-0.402499,-0.652635,-0.618033,-0.349857,0.025208,0.372812,0.589393,0.607857,0.400531,0.002476,-0.461157,-0.789327,-0.788378,-0.393240,0.254646,0.845287,0.735679,0.016480,-0.746846,-1.158333,-0.994989,-0.328324,0.510899,1.102547,1.150703,0.632059,-0.193838,-0.916257,-1.180454,-0.865362,-0.140367,0.627731,1.066169,0.982002,0.445192,-0.266065,-0.815837,-0.970232,-0.689446,-0.122796,0.472661,0.844171},
  {0.308787,-0.384390,-0.882237,-0.975222,-0.642503,-0.051331,0.530813,0.862389,0.826792,0.462386,-0.073772,-0.574880,-0.853151,-0.795566,-0.405303,0.181580,0.727046,0.980962,0.802054,0.244944,-0.447782,-0.956748,-1.042348,-0.659811,0.025029,0.716098,1.035468,0.486024,-0.325199,-1.048079,-1.327821,-0.979076,-0.113799,0.869769,1.467399,1.340394,0.521599,-0.580365,-1.395875,-1.505744,-0.865325,0.184674,1.113361,1.477731,1.131275,0.269593,-0.685995,-1.293746,-1.288749,-0.692300,0.206498,0.986990,-1.004083,-0.956235,-0.492372,0.166324,0.723233,0.943525,0.754578,0.262887,-0.311237,-0.736809,-0.859318,-0.642770,-0.169600,0.386468,0.809055,0.911347,0.619910,0.031080,-0.606633,-0.997249,-0.943990,-0.455565,0.252278,0.860867,1.097865,0.854573,-0.533153,-1.096177,-1.196043,-0.742485,0.105662,0.972437,1.421258,1.181866,0.324613,-0.739296,-1.459757,-1.448768,-0.702248,0.394096,1.278103,1.513822,1.009319,0.040157,-0.911984,-1.402801,-1.226429,-0.491117,0.447329,1.154188,1.312185,0.862529},
  {-1.148838,-0.977074,-0.385427,0.399339,1.040478,1.225919,0.833167,0.025104,-0.807247,-1.245582,-1.074780,-0.398792,0.428878,1.008452,1.099335,0.712231,0.060549,-0.569201,-0.941456,-0.938853,-0.574500,0.023915,0.643716,1.039214,1.016043,0.529717,-0.991727,-1.309868,-1.000029,-0.163437,0.803644,1.401004,1.299262,0.536673,-0.490722,-1.249475,-1.367047,-0.824771,0.063902,0.854583,1.209306,1.030031,0.445359,-0.290792,-0.902831,-1.163117,-0.947854,-0.298642,0.543075,1.194647,1.305777,0.768630,-0.109816,0.623179,1.108041,1.125000,0.631344,-0.181585,-0.941613,-1.268277,-0.982068,-0.218778,0.635623,1.157286,1.112518,0.564117,-0.193456,-0.808451,-1.040509,-0.838905,-0.320816,0.303501,0.807398,1.006904,0.809657,0.257639,-0.456622,-1.034031,-0.780972,0.043822,0.914157,1.383737,1.175935,0.359211,-0.662095,-1.357028,-1.363614,-0.692050,0.290591,1.079810,1.312854,0.936616,0.184407,-0.585911,-1.068248,-1.106143,-0.705526,-0.010792,0.724944,1.195464,1.153714,0.555326,-0.361202,-1.150914},
  {0.077038,-0.754421,-1.270696,-1.224328,-0.614084,0.301792,1.111887,1.435255,1.100453,0.235957,-0.774473,-1.458082,-1.471964,-0.776513,0.323387,1.304104,1.672085,1.220162,0.153553,-0.997945,-1.650575,-1.477397,-0.582415,0.563725,1.385989,1.507927,-0.038712,-0.915822,-1.334876,-1.158385,-0.502831,0.338779,1.018199,1.257366,0.951990,0.223660,-0.613178,-1.178726,-1.205675,-0.677659,0.154934,0.898866,1.214825,0.977970,0.320871,-0.448967,-0.998841,-1.109912,-0.752487,-0.083729,0.618815,1.063214,-1.274293,-1.054189,-0.347297,0.543040,1.216055,1.352794,0.867925,-0.038948,-0.962355,-1.470089,-1.304161,-0.511900,0.557770,1.401685,1.596882,1.016771,-0.082794,-1.168555,-1.691453,-1.376124,-0.377256,0.795143,1.547944,1.520908,0.765372,-0.308971,-1.443441,-1.055806,-0.236311,0.632954,1.190540,1.227372,0.746183,-0.048756,-0.824173,-1.242678,-1.108005,-0.468116,0.388880,1.063531,1.241045,0.848286,0.083885,-0.690727,-1.131653,-1.065555,-0.547206,0.186201,0.824983,1.109610,0.925852,0.347312},
  {0.193570,-0.180030,-0.484449,-0.564454,-0.368540,0.020692,0.419098,0.626027,0.525828,0.155234,-0.305017,-0.619218,-0.622840,-0.313922,0.146032,0.522623,0.634910,0.443243,0.054902,-0.342463,-0.572821,-0.542842,-0.270896,0.124557,0.469134,0.601108,0.069387,-0.348252,-0.590570,-0.529208,-0.200480,0.213275,0.491188,0.501523,0.267864,-0.062512,-0.316739,-0.391164,-0.287838,-0.086433,0.113679,0.240111,0.264392,0.195913,0.068196,-0.073898,-0.185701,-0.233608,-0.202887,-0.100238,0.047383,0.195232,-0.494100,-0.514980,-0.280763,0.105049,0.458646,0.602207,0.452109,0.067731,-0.367619,-0.632810,-0.584172,-0.238021,0.231239,0.582710,0.639644,0.382265,-0.049916,-0.440941,-0.611257,-0.497011,-0.164006,0.234264,0.524154,0.578655,0.367790,-0.021253,-0.606252,-0.501953,-0.143633,0.282854,0.552082,0.528205,0.241111,-0.139392,-0.410948,-0.453939,-0.283021,-0.014291,0.215331,0.318544,0.282113,0.148619,-0.017765,-0.158232,-0.232731,-0.224755,-0.141960,-0.012500,0.123290,0.223036,0.251170,0.187511},
  {-0.539413,-0.156981,0.289003,0.648743,0.786266,0.622080,0.177739,-0.400348,-0.870438,-0.991579,-0.653093,0.036603,0.771058,1.186142,1.050703,0.398650,-0.476101,-1.160311,-1.321266,-0.864902,0.018097,0.932352,1.448384,1.297341,0.510444,-0.567484,-1.602558,-0.992378,0.132237,1.212687,1.699506,1.344445,0.330364,-0.831357,-1.570558,-1.542531,-0.782294,0.331972,1.269504,1.594044,1.160120,0.178689,-0.877818,-1.497245,-1.379708,-0.593577,0.455790,1.238562,1.380682,0.852910,-0.036403,-0.829274,0.490430,0.713316,0.682051,0.396497,-0.062742,-0.542233,-0.849888,-0.823967,-0.420337,0.229824,0.845033,1.114901,0.865737,0.174381,-0.647447,-1.201177,-1.203331,-0.631103,0.262935,1.068110,1.403339,1.090805,0.244817,-0.762398,-1.454472,-1.471906,0.355449,1.338772,1.680051,1.187427,0.097706,-1.041851,-1.661248,-1.462445,-0.560836,0.590469,1.436399,1.586210,0.985646,-0.070656,-1.080386,-1.565082,-1.294651,-0.403245,0.668181,1.388528,1.409018,0.744153,-0.243963,-1.050007,-1.297363,-0.920099},
  {-0.848057,-1.278551,-1.126500,-0.470858,0.393671,1.082942,1.285098,0.898940,0.089972,-0.772019,-1.279524,-1.185212,-0.529802,0.372829,1.090330,1.285692,0.878440,0.074220,-0.743739,-1.199916,-1.097647,-0.500647,0.305545,0.949958,1.147144,0.824587,-0.565770,-1.001044,-0.985267,-0.552061,0.093273,0.675580,0.964075,0.853565,0.393530,-0.233564,-0.775735,-1.003305,-0.804072,-0.243293,0.448057,0.965001,1.065302,0.686276,-0.017835,-0.738565,-1.148037,-1.046065,-0.456211,0.371907,1.061797,1.277506,-0.998638,-0.229068,0.630068,1.196972,1.223850,0.698030,-0.150275,-0.940227,-1.304949,-1.063705,-0.318800,0.581527,1.207410,1.259532,0.717877,-0.151656,-0.933229,-1.264954,-1.006747,-0.295198,0.531203,1.093768,1.145925,0.680112,-0.076303,-0.772352,-0.927516,-0.359644,0.336614,0.857691,0.997004,0.718799,0.153959,-0.464027,-0.889197,-0.950227,-0.613744,-0.005343,0.627341,1.008781,0.956311,0.472419,-0.242772,-0.873366,-1.129015,-0.879292,-0.218527,0.568207,1.124645,1.180851,0.683816,-0.160024},
  {-1.321173,-1.154852,-0.480115,0.379539,1.050517,1.262960,0.939355,0.209349,-0.635839,-1.239180,-1.312923,-0.777368,0.164583,1.083401,1.516078,1.212129,0.291679,-0.793216,-1.490081,-1.443909,-0.688004,0.382062,1.229387,1.457444,0.995648,0.103050,-1.279210,-1.185988,-0.580739,0.254294,0.955367,1.225640,0.954429,0.264621,-0.535774,-1.086903,-1.141659,-0.682994,0.068742,0.765402,1.100018,0.945728,0.397178,-0.293718,-0.839865,-1.033381,-0.809765,-0.256300,0.420272,0.955088,1.112132,0.784504,-0.243850,0.643440,1.209168,1.225674,0.715073,-0.090309,-0.855637,-1.267382,-1.142346,-0.503661,0.402189,1.178051,1.440480,1.017042,0.068811,-0.954901,-1.533507,-1.355566,-0.499299,0.600726,1.387021,1.477021,0.854564,-0.144328,-1.025596,-1.389633,-0.348830,0.525125,1.132351,1.226715,0.786419,0.012909,-0.754484,-1.179593,-1.075171,-0.490672,0.305202,0.947921,1.150071,0.835827,0.167503,-0.544698,-0.994546,-1.011400,-0.613604,0.022689,0.644836,1.013634,0.978388,0.529941,-0.178104,-0.861196},
  {-0.859265,-0.042809,0.769632,1.211441,1.086256,0.455430,-0.381629,-1.022678,-1.161255,-0.744988,0.001273,0.703707,1.039502,0.888892,0.363365,-0.279594,-0.765675,-0.909527,-0.669407,-0.152966,0.421337,0.806146,0.832174,0.492119,-0.052060,-0.551636,-0.702950,-0.333637,0.159047,0.593417,0.807363,0.699003,0.274674,-0.316018,-0.809057,-0.943893,-0.619117,0.022238,0.656400,0.963538,0.809456,0.301837,-0.301469,-0.745416,-0.881315,-0.681346,-0.209691,0.390818,0.899466,1.064644,0.729125,-0.028811,0.956353,1.265448,0.985956,0.259671,-0.575691,-1.132022,-1.147663,-0.618910,0.190092,0.879835,1.124036,0.833877,0.184313,-0.499962,-0.916326,-0.913615,-0.528614,0.057020,0.598137,0.875022,0.773908,0.338352,-0.239046,-0.698807,-0.839045,-0.612756,0.368403,0.710016,0.766915,0.523868,0.061238,-0.458693,-0.823232,-0.844188,-0.464613,0.170628,0.756316,0.985667,0.733269,0.133483,-0.504251,-0.879931,-0.855514,-0.485457,0.057785,0.576313,0.894907,0.879651,0.479324,-0.204845,-0.892042,-1.217726},
  {1.176731,1.410845,0.979919,0.122622,-0.751301,-1.253767,-1.178724,-0.576836,0.273237,0.985024,1.234308,0.910106,0.172121,-0.623915,-1.102670,-1.055431,-0.534657,0.190558,0.783103,1.000512,0.787566,0.269047,-0.328741,-0.774499,-0.907421,-0.680240,0.425905,0.872766,0.963044,0.627776,-0.012305,-0.679511,-1.059482,-0.956564,-0.401878,0.350676,0.945708,1.102955,0.754470,0.070675,-0.632055,-1.045303,-1.002104,-0.532819,0.164124,0.806199,1.128083,0.975653,0.375209,-0.447747,-1.130977,-1.324940,0.843845,-0.117799,-0.976977,-1.348112,-1.093692,-0.358783,0.512750,1.131838,1.227833,0.764024,-0.042528,-0.815122,-1.193243,-1.008273,-0.365683,0.414188,0.964205,1.051863,0.676219,0.040143,-0.567745,-0.906117,-0.865660,-0.485937,0.077903,0.612114,0.842063,0.411488,-0.223318,-0.795149,-1.036873,-0.812127,-0.198840,0.529655,1.029012,1.054866,0.589205,-0.148462,-0.811891,-1.099311,-0.893032,-0.300124,0.413037,0.945264,1.080504,0.760940,0.103085,-0.637069,-1.144982,-1.167121,-0.638044,0.247835},
  {0.259566,0.259394,0.136214,-0.056270,-0.216449,-0.257634,-0.167990,-0.017026,0.100297,0.136198,0.116531,0.098389,0.100617,0.077890,-0.029196,-0.210541,-0.354464,-0.316068,-0.044686,0.336935,0.585399,0.501829,0.090314,-0.418362,-0.708848,-0.592480,0.389349,0.680629,0.596840,0.219174,-0.227586,-0.522224,-0.556682,-0.355042,-0.024678,0.303221,0.509852,0.510485,0.283647,-0.097077,-0.465051,-0.626406,-0.470452,-0.054950,0.404524,0.651836,0.545721,0.149787,-0.306288,-0.569492,-0.514437,-0.205007,0.083409,-0.099870,-0.245350,-0.273227,-0.164332,0.018503,0.169015,0.211364,0.150236,0.054671,-0.009653,-0.037151,-0.073814,-0.150482,-0.224891,-0.199097,-0.011454,0.274919,0.478478,0.419351,0.070110,-0.387838,-0.664763,-0.559643,-0.110081,0.420538,0.603190,0.170413,-0.323864,-0.614008,-0.579450,-0.281658,0.107982,0.415252,0.532765,0.433776,0.158908,-0.194978,-0.487902,-0.577162,-0.389660,0.013353,0.438327,0.652451,0.522623,0.108632,-0.361003,-0.623664,-0.541736,-0.181051,0.240370,0.492977},
  {0.611413,0.308057,-0.192389,-0.643243,-0.792403,-0.530511,0.028001,0.591821,0.852588,0.665570,0.136805,-0.441760,-0.767114,-0.695246,-0.301274,0.192616,0.554403,0.650115,0.473139,0.113143,-0.288872,-0.577224,-0.623068,-0.382494,0.055403,0.483245,0.524448,0.115574,-0.322661,-0.564045,-0.518597,-0.260289,0.055555,0.301737,0.426162,0.421823,0.282788,0.011838,-0.326389,-0.580889,-0.580145,-0.261458,0.242792,0.654734,0.723107,0.396439,-0.135827,-0.568115,-0.675865,-0.442202,-0.035764,0.321566,-0.266301,-0.634040,-0.714902,-0.427536,0.111500,0.629283,0.839688,0.611194,0.055071,-0.529698,-0.828341,-0.692708,-0.218250,0.328311,0.673060,0.678760,0.386810,-0.041831,-0.422326,-0.615266,-0.554863,-0.259026,0.164407,0.534894,0.666790,0.472877,-0.414890,-0.641830,-0.537616,-0.187687,0.202467,0.447004,0.477626,0.338232,0.110552,-0.143387,-0.373893,-0.505960,-0.444802,-0.149902,0.284077,0.634387,0.675505,0.343004,-0.195679,-0.633611,-0.721685,-0.427281,0.058790,0.461354,0.594269,0.446686},
  {-0.138752,-0.327741,-0.358429,-0.216184,0.037253,0.281867,0.387937,0.285314,0.016924,-0.268541,-0.398208,-0.287486,-0.004546,0.268013,0.355546,0.211944,-0.051070,-0.248239,-0.254798,-0.089856,0.109560,0.197643,0.125681,-0.032592,-0.147308,-0.133275,0.125859,0.166900,0.082129,-0.069713,-0.183498,-0.180889,-0.061280,0.100984,0.207011,0.195376,0.075949,-0.082195,-0.195380,-0.210918,-0.127582,0.013332,0.151809,0.231136,0.213281,0.092463,-0.092607,-0.260086,-0.314883,-0.203340,0.039060,0.288366,-0.346463,-0.170051,0.084915,0.300875,0.373244,0.256760,-0.001977,-0.271656,-0.397923,-0.296534,-0.018435,0.268835,0.384747,0.258271,-0.020437,-0.262000,-0.311207,-0.153736,0.082100,0.226263,0.191127,0.026209,-0.131365,-0.165426,-0.063570,0.083686,0.104631,-0.036104,-0.159016,-0.173984,-0.067411,0.091447,0.199533,0.188023,0.064064,-0.097998,-0.205643,-0.202915,-0.097114,0.053658,0.176885,0.220052,0.166822,0.036571,-0.122715,-0.244635,-0.264050,-0.149706,0.064184,0.275704,0.360657,0.249054},
  {0.124213,0.630826,0.782377,0.536026,0.048831,-0.417446,-0.634456,-0.518221,-0.159646,0.236456,0.467072,0.436478,0.195131,-0.103877,-0.298976,-0.307489,-0.158965,0.037023,0.162799,0.160325,0.058110,-0.054601,-0.089428,-0.019539,0.098758,0.161202,-0.099188,-0.290855,-0.335450,-0.155745,0.180740,0.481094,0.538679,0.271295,-0.206069,-0.629770,-0.736652,-0.426495,0.162333,0.715033,0.910950,0.609003,-0.057839,-0.738625,-1.049451,-0.791305,-0.077524,0.711113,1.131336,0.932382,0.210824,-0.634510,0.846519,0.522261,-0.031700,-0.521390,-0.711434,-0.535241,-0.113394,0.321799,0.552417,0.484801,0.186788,-0.163164,-0.381286,-0.376137,-0.185542,0.060960,0.224667,0.234400,0.116220,-0.034422,-0.116980,-0.088015,0.014208,0.097491,0.080753,-0.043423,-0.242127,-0.115826,0.145758,0.388890,0.435924,0.208035,-0.201582,-0.562594,-0.639822,-0.344484,0.192925,0.680676,0.827452,0.515606,-0.116169,-0.733828,-0.985676,-0.702606,-0.008258,0.730824,1.099222,0.869584,0.145972,-0.679288,-1.142197,-0.975937},
  {-0.045600,-0.694519,-0.996913,-0.771313,-0.135673,0.569842,0.983915,0.914054,0.411402,-0.281820,-0.853464,-1.046197,-0.753912,-0.076758,0.689951,1.162857,1.060282,0.384195,-0.534371,-1.193924,-1.213850,-0.574970,0.359228,1.063820,1.169686,0.667291,-0.770752,-0.978392,-0.710665,-0.157174,0.401366,0.729564,0.717845,0.401080,-0.068192,-0.480650,-0.655429,-0.522858,-0.161201,0.242726,0.494028,0.492603,0.275680,-0.021252,-0.251938,-0.335781,-0.280805,-0.152036,-0.017501,0.089632,0.172003,0.238365,-0.940790,-0.683313,-0.034440,0.655168,1.009905,0.846227,0.261510,-0.442149,-0.927935,-0.980047,-0.579357,0.103332,0.771532,1.109689,0.919705,0.243049,-0.611613,-1.194759,-1.161391,-0.494677,0.452489,1.151489,1.215194,0.630126,-0.249730,-0.933846,-0.692937,-0.015396,0.588159,0.856287,0.720208,0.289863,-0.224474,-0.603675,-0.698000,-0.480749,-0.061141,0.360433,0.587227,0.525991,0.232309,-0.128592,-0.380032,-0.427444,-0.291994,-0.074204,0.117235,0.222084,0.240993,0.207518,0.147671,0.058879},
  {-0.576583,-1.236354,-1.317773,-0.766483,0.163984,1.025531,1.395128,1.090899,0.266386,-0.671253,-1.272266,-1.265764,-0.676710,0.206658,0.978719,1.296838,1.022789,0.279575,-0.595482,-1.193321,-1.224259,-0.670231,0.192979,0.934454,1.198789,0.891665,-0.503459,-0.935289,-0.952782,-0.603262,-0.045758,0.522097,0.904634,0.942544,0.575429,-0.088207,-0.766760,-1.119361,-0.936940,-0.286078,0.507828,1.041804,1.063359,0.596101,-0.104788,-0.712824,-0.989070,-0.856640,-0.389700,0.234346,0.784982,1.037132,-1.213119,-0.560038,0.375921,1.149501,1.380490,0.946033,0.051792,-0.865359,-1.358588,-1.197445,-0.476082,0.448550,1.142345,1.298114,0.861999,0.041202,-0.792891,-1.262547,-1.147557,-0.493296,0.394205,1.085279,1.243008,0.803379,0.007503,-0.739367,-0.939131,-0.407800,0.236478,0.739145,0.939739,0.785774,0.323325,-0.300785,-0.848082,-1.058497,-0.784042,-0.108088,0.655065,1.114967,1.029282,0.447681,-0.323204,-0.904052,-1.046682,-0.733031,-0.137747,0.483852,0.899694,0.961004,0.633790,0.020053},
  {1.905491,0.879010,-0.562473,-1.745437,-2.113017,-1.488658,-0.164003,1.234898,2.044272,1.882208,0.834782,-0.586583,-1.698760,-1.984476,-1.340611,-0.110849,1.106317,1.761960,1.608152,0.775992,-0.331510,-1.245194,-1.619408,-1.335129,-0.512542,0.537354,1.708342,1.267386,0.213690,-1.005902,-1.809140,-1.771017,-0.871313,0.464429,1.576628,1.921571,1.353907,0.181286,-1.022309,-1.716178,-1.633829,-0.860382,0.249044,1.234600,1.702678,1.458746,0.581222,-0.586298,-1.546191,-1.848481,-1.309197,-0.131653,-0.909392,-1.923866,-2.042406,-1.204988,0.199719,1.512754,2.113977,1.717892,0.513685,-0.922416,-1.904928,-1.973078,-1.114068,0.238629,1.430345,1.913652,1.506654,0.452097,-0.735904,-1.535488,-1.644787,-1.073513,-0.090994,0.906366,1.537019,1.550445,-0.157743,-1.224840,-1.797774,-1.559076,-0.560803,0.751037,1.735986,1.893016,1.137144,-0.151232,-1.335274,-1.859766,-1.519726,-0.522922,0.653618,1.503109,1.695344,1.177926,0.169700,-0.924692,-1.653632,-1.686766,-0.966317,0.230806,1.379691,1.934425},
  {-0.998541,-0.908225,-0.428865,0.205343,0.731689,0.951428,0.779253,0.267200,-0.394236,-0.922513,-1.053644,-0.682661,0.049036,0.794277,1.169795,0.966534,0.274853,-0.555388,-1.100863,-1.091020,-0.547373,0.238096,0.867058,1.045636,0.725411,0.103796,-0.831269,-0.781865,-0.429511,0.053445,0.486380,0.731812,0.709032,0.405222,-0.097877,-0.611449,-0.891286,-0.761145,-0.239890,0.429855,0.899822,0.919191,0.486160,-0.158295,-0.685128,-0.865206,-0.665796,-0.217522,0.286645,0.672321,0.812145,0.636827,-0.255344,0.426077,0.879594,0.938005,0.607224,0.031200,-0.566775,-0.947430,-0.932093,-0.488086,0.220375,0.872464,1.134636,0.843537,0.117051,-0.687623,-1.157893,-1.049477,-0.420121,0.403186,1.002459,1.090002,0.650748,-0.067154,-0.699075,-0.958403,-0.270455,0.285288,0.670620,0.767801,0.577412,0.181299,-0.291067,-0.678758,-0.816874,-0.603239,-0.081676,0.529578,0.921879,0.868181,0.374037,-0.307440,-0.820419,-0.915653,-0.581469,-0.018245,0.502357,0.779707,0.742849,0.428916,-0.056364,-0.554460},
  {-0.484420,-0.412416,-0.166688,0.164274,0.448833,0.556111,0.416222,0.068245,-0.340098,-0.614281,-0.609796,-0.311066,0.152837,0.565604,0.725597,0.543473,0.090490,-0.426422,-0.756743,-0.728194,-0.339956,0.225990,0.690630,0.820777,0.551160,0.016804,-0.804959,-0.709166,-0.283261,0.274780,0.708481,0.812954,0.527953,-0.022734,-0.573957,-0.842530,-0.680153,-0.168225,0.416190,0.757355,0.687116,0.277929,-0.218408,-0.537991,-0.557556,-0.333909,-0.025121,0.225901,0.355413,0.364260,0.270282,0.088445,-0.036983,0.269084,0.475155,0.492170,0.295787,-0.050508,-0.404303,-0.598190,-0.522062,-0.189454,0.255748,0.602984,0.677848,0.430415,-0.035400,-0.505401,-0.752353,-0.644788,-0.217806,0.332376,0.736780,0.788080,0.451981,-0.109060,-0.617801,-0.825577,-0.149068,0.403275,0.763909,0.768372,0.412511,-0.144653,-0.644069,-0.839411,-0.619995,-0.083062,0.498641,0.816630,0.702925,0.232214,-0.323555,-0.663459,-0.636202,-0.310218,0.100919,0.388468,0.460751,0.351951,0.152228,-0.062927,-0.249244,-0.367615},
  {-0.281160,0.011235,0.309372,0.429518,0.301713,0.015507,-0.248696,-0.346516,-0.256688,-0.069650,0.097887,0.183675,0.195008,0.164086,0.101217,-0.005115,-0.147221,-0.267439,-0.280754,-0.141225,0.104041,0.325862,0.389845,0.245682,-0.035899,-0.304168,-0.321129,-0.070328,0.207602,0.380931,0.374045,0.195772,-0.069891,-0.302157,-0.395371,-0.305416,-0.071642,0.197786,0.374314,0.370983,0.187744,-0.085130,-0.310833,-0.376809,-0.254939,-0.016204,0.210735,0.313585,0.257611,0.095762,-0.075665,-0.180875,0.306792,0.427772,0.302175,0.000965,-0.290953,-0.401391,-0.284414,-0.037339,0.183025,0.271196,0.225137,0.112822,-0.000227,-0.092531,-0.169071,-0.217975,-0.197454,-0.073559,0.126879,0.305331,0.345740,0.198040,-0.074653,-0.325652,-0.413105,-0.286222,0.263494,0.405715,0.350702,0.132775,-0.141403,-0.345699,-0.389512,-0.254669,-0.002416,0.252194,0.390420,0.344917,0.134433,-0.141236,-0.347497,-0.382039,-0.228736,0.032001,0.265120,0.354212,0.264673,0.058629,-0.147619,-0.255198,-0.235234,-0.129265},
  {-2.489926,-1.741092,-0.180216,1.475110,2.462857,2.321918,1.102764,-0.645993,-2.115989,-2.609051,-1.875292,-0.250392,1.493580,2.523453,2.356769,1.093440,-0.649936,-2.055196,-2.492827,-1.795429,-0.305067,1.299153,2.302276,2.259862,1.192429,-0.414491,-2.373883,-1.826119,-0.455577,1.078192,2.069005,2.102538,1.221789,-0.141021,-1.392247,-2.029352,-1.815341,-0.842697,0.503258,1.670342,2.142149,1.667071,0.410516,-1.076925,-2.099743,-2.160488,-1.218371,0.286028,1.652512,2.261506,1.853345,0.623422,0.283038,1.816577,2.519279,2.062459,0.649302,-1.078266,-2.326497,-2.507951,-1.518233,0.197552,1.836549,2.615831,2.158062,0.684382,-1.094360,-2.333590,-2.467875,-1.467454,0.176409,1.703756,2.435952,2.064441,0.769811,-0.862748,-2.096073,-2.367018,-0.029100,1.479480,2.274045,2.010784,0.855739,-0.626777,-1.769041,-2.105985,-1.545221,-0.357438,0.961964,1.881621,2.019050,1.287548,-0.039430,-1.400832,-2.171845,-1.961931,-0.832841,0.702933,1.924382,2.259228,1.560592,0.161860,-1.298679,-2.175139},
  {1.085145,0.387927,-0.520235,-1.176033,-1.246599,-0.702918,0.175439,0.955146,1.267853,0.978333,0.232455,-0.619207,-1.179398,-1.180848,-0.613738,0.255720,1.001122,1.246993,0.870424,0.073892,-0.724552,-1.124294,-0.957078,-0.355907,0.349504,0.826655,0.589195,0.069259,-0.439946,-0.746380,-0.740266,-0.426720,0.066538,0.527063,0.747007,0.627664,0.234954,-0.236536,-0.571402,-0.642656,-0.455860,-0.115637,0.242961,0.505612,0.594831,0.472660,0.155386,-0.264970,-0.625811,-0.750745,-0.541534,-0.050965,-0.654262,-1.223282,-1.184338,-0.549430,0.359520,1.084852,1.273159,0.846837,0.025306,-0.796123,-1.235357,-1.092208,-0.433133,0.435897,1.101560,1.235260,0.762271,-0.084894,-0.876007,-1.210360,-0.934829,-0.220559,0.547497,0.993223,0.942551,0.479696,-0.637551,-0.831466,-0.678704,-0.262694,0.246480,0.645059,0.765346,0.550450,0.094529,-0.391029,-0.681888,-0.657292,-0.355146,0.065762,0.421776,0.589822,0.536601,0.298748,-0.046733,-0.395939,-0.626215,-0.626371,-0.353786,0.115310,0.589761,0.839901},
  {0.571926,-0.043291,-0.622799,-0.804693,-0.487449,0.108575,0.596225,0.681371,0.346676,-0.159724,-0.508097,-0.505715,-0.202232,0.173943,0.384703,0.331933,0.094251,-0.153648,-0.265899,-0.206330,-0.043935,0.113150,0.186982,0.158931,0.056843,-0.071445,-0.200682,-0.119898,0.053577,0.238942,0.315370,0.197794,-0.083275,-0.368356,-0.456379,-0.247818,0.160566,0.514676,0.566512,0.252383,-0.246891,-0.616464,-0.615833,-0.238970,0.284112,0.639330,0.624361,0.260099,-0.239816,-0.602610,-0.642662,-0.345128,-0.614214,-0.833473,-0.539858,0.075166,0.617632,0.752689,0.420745,-0.138036,-0.558828,-0.596722,-0.271936,0.171750,0.448351,0.415341,0.141960,-0.167342,-0.322309,-0.260834,-0.061182,0.134855,0.219608,0.171655,0.042778,-0.091027,-0.170990,-0.168924,0.057801,0.196701,0.251203,0.159832,-0.061628,-0.297854,-0.386329,-0.228369,0.117503,0.443359,0.518252,0.255105,-0.206258,-0.574408,-0.598691,-0.244708,0.274814,0.637849,0.622231,0.242265,-0.272042,-0.625270,-0.629249,-0.294884,0.192484,0.579251},
  {-0.971457,-0.751045,-0.185027,0.449306,0.849577,0.828632,0.406330,-0.197245,-0.674019,-0.791340,-0.514246,-0.013835,0.440421,0.633714,0.510553,0.177749,-0.178476,-0.398543,-0.417578,-0.271167,-0.053578,0.138451,0.246794,0.262892,0.210371,0.116061,-0.150536,-0.284514,-0.345599,-0.264814,-0.026897,0.285393,0.511305,0.501534,0.222302,-0.203563,-0.556652,-0.646651,-0.420513,0.013772,0.451854,0.695262,0.633429,0.280014,-0.231302,-0.684130,-0.853649,-0.612458,-0.025140,0.639766,1.024570,0.884011,-0.045444,0.586041,0.916525,0.801724,0.308049,-0.318588,-0.769271,-0.826045,-0.475346,0.086369,0.563620,0.725693,0.524924,0.102616,-0.309602,-0.522213,-0.474131,-0.235450,0.055065,0.269097,0.341671,0.280952,0.142697,-0.009423,-0.134171,-0.218051,-0.235685,-0.128685,0.066606,0.294018,0.439938,0.391990,0.124285,-0.256443,-0.552151,-0.587250,-0.320495,0.123208,0.522479,0.681172,0.524547,0.122764,-0.351479,-0.694620,-0.745048,-0.447557,0.102442,0.666157,0.950317,0.761579,0.144516,-0.601115},
  {-0.170019,0.074132,0.229774,0.267143,0.216775,0.119038,-0.003919,-0.136133,-0.242496,-0.268823,-0.177196,0.012804,0.217676,0.331849,0.290779,0.110520,-0.122260,-0.299157,-0.343636,-0.240302,-0.033403,0.194278,0.349912,0.361866,0.210605,-0.052002,-0.441815,-0.363039,-0.100013,0.224440,0.448413,0.456848,0.243796,-0.085103,-0.369676,-0.477336,-0.364968,-0.091714,0.216456,0.426249,0.451196,0.281382,-0.015753,-0.319223,-0.496593,-0.456259,-0.194775,0.184404,0.502456,0.587087,0.370447,-0.055074,0.343384,0.332239,0.194597,0.024343,-0.114074,-0.200881,-0.233988,-0.202697,-0.094510,0.073693,0.238212,0.312663,0.242488,0.048110,-0.178963,-0.326554,-0.323784,-0.174928,0.050010,0.253547,0.352070,0.303956,0.122315,-0.125811,-0.336984,-0.409338,-0.024071,0.275093,0.455608,0.418626,0.173854,-0.160679,-0.419506,-0.476486,-0.308068,-0.000017,0.300979,0.460080,0.413021,0.186652,-0.119903,-0.378223,-0.479028,-0.372431,-0.090978,0.253173,0.504283,0.529135,0.289832,-0.117170,-0.491074,-0.626036},
  {-0.821178,-0.541203,-0.025871,0.519279,0.865911,0.850355,0.448214,-0.193279,-0.793152,-1.051967,-0.806663,-0.142575,0.620657,1.087483,1.008707,0.429122,-0.339729,-0.905273,-1.013424,-0.662367,-0.058673,0.522533,0.864932,0.864052,0.524486,-0.048315,-1.017124,-0.933199,-0.374824,0.420641,1.045995,1.150943,0.662269,-0.159711,-0.875130,-1.124736,-0.821990,-0.164977,0.509159,0.908962,0.902192,0.528403,-0.049135,-0.604989,-0.915532,-0.835302,-0.373019,0.281343,0.823498,0.983183,0.673572,0.045830,0.182121,0.653293,0.859743,0.706446,0.239088,-0.362672,-0.842643,-0.967809,-0.641630,0.021751,0.719282,1.094587,0.931726,0.293553,-0.495015,-1.024784,-1.034847,-0.550875,0.154049,0.734000,0.952936,0.766680,0.289604,-0.287592,-0.761081,-0.950373,-0.177154,0.537066,1.052877,1.071940,0.536918,-0.296720,-0.987776,-1.167076,-0.755007,0.005716,0.712007,1.034228,0.869795,0.346633,-0.282287,-0.762307,-0.918839,-0.696167,-0.173646,0.443723,0.885835,0.933551,0.540818,-0.118192,-0.724846,-0.981861},
  {0.799429,0.385290,-0.159432,-0.573207,-0.693650,-0.507962,-0.127537,0.276607,0.540885,0.563141,0.339486,-0.027422,-0.365750,-0.515683,-0.415874,-0.137777,0.161935,0.340657,0.348882,0.234013,0.078104,-0.067391,-0.192933,-0.290574,-0.318100,-0.218233,0.299086,0.476307,0.427717,0.154758,-0.209480,-0.480332,-0.529549,-0.345153,-0.015975,0.325757,0.554076,0.574856,0.347957,-0.077966,-0.542493,-0.811798,-0.695110,-0.182598,0.498899,0.980827,0.963425,0.412159,-0.396096,-1.019868,-1.107618,-0.603346,-0.309632,-0.717221,-0.754920,-0.453579,0.011108,0.423143,0.620870,0.545875,0.247398,-0.142524,-0.455910,-0.554629,-0.396771,-0.065744,0.268480,0.443899,0.398021,0.192308,-0.045548,-0.211836,-0.277255,-0.266500,-0.202592,-0.080200,0.104348,0.303427,0.336211,0.068850,-0.270026,-0.499847,-0.491211,-0.245459,0.113782,0.419943,0.548400,0.455634,0.173461,-0.208042,-0.551434,-0.696672,-0.526266,-0.054603,0.526133,0.909703,0.843354,0.302187,-0.456596,-1.018476,-1.051661,-0.512590,0.316750,0.986102},
  {0.142863,0.307277,0.370973,0.291977,0.079577,-0.190921,-0.401017,-0.445236,-0.289285,0.006631,0.314236,0.496884,0.469602,0.233372,-0.124107,-0.456803,-0.611552,-0.493117,-0.121873,0.350320,0.693548,0.713173,0.366541,-0.192235,-0.680431,-0.837926,-0.017543,0.549562,0.846896,0.733986,0.271314,-0.318763,-0.759966,-0.845929,-0.530995,0.045235,0.612923,0.892705,0.734707,0.205999,-0.430430,-0.847421,-0.829831,-0.393804,0.223592,0.699035,0.800693,0.505005,-0.008662,-0.470481,-0.666347,-0.536176,0.316891,0.183236,-0.031859,-0.257917,-0.400017,-0.380660,-0.187485,0.106874,0.372291,0.483830,0.383593,0.107954,-0.229746,-0.486743,-0.546262,-0.364157,0.004339,0.410478,0.662130,0.612106,0.247377,-0.277560,-0.700998,-0.789804,-0.475788,0.093866,0.856402,0.659519,0.140495,-0.443728,-0.813162,-0.796614,-0.404046,0.182994,0.691976,0.879164,0.643794,0.086511,-0.525271,-0.882964,-0.797824,-0.309141,0.329405,0.785505,0.830183,0.459182,-0.115431,-0.592108,-0.744735,-0.530907,-0.091920,0.340647},
  {-0.184856,-0.004697,0.165588,0.266691,0.260175,0.143023,-0.040954,-0.209677,-0.279469,-0.213493,-0.048166,0.126341,0.221837,0.204639,0.106920,-0.007698,-0.091946,-0.136086,-0.150558,-0.135489,-0.073507,0.043624,0.181927,0.265569,0.222979,0.047112,-0.335170,-0.319214,-0.134535,0.121822,0.316514,0.356160,0.230827,0.006110,-0.218183,-0.351369,-0.339497,-0.179111,0.076579,0.324310,0.443009,0.351900,0.067696,-0.281514,-0.510680,-0.480472,-0.187720,0.218947,0.517061,0.538986,0.272016,-0.133587,0.236640,0.288583,0.227741,0.080487,-0.099382,-0.240696,-0.278518,-0.188200,-0.008201,0.172100,0.260762,0.218417,0.080356,-0.071420,-0.164292,-0.175657,-0.129927,-0.062637,0.010450,0.090726,0.168528,0.205245,0.153216,0.002614,-0.187525,-0.310438,-0.090539,0.160332,0.337211,0.344317,0.180908,-0.065688,-0.275430,-0.357556,-0.284216,-0.089549,0.150067,0.339858,0.393716,0.268583,-0.002675,-0.305013,-0.483242,-0.423843,-0.131744,0.253042,0.522497,0.519257,0.234641,-0.179013,-0.493967,-0.539546},
  {0.108617,0.047277,-0.027238,-0.063451,-0.038900,0.018800,0.050060,0.014862,-0.064387,-0.113305,-0.069551,0.053521,0.166038,0.172752,0.056368,-0.103299,-0.194141,-0.162388,-0.047514,0.065043,0.120767,0.126343,0.111730,0.077131,-0.007341,-0.144147,-0.246421,-0.049792,0.236454,0.416627,0.336565,0.019633,-0.330122,-0.473140,-0.313930,0.031112,0.328886,0.403062,0.244932,-0.012741,-0.213457,-0.277774,-0.218322,-0.089468,0.059561,0.188805,0.251545,0.203213,0.042448,-0.159184,-0.284797,-0.250209,-0.029852,-0.085417,-0.077587,-0.020543,0.035705,0.041406,-0.009210,-0.066116,-0.063329,0.017737,0.119887,0.151228,0.066357,-0.085282,-0.193032,-0.175364,-0.046833,0.098364,0.168243,0.142313,0.067467,-0.004047,-0.062619,-0.124895,-0.179035,-0.165644,0.183743,0.345567,0.306099,0.043297,-0.289937,-0.461616,-0.337021,0.009591,0.345181,0.451222,0.278862,-0.033975,-0.282323,-0.340764,-0.222926,-0.031034,0.134742,0.225148,0.230087,0.150860,0.001360,-0.168568,-0.272941,-0.237579,-0.063977,0.152877},
  {-0.435901,-1.260043,-1.493897,-1.015476,-0.056589,0.910540,1.418372,1.244410,0.511492,-0.401010,-1.069804,-1.233129,-0.881038,-0.209226,0.502220,1.001560,1.126566,0.826857,0.178635,-0.606359,-1.214283,-1.338545,-0.841704,0.120868,1.119060,1.639721,0.383575,-0.835440,-1.666742,-1.674022,-0.848195,0.389439,1.417190,1.739070,1.226209,0.156060,-0.948823,-1.581012,-1.475258,-0.707590,0.358712,1.242337,1.553532,1.160615,0.246589,-0.771091,-1.428202,-1.427358,-0.776583,0.216628,1.093818,1.461761,-1.428933,-0.818240,0.188489,1.107649,1.491261,1.159338,0.292021,-0.672909,-1.276249,-1.268620,-0.709484,0.103369,0.807759,1.141978,1.021529,0.524015,-0.167947,-0.819976,-1.192031,-1.103084,-0.520595,0.370218,1.190494,1.520713,1.127561,0.132999,-1.689188,-1.550252,-0.623992,0.629664,1.574171,1.736456,1.050686,-0.123834,-1.204873,-1.685556,-1.369510,-0.437654,0.662198,1.431258,1.538195,0.952634,-0.051707,-1.020277,-1.517535,-1.321344,-0.525583,0.500979,1.285894,1.474429,0.992825,0.074479},
  {-0.557258,-0.732216,-0.548677,-0.059672,0.514211,0.878351,0.812654,0.303762,-0.417456,-0.973324,-1.038290,-0.535369,0.292047,0.995160,1.171093,0.704983,-0.150667,-0.917668,-1.172370,-0.790955,-0.009400,0.730607,1.043342,0.804451,0.188082,-0.461648,-0.769455,-0.360951,0.175519,0.586196,0.696860,0.479244,0.054821,-0.364532,-0.578112,-0.495928,-0.183218,0.179857,0.403691,0.396209,0.204201,-0.034046,-0.186711,-0.206583,-0.139113,-0.065449,-0.032131,-0.022573,0.012970,0.099571,0.202140,0.242262,-0.417883,0.049677,0.544032,0.810648,0.682147,0.179705,-0.470873,-0.933388,-0.933714,-0.424638,0.357102,0.995086,1.119419,0.630124,-0.223292,-0.970159,-1.189212,-0.758360,0.073337,0.837140,1.122224,0.805217,0.097221,-0.602957,-0.942511,-0.791812,0.315905,0.706647,0.738060,0.430310,-0.049549,-0.471199,-0.644148,-0.502222,-0.133005,0.267367,0.497759,0.459828,0.206139,-0.101939,-0.298499,-0.309725,-0.180720,-0.022493,0.074292,0.093613,0.082385,0.092054,0.126120,0.136139,0.067115,-0.085901},
  {-1.715433,-1.989990,-1.289273,0.022916,1.288462,1.889958,1.557994,0.494198,-0.749508,-1.565255,-1.595340,-0.888522,0.163184,1.050897,1.400690,1.121269,0.397550,-0.430952,-1.025718,-1.171645,-0.837885,-0.175739,0.540326,1.016773,1.060149,0.661219,-0.645310,-1.010870,-0.966057,-0.542371,0.095211,0.712462,1.076137,1.023575,0.530399,-0.246102,-0.990865,-1.348071,-1.097637,-0.297610,0.705836,1.430500,1.501307,0.851242,-0.232734,-1.243694,-1.697151,-1.361195,-0.368810,0.834604,1.686031,1.762442,-1.083398,0.305121,1.520151,1.968741,1.450190,0.247139,-1.028894,-1.754531,-1.607065,-0.709898,0.458157,1.327721,1.524715,1.026468,0.125812,-0.747056,-1.231307,-1.170592,-0.639303,0.118350,0.792813,1.121267,0.981225,0.438669,-0.274663,-0.857312,-0.837832,-0.273312,0.387511,0.888577,1.045416,0.796285,0.216507,-0.494254,-1.058170,-1.211588,-0.829184,-0.020924,0.873400,1.423050,1.324131,0.576522,-0.490431,-1.369374,-1.625783,-1.115288,-0.057928,1.061744,1.716651,1.580163,0.684911,-0.574474},
  {-0.429004,0.807107,1.684486,1.827986,1.175690,0.003520,-1.186831,-1.874049,-1.739783,-0.818071,0.499471,1.621494,2.022367,1.496403,0.270887,-1.090931,-1.956849,-1.928496,-1.025615,0.335003,1.542221,2.065868,1.678666,0.542362,-0.860659,-1.918727,-1.384804,0.053002,1.525406,2.322455,2.023607,0.736216,-0.928983,-2.155456,-2.339786,-1.401603,0.185027,1.646624,2.301600,1.878642,0.614508,-0.888485,-1.952167,-2.119423,-1.338300,0.029117,1.368681,2.081672,1.849602,0.780700,-0.634763,-1.748100,1.833599,1.693575,0.818392,-0.411050,-1.465640,-1.888685,-1.487169,-0.419261,0.860268,1.784382,1.921555,1.182341,-0.118110,-1.388643,-2.035097,-1.747864,-0.655732,0.736038,1.789928,2.034465,1.370144,0.097308,-1.226793,-2.025722,-1.939841,-0.978932,1.750188,2.272673,1.738933,0.351650,-1.249693,-2.284132,-2.226146,-1.089126,0.570773,1.939860,2.363601,1.666769,0.215316,-1.290145,-2.161290,-2.031437,-0.994881,0.461520,1.684501,2.137404,1.627889,0.390319,-1.015150,-1.951111,-1.993357,-1.128499},
  {-1.720340,-1.540969,-0.555294,0.701117,1.558097,1.588395,0.825737,-0.291429,-1.188537,-1.458511,-1.034603,-0.172499,0.707374,1.217575,1.157842,0.582329,-0.232512,-0.909202,-1.139713,-0.832469,-0.157461,0.544114,0.940613,0.877453,0.436093,-0.138576,-0.738427,-0.594172,-0.251081,0.146016,0.463905,0.609567,0.542124,0.280238,-0.096157,-0.459899,-0.672019,-0.631707,-0.323707,0.157685,0.625787,0.866290,0.734101,0.240746,-0.420681,-0.944834,-1.058073,-0.666075,0.079195,0.837746,1.240395,1.068798,-0.395256,0.865724,1.668427,1.590433,0.698302,-0.508104,-1.394612,-1.541485,-0.938344,0.060241,0.954198,1.348237,1.110071,0.391675,-0.462857,-1.070684,-1.170014,-0.731999,0.024317,0.733444,1.063079,0.880502,0.311150,-0.343929,-0.777512,-0.827992,-0.063298,0.368396,0.615183,0.621525,0.413846,0.073199,-0.289380,-0.555732,-0.629267,-0.468200,-0.110482,0.325147,0.670209,0.766012,0.534885,0.034039,-0.541640,-0.927477,-0.911351,-0.453776,0.265572,0.915086,1.168502,0.872415,0.134337,-0.716122},
  {0.874412,1.190806,0.963372,0.263633,-0.609701,-1.245015,-1.305026,-0.710992,0.279797,1.174411,1.496213,1.055010,0.068879,-0.948289,-1.471754,-1.250930,-0.427717,0.565159,1.244961,1.313968,0.775953,-0.095290,-0.894712,-1.264116,-1.044019,-0.344444,1.087970,1.143947,0.662131,-0.100109,-0.766226,-1.038323,-0.832737,-0.288403,0.331540,0.770023,0.870985,0.616629,0.118977,-0.420317,-0.778881,-0.802236,-0.478524,0.046952,0.538069,0.783407,0.693594,0.327228,-0.155767,-0.570392,-0.768203,-0.672200,0.765191,0.033155,-0.754942,-1.232185,-1.147096,-0.494546,0.448803,1.227144,1.424943,0.900512,-0.106824,-1.082319,-1.512185,-1.171414,-0.247343,0.773722,1.379591,1.297193,0.606365,-0.334070,-1.079512,-1.303203,-0.925880,-0.135494,0.699762,1.193623,0.521670,-0.300191,-0.944997,-1.115840,-0.765142,-0.097560,0.558050,0.919491,0.867553,0.464849,-0.100902,-0.600697,-0.842280,-0.732427,-0.315137,0.234698,0.677886,0.819658,0.604765,0.141139,-0.361746,-0.697549,-0.747209,-0.506756,-0.068757,0.412416},
  {0.101777,0.060381,-0.030072,-0.126231,-0.155390,-0.081856,0.048650,0.138665,0.121905,0.021961,-0.070813,-0.082844,-0.021205,0.041618,0.042804,-0.012010,-0.061477,-0.053906,0.003852,0.060138,0.073262,0.046464,0.010428,-0.018372,-0.050427,-0.092299,-0.064830,0.066087,0.208037,0.244082,0.109186,-0.134566,-0.324169,-0.314935,-0.096994,0.190408,0.360220,0.310888,0.087227,-0.167194,-0.313311,-0.292384,-0.134432,0.078704,0.253324,0.310979,0.214610,-0.002796,-0.233095,-0.340822,-0.250723,-0.011534,-0.046057,-0.110307,-0.136773,-0.084053,0.033657,0.138968,0.150656,0.057985,-0.064250,-0.119709,-0.075141,0.014553,0.063240,0.035167,-0.027620,-0.054243,-0.016805,0.046718,0.075950,0.047862,-0.008330,-0.049388,-0.061237,-0.059433,-0.053193,-0.023584,0.144242,0.181845,0.095192,-0.096528,-0.272134,-0.290202,-0.107615,0.169465,0.354744,0.319532,0.087067,-0.190096,-0.343612,-0.298809,-0.103101,0.126784,0.280074,0.296693,0.175002,-0.034314,-0.238011,-0.328909,-0.242448,-0.011764,0.232153,0.337214},
  {-0.570213,-0.027474,0.508331,0.801737,0.742591,0.381605,-0.115499,-0.553489,-0.778575,-0.711483,-0.358191,0.180159,0.707506,0.979786,0.815227,0.221922,-0.551806,-1.113342,-1.138955,-0.576839,0.300295,1.039442,1.261067,0.863511,0.060479,-0.751013,-1.089035,-0.490595,0.330135,1.009726,1.235765,0.885407,0.101146,-0.750799,-1.247583,-1.130849,-0.456090,0.429197,1.075073,1.173679,0.712009,-0.048087,-0.730759,-1.038953,-0.874981,-0.349575,0.293745,0.786425,0.933654,0.681811,0.139245,-0.461907,0.658663,0.858510,0.674111,0.206346,-0.326025,-0.698300,-0.776254,-0.551074,-0.116194,0.376704,0.754287,0.857197,0.596408,0.023196,-0.640233,-1.068754,-0.999888,-0.407854,0.439523,1.104944,1.226155,0.728259,-0.132813,-0.918743,-1.248455,-0.983956,0.549485,1.114277,1.175157,0.700269,-0.108847,-0.887908,-1.262563,-1.032125,-0.290903,0.598148,1.185431,1.177552,0.596050,-0.244633,-0.920596,-1.124866,-0.805119,-0.153319,0.517480,0.923921,0.919140,0.529321,-0.071595,-0.631270,-0.914478,-0.798687},
  {-0.229775,0.249969,0.583350,0.625662,0.382964,-0.003229,-0.341387,-0.492720,-0.429658,-0.221473,0.029236,0.244325,0.382672,0.415988,0.312418,0.061260,-0.277926,-0.559115,-0.609852,-0.346051,0.140936,0.605287,0.782132,0.553718,0.030979,-0.508739,-0.672836,-0.249688,0.264970,0.637187,0.721397,0.500614,0.071673,-0.395915,-0.712079,-0.729873,-0.413464,0.121472,0.635295,0.869618,0.685089,0.151109,-0.475144,-0.878023,-0.850493,-0.404209,0.237786,0.758054,0.905492,0.616422,0.039133,-0.544277,0.672776,0.642143,0.318979,-0.124593,-0.472445,-0.575648,-0.419685,-0.112397,0.192366,0.380202,0.415800,0.323235,0.141865,-0.093794,-0.335303,-0.496360,-0.472074,-0.210736,0.213016,0.597677,0.715711,0.461292,-0.060307,-0.576517,-0.805299,-0.623503,0.403137,0.727191,0.704656,0.373703,-0.103018,-0.523990,-0.724094,-0.622359,-0.247410,0.260010,0.683324,0.814550,0.561282,0.016298,-0.566033,-0.891076,-0.781813,-0.281150,0.364399,0.832361,0.891443,0.517246,-0.101049,-0.660205,-0.893545,-0.697565},
  {0.685607,0.369609,-0.109273,-0.531883,-0.716615,-0.588384,-0.199908,0.289878,0.671483,0.765082,0.504219,-0.015085,-0.558075,-0.854722,-0.739494,-0.250313,0.377345,0.827275,0.869083,0.481084,-0.139277,-0.681319,-0.882402,-0.656994,-0.129264,0.439607,0.757887,0.390207,-0.139848,-0.592009,-0.770388,-0.602984,-0.167816,0.340854,0.693921,0.727752,0.422881,-0.078825,-0.536379,-0.728577,-0.569151,-0.151376,0.307075,0.586580,0.579615,0.329101,-0.021464,-0.319396,-0.470604,-0.451480,-0.283536,-0.012527,-0.243033,-0.622386,-0.711668,-0.481568,-0.041285,0.418431,0.702756,0.684866,0.357190,-0.153441,-0.623276,-0.823272,-0.633504,-0.120629,0.475880,0.856411,0.818636,0.371281,-0.264178,-0.768127,-0.890247,-0.577200,0.006578,0.570360,0.846491,0.717925,-0.294152,-0.698093,-0.775523,-0.505131,-0.016625,0.470938,0.742871,0.678798,0.305817,-0.208139,-0.624710,-0.745472,-0.512268,-0.042137,0.430041,0.675379,0.591342,0.247177,-0.169677,-0.465752,-0.537508,-0.397265,-0.132078,0.156480,0.385443,0.490567},
  {-0.038921,-0.177628,-0.190181,-0.046592,0.149518,0.249965,0.184898,0.009979,-0.152931,-0.214723,-0.168179,-0.061261,0.056468,0.154953,0.206771,0.176301,0.047083,-0.136962,-0.272628,-0.262046,-0.093566,0.136053,0.285784,0.270145,0.112411,-0.085946,-0.246939,-0.167103,-0.018912,0.146047,0.260041,0.253892,0.103441,-0.126634,-0.299028,-0.292934,-0.102666,0.144718,0.281169,0.227257,0.047770,-0.114021,-0.159937,-0.104629,-0.033359,-0.004415,0.000587,0.033373,0.099303,0.135772,0.077812,-0.058739,-0.160833,-0.075328,0.103134,0.229587,0.195173,0.020409,-0.167142,-0.241723,-0.172022,-0.023437,0.112189,0.181947,0.179952,0.116295,0.000455,-0.140129,-0.241374,-0.228127,-0.077676,0.138843,0.289650,0.274771,0.101913,-0.119812,-0.261034,-0.257297,0.036860,0.179971,0.247135,0.210537,0.069435,-0.127936,-0.280801,-0.284914,-0.114328,0.135985,0.302399,0.272831,0.076271,-0.140402,-0.232025,-0.166303,-0.030387,0.063596,0.077305,0.056950,0.058531,0.076483,0.054523,-0.036115,-0.142363,-0.167132},
  {0.608956,1.252228,1.258292,0.627516,-0.308017,-1.060962,-1.250016,-0.800246,0.027716,0.790392,1.104881,0.846229,0.194679,-0.483549,-0.846268,-0.754293,-0.321556,0.181386,0.499706,0.530317,0.342614,0.089915,-0.107896,-0.221294,-0.279352,-0.298581,-0.092178,0.153904,0.386948,0.473764,0.342609,0.040154,-0.293260,-0.507018,-0.516080,-0.322651,0.007242,0.370871,0.639531,0.676946,0.398227,-0.145057,-0.726220,-1.022483,-0.801161,-0.099905,0.741000,1.249481,1.104415,0.346638,-0.627127,-1.288936,1.208118,0.497993,-0.457707,-1.168415,-1.272349,-0.728939,0.163254,0.933215,1.193194,0.839874,0.093398,-0.638573,-0.988247,-0.817871,-0.271597,0.330011,0.682051,0.656987,0.344474,-0.040393,-0.305374,-0.381762,-0.319666,-0.205071,-0.081297,0.059930,0.362167,0.383408,0.227562,-0.066907,-0.365359,-0.514901,-0.437676,-0.169945,0.171625,0.455775,0.582239,0.494453,0.187866,-0.263750,-0.688536,-0.857791,-0.607499,0.022560,0.746345,1.156829,0.968651,0.222218,-0.702802,-1.293850,-1.207675,-0.475816},
  {-0.502123,-0.277344,0.084991,0.440696,0.629242,0.542963,0.188892,-0.291993,-0.673104,-0.749299,-0.452554,0.092771,0.619051,0.852380,0.662784,0.139117,-0.456717,-0.828901,-0.799432,-0.390628,0.196956,0.688047,0.859837,0.636313,0.117054,-0.465171,-0.829644,-0.419331,0.203412,0.738516,0.917944,0.647090,0.060336,-0.546254,-0.870918,-0.763448,-0.296267,0.285255,0.697774,0.761538,0.475741,-0.000684,-0.439764,-0.653643,-0.570815,-0.252327,0.148973,0.460875,0.562857,0.428518,0.127032,-0.211787,0.209062,0.487746,0.575273,0.414551,0.049903,-0.374221,-0.662449,-0.656544,-0.325163,0.197318,0.659240,0.815902,0.566181,0.019836,-0.551448,-0.856668,-0.740691,-0.263517,0.337077,0.771355,0.839122,0.516668,-0.042878,-0.584124,-0.861181,-0.742998,0.336627,0.801622,0.889656,0.545590,-0.069827,-0.652880,-0.911726,-0.720238,-0.183539,0.422005,0.798050,0.776797,0.394892,-0.142446,-0.576130,-0.719669,-0.535347,-0.133008,0.295304,0.566288,0.580215,0.352116,-0.006461,-0.341231,-0.519386,-0.478914},
  {0.424043,0.681225,0.677733,0.403368,-0.061696,-0.554722,-0.863782,-0.807796,-0.346553,0.348833,0.941617,1.099596,0.697859,-0.083553,-0.845797,-1.193995,-0.955003,-0.258482,0.550730,1.095754,1.137628,0.662484,-0.124500,-0.879047,-1.250547,-1.037579,0.606992,1.242720,1.262520,0.646225,-0.286363,-1.053137,-1.277287,-0.879817,-0.092387,0.691514,1.119597,1.028243,0.485776,-0.256311,-0.869620,-1.080534,-0.790606,-0.134091,0.572853,0.986152,0.914711,0.419804,-0.230410,-0.718866,-0.845497,-0.603485,0.556404,0.194631,-0.255941,-0.631365,-0.780960,-0.612304,-0.144094,0.459061,0.920228,0.974722,0.533560,-0.224501,-0.918928,-1.173516,-0.837576,-0.077146,0.721177,1.165083,1.054106,0.456716,-0.346442,-0.997067,-1.204808,-0.861612,-0.097940,0.748278,1.174919,0.490243,-0.453888,-1.172404,-1.295830,-0.774935,0.103326,0.889265,1.214916,0.964066,0.292880,-0.475036,-1.001915,-1.069179,-0.656354,0.049881,0.726488,1.054816,0.878244,0.290757,-0.407538,-0.872848,-0.901619,-0.523377,0.044615,0.533681},
  {-0.166890,0.209805,0.482451,0.565396,0.433501,0.128670,-0.240704,-0.526587,-0.599850,-0.415011,-0.040658,0.366471,0.630066,0.629506,0.350250,-0.104712,-0.545184,-0.764088,-0.633117,-0.183629,0.382337,0.780690,0.799025,0.423461,-0.149262,-0.627488,-0.594819,-0.164089,0.304445,0.635850,0.722532,0.529521,0.101175,-0.421466,-0.813949,-0.854810,-0.462695,0.210388,0.823743,1.032794,0.702503,0.001306,-0.694234,-1.020632,-0.828409,-0.243406,0.427009,0.864208,0.884116,0.500063,-0.100820,-0.642719,0.585307,0.547860,0.308373,-0.037034,-0.366738,-0.559932,-0.532890,-0.280492,0.104860,0.462046,0.631738,0.531363,0.194047,-0.244468,-0.599357,-0.708281,-0.500471,-0.041690,0.472120,0.790739,0.735979,0.312421,-0.275386,-0.727313,-0.816930,-0.516555,0.483639,0.726504,0.662509,0.344781,-0.103893,-0.530719,-0.774488,-0.704534,-0.294326,0.314291,0.833274,0.967125,0.599096,-0.106808,-0.778331,-1.049349,-0.776824,-0.117876,0.574319,0.955294,0.863156,0.373682,-0.264645,-0.757587,-0.890375,-0.611266},
  {-0.271267,0.015562,0.282452,0.425264,0.387757,0.179431,-0.118844,-0.375801,-0.464419,-0.329852,-0.028836,0.291513,0.469385,0.414998,0.157545,-0.172237,-0.410537,-0.442117,-0.255807,0.050668,0.319342,0.413550,0.292227,0.033439,-0.212515,-0.315580,-0.072317,0.081840,0.145547,0.129031,0.091954,0.074322,0.059136,0.000766,-0.111390,-0.219710,-0.233758,-0.107538,0.109467,0.294948,0.334656,0.198427,-0.043654,-0.268648,-0.370032,-0.303800,-0.097114,0.167209,0.376613,0.425940,0.267286,-0.047403,0.363403,0.441998,0.331527,0.084597,-0.199474,-0.403846,-0.433840,-0.262474,0.042626,0.338784,0.476341,0.380411,0.095738,-0.234872,-0.446053,-0.435209,-0.212151,0.108885,0.367235,0.435450,0.283884,-0.002407,-0.268035,-0.374133,-0.278621,-0.057345,0.238284,0.191835,0.082603,-0.005672,-0.043634,-0.062721,-0.102008,-0.152074,-0.154021,-0.057662,0.115849,0.269321,0.294123,0.153008,-0.086555,-0.294149,-0.358297,-0.247980,-0.019012,0.223824,0.374993,0.364694,0.182975,-0.106454,-0.375418,-0.480205},
  {0.122281,0.953586,1.326198,1.008637,0.155034,-0.776555,-1.292506,-1.144014,-0.446075,0.419711,1.032367,1.139968,0.744449,0.054791,-0.629173,-1.034428,-1.001506,-0.535977,0.181642,0.846284,1.146401,0.914411,0.232260,-0.582740,-1.126151,-1.118454,0.260587,0.929007,1.121129,0.771487,0.087423,-0.581833,-0.934184,-0.851516,-0.421499,0.140922,0.605821,0.811500,0.698329,0.310567,-0.214372,-0.673932,-0.863747,-0.671908,-0.157463,0.450238,0.855956,0.857302,0.459021,-0.133678,-0.636582,-0.838229,1.248894,0.878012,0.015539,-0.888526,-1.340819,-1.096317,-0.298310,0.618380,1.186503,1.156756,0.596436,-0.190807,-0.842265,-1.098189,-0.882524,-0.301998,0.405394,0.950227,1.092125,0.743607,0.033267,-0.723300,-1.158684,-1.040895,-0.409647,0.427240,1.145083,0.682234,-0.087377,-0.771290,-1.049196,-0.827682,-0.258762,0.368510,0.783299,0.845121,0.570117,0.089643,-0.412473,-0.753699,-0.798876,-0.508751,0.021723,0.572997,0.884979,0.790123,0.318254,-0.304169,-0.772964,-0.872130,-0.580867,-0.060482},
  {-0.723016,-0.511641,-0.051901,0.446899,0.742331,0.684640,0.300581,-0.218644,-0.620614,-0.723417,-0.498840,-0.067913,0.372749,0.642010,0.639239,0.370193,-0.059187,-0.475404,-0.697152,-0.613090,-0.245070,0.246167,0.631216,0.727239,0.491879,0.040162,-0.693245,-0.670582,-0.366247,0.100893,0.547263,0.781784,0.678127,0.245431,-0.343832,-0.809482,-0.898956,-0.535439,0.116839,0.725980,0.972033,0.726636,0.122940,-0.523714,-0.891026,-0.815450,-0.360349,0.236117,0.690380,0.807401,0.558351,0.076956,0.086704,0.535124,0.749412,0.614123,0.181995,-0.341214,-0.699347,-0.720840,-0.406358,0.080952,0.509539,0.695592,0.577194,0.221313,-0.219283,-0.567392,-0.681014,-0.504153,-0.098088,0.368106,0.682002,0.688967,0.377016,-0.109761,-0.543307,-0.727506,-0.200689,0.269943,0.630698,0.735091,0.528681,0.074767,-0.449878,-0.807848,-0.804465,-0.401286,0.232327,0.782974,0.955628,0.644216,0.001940,-0.638568,-0.949228,-0.783353,-0.243771,0.387071,0.802824,0.823534,0.467201,-0.078938,-0.558929,-0.766360},
  {-0.161326,-0.417472,-0.524054,-0.400975,-0.066228,0.341503,0.616526,0.598582,0.274887,-0.200007,-0.585275,-0.686091,-0.455774,-0.011923,0.431924,0.672296,0.604717,0.262372,-0.202017,-0.580246,-0.697093,-0.491146,-0.050609,0.420693,0.698391,0.648128,-0.199376,-0.597848,-0.718424,-0.505935,-0.056907,0.423140,0.709667,0.661917,0.294976,-0.217829,-0.624120,-0.720875,-0.463595,0.009442,0.455222,0.659450,0.544603,0.193241,-0.214104,-0.496861,-0.550531,-0.373272,-0.050237,0.284088,0.492952,0.487877,-0.444024,-0.270007,0.046868,0.386611,0.583791,0.512530,0.174016,-0.279898,-0.617541,-0.656336,-0.368747,0.101840,0.521715,0.690307,0.535222,0.135829,-0.322883,-0.634997,-0.660282,-0.383305,0.075881,0.508744,0.710718,0.580396,0.174227,-0.316821,-0.693800,-0.404335,0.072694,0.516971,0.723430,0.593513,0.181931,-0.321980,-0.676919,-0.705803,-0.390060,0.113274,0.550192,0.705097,0.514676,0.093114,-0.341512,-0.587947,-0.555802,-0.288203,0.080528,0.393377,0.529806,0.442109,0.169299,-0.173797},
  {-0.448804,-0.356825,-0.054601,0.302792,0.516426,0.467121,0.182816,-0.188102,-0.465796,-0.526948,-0.349067,-0.008580,0.350213,0.565005,0.520922,0.214748,-0.220558,-0.565582,-0.629373,-0.365752,0.088744,0.489218,0.625461,0.441070,0.054332,-0.323782,-0.450211,-0.199408,0.104322,0.329268,0.400111,0.312569,0.117248,-0.109305,-0.290759,-0.367922,-0.309311,-0.121686,0.139523,0.372227,0.458737,0.326528,0.008485,-0.346478,-0.541304,-0.449924,-0.109537,0.288362,0.514889,0.451354,0.160770,-0.168011,0.001157,0.319223,0.499098,0.421055,0.114337,-0.258829,-0.503239,-0.500704,-0.261816,0.096016,0.412204,0.548586,0.438378,0.115371,-0.285446,-0.572497,-0.587242,-0.299521,0.155509,0.538927,0.642465,0.412550,-0.018792,-0.416381,-0.580736,-0.453160,0.217399,0.427459,0.432634,0.262252,0.008866,-0.222222,-0.352469,-0.347817,-0.217894,-0.006594,0.218045,0.374995,0.390298,0.230623,-0.061801,-0.362390,-0.510850,-0.401862,-0.066300,0.323018,0.544230,0.466538,0.139572,-0.237921,-0.451449,-0.408282},
  {-0.956858,-0.773483,-0.271757,0.331545,0.787624,0.904070,0.623732,0.061835,-0.532184,-0.886493,-0.839318,-0.417235,0.183872,0.697508,0.905638,0.722879,0.223059,-0.388564,-0.848179,-0.938799,-0.596320,0.038608,0.670097,0.990884,0.845076,0.310249,-0.837121,-0.946306,-0.652356,-0.086298,0.525860,0.937080,0.957888,0.539825,-0.167388,-0.843501,-1.138700,-0.871382,-0.156683,0.638088,1.100094,1.008008,0.443451,-0.284714,-0.831017,-0.983092,-0.721505,-0.179616,0.429685,0.875478,0.966934,0.628831,-0.069233,0.531334,0.882853,0.853302,0.460993,-0.131410,-0.671315,-0.917037,-0.751044,-0.244998,0.369079,0.811735,0.889612,0.577608,0.017084,-0.552821,-0.891219,-0.846433,-0.420611,0.214790,0.775505,0.989690,0.739663,0.136580,-0.528892,-0.938995,-0.482671,0.142918,0.694752,0.952724,0.814018,0.320079,-0.345710,-0.901398,-1.070777,-0.727934,-0.000868,0.757872,1.150310,0.964190,0.302591,-0.480014,-0.990314,-1.010657,-0.583119,0.060053,0.638057,0.935755,0.853014,0.415686,-0.222699,-0.803872},
  {-0.110570,-0.706567,-0.916269,-0.655885,-0.108883,0.411245,0.663925,0.600307,0.331294,0.006310,-0.278116,-0.477362,-0.547074,-0.428602,-0.105516,0.326602,0.666487,0.714876,0.410875,-0.111604,-0.595125,-0.805284,-0.650383,-0.208232,0.329655,0.742566,0.593153,0.033764,-0.596920,-0.995104,-0.928337,-0.383734,0.389681,0.996631,1.113034,0.671284,-0.102917,-0.819123,-1.130155,-0.899253,-0.249399,0.508835,1.022989,1.054795,0.588139,-0.156969,-0.821777,-1.083556,-0.821613,-0.178992,0.519726,0.944233,-0.959889,-0.630634,-0.001262,0.577858,0.814744,0.641880,0.218214,-0.212277,-0.478936,-0.542784,-0.444218,-0.226514,0.078956,0.406419,0.625961,0.595222,0.268797,-0.230822,-0.657686,-0.783729,-0.536196,-0.035296,0.482261,0.788131,0.756866,0.398813,-0.677245,-0.937219,-0.774789,-0.215317,0.501961,1.017594,1.042729,0.535599,-0.256928,-0.929336,-1.140381,-0.792424,-0.068711,0.674922,1.089186,0.988824,0.426945,-0.333030,-0.934054,-1.088894,-0.721863,-0.014115,0.684023,1.034790,0.886552,0.338604},
  {0.531531,0.486653,0.242222,-0.130397,-0.484519,-0.653903,-0.538084,-0.165375,0.309179,0.672444,0.750940,0.489954,-0.017136,-0.557816,-0.880674,-0.806121,-0.326908,0.357559,0.914037,1.040450,0.640016,-0.104398,-0.815192,-1.123729,-0.872384,-0.194792,1.041882,1.018942,0.523117,-0.208432,-0.840363,-1.083723,-0.820801,-0.164891,0.578220,1.046813,1.004157,0.469087,-0.285997,-0.878834,-1.022454,-0.671105,-0.026317,0.587140,0.891416,0.777162,0.328683,-0.236130,-0.667993,-0.787694,-0.555693,-0.087222,0.070123,-0.263857,-0.522890,-0.587521,-0.399857,-0.013007,0.413457,0.682086,0.655053,0.325404,-0.174769,-0.628957,-0.826330,-0.653092,-0.153822,0.465587,0.911401,0.938652,0.491646,-0.236824,-0.883353,-1.103512,-0.767388,-0.039698,0.708357,1.101612,0.357965,-0.395551,-0.952031,-1.062138,-0.681075,0.017508,0.714107,1.080111,0.931375,0.329059,-0.435215,-0.980112,-1.034495,-0.582880,0.131382,0.745604,0.972372,0.735500,0.182207,-0.413449,-0.787612,-0.795422,-0.456343,0.066304,0.537421,0.750341},
  {0.256707,0.470016,0.494648,0.318599,0.008598,-0.318107,-0.536069,-0.551036,-0.331692,0.066020,0.493640,0.748008,0.662484,0.217674,-0.402897,-0.876628,-0.916404,-0.457112,0.276081,0.881950,1.019399,0.614156,-0.100159,-0.729770,-0.954241,-0.695219,0.444903,0.763074,0.718637,0.372438,-0.103236,-0.507314,-0.683160,-0.568310,-0.214615,0.228814,0.572020,0.663965,0.461375,0.051726,-0.383365,-0.648315,-0.621037,-0.309415,0.148110,0.541011,0.682793,0.502748,0.086098,-0.364451,-0.631108,-0.592893,0.434248,0.191575,-0.132659,-0.409253,-0.528011,-0.438482,-0.164964,0.201089,0.522920,0.655206,0.500985,0.077079,-0.452732,-0.824162,-0.804605,-0.346524,0.344528,0.897936,0.989480,0.546313,-0.195192,-0.825557,-1.006252,-0.662823,-0.008675,0.599923,0.713596,0.252067,-0.275631,-0.639963,-0.709259,-0.480463,-0.062588,0.369374,0.637880,0.630377,0.348326,-0.087645,-0.486186,-0.669205,-0.552612,-0.185723,0.268602,0.604518,0.665134,0.416993,-0.028126,-0.460352,-0.671867,-0.562186,-0.190816,0.255124},
  {-0.004695,0.066442,0.095639,0.120652,0.159805,0.181881,0.126445,-0.036299,-0.255083,-0.405814,-0.365413,-0.104614,0.268710,0.554909,0.575631,0.285789,-0.186621,-0.600462,-0.729353,-0.486743,0.020771,0.542045,0.808396,0.673872,0.195068,-0.393404,-0.811591,-0.426661,0.170870,0.691240,0.883025,0.651230,0.100188,-0.513263,-0.894409,-0.846823,-0.373470,0.307837,0.856250,0.977397,0.588744,-0.117202,-0.764361,-1.000357,-0.700512,-0.041226,0.606368,0.896182,0.701937,0.170026,-0.389224,-0.689862,0.183580,0.134620,0.088675,0.057458,0.009889,-0.086809,-0.216183,-0.300297,-0.247081,-0.028196,0.273451,0.492233,0.476230,0.191167,-0.239578,-0.591208,-0.660763,-0.385610,0.112341,0.583510,0.779278,0.584474,0.083281,-0.478030,-0.814739,-0.750586,0.290179,0.755244,0.855607,0.540983,-0.039058,-0.608782,-0.895363,-0.754508,-0.240262,0.410927,0.881360,0.923040,0.491936,-0.208898,-0.817887,-1.004472,-0.659000,0.033921,0.693983,0.963684,0.713878,0.109085,-0.503323,-0.802581,-0.668776,-0.223107},
  {-0.293345,-0.613299,-0.624399,-0.352518,0.045495,0.376501,0.507445,0.414674,0.172816,-0.097881,-0.292443,-0.360462,-0.309281,-0.177676,-0.004450,0.181803,0.345916,0.426486,0.349006,0.081947,-0.301552,-0.619603,-0.668067,-0.357700,0.194960,0.704571,0.590459,-0.018422,-0.632852,-0.934646,-0.775195,-0.240165,0.409897,0.871308,0.930507,0.550741,-0.108386,-0.746108,-1.045371,-0.830200,-0.178889,0.587908,1.065088,0.990318,0.401839,-0.379647,-0.938175,-0.999052,-0.567418,0.103720,0.673721,0.891674,-0.638832,-0.285675,0.169294,0.503776,0.579418,0.396524,0.071041,-0.239007,-0.411183,-0.403496,-0.253500,-0.042054,0.152937,0.285463,0.339432,0.306714,0.174479,-0.056248,-0.332176,-0.532815,-0.517420,-0.222814,0.255904,0.679351,0.790313,0.480916,-0.689690,-0.924081,-0.687561,-0.101071,0.537010,0.914347,0.856029,0.393227,-0.262792,-0.813391,-0.995703,-0.700590,-0.041679,0.671438,1.071229,0.928977,0.298988,-0.491884,-1.021216,-1.012623,-0.490138,0.249574,0.819608,0.956129,0.636001,0.051682},
  {-0.603556,-0.456651,-0.046187,0.402319,0.629599,0.503367,0.102323,-0.334887,-0.560992,-0.469157,-0.143544,0.212200,0.409302,0.377957,0.181403,-0.050929,-0.210936,-0.259441,-0.215591,-0.116380,0.010676,0.142511,0.241119,0.253654,0.145928,-0.054712,-0.325051,-0.219061,0.012772,0.230164,0.300140,0.190863,-0.007936,-0.156344,-0.171237,-0.082158,0.008082,0.021054,-0.028512,-0.053668,0.013848,0.146596,0.231779,0.165471,-0.048719,-0.283651,-0.374445,-0.240402,0.051992,0.331606,0.435113,0.306191,-0.006790,0.417570,0.627687,0.490914,0.077281,-0.375523,-0.607209,-0.495196,-0.123767,0.279968,0.493611,0.428814,0.162697,-0.134539,-0.313219,-0.320297,-0.199249,-0.034221,0.108172,0.198978,0.229772,0.191028,0.075843,-0.093478,-0.248705,-0.299758,0.027846,0.245817,0.325918,0.217324,-0.007404,-0.201072,-0.247669,-0.143697,0.009644,0.095598,0.076485,0.013868,-0.000362,0.062191,0.134346,0.114523,-0.031933,-0.223292,-0.313315,-0.206479,0.057577,0.320937,0.414235,0.271948,-0.027190,-0.315941},
  {-1.255093,-1.320639,-0.727419,0.239492,1.088669,1.387271,0.996910,0.138202,-0.746696,-1.237398,-1.136902,-0.533681,0.275731,0.934634,1.169780,0.888303,0.211517,-0.565082,-1.087782,-1.105534,-0.602221,0.181057,0.862375,1.116631,0.841109,0.195013,-0.928545,-0.925086,-0.525941,0.070954,0.604199,0.857826,0.742934,0.326050,-0.206021,-0.630865,-0.785445,-0.625731,-0.227934,0.255381,0.651161,0.811984,0.655087,0.202288,-0.394375,-0.879689,-0.998041,-0.637436,0.073881,0.800549,1.167277,0.967905,-0.541133,0.417995,1.193467,1.382172,0.879725,-0.054210,-0.938726,-1.336831,-1.081388,-0.335978,0.521238,1.099397,1.166257,0.721894,-0.026174,-0.753850,-1.145022,-1.019887,-0.424019,0.373262,0.994081,1.138301,0.741559,0.009460,-0.695235,-1.044204,-0.369915,0.287446,0.778912,0.910784,0.653380,0.136929,-0.411540,-0.764646,-0.787832,-0.489938,-0.008509,0.458964,0.737852,0.733008,0.446333,-0.030543,-0.533805,-0.861824,-0.843078,-0.429086,0.239711,0.860951,1.108737,0.818491,0.101626,-0.695055},
  {0.082459,0.741701,0.997207,0.682975,-0.025066,-0.707182,-0.961400,-0.655137,0.001692,0.604612,0.814417,0.553547,0.022556,-0.450858,-0.615748,-0.427311,-0.040740,0.303796,0.424731,0.290693,0.018678,-0.210222,-0.264453,-0.137686,0.058167,0.176204,-0.018377,-0.165743,-0.187927,-0.059569,0.137363,0.271100,0.246301,0.062015,-0.188497,-0.367786,-0.364402,-0.152714,0.181624,0.467910,0.530464,0.293560,-0.149353,-0.561415,-0.690169,-0.428486,0.100008,0.600431,0.782004,0.535701,-0.002527,-0.538565,0.968794,0.653434,-0.046582,-0.731584,-0.995267,-0.681902,0.012027,0.664782,0.898794,0.609901,0.009652,-0.530913,-0.717167,-0.491708,-0.034446,0.372707,0.516935,0.360695,0.036595,-0.249017,-0.340580,-0.216211,0.013658,0.186659,0.196302,0.057870,-0.176861,-0.090327,0.085197,0.219897,0.210378,0.049240,-0.171810,-0.319762,-0.297589,-0.097702,0.190253,0.417076,0.444000,0.220604,-0.167101,-0.517815,-0.615500,-0.364409,0.128090,0.591408,0.747025,0.484745,-0.059884,-0.583249,-0.795429,-0.586200},
  {-0.386071,-0.266415,-0.062968,0.143069,0.294032,0.354696,0.299907,0.122203,-0.140032,-0.387958,-0.494317,-0.375471,-0.055523,0.328084,0.588350,0.584908,0.297629,-0.158219,-0.577827,-0.753257,-0.570366,-0.079498,0.500791,0.871472,0.808929,0.308207,-0.894915,-0.934496,-0.478227,0.219672,0.779530,0.917948,0.595238,0.008981,-0.538209,-0.799289,-0.683637,-0.269674,0.247704,0.639759,0.732879,0.483447,0.007686,-0.462949,-0.695424,-0.581022,-0.194822,0.252878,0.541204,0.556042,0.329429,-0.006758,0.049716,0.258711,0.350512,0.315818,0.182099,-0.012820,-0.222579,-0.380375,-0.406962,-0.253504,0.047608,0.371899,0.555599,0.485835,0.170663,-0.255699,-0.594203,-0.673949,-0.433171,0.043141,0.545052,0.820736,0.699310,0.199380,-0.447509,-0.898558,-0.401340,0.309831,0.855557,0.942803,0.541528,-0.112777,-0.670869,-0.867207,-0.642467,-0.139632,0.393130,0.721881,0.715734,0.387827,-0.112004,-0.554069,-0.728056,-0.548882,-0.109424,0.363273,0.632457,0.581581,0.267210,-0.132501,-0.428227,-0.511647},
  {-1.367163,-1.450061,-0.854929,0.116058,1.004237,1.416361,1.190484,0.444833,-0.488456,-1.204240,-1.387856,-0.947997,-0.067983,0.858694,1.398731,1.286882,0.566744,-0.419024,-1.195296,-1.393961,-0.937211,-0.066441,0.793042,1.250479,1.131345,0.534297,-0.879143,-1.125493,-0.920723,-0.362153,0.341222,0.933002,1.177997,0.940808,0.263120,-0.604944,-1.272433,-1.381324,-0.812389,0.204656,1.172933,1.583942,1.205577,0.223455,-0.858297,-1.497163,-1.400644,-0.656412,0.349628,1.150408,1.414323,1.062006,-0.648080,0.383197,1.211313,1.458605,1.037105,0.164320,-0.758505,-1.329568,-1.309535,-0.710880,0.208529,1.045696,1.419211,1.143367,0.329599,-0.647996,-1.323934,-1.371646,-0.771485,0.178314,1.016301,1.353005,1.058505,0.306805,-0.533598,-1.090401,-0.741131,-0.054939,0.625590,1.050088,1.067781,0.661863,-0.039854,-0.781816,-1.247508,-1.185158,-0.552003,0.410378,1.248783,1.517249,1.032745,0.007606,-1.042626,-1.576923,-1.327867,-0.440665,0.624298,1.351215,1.427775,0.865987,-0.047821,-0.909229},
  {-0.053059,-0.336436,-0.453379,-0.371284,-0.135232,0.148453,0.351086,0.379855,0.229410,-0.010981,-0.209997,-0.276103,-0.209603,-0.085564,0.015627,0.069200,0.106641,0.160343,0.209372,0.183937,0.031971,-0.209586,-0.408479,-0.415579,-0.176559,0.208087,0.582321,0.318338,-0.137225,-0.540251,-0.668975,-0.449525,0.003927,0.454316,0.671539,0.552623,0.167969,-0.285296,-0.589670,-0.612094,-0.355932,0.054765,0.437897,0.628426,0.539874,0.199251,-0.253517,-0.611147,-0.687639,-0.419168,0.080164,0.557543,-0.496483,-0.336008,-0.049426,0.236997,0.405534,0.387984,0.196704,-0.073280,-0.286891,-0.342807,-0.232736,-0.040937,0.119114,0.182778,0.165422,0.125191,0.096122,0.056099,-0.039303,-0.189508,-0.316108,-0.305944,-0.104359,0.216850,0.480084,0.508499,-0.181515,-0.546743,-0.635974,-0.386170,0.077039,0.508766,0.680946,0.505833,0.078770,-0.379058,-0.640784,-0.588203,-0.261105,0.175881,0.520663,0.625022,0.449971,0.072595,-0.346846,-0.623656,-0.621026,-0.317344,0.163347,0.589902,0.733433,0.498461},
  {1.247484,1.217987,0.596372,-0.354894,-1.180085,-1.457374,-1.027206,-0.088629,0.898248,1.451342,1.312124,0.564277,-0.426902,-1.204436,-1.430509,-1.020863,-0.161652,0.776870,1.387996,1.390368,0.754168,-0.261291,-1.196328,-1.593220,-1.228896,-0.252663,1.566390,1.498207,0.701660,-0.414832,-1.297473,-1.533982,-1.047190,-0.104504,0.838440,1.361403,1.258989,0.607701,-0.287606,-1.031705,-1.304704,-0.994910,-0.247244,0.598212,1.158511,1.185130,0.679900,-0.110866,-0.821129,-1.141675,-0.956612,-0.376730,0.342956,-0.550662,-1.240581,-1.366365,-0.827277,0.139956,1.065428,1.486156,1.190030,0.325335,-0.682911,-1.355382,-1.392152,-0.798751,0.140891,1.007789,1.428574,1.221438,0.465343,-0.524023,-1.310210,-1.517391,-1.012975,-0.000566,1.047437,1.610792,0.488099,-0.652665,-1.460389,-1.544689,-0.889240,0.159161,1.086262,1.470789,1.171784,0.364395,-0.567535,-1.212748,-1.304598,-0.821696,0.012058,0.824795,1.256401,1.118137,0.480459,-0.358097,-1.012173,-1.192900,-0.839906,-0.136560,0.591696,1.034597},
  {0.735759,0.719910,0.355136,-0.188953,-0.659948,-0.835913,-0.623621,-0.104582,0.491922,0.884524,0.869409,0.426431,-0.254145,-0.847966,-1.049319,-0.729952,-0.021362,0.732070,1.138953,0.968373,0.287328,-0.557774,-1.119501,-1.095460,-0.500446,0.340646,1.088154,0.644586,-0.090528,-0.728678,-0.966608,-0.726350,-0.164310,0.430447,0.781274,0.744313,0.361969,-0.164564,-0.573034,-0.670103,-0.431499,-0.012307,0.347868,0.471142,0.342739,0.097359,-0.095654,-0.156642,-0.132212,-0.121965,-0.166985,-0.203199,0.230651,-0.307942,-0.710888,-0.784685,-0.488678,0.048967,0.586074,0.870201,0.752594,0.265017,-0.380162,-0.877117,-0.969419,-0.583291,0.118394,0.798713,1.106598,0.860387,0.158683,-0.650961,-1.144006,-1.048161,-0.402270,0.454032,1.063999,1.108408,-0.218707,-0.864040,-1.038800,-0.692774,-0.039452,0.580623,0.878651,0.744497,0.275079,-0.288786,-0.678822,-0.721209,-0.416135,0.063552,0.463326,0.587095,0.406124,0.064614,-0.225170,-0.325229,-0.248226,-0.115239,-0.037269,-0.023774,0.005151,0.119044},
  {0.390639,0.010904,-0.340249,-0.529254,-0.509904,-0.302669,0.031710,0.392595,0.636493,0.617930,0.281307,-0.258245,-0.731248,-0.853801,-0.513860,0.130312,0.725444,0.934454,0.643267,0.024418,-0.578160,-0.856277,-0.699611,-0.225197,0.315847,0.676220,0.441808,-0.017410,-0.461235,-0.694823,-0.608654,-0.235683,0.250508,0.612077,0.668384,0.395720,-0.057579,-0.454269,-0.600770,-0.448856,-0.107646,0.233986,0.419249,0.398783,0.230476,0.018560,-0.155560,-0.262037,-0.301639,-0.268834,-0.143554,0.074576,-0.460057,-0.582573,-0.449017,-0.148231,0.193272,0.463119,0.573519,0.463624,0.130687,-0.323557,-0.692060,-0.751925,-0.410708,0.195210,0.744819,0.915611,0.590309,-0.058458,-0.669518,-0.912555,-0.677941,-0.119696,0.457147,0.774408,0.712009,0.335274,-0.569830,-0.711654,-0.535732,-0.118743,0.354149,0.662525,0.654139,0.328796,-0.151335,-0.542384,-0.650242,-0.435680,-0.029373,0.350252,0.522570,0.436060,0.175223,-0.109629,-0.295173,-0.339504,-0.272591,-0.146269,0.006759,0.171622,0.318224,0.380811},
  {0.707897,0.584306,0.197377,-0.283282,-0.641622,-0.715361,-0.470704,-0.016306,0.447350,0.717041,0.674057,0.333820,-0.160348,-0.595748,-0.778534,-0.617744,-0.170688,0.372803,0.766959,0.819952,0.489374,-0.085400,-0.638329,-0.901042,-0.737856,-0.220018,0.836358,0.871297,0.501771,-0.089932,-0.628084,-0.875056,-0.731614,-0.267766,0.315385,0.768048,0.888748,0.608409,0.032613,-0.585375,-0.948189,-0.860412,-0.343486,0.355332,0.882191,0.966242,0.569774,-0.092994,-0.679622,-0.908068,-0.697192,-0.185319,0.044497,-0.411949,-0.692160,-0.665841,-0.340778,0.138816,0.558703,0.732302,0.583103,0.176023,-0.312620,-0.670811,-0.740098,-0.483152,-0.003053,0.495006,0.787686,0.731773,0.335280,-0.234322,-0.716762,-0.877638,-0.625724,-0.067940,0.533552,0.887583,0.365934,-0.255663,-0.748620,-0.888874,-0.624500,-0.086832,0.480927,0.833280,0.820648,0.444661,-0.140963,-0.684045,-0.932512,-0.749778,-0.196470,0.475118,0.932249,0.933834,0.468784,-0.227458,-0.797369,-0.956904,-0.645747,-0.045790,0.533506,0.824437},
  {-0.372468,0.388582,0.998085,1.137964,0.725006,-0.038557,-0.776622,-1.138583,-0.968486,-0.362158,0.395599,0.965814,1.099361,0.738904,0.044496,-0.671356,-1.081226,-0.996027,-0.457564,0.281682,0.882574,1.079995,0.797883,0.170253,-0.527283,-0.995300,-0.610103,0.091805,0.766837,1.105320,0.943140,0.347765,-0.409106,-0.981971,-1.114637,-0.751688,-0.052371,0.683578,1.136572,1.092455,0.538934,-0.302673,-1.045825,-1.309522,-0.925410,-0.060267,0.845741,1.315575,1.110329,0.364602,-0.507217,-1.064949,1.030658,1.055325,0.563119,-0.222172,-0.912261,-1.163833,-0.859806,-0.158859,0.600185,1.070039,1.049687,0.559845,-0.176575,-0.831708,-1.111737,-0.887282,-0.258043,0.487106,1.004590,1.060446,0.638736,-0.059907,-0.720453,-1.057078,-0.930520,-0.397810,0.897875,1.091150,0.794987,0.130809,-0.603365,-1.068892,-1.049698,-0.555564,0.187963,0.850035,1.141754,0.932664,0.299859,-0.496352,-1.103887,-1.221893,-0.752612,0.114586,0.961092,1.343728,1.046225,0.219393,-0.695245,-1.221493,-1.119868,-0.499830},
  {0.906926,0.794708,0.316822,-0.270060,-0.691577,-0.772613,-0.496076,0.000509,0.483169,0.721332,0.598312,0.179251,-0.312691,-0.614663,-0.574720,-0.239996,0.178212,0.440983,0.428040,0.197096,-0.076258,-0.226844,-0.203242,-0.079737,0.019674,0.021466,-0.088976,-0.024734,0.134778,0.282291,0.286094,0.091511,-0.220957,-0.468896,-0.479165,-0.206465,0.222120,0.571789,0.636396,0.361267,-0.122515,-0.569000,-0.747132,-0.556640,-0.075737,0.473540,0.822717,0.779623,0.330106,-0.330455,-0.869595,-0.981531,0.219841,-0.415509,-0.802032,-0.786283,-0.411718,0.128033,0.583529,0.752100,0.560870,0.103724,-0.392870,-0.676450,-0.603389,-0.224264,0.241500,0.535432,0.514562,0.229632,-0.122724,-0.336028,-0.321906,-0.146106,0.041066,0.120043,0.078492,0.000540,0.064463,0.168575,0.185793,0.051148,-0.187501,-0.383896,-0.385401,-0.143799,0.233237,0.532788,0.563592,0.278884,-0.185546,-0.583764,-0.697163,-0.454005,0.034117,0.530490,0.788391,0.666819,0.200191,-0.404724,-0.850421,-0.887588,-0.455404,0.255560},
  {0.096996,0.360238,0.431710,0.324282,0.116426,-0.112988,-0.306844,-0.411373,-0.367486,-0.147104,0.190803,0.489910,0.570052,0.347713,-0.086572,-0.502773,-0.664909,-0.475445,-0.034413,0.421422,0.654475,0.552545,0.178479,-0.272254,-0.574759,-0.585415,0.105447,0.447041,0.550401,0.382213,0.049557,-0.270041,-0.430175,-0.384469,-0.187705,0.055469,0.248722,0.334386,0.295206,0.148183,-0.056977,-0.243708,-0.333107,-0.282655,-0.113065,0.100430,0.268325,0.329018,0.266102,0.101010,-0.117962,-0.317997,0.481263,0.288227,0.000491,-0.244260,-0.370642,-0.365906,-0.242470,-0.021165,0.246230,0.455258,0.479882,0.257094,-0.138899,-0.507617,-0.632180,-0.419490,0.029626,0.473378,0.670744,0.519084,0.105018,-0.352110,-0.621218,-0.575543,-0.248815,0.188416,0.578212,0.354874,-0.025902,-0.364768,-0.500519,-0.391355,-0.120980,0.165219,0.344025,0.364649,0.247280,0.051759,-0.151211,-0.294465,-0.325676,-0.226604,-0.031130,0.179728,0.313975,0.315770,0.190690,-0.005751,-0.200376,-0.327829,-0.339786,-0.212811},
  {0.296241,-0.196881,-0.597848,-0.788569,-0.704511,-0.340232,0.219475,0.775021,1.055370,0.851468,0.174893,-0.681156,-1.262320,-1.212696,-0.511595,0.483661,1.235962,1.344963,0.774721,-0.148629,-0.947436,-1.257764,-0.987560,-0.307674,0.469574,1.029133,0.784586,0.053470,-0.738047,-1.221489,-1.136246,-0.489286,0.413855,1.115511,1.257232,0.780890,-0.048344,-0.804967,-1.139171,-0.940262,-0.350420,0.343616,0.853468,0.993308,0.724528,0.155798,-0.489225,-0.940751,-0.987214,-0.581702,0.110318,0.768846,-0.750964,-0.762773,-0.503368,-0.067205,0.416726,0.791832,0.891872,0.607116,-0.018563,-0.738775,-1.183028,-1.057576,-0.352898,0.597890,1.282292,1.309046,0.651188,-0.334206,-1.122335,-1.324831,-0.886046,-0.068756,0.723965,1.155365,1.078396,0.552559,-0.888210,-1.204779,-0.984599,-0.287907,0.580292,1.193968,1.228535,0.653423,-0.236783,-0.984440,-1.224820,-0.875124,-0.149317,0.586794,1.011388,0.979334,0.545871,-0.091000,-0.676421,-0.981158,-0.874965,-0.383504,0.298739,0.870160,1.054003,0.742877},
  {-1.585438,-0.200037,1.301566,2.152639,1.932156,0.772584,-0.733543,-1.853916,-2.076837,-1.331784,0.011298,1.331336,2.032923,1.798399,0.725668,-0.701867,-1.816596,-2.072947,-1.324946,0.074881,1.433285,2.069163,1.674592,0.476681,-0.895770,-1.760110,-0.910382,0.256540,1.202172,1.537049,1.189357,0.379975,-0.517041,-1.140531,-1.269178,-0.882732,-0.155288,0.613239,1.111480,1.141146,0.700164,-0.017864,-0.711272,-1.102049,-1.046918,-0.580647,0.113724,0.778843,1.166352,1.110961,0.590405,-0.239555,1.498200,2.191143,1.783942,0.484085,-1.043736,-2.037558,-2.029320,-1.058148,0.383894,1.613662,2.077200,1.582662,0.365211,-1.022448,-1.945785,-1.965945,-1.051025,0.382556,1.645580,2.109391,1.535227,0.213419,-1.181772,-1.951222,-1.740765,-0.710419,1.505693,1.665450,1.071844,0.070147,-0.866577,-1.359208,-1.257017,-0.656018,0.171159,0.889260,1.221412,1.047399,0.449140,-0.320153,-0.940088,-1.159432,-0.901003,-0.285335,0.432381,0.972778,1.135484,0.858925,0.232009,-0.530322,-1.141065,-1.327849},
  {-0.425116,-0.628927,-0.485932,-0.104096,0.276546,0.441814,0.337652,0.084790,-0.129544,-0.191392,-0.122689,-0.030434,-0.001288,-0.035891,-0.068834,-0.040539,0.049812,0.149770,0.198057,0.161719,0.043321,-0.126724,-0.291032,-0.365742,-0.268860,0.016232,0.628847,0.551686,0.118683,-0.472182,-0.876314,-0.811584,-0.256179,0.506393,1.039252,1.012355,0.408457,-0.454027,-1.096547,-1.151633,-0.573973,0.328274,1.060995,1.219195,0.715948,-0.167018,-0.940093,-1.186130,-0.794243,-0.008626,0.729622,1.041028,-0.510615,-0.082336,0.349256,0.546438,0.425885,0.102181,-0.203434,-0.320182,-0.232382,-0.059380,0.058731,0.068303,0.019797,-0.001696,0.040632,0.110537,0.140714,0.091944,-0.022351,-0.153475,-0.246164,-0.253233,-0.143261,0.077914,0.336951,0.493939,0.050761,-0.431847,-0.759714,-0.687978,-0.186621,0.498980,0.970898,0.919805,0.329714,-0.491296,-1.080606,-1.089734,-0.491193,0.397978,1.089443,1.196013,0.650943,-0.250053,-1.011499,-1.216942,-0.764331,0.080803,0.845900,1.126382,0.806989,0.101688},
  {0.804230,0.780794,0.458469,0.030354,-0.347076,-0.595317,-0.673015,-0.535671,-0.163490,0.362308,0.825895,0.958812,0.611221,-0.108250,-0.846358,-1.192308,-0.926994,-0.168442,0.687147,1.191980,1.096058,0.469843,-0.357282,-0.984866,-1.137655,-0.773577,0.646175,1.077435,1.027339,0.506113,-0.263954,-0.929241,-1.162603,-0.832900,-0.091283,0.691680,1.119201,0.985132,0.383081,-0.359064,-0.873228,-0.947410,-0.607526,-0.056897,0.458606,0.760816,0.773799,0.505653,0.031830,-0.499703,-0.877059,-0.894259,0.345795,-0.212097,-0.590503,-0.697127,-0.569350,-0.285071,0.090433,0.482218,0.761608,0.765362,0.400894,-0.237624,-0.856687,-1.103788,-0.787649,-0.026784,0.790165,1.221193,1.029118,0.316704,-0.540483,-1.110294,-1.131054,-0.624072,0.147918,0.826356,0.910863,0.297551,-0.455413,-1.014127,-1.114068,-0.688044,0.079808,0.822105,1.165895,0.933221,0.245967,-0.537223,-1.020920,-0.988619,-0.503133,0.159426,0.682389,0.868427,0.697619,0.282145,-0.215348,-0.634681,-0.834742,-0.714429,-0.266840,0.363877},
  {0.397081,0.235829,0.008208,-0.175202,-0.262865,-0.257743,-0.180912,-0.050464,0.108231,0.245855,0.298570,0.225857,0.045764,-0.165295,-0.311314,-0.326482,-0.204174,0.005933,0.221745,0.358071,0.354254,0.198191,-0.060193,-0.318401,-0.459063,-0.403282,0.197472,0.496776,0.592884,0.406474,-0.014629,-0.488614,-0.765607,-0.656979,-0.166285,0.470299,0.891349,0.825416,0.279883,-0.437949,-0.903161,-0.844991,-0.319195,0.340626,0.752054,0.723390,0.339659,-0.140092,-0.469512,-0.542153,-0.393859,-0.125874,-0.076112,-0.285236,-0.335781,-0.249409,-0.096808,0.059705,0.185673,0.258163,0.250880,0.147163,-0.031421,-0.215906,-0.319069,-0.285342,-0.124426,0.094161,0.277517,0.350587,0.282332,0.093643,-0.148247,-0.347957,-0.414595,-0.302430,-0.040685,0.268021,0.499945,0.276582,-0.110606,-0.495845,-0.682137,-0.536470,-0.080936,0.479575,0.838063,0.756804,0.233760,-0.458415,-0.915896,-0.855502,-0.306292,0.401054,0.848279,0.797863,0.327428,-0.253037,-0.621628,-0.633975,-0.361566,0.009575,0.311196,0.457630},
  {0.683330,0.529050,0.119361,-0.365006,-0.697037,-0.707276,-0.371416,0.163349,0.637236,0.804541,0.567147,0.038221,-0.509545,-0.790281,-0.663595,-0.210558,0.318863,0.652421,0.644351,0.338566,-0.081014,-0.408021,-0.519591,-0.413118,-0.171576,0.099703,0.426771,0.396176,0.216860,-0.073881,-0.376716,-0.551778,-0.485498,-0.169050,0.268249,0.608107,0.659247,0.373597,-0.113313,-0.550194,-0.709318,-0.513225,-0.072699,0.382605,0.632931,0.577882,0.269666,-0.133682,-0.454315,-0.569573,-0.447927,-0.146685,-0.010564,-0.452666,-0.699958,-0.626151,-0.249029,0.266636,0.675843,0.768164,0.479523,-0.060334,-0.581686,-0.812731,-0.629500,-0.129230,0.421470,0.736443,0.668332,0.280721,-0.204177,-0.541346,-0.593721,-0.383038,-0.046007,0.258515,0.425885,0.427901,0.061170,-0.198034,-0.409575,-0.484812,-0.360424,-0.050168,0.329147,0.593688,0.586566,0.278147,-0.195692,-0.593663,-0.700588,-0.452538,0.023101,0.478921,0.685985,0.554966,0.171399,-0.265590,-0.554045,-0.582541,-0.363423,-0.006219,0.339249,0.539379},
  {0.109810,0.277621,0.411018,0.433964,0.267243,-0.090700,-0.509044,-0.761049,-0.652863,-0.166930,0.486060,0.960674,0.970962,0.467164,-0.317812,-0.984630,-1.180170,-0.786457,0.015276,0.834542,1.265225,1.085514,0.368567,-0.547911,-1.220079,-1.311739,0.175185,1.048346,1.423833,1.102850,0.227955,-0.776817,-1.409622,-1.342690,-0.596793,0.456672,1.278272,1.441580,0.864372,-0.142185,-1.042187,-1.370610,-0.985816,-0.132308,0.716755,1.133562,0.958639,0.350875,-0.340405,-0.781791,-0.814404,-0.492688,0.326117,0.247429,0.071945,-0.195481,-0.473092,-0.608747,-0.464452,-0.031415,0.514703,0.880938,0.823776,0.313007,-0.420492,-0.995638,-1.090501,-0.626390,0.180832,0.929533,1.238703,0.941728,0.170902,-0.705254,-1.259080,-1.210899,-0.568498,0.368993,1.383528,0.942424,0.026393,-0.922266,-1.432203,-1.237991,-0.421021,0.619160,1.357751,1.412023,0.746899,-0.295971,-1.172615,-1.428149,-0.944582,-0.001260,0.889044,1.270733,0.989307,0.249473,-0.531120,-0.967176,-0.898689,-0.433454,0.154923,0.588388},
  {0.168274,0.119306,-0.010232,-0.154262,-0.229412,-0.180861,-0.019273,0.175343,0.292093,0.252954,0.064411,-0.177811,-0.338477,-0.319966,-0.121342,0.156169,0.361751,0.377359,0.185185,-0.117313,-0.365920,-0.419061,-0.240326,0.074958,0.350030,0.428862,-0.032081,-0.301183,-0.392486,-0.271655,-0.023554,0.210718,0.318396,0.266639,0.100160,-0.096489,-0.239527,-0.272225,-0.179853,0.001196,0.187801,0.281514,0.223086,0.038003,-0.166922,-0.266287,-0.200372,-0.018659,0.154111,0.206856,0.119375,-0.030044,-0.015199,-0.138779,-0.197548,-0.147344,-0.001966,0.166595,0.261774,0.216881,0.040290,-0.179448,-0.318121,-0.287539,-0.091500,0.169906,0.352847,0.350022,0.153126,-0.137991,-0.365976,-0.400983,-0.215122,0.095959,0.361093,0.429158,0.258698,-0.054123,-0.416623,-0.272934,0.006796,0.260811,0.358472,0.268558,0.059617,-0.154225,-0.277136,-0.267823,-0.141879,0.043575,0.209214,0.277950,0.208545,0.026540,-0.174579,-0.278803,-0.220481,-0.034271,0.161227,0.242129,0.165150,-0.004286,-0.143505,-0.163389},
  {-0.035981,0.405657,0.609868,0.508685,0.197712,-0.142033,-0.358176,-0.398419,-0.302171,-0.139640,0.040332,0.213744,0.349279,0.388588,0.273139,0.002993,-0.325463,-0.547933,-0.522297,-0.224468,0.217683,0.582277,0.673083,0.430362,-0.032573,-0.487612,-0.595429,-0.201424,0.281699,0.630896,0.693288,0.448101,0.005872,-0.444314,-0.711244,-0.674043,-0.331479,0.186188,0.654918,0.845101,0.634445,0.090562,-0.535312,-0.922111,-0.851314,-0.339448,0.356429,0.873751,0.944043,0.538650,-0.123206,-0.701430,0.694005,0.521822,0.124420,-0.278306,-0.496233,-0.465845,-0.256776,0.000770,0.203218,0.312431,0.333498,0.271979,0.121254,-0.107332,-0.347332,-0.482417,-0.408489,-0.114386,0.282253,0.581662,0.611207,0.330773,-0.133402,-0.550301,-0.706552,-0.519790,0.396960,0.685330,0.654026,0.325349,-0.145810,-0.549358,-0.712243,-0.565678,-0.167371,0.321064,0.691590,0.768808,0.490006,-0.046769,-0.602585,-0.897791,-0.756937,-0.220480,0.453240,0.914546,0.913931,0.445689,-0.245649,-0.801217,-0.943593,-0.618137},
  {0.710581,0.203355,-0.456255,-0.991414,-1.125622,-0.721899,0.103580,0.981756,1.447927,1.196874,0.288595,-0.839801,-1.590886,-1.538854,-0.679979,0.551863,1.516668,1.712914,1.041703,-0.148795,-1.252128,-1.717752,-1.326573,-0.291863,0.858901,1.556290,0.684681,-0.397990,-1.238117,-1.449868,-0.972672,-0.073643,0.805523,1.265895,1.126236,0.485523,-0.339719,-0.966773,-1.120630,-0.756202,-0.072321,0.592867,0.934520,0.829377,0.378325,-0.173579,-0.580186,-0.708302,-0.564444,-0.245621,0.127605,0.447214,-0.596125,-0.953367,-0.923772,-0.460725,0.288668,1.001546,1.304380,0.971656,0.090776,-0.928840,-1.545788,-1.387879,-0.486017,0.713480,1.580571,1.647306,0.866901,-0.360635,-1.404631,-1.736232,-1.197574,-0.072558,1.067544,1.657653,1.420917,0.498670,-1.415190,-1.484052,-0.844004,0.159585,1.031733,1.375317,1.067711,0.292189,-0.570902,-1.127815,-1.144996,-0.643163,0.122608,0.787292,1.050602,0.818832,0.240051,-0.386829,-0.775373,-0.790473,-0.486568,-0.040314,0.359784,0.591076,0.610597,0.430872},
  {-0.273416,-0.190613,0.011739,0.227905,0.337115,0.272028,0.057317,-0.201672,-0.372207,-0.361140,-0.163005,0.133114,0.382078,0.451275,0.289438,-0.038207,-0.371385,-0.530392,-0.413072,-0.061407,0.346170,0.583735,0.505885,0.141050,-0.312357,-0.594915,-0.180928,0.270561,0.549164,0.501980,0.177704,-0.214107,-0.442927,-0.399535,-0.147949,0.137473,0.294589,0.267342,0.115318,-0.049962,-0.143669,-0.146449,-0.090545,-0.020859,0.033235,0.061523,0.063619,0.043734,0.012874,-0.011596,-0.016370,-0.005289,0.030764,0.222449,0.308932,0.230220,0.017638,-0.220792,-0.358073,-0.315877,-0.106348,0.171839,0.380027,0.406745,0.224963,-0.087717,-0.378962,-0.493087,-0.353286,-0.012540,0.360168,0.561283,0.465157,0.105216,-0.330111,-0.595638,-0.531895,-0.166668,0.579790,0.530513,0.184062,-0.244707,-0.503048,-0.457054,-0.164584,0.178207,0.371911,0.334456,0.130825,-0.093692,-0.216553,-0.203341,-0.102147,0.010330,0.081238,0.098997,0.078551,0.039754,-0.001807,-0.033036,-0.043384,-0.031914,-0.012366,-0.004964},
  {-0.542972,-0.801975,-0.621509,-0.087677,0.501578,0.809087,0.661431,0.152988,-0.415871,-0.724804,-0.622438,-0.200685,0.281900,0.565310,0.531413,0.244325,-0.116641,-0.370675,-0.422227,-0.283319,-0.041855,0.189671,0.318082,0.298147,0.146768,-0.061349,-0.260782,-0.162759,0.002376,0.131387,0.154989,0.083764,-0.005745,-0.035940,0.007104,0.062875,0.050845,-0.053343,-0.184499,-0.229965,-0.118781,0.111248,0.324421,0.373694,0.202947,-0.107820,-0.386424,-0.471586,-0.307699,0.025449,0.359195,0.525149,-0.569695,-0.043916,0.526987,0.816825,0.652234,0.123553,-0.464917,-0.778033,-0.650510,-0.178008,0.354412,0.652375,0.581245,0.222590,-0.201211,-0.469317,-0.477229,-0.265227,0.033608,0.275605,0.368805,0.295524,0.103738,-0.117282,-0.270002,-0.287530,0.023148,0.177832,0.216449,0.134129,0.002586,-0.083900,-0.078964,-0.016155,0.024472,-0.010754,-0.097197,-0.146954,-0.082708,0.088175,0.262224,0.306769,0.158718,-0.118786,-0.366649,-0.428755,-0.252329,0.076699,0.383384,0.503125,0.369403,0.044083},
  {-0.512005,-0.853388,-0.745720,-0.251944,0.358590,0.764798,0.767989,0.388684,-0.159165,-0.592308,-0.707558,-0.476997,-0.044627,0.364385,0.564843,0.495114,0.224552,-0.104635,-0.355041,-0.445887,-0.363996,-0.149750,0.119984,0.347260,0.438163,0.342649,-0.207952,-0.412140,-0.425918,-0.250108,0.023765,0.270132,0.393707,0.361465,0.196140,-0.044933,-0.283394,-0.429182,-0.405246,-0.191870,0.137866,0.432066,0.534131,0.376775,0.030241,-0.333380,-0.537213,-0.492646,-0.232480,0.122392,0.426066,0.560356,-0.702198,-0.174442,0.443559,0.821689,0.767300,0.324452,-0.261922,-0.687020,-0.748142,-0.440719,0.055595,0.483869,0.646154,0.495270,0.138656,-0.236700,-0.466269,-0.477849,-0.300499,-0.026465,0.237344,0.401770,0.411409,0.257560,-0.009172,-0.282856,-0.399591,-0.177022,0.121617,0.354857,0.422606,0.311122,0.083691,-0.163914,-0.345201,-0.401390,-0.306325,-0.076802,0.213357,0.441085,0.483708,0.293127,-0.057189,-0.397215,-0.552097,-0.442491,-0.126473,0.240526,0.493032,0.530856,0.346869,0.013767},
  {0.204254,-0.181908,-0.464882,-0.543041,-0.400630,-0.096144,0.257440,0.519125,0.565565,0.352282,-0.043711,-0.441349,-0.640716,-0.532361,-0.162499,0.288579,0.601312,0.627791,0.359554,-0.074961,-0.473132,-0.649551,-0.519762,-0.142910,0.300090,0.591888,0.306839,-0.104773,-0.435669,-0.539352,-0.398702,-0.110255,0.188174,0.387483,0.435016,0.326326,0.093501,-0.192834,-0.424871,-0.489829,-0.331787,-0.002338,0.347582,0.543042,0.482831,0.195251,-0.181356,-0.473803,-0.555131,-0.392265,-0.051795,0.325588,-0.551712,-0.540105,-0.302802,0.044977,0.364277,0.536305,0.490908,0.231385,-0.149715,-0.488661,-0.617172,-0.453330,-0.060188,0.374648,0.634713,0.589900,0.263026,-0.186518,-0.545419,-0.647624,-0.447364,-0.037686,0.390064,0.631922,0.569505,0.233908,-0.526764,-0.580281,-0.361123,-0.000621,0.320848,0.472636,0.422559,0.220818,-0.046574,-0.291944,-0.436451,-0.418804,-0.222116,0.094342,0.396565,0.532475,0.418696,0.098279,-0.275579,-0.521999,-0.527007,-0.293891,0.069554,0.405661,0.570303,0.485334},
  {0.603175,-0.037661,-0.629528,-0.917279,-0.793044,-0.320909,0.295720,0.788936,0.930498,0.637630,0.030442,-0.605903,-0.955261,-0.837148,-0.309178,0.360337,0.836541,0.894288,0.526569,-0.067755,-0.597411,-0.824014,-0.665911,-0.219875,0.297248,0.652751,0.439287,0.003173,-0.406504,-0.615276,-0.549423,-0.258050,0.120424,0.424908,0.538565,0.429847,0.156369,-0.165046,-0.408038,-0.485557,-0.378131,-0.132203,0.164450,0.412783,0.525288,0.444062,0.164467,-0.237940,-0.603169,-0.736846,-0.514094,0.016986,-0.776386,-0.960462,-0.701068,-0.140804,0.465739,0.859584,0.872235,0.490216,-0.128277,-0.704875,-0.960075,-0.754861,-0.176858,0.490874,0.913636,0.883174,0.426260,-0.217384,-0.728738,-0.873415,-0.607591,-0.080831,0.450853,0.749426,0.697875,0.341450,-0.537174,-0.672732,-0.509288,-0.138711,0.265601,0.531192,0.559129,0.356601,0.022394,-0.301351,-0.488063,-0.473758,-0.276120,0.019606,0.299421,0.464564,0.461037,0.287842,-0.007494,-0.334955,-0.572275,-0.596023,-0.341999,0.129529,0.617868,0.857863},
  {0.814051,0.434127,-0.188148,-0.734874,-0.918496,-0.637023,-0.031390,0.588198,0.907639,0.774120,0.269357,-0.345476,-0.773436,-0.827903,-0.506054,0.031638,0.545127,0.813983,0.719034,0.290895,-0.288801,-0.749815,-0.855131,-0.532973,0.062641,0.620465,0.633714,0.124913,-0.392968,-0.665319,-0.605039,-0.301607,0.073004,0.370629,0.512138,0.472626,0.260662,-0.071003,-0.405238,-0.584066,-0.492572,-0.149869,0.275261,0.556142,0.549629,0.282394,-0.080938,-0.355759,-0.445566,-0.365207,-0.185292,0.032747,-0.279851,-0.767981,-0.879579,-0.541451,0.082631,0.674334,0.928530,0.715757,0.149649,-0.477920,-0.855254,-0.811028,-0.388766,0.194576,0.667405,0.827813,0.617997,0.134002,-0.415971,-0.788215,-0.801198,-0.427212,0.170082,0.695508,0.872001,0.602111,-0.520233,-0.775362,-0.632014,-0.213041,0.241277,0.525795,0.562299,0.389843,0.099370,-0.214699,-0.459575,-0.541013,-0.395771,-0.051670,0.345727,0.591462,0.544127,0.225140,-0.188095,-0.476242,-0.513888,-0.327551,-0.045353,0.203810,0.354765,0.397027},
  {0.502440,0.135893,-0.297257,-0.600865,-0.646280,-0.404510,0.048815,0.540611,0.838623,0.746597,0.233588,-0.489152,-1.034332,-1.050897,-0.462539,0.439761,1.143225,1.222714,0.613065,-0.341694,-1.097564,-1.238742,-0.713185,0.161579,0.903596,1.140213,0.073424,-0.631209,-0.982580,-0.835200,-0.291715,0.361107,0.798130,0.815437,0.427874,-0.145182,-0.600289,-0.712967,-0.453695,0.007248,0.406088,0.538651,0.370138,0.039446,-0.239721,-0.316165,-0.189263,0.007719,0.114977,0.066968,-0.062301,-0.125080,-0.376840,-0.619343,-0.568246,-0.255542,0.184006,0.571834,0.737581,0.572788,0.094690,-0.512649,-0.941324,-0.910666,-0.358000,0.466970,1.105246,1.156747,0.546542,-0.400067,-1.141264,-1.248627,-0.667041,0.261723,1.015697,1.200033,0.754287,-0.046942,-1.066081,-0.818746,-0.189462,0.491779,0.892709,0.835221,0.372759,-0.244455,-0.700095,-0.774448,-0.454929,0.065523,0.501226,0.633329,0.425001,0.028094,-0.318096,-0.432032,-0.290753,-0.026881,0.172102,0.193507,0.069574,-0.060330,-0.067247,0.059201},
  {0.498298,-0.278995,-0.894495,-1.053865,-0.709041,-0.062259,0.560013,0.879772,0.791197,0.381814,-0.139960,-0.556297,-0.727981,-0.624468,-0.303396,0.126336,0.530133,0.764493,0.710261,0.334373,-0.250803,-0.791954,-1.000323,-0.719622,-0.048974,0.680478,0.945649,0.347576,-0.394318,-0.918159,-1.005934,-0.660183,-0.055968,0.561491,0.961310,0.979895,0.570721,-0.143501,-0.866299,-1.230361,-0.994695,-0.221521,0.709367,1.296021,1.211178,0.503437,-0.435580,-1.111759,-1.209694,-0.737232,0.029044,0.722948,-1.008437,-1.073971,-0.618651,0.109602,0.742287,0.987654,0.767441,0.228706,-0.356496,-0.734491,-0.778139,-0.515122,-0.082303,0.350903,0.643378,0.707861,0.515769,0.106521,-0.396358,-0.793337,-0.875829,-0.543020,0.100871,0.756106,1.072294,0.855059,-0.560431,-1.030721,-0.993596,-0.501210,0.185602,0.756443,0.992173,0.822202,0.314669,-0.351502,-0.919078,-1.121033,-0.803416,-0.049737,0.798861,1.292630,1.132228,0.371370,-0.589975,-1.234991,-1.234189,-0.623763,0.246375,0.936009,1.149073,0.845137},
  {0.233655,0.248372,0.132949,-0.116327,-0.385947,-0.497835,-0.335407,0.053774,0.465161,0.657359,0.503031,0.068764,-0.422926,-0.717103,-0.658667,-0.266449,0.277071,0.708645,0.805357,0.496660,-0.085060,-0.652833,-0.904968,-0.690932,-0.107196,0.543208,0.806144,0.281699,-0.377655,-0.825607,-0.837340,-0.422647,0.188382,0.673248,0.788668,0.496070,-0.025438,-0.486075,-0.651777,-0.471357,-0.087698,0.268724,0.426723,0.360841,0.168200,-0.027395,-0.158095,-0.222078,-0.235431,-0.190835,-0.069916,0.108553,0.020371,-0.139382,-0.313966,-0.381013,-0.239128,0.089758,0.439137,0.591005,0.422329,-0.002272,-0.459635,-0.698054,-0.581132,-0.159637,0.359637,0.719360,0.734747,0.381839,-0.183235,-0.686637,-0.864309,-0.602004,-0.012636,0.605502,0.922152,0.759397,-0.466280,-0.880110,-0.831765,-0.358101,0.282751,0.755077,0.823251,0.470307,-0.101084,-0.583228,-0.731941,-0.496539,-0.036991,0.381387,0.548779,0.423891,0.130193,-0.149314,-0.293027,-0.290790,-0.203685,-0.089394,0.033586,0.160650,0.258681,0.266026},
  {-0.070859,-0.387111,-0.464931,-0.313185,-0.058348,0.142306,0.199650,0.138987,0.061753,0.052283,0.103749,0.125238,0.027335,-0.183321,-0.382669,-0.407749,-0.181215,0.212466,0.560749,0.648600,0.393003,-0.100061,-0.588253,-0.819236,-0.658769,-0.158292,0.912767,0.952012,0.518182,-0.222897,-0.926612,-1.221803,-0.905810,-0.080831,0.859857,1.415217,1.247811,0.393742,-0.722329,-1.498127,-1.486923,-0.664169,0.536942,1.456908,1.583494,0.849079,-0.328680,-1.290818,-1.519404,-0.927382,0.114052,1.014252,-0.574455,-0.350666,-0.010767,0.258391,0.339495,0.241200,0.073968,-0.038525,-0.049582,-0.013806,-0.026553,-0.127678,-0.251209,-0.268622,-0.097016,0.213541,0.488457,0.535901,0.279827,-0.175397,-0.594576,-0.743392,-0.520084,-0.012602,0.543216,0.875775,0.329846,-0.354467,-0.929839,-1.093422,-0.713408,0.075525,0.903048,1.330747,1.086519,0.239454,-0.798733,-1.471719,-1.383115,-0.537295,0.633927,1.493328,1.554784,0.769311,-0.434410,-1.389063,-1.571504,-0.901686,0.221431,1.164497,1.430300,0.928238},
  {-1.978777,-0.797507,0.681010,1.788511,2.070153,1.448159,0.219277,-1.082461,-1.900228,-1.879323,-1.024315,0.287228,1.463524,1.971599,1.590735,0.511417,-0.769355,-1.689682,-1.869256,-1.250306,-0.097590,1.113921,1.874817,1.835489,0.966213,-0.388497,-2.136691,-1.647597,-0.360926,1.109998,2.053272,2.023714,1.058501,-0.365692,-1.587492,-2.074585,-1.642498,-0.502649,0.847966,1.833264,2.026371,1.326409,0.016601,-1.336058,-2.118381,-1.951292,-0.879948,0.627602,1.883348,2.293811,1.641028,0.199006,1.107555,2.068423,2.057506,1.141719,-0.230685,-1.453969,-2.017864,-1.699718,-0.644656,0.689509,1.715745,1.972784,1.342658,0.115473,-1.145643,-1.874861,-1.765753,-0.893019,0.348333,1.429974,1.904632,1.569908,0.544258,-0.760867,-1.780961,-2.029631,0.011068,1.398501,2.145821,1.877072,0.719732,-0.762139,-1.863306,-2.088210,-1.369408,-0.062848,1.242630,1.988000,1.865742,0.931033,-0.422542,-1.614515,-2.113078,-1.670798,-0.454962,1.003947,2.040383,2.160168,1.279546,-0.220717,-1.656912,-2.351012},
  {-0.022694,-1.332647,-1.951418,-1.594334,-0.479425,0.808238,1.634779,1.637999,0.882308,-0.215304,-1.123438,-1.457251,-1.131828,-0.355226,0.503502,1.087601,1.188711,0.804922,0.118635,-0.584993,-1.028459,-1.045515,-0.641810,0.011870,0.651785,1.027228,0.565446,-0.103175,-0.760635,-1.143886,-1.070328,-0.522314,0.312298,1.083285,1.416375,1.100374,0.225742,-0.820357,-1.526610,-1.519338,-0.769764,0.375586,1.364269,1.715580,1.257493,0.204182,-0.953682,-1.680807,-1.639081,-0.836290,0.374697,1.444291,-2.019067,-1.486245,-0.236787,1.084168,1.821553,1.645216,0.697024,-0.514943,-1.398772,-1.574130,-1.029012,-0.078874,0.820611,1.292824,1.186279,0.601239,-0.185925,-0.849065,-1.136488,-0.955716,-0.397950,0.303255,0.865617,1.069592,0.842467,0.280739,-0.921854,-1.095588,-0.832240,-0.207491,0.553576,1.139562,1.268588,0.825069,-0.048774,-0.976256,-1.504560,-1.335091,-0.501367,0.618577,1.479502,1.646984,1.023892,-0.098237,-1.186058,-1.725830,-1.464576,-0.520111,0.678772,1.585125,1.774887,1.138668},
  {-1.636050,-1.173962,-0.151503,0.923100,1.528226,1.378406,0.560616,-0.510599,-1.302367,-1.433469,-0.863633,0.097894,0.963870,1.321602,1.030795,0.272030,-0.563594,-1.075960,-1.046736,-0.531859,0.183034,0.738760,0.889070,0.617038,0.117628,-0.336885,-0.518981,-0.323788,-0.092360,0.115620,0.295462,0.433348,0.465820,0.316720,-0.016617,-0.412826,-0.672339,-0.636798,-0.293939,0.208749,0.644689,0.820361,0.651997,0.186513,-0.413753,-0.907743,-1.046604,-0.688716,0.082524,0.930155,1.395644,1.156390,0.070734,1.116613,1.596316,1.291393,0.365769,-0.719094,-1.430513,-1.427192,-0.728087,0.302060,1.145220,1.397114,0.965020,0.096089,-0.766504,-1.212549,-1.059003,-0.420472,0.366014,0.916848,0.990766,0.598607,-0.020883,-0.544369,-0.742703,-0.588465,0.121714,0.343370,0.417924,0.391761,0.293059,0.109531,-0.160055,-0.442862,-0.596121,-0.494431,-0.133988,0.336142,0.688292,0.743884,0.466233,-0.031932,-0.549003,-0.872996,-0.848204,-0.432714,0.253666,0.927337,1.234269,0.935528,0.089401,-0.910665},
  {-0.026361,0.197466,0.310714,0.244461,0.047632,-0.156279,-0.258506,-0.228471,-0.110456,0.027681,0.140490,0.210042,0.221829,0.152395,-0.006993,-0.211293,-0.355493,-0.328721,-0.100825,0.227433,0.464778,0.448459,0.162744,-0.233642,-0.501479,-0.477060,0.198746,0.435275,0.410614,0.177019,-0.101490,-0.271813,-0.282135,-0.181785,-0.051939,0.060318,0.149946,0.213603,0.218357,0.122965,-0.064864,-0.257750,-0.330630,-0.214251,0.037035,0.268964,0.334053,0.199397,-0.031952,-0.203482,-0.222856,-0.118951,0.299980,0.239078,0.033573,-0.188664,-0.295710,-0.239098,-0.072575,0.101392,0.204605,0.217556,0.161030,0.059201,-0.072681,-0.207903,-0.288528,-0.244598,-0.051927,0.218730,0.416387,0.398406,0.137895,-0.233756,-0.494745,-0.475242,-0.176341,0.223102,0.454502,0.179822,-0.158359,-0.363594,-0.350771,-0.176575,0.029951,0.167548,0.212685,0.194325,0.137505,0.039661,-0.099685,-0.236508,-0.285481,-0.182422,0.045137,0.270751,0.347735,0.218605,-0.034841,-0.247322,-0.290758,-0.163420,0.022440,0.138583},
  {-0.221400,0.213980,0.501586,0.490407,0.218689,-0.130521,-0.358391,-0.367667,-0.196860,0.031082,0.193783,0.231158,0.158448,0.039261,-0.057614,-0.094866,-0.080498,-0.052271,-0.042309,-0.047920,-0.034839,0.025660,0.117296,0.177308,0.142984,0.010038,-0.239707,-0.200783,-0.060684,0.097855,0.199234,0.216920,0.164255,0.059597,-0.085526,-0.240565,-0.331664,-0.269435,-0.027490,0.295587,0.505980,0.439701,0.095073,-0.339325,-0.598213,-0.517365,-0.143768,0.300708,0.567453,0.528978,0.231498,-0.159030,0.546978,0.531271,0.224396,-0.176051,-0.436673,-0.433348,-0.208930,0.080294,0.274845,0.299268,0.181138,0.010530,-0.120642,-0.163503,-0.125398,-0.052786,0.004006,0.024090,0.025435,0.041610,0.082941,0.117253,0.093312,-0.008138,-0.141865,-0.220334,-0.031313,0.137678,0.232171,0.211273,0.103751,-0.030632,-0.147168,-0.224896,-0.241964,-0.163663,0.024587,0.265309,0.423700,0.364615,0.066898,-0.323588,-0.566883,-0.490192,-0.117947,0.333572,0.597275,0.527377,0.180187,-0.240620,-0.517102,-0.530557},
  {0.233868,0.113562,-0.027758,-0.123166,-0.146311,-0.108013,-0.039186,0.025155,0.058751,0.055633,0.034329,0.024869,0.041263,0.061651,0.040744,-0.046423,-0.164588,-0.225122,-0.148343,0.061400,0.292637,0.387458,0.251623,-0.065556,-0.385854,-0.508895,0.037006,0.416737,0.579388,0.425462,0.032312,-0.387904,-0.605018,-0.497934,-0.122711,0.316859,0.582114,0.533335,0.206751,-0.211323,-0.496226,-0.511905,-0.275909,0.069430,0.348880,0.444962,0.338655,0.095343,-0.176339,-0.365546,-0.392908,-0.240185,-0.076938,-0.186664,-0.190296,-0.114755,-0.012945,0.068141,0.102876,0.089452,0.046761,0.005184,-0.011479,-0.004920,-0.003700,-0.037414,-0.100381,-0.140283,-0.093280,0.054286,0.230362,0.309524,0.201799,-0.066139,-0.345977,-0.454615,-0.297794,0.056537,0.550158,0.383993,-0.006766,-0.408695,-0.597617,-0.464454,-0.076799,0.356775,0.600524,0.522054,0.166667,-0.268533,-0.547690,-0.529838,-0.242784,0.144759,0.428764,0.482192,0.307625,0.012167,-0.262388,-0.404855,-0.368048,-0.173685,0.097569,0.328759},
  {0.940838,-0.073103,-1.078988,-1.575295,-1.296355,-0.365005,0.753356,1.487850,1.467160,0.718731,-0.354568,-1.203300,-1.426463,-0.963150,-0.087714,0.761978,1.208414,1.092892,0.511938,-0.254858,-0.874283,-1.092710,-0.831764,-0.216835,0.475798,0.939168,0.580078,-0.050971,-0.631012,-0.912951,-0.796043,-0.354536,0.211566,0.669073,0.843355,0.677083,0.242764,-0.288654,-0.710522,-0.854781,-0.654394,-0.173068,0.409641,0.857120,0.964350,0.649258,0.009354,-0.692743,-1.128644,-1.058714,-0.469081,0.391159,-1.207744,-1.548382,-1.137478,-0.153292,0.926527,1.556311,1.408117,0.554853,-0.561799,-1.369164,-1.472281,-0.854965,0.135888,0.997367,1.335878,1.042897,0.307263,-0.509986,-1.052158,-1.110604,-0.690292,0.009108,0.680595,1.036110,0.928083,0.415077,-0.802794,-0.968613,-0.708012,-0.157850,0.430844,0.811263,0.841811,0.530478,0.016419,-0.492651,-0.799497,-0.786932,-0.458085,0.064151,0.578884,0.878115,0.825044,0.414181,-0.210389,-0.794123,-1.067155,-0.867629,-0.239197,0.557066,1.144569,1.213169},
  {1.646456,0.625323,-0.671039,-1.647114,-1.864375,-1.234307,-0.050301,1.149175,1.822801,1.668098,0.756991,-0.495989,-1.520940,-1.851971,-1.339920,-0.219906,0.997054,1.757372,1.716056,0.892778,-0.336368,-1.408422,-1.830568,-1.409329,-0.343936,0.865595,1.673268,0.930836,-0.204827,-1.206868,-1.639727,-1.346057,-0.488825,0.547645,1.330996,1.548724,1.116439,0.204711,-0.818222,-1.518385,-1.571076,-0.915910,0.186691,1.247350,1.765514,1.474142,0.483892,-0.755677,-1.664992,-1.810855,-1.114193,0.110038,-1.000354,-1.812943,-1.786640,-0.945887,0.315977,1.422822,1.876821,1.478606,0.412779,-0.836503,-1.703096,-1.794347,-1.069813,0.139586,1.282490,1.839100,1.557884,0.568808,-0.676867,-1.611478,-1.808415,-1.177429,-0.008958,1.156692,1.780018,1.577230,-0.544899,-1.463461,-1.693806,-1.163168,-0.143707,0.897077,1.516049,1.475513,0.817612,-0.174628,-1.094749,-1.563540,-1.371727,-0.573362,0.512154,1.412632,1.704504,1.219476,0.148520,-1.026124,-1.751737,-1.672837,-0.809386,0.446023,1.510779,1.885251},
  {-0.307090,0.273646,0.672929,0.706891,0.401254,-0.053341,-0.427264,-0.570317,-0.459803,-0.176143,0.153147,0.402338,0.479898,0.354247,0.073538,-0.239657,-0.436567,-0.420056,-0.204724,0.088007,0.303895,0.349502,0.238787,0.062932,-0.085435,-0.169386,-0.211375,-0.175742,-0.062686,0.129962,0.330701,0.415983,0.291607,-0.023835,-0.382222,-0.580353,-0.483347,-0.116296,0.338421,0.639608,0.622079,0.287834,-0.196624,-0.590156,-0.700360,-0.475214,-0.021926,0.447998,0.716141,0.653521,0.278506,-0.245451,0.763584,0.746839,0.359299,-0.167452,-0.558401,-0.645795,-0.434579,-0.063577,0.288804,0.487267,0.475826,0.275892,-0.029830,-0.319290,-0.468150,-0.403899,-0.152226,0.163064,0.382141,0.401249,0.232430,-0.012901,-0.203518,-0.269855,-0.228144,-0.138589,0.056005,0.171337,0.277092,0.302412,0.180210,-0.080923,-0.367159,-0.510146,-0.393412,-0.041859,0.373032,0.623870,0.559919,0.198815,-0.278927,-0.627874,-0.669055,-0.380960,0.094867,0.529006,0.715911,0.567257,0.148428,-0.351683,-0.701985,-0.730219},
  {-0.307536,-0.469893,-0.412099,-0.134721,0.231956,0.495688,0.515200,0.280753,-0.087325,-0.410511,-0.541682,-0.425113,-0.111727,0.262752,0.527798,0.549111,0.299684,-0.109333,-0.472295,-0.597762,-0.420073,-0.038682,0.343425,0.539077,0.473339,0.202342,-0.403782,-0.494021,-0.374089,-0.086034,0.253849,0.488521,0.492436,0.250219,-0.117557,-0.415811,-0.491696,-0.325118,-0.027988,0.240508,0.371286,0.345029,0.204087,0.004770,-0.200418,-0.350272,-0.373552,-0.227394,0.049584,0.328324,0.454668,0.350606,-0.323802,-0.054671,0.276820,0.497428,0.475598,0.208828,-0.168930,-0.465028,-0.535339,-0.353026,-0.008833,0.340221,0.538675,0.492814,0.211676,-0.184753,-0.507121,-0.586164,-0.369738,0.035882,0.418618,0.581372,0.452999,0.117690,-0.247952,-0.477059,-0.290043,0.022978,0.327487,0.496337,0.444900,0.179192,-0.184593,-0.463839,-0.509027,-0.297752,0.048195,0.340904,0.443180,0.338640,0.112895,-0.121517,-0.286773,-0.348754,-0.294466,-0.125107,0.120216,0.345744,0.430015,0.303451,0.012846,-0.290630},
  {-0.165471,0.465904,0.847701,0.792916,0.342731,-0.260377,-0.704019,-0.771591,-0.452637,0.062349,0.497194,0.645258,0.472160,0.110222,-0.239611,-0.425939,-0.410315,-0.250351,-0.036556,0.159855,0.296903,0.344319,0.275935,0.090552,-0.158843,-0.366151,-0.276359,0.007783,0.293332,0.438822,0.378224,0.151196,-0.128272,-0.337022,-0.398584,-0.303406,-0.096550,0.147053,0.344183,0.421056,0.334187,0.094384,-0.219639,-0.476558,-0.543287,-0.354491,0.035836,0.457611,0.695330,0.599688,0.181946,-0.368913,0.893119,0.768375,0.260039,-0.364096,-0.784234,-0.794847,-0.408255,0.158861,0.607998,0.721634,0.473867,0.027601,-0.373360,-0.545042,-0.449757,-0.184867,0.100796,0.294864,0.358054,0.304538,0.164770,-0.029008,-0.229879,-0.366026,-0.362968,-0.193445,0.342184,0.445951,0.337926,0.071272,-0.220900,-0.401269,-0.398107,-0.229674,0.020468,0.250688,0.380441,0.368498,0.216652,-0.030645,-0.290290,-0.457804,-0.444359,-0.224099,0.133913,0.476407,0.627835,0.481243,0.070897,-0.421264,-0.743367,-0.705048},
  {-1.401286,-0.876075,0.061742,0.943628,1.354498,1.115337,0.349147,-0.580243,-1.229602,-1.280547,-0.701171,0.222770,1.023502,1.295836,0.915634,0.101466,-0.716702,-1.137151,-0.989245,-0.392413,0.337197,0.857521,0.954260,0.617297,0.026346,-0.537195,-0.705157,-0.282265,0.221540,0.561252,0.607500,0.397641,0.080365,-0.194031,-0.351690,-0.394050,-0.343845,-0.205391,0.020513,0.290400,0.500086,0.528657,0.318408,-0.071243,-0.478585,-0.714014,-0.648704,-0.275358,0.276758,0.775189,0.966811,0.698190,0.252370,1.102001,1.389502,1.000254,0.143756,-0.765389,-1.300892,-1.212331,-0.539151,0.397691,1.138347,1.310356,0.827432,-0.056652,-0.882616,-1.236436,-0.968020,-0.251907,0.531492,1.007177,0.983854,0.517162,-0.146837,-0.698385,-0.899937,-0.682808,0.377871,0.705575,0.679762,0.356870,-0.068346,-0.388089,-0.494712,-0.408775,-0.220334,-0.008645,0.190147,0.355019,0.440642,0.382254,0.150074,-0.196905,-0.513899,-0.639212,-0.484337,-0.087410,0.396741,0.757333,0.810881,0.483523,-0.130968,-0.772625},
  {0.734164,0.510925,0.076101,-0.370995,-0.646094,-0.646308,-0.377413,0.052570,0.469089,0.693709,0.619382,0.265875,-0.218830,-0.620148,-0.753964,-0.551172,-0.090678,0.430863,0.778659,0.780330,0.411013,-0.176714,-0.706677,-0.908625,-0.664795,-0.087067,0.882338,0.796273,0.339537,-0.247936,-0.690533,-0.809534,-0.581218,-0.117211,0.393418,0.746779,0.786926,0.471213,-0.085115,-0.630812,-0.888847,-0.710331,-0.174867,0.441541,0.821957,0.788109,0.387666,-0.157074,-0.587444,-0.735307,-0.572804,-0.188819,-0.073513,-0.510546,-0.703205,-0.587281,-0.229600,0.215197,0.567219,0.683492,0.509925,0.109431,-0.352711,-0.672997,-0.701156,-0.413849,0.069496,0.537536,0.779045,0.674911,0.254124,-0.307911,-0.754503,-0.860772,-0.550899,0.043771,0.633627,0.917111,0.214656,-0.403998,-0.804916,-0.815273,-0.462194,0.070802,0.549216,0.785176,0.692067,0.302693,-0.235465,-0.695906,-0.855840,-0.609999,-0.052043,0.547461,0.878490,0.768956,0.285573,-0.310822,-0.722166,-0.774154,-0.483578,-0.013100,0.429869,0.679132},
  {-1.588363,-1.686028,-0.958124,0.236068,1.298151,1.698289,1.253162,0.217216,-0.866230,-1.465187,-1.333041,-0.603993,0.323058,1.016737,1.215371,0.902762,0.258751,-0.447351,-0.954623,-1.079180,-0.765079,-0.118484,0.603703,1.081079,1.077541,0.575101,-0.867660,-1.123945,-0.864556,-0.239805,0.448003,0.905202,0.972098,0.659129,0.106532,-0.483412,-0.904791,-0.995204,-0.686000,-0.051481,0.678153,1.180207,1.180066,0.608717,-0.318338,-1.170041,-1.504324,-1.107553,-0.132387,0.956018,1.609434,1.482460,-0.741326,0.477500,1.461864,1.722020,1.131285,-0.002709,-1.098751,-1.612200,-1.320204,-0.420253,0.605181,1.263245,1.295883,0.765985,-0.030543,-0.739492,-1.099164,-1.009311,-0.529272,0.156439,0.787915,1.105265,0.951644,0.365281,-0.405461,-1.002223,-0.742421,-0.020455,0.680481,1.044908,0.940894,0.455364,-0.181172,-0.714318,-0.959495,-0.842111,-0.400444,0.224256,0.810094,1.110125,0.949760,0.332638,-0.512642,-1.200914,-1.367365,-0.869972,0.101094,1.087669,1.585895,1.313773,0.374884,-0.779321},
  {-0.286877,0.463711,1.010347,1.105813,0.696810,-0.038568,-0.759541,-1.121867,-0.953269,-0.345365,0.397431,0.923526,1.012604,0.663930,0.061333,-0.536766,-0.904882,-0.912754,-0.550449,0.062478,0.691156,1.053660,0.948081,0.380458,-0.400154,-1.011160,-0.727151,0.020135,0.736842,1.101950,0.978484,0.443216,-0.274676,-0.888434,-1.145672,-0.913369,-0.248598,0.584298,1.197845,1.263225,0.702825,-0.233039,-1.077124,-1.394539,-1.022806,-0.157165,0.763953,1.295211,1.203373,0.560228,-0.316037,-1.021261,1.091152,1.027941,0.505707,-0.249515,-0.899120,-1.139212,-0.848714,-0.161163,0.592166,1.049846,1.007225,0.512853,-0.177618,-0.748764,-0.975683,-0.798220,-0.308906,0.302567,0.808218,1.001057,0.769000,0.168786,-0.555569,-1.059994,-1.074705,-0.566881,0.902751,1.148818,0.863428,0.204050,-0.522513,-1.011286,-1.073325,-0.685014,0.011537,0.743710,1.189808,1.111145,0.490279,-0.413774,-1.161995,-1.359143,-0.880758,0.042222,0.942763,1.371113,1.129964,0.360633,-0.550668,-1.175610,-1.242798,-0.745352},
  {0.153289,-0.398974,-0.722312,-0.689186,-0.362975,0.069056,0.415788,0.569232,0.516218,0.299293,-0.018203,-0.354041,-0.597075,-0.627617,-0.381276,0.082626,0.570883,0.835985,0.711528,0.221234,-0.412823,-0.876811,-0.929319,-0.530760,0.133216,0.744677,0.805182,0.222826,-0.467445,-0.949400,-1.001428,-0.593790,0.097238,0.762449,1.091989,0.916022,0.294267,-0.493394,-1.066188,-1.127955,-0.628714,0.191896,0.918448,1.179017,0.847579,0.109616,-0.647785,-1.051838,-0.935179,-0.397478,0.277732,0.781004,-0.817219,-0.697505,-0.265218,0.242562,0.585836,0.644263,0.447008,0.114693,-0.222705,-0.470629,-0.567687,-0.473904,-0.186426,0.223688,0.599538,0.750777,0.558341,0.066614,-0.508651,-0.878606,-0.836313,-0.377546,0.286025,0.831261,0.988056,0.675248,-0.621455,-0.997644,-0.915285,-0.410445,0.289867,0.869357,1.060852,0.764930,0.100856,-0.634902,-1.093983,-1.039404,-0.473100,0.344096,1.007889,1.175767,0.754701,-0.040048,-0.797893,-1.136830,-0.906970,-0.255951,0.472094,0.930207,0.936232,0.531374},
  {-0.202130,-0.826504,-0.982129,-0.633300,-0.007477,0.557992,0.800690,0.645951,0.209326,-0.283418,-0.605004,-0.620780,-0.341998,0.080069,0.426186,0.524091,0.345996,0.022415,-0.246209,-0.323261,-0.217867,-0.054336,0.041465,0.041476,0.018507,0.057531,0.235970,0.177412,-0.030312,-0.281424,-0.417181,-0.337907,-0.071058,0.249489,0.466030,0.477734,0.276070,-0.063540,-0.409882,-0.612456,-0.553088,-0.210810,0.293330,0.720375,0.823574,0.496283,-0.136348,-0.756503,-1.018499,-0.748531,-0.058718,0.698165,-1.047588,-0.612897,0.098867,0.698181,0.896983,0.643645,0.112574,-0.416105,-0.701417,-0.639526,-0.288795,0.169385,0.513724,0.584179,0.362047,-0.017051,-0.338479,-0.436981,-0.295767,-0.044044,0.146823,0.188184,0.121931,0.058262,0.064260,0.104266,-0.049985,-0.236915,-0.342613,-0.261855,-0.008144,0.286584,0.457539,0.408800,0.160985,-0.172715,-0.448017,-0.546101,-0.409990,-0.067887,0.357152,0.672550,0.694351,0.355872,-0.219744,-0.749841,-0.933076,-0.627928,0.043093,0.738767,1.078535,0.856337},
  {-0.523675,-0.571144,-0.363789,0.022467,0.419579,0.631542,0.536444,0.166223,-0.296928,-0.615499,-0.626361,-0.326175,0.132708,0.523838,0.656853,0.465579,0.040770,-0.406766,-0.645338,-0.545463,-0.160637,0.293551,0.564076,0.514955,0.205819,-0.161320,-0.383120,-0.218258,-0.011745,0.145956,0.227907,0.238818,0.178144,0.046644,-0.118530,-0.237192,-0.236181,-0.115490,0.040837,0.132064,0.127346,0.084726,0.078938,0.110043,0.092957,-0.048751,-0.272640,-0.410938,-0.298903,0.063823,0.469122,0.632912,-0.254978,0.132302,0.471587,0.608032,0.460032,0.076926,-0.362947,-0.634794,-0.591062,-0.248381,0.219449,0.576382,0.646963,0.399774,-0.043057,-0.465365,-0.657154,-0.516783,-0.110416,0.350155,0.616169,0.545457,0.190990,-0.232218,-0.486096,-0.457832,0.078929,0.266621,0.302704,0.227417,0.101802,-0.037164,-0.166109,-0.245664,-0.226660,-0.097658,0.079994,0.202016,0.201931,0.107137,0.009590,-0.025843,-0.023622,-0.061720,-0.168655,-0.261711,-0.205118,0.050385,0.378209,0.539395,0.366889,-0.079930},
  {-0.717802,-0.644169,-0.279651,0.210488,0.608311,0.736292,0.532140,0.077416,-0.431023,-0.759261,-0.739177,-0.356029,0.224539,0.718970,0.864073,0.565694,-0.031847,-0.611997,-0.862338,-0.657076,-0.128099,0.422750,0.709928,0.623666,0.264082,-0.153289,-0.504452,-0.382012,-0.145785,0.122986,0.348032,0.454277,0.385756,0.146544,-0.173778,-0.428644,-0.491732,-0.331564,-0.028939,0.273477,0.449256,0.440786,0.264240,-0.014399,-0.302340,-0.494661,-0.497989,-0.275157,0.109766,0.490339,0.666895,0.519477,-0.145744,0.343058,0.673103,0.698972,0.409711,-0.068641,-0.526169,-0.756088,-0.643327,-0.221439,0.328479,0.746810,0.814689,0.473245,-0.124481,-0.674732,-0.881496,-0.627833,-0.052083,0.528424,0.804584,0.654318,0.198167,-0.296166,-0.584163,-0.571406,0.002314,0.278987,0.428744,0.426978,0.278880,0.021186,-0.263419,-0.456761,-0.458075,-0.249908,0.076908,0.367141,0.487266,0.394095,0.143627,-0.153004,-0.384920,-0.474098,-0.384993,-0.131839,0.208814,0.501047,0.594571,0.406533,-0.008432,-0.459259},
  {-0.019935,0.205073,0.330279,0.338604,0.235255,0.042763,-0.184296,-0.356654,-0.384629,-0.235124,0.033624,0.294235,0.419961,0.354568,0.136256,-0.133002,-0.342796,-0.416846,-0.328624,-0.101577,0.192132,0.439156,0.516724,0.352881,-0.013494,-0.421490,-0.561923,-0.159937,0.354025,0.702346,0.686045,0.305790,-0.233330,-0.639453,-0.702118,-0.407479,0.066987,0.467172,0.607830,0.458895,0.131402,-0.208275,-0.427827,-0.469741,-0.341093,-0.088209,0.212917,0.455925,0.524714,0.351217,-0.019820,-0.418921,0.400641,0.312515,0.131355,-0.077179,-0.257495,-0.355194,-0.322239,-0.148057,0.110315,0.337596,0.417646,0.303396,0.048081,-0.225408,-0.393525,-0.391460,-0.230592,0.021739,0.273622,0.432572,0.425915,0.229082,-0.103891,-0.435917,-0.594895,-0.465821,0.394481,0.691620,0.636488,0.237490,-0.300065,-0.685116,-0.708281,-0.362890,0.155107,0.566121,0.667930,0.439216,0.029231,-0.346141,-0.525845,-0.468305,-0.236678,0.060618,0.320962,0.465264,0.439310,0.228645,-0.110747,-0.441208,-0.589996,-0.447789},
  {1.026953,0.911478,0.377571,-0.307148,-0.820746,-0.940013,-0.634571,-0.064827,0.504901,0.829883,0.786761,0.413030,-0.122824,-0.597311,-0.818552,-0.694632,-0.268026,0.291926,0.743766,0.870718,0.589068,0.011936,-0.584339,-0.895359,-0.758694,-0.252925,0.730120,0.735319,0.415779,-0.025753,-0.381772,-0.546707,-0.522505,-0.353548,-0.075365,0.270728,0.587719,0.717678,0.524921,0.019639,-0.586249,-0.965153,-0.867619,-0.295805,0.470598,1.024332,1.063636,0.562294,-0.221859,-0.893007,-1.124317,-0.813480,0.221576,-0.485385,-0.939942,-0.943147,-0.517043,0.121369,0.674016,0.901926,0.725500,0.244851,-0.319023,-0.726654,-0.817393,-0.564485,-0.075959,0.449306,0.792930,0.798571,0.442752,-0.135137,-0.673767,-0.904946,-0.696877,-0.142472,0.475438,0.837564,0.343175,-0.195860,-0.575732,-0.657397,-0.474494,-0.159986,0.159878,0.414288,0.560878,0.543826,0.308406,-0.124385,-0.598317,-0.861858,-0.713674,-0.159521,0.545142,1.020167,0.984021,0.429875,-0.361724,-0.979900,-1.109292,-0.691539,0.058313,0.772141},
  {0.440646,0.472502,0.314806,-0.000782,-0.359558,-0.593690,-0.564631,-0.253188,0.208529,0.595799,0.710040,0.485475,0.022551,-0.463840,-0.746662,-0.688793,-0.304816,0.239029,0.690888,0.827043,0.566591,0.024628,-0.536798,-0.842393,-0.747185,-0.305702,0.714021,0.842969,0.602573,0.086962,-0.495386,-0.886834,-0.880140,-0.431478,0.275527,0.885115,1.051674,0.654764,-0.101297,-0.792876,-1.034030,-0.713869,-0.050954,0.565341,0.823632,0.654989,0.220946,-0.229203,-0.507620,-0.550420,-0.391953,-0.112078,0.167320,-0.130446,-0.408062,-0.544874,-0.450366,-0.128435,0.293813,0.612029,0.651788,0.372228,-0.102508,-0.545024,-0.740747,-0.592059,-0.161218,0.359239,0.729964,0.769730,0.443103,-0.109760,-0.627508,-0.853005,-0.668730,-0.162959,0.416632,0.794506,0.453000,-0.096567,-0.610318,-0.869703,-0.748305,-0.268174,0.380925,0.893555,0.985465,0.563271,-0.182838,-0.854093,-1.069192,-0.703618,0.025547,0.696561,0.949067,0.694187,0.132937,-0.405583,-0.671459,-0.605316,-0.310331,0.051476,0.345336,0.490783},
  {-0.244585,-0.333623,-0.240956,0.007838,0.279164,0.406777,0.301688,0.017807,-0.277820,-0.411721,-0.312860,-0.049987,0.221151,0.356525,0.300948,0.102785,-0.127430,-0.278594,-0.287304,-0.158567,0.040664,0.211101,0.266982,0.181378,0.005017,-0.159655,-0.150307,-0.008047,0.110780,0.138022,0.076606,-0.011208,-0.057272,-0.038825,0.010933,0.036780,0.009401,-0.050903,-0.091078,-0.067705,0.017496,0.114566,0.156801,0.105936,-0.018795,-0.147824,-0.202233,-0.143758,-0.001246,0.145320,0.213922,0.170026,-0.190474,0.026495,0.264152,0.377575,0.278410,0.005880,-0.284947,-0.418249,-0.312107,-0.031559,0.256191,0.389641,0.307947,0.074148,-0.176390,-0.317816,-0.294004,-0.132502,0.080394,0.242488,0.279212,0.176114,-0.011793,-0.184062,-0.247788,-0.172592,0.135755,0.182645,0.117067,-0.000155,-0.084315,-0.088867,-0.032852,0.023550,0.031552,-0.008642,-0.052598,-0.051303,0.007294,0.086419,0.125946,0.086132,-0.021129,-0.135149,-0.182753,-0.125716,0.011234,0.151703,0.213237,0.158676,0.019109,-0.127021},
  {1.035241,1.150841,0.708555,-0.008090,-0.634211,-0.924211,-0.825763,-0.429638,0.111653,0.622945,0.916936,0.838740,0.361463,-0.338309,-0.922547,-1.068025,-0.671693,0.066740,0.756120,1.045906,0.819881,0.232276,-0.410809,-0.823521,-0.859629,-0.540031,0.502711,0.803976,0.763694,0.395567,-0.142468,-0.614726,-0.817820,-0.672561,-0.248785,0.277884,0.700152,0.848246,0.643876,0.139553,-0.473142,-0.917742,-0.956176,-0.528419,0.184223,0.834221,1.091572,0.824935,0.167548,-0.563809,-1.033668,-1.037756,0.633544,-0.198649,-0.859312,-1.055353,-0.770270,-0.205110,0.377531,0.775099,0.876426,0.647760,0.140803,-0.476714,-0.936582,-0.983337,-0.539331,0.203838,0.864062,1.087668,0.762648,0.078345,-0.601546,-0.953238,-0.850844,-0.389784,0.199684,0.670081,0.669122,0.216291,-0.326462,-0.728552,-0.814349,-0.547655,-0.049643,0.462502,0.777182,0.772352,0.450045,-0.072339,-0.596137,-0.898470,-0.817211,-0.343446,0.335648,0.898611,1.049520,0.688945,-0.016997,-0.721531,-1.083692,-0.939881,-0.367504,0.371435},
  {0.568518,1.364323,1.516037,0.935064,-0.101370,-1.081992,-1.525655,-1.231506,-0.371402,0.621061,1.285338,1.350387,0.827537,-0.033024,-0.865131,-1.325119,-1.212309,-0.553409,0.381213,1.167413,1.418127,0.991476,0.087814,-0.844132,-1.349043,-1.207010,0.339203,1.008475,1.224273,0.934528,0.270851,-0.510555,-1.101924,-1.240312,-0.825165,-0.003408,0.857159,1.333435,1.175470,0.455359,-0.467173,-1.143960,-1.274092,-0.835633,-0.058421,0.712152,1.166531,1.134079,0.627413,-0.161077,-0.912540,-1.293274,1.421125,0.722088,-0.337594,-1.245896,-1.552821,-1.106352,-0.135696,0.872541,1.434380,1.311380,0.603553,-0.336394,-1.090507,-1.353813,-1.034714,-0.270305,0.624550,1.264225,1.345044,0.798133,-0.142822,-1.028978,-1.420751,-1.127433,-0.311201,0.612228,1.236455,0.738133,-0.038365,-0.769665,-1.178024,-1.106750,-0.565914,0.248630,0.996017,1.319996,1.031614,0.238697,-0.681435,-1.274274,-1.254782,-0.654167,0.217505,0.951627,1.241707,0.997584,0.346008,-0.443035,-1.055519,-1.236027,-0.884695,-0.120149},
  {-0.323813,0.401743,1.002418,1.139083,0.688557,-0.155054,-0.962088,-1.299286,-0.975968,-0.153568,0.745903,1.271197,1.173815,0.517234,-0.375404,-1.086128,-1.290661,-0.893748,-0.068726,0.809774,1.322951,1.202956,0.480540,-0.502304,-1.247500,-1.360731,0.200128,1.045098,1.321127,0.912140,0.074480,-0.727919,-1.093329,-0.891462,-0.297863,0.343996,0.728776,0.735352,0.443085,0.039518,-0.299325,-0.479574,-0.488437,-0.354280,-0.117099,0.169153,0.422075,0.539859,0.447047,0.150589,-0.239710,-0.552253,0.965531,0.995626,0.513408,-0.286004,-1.003134,-1.242330,-0.843598,0.008578,0.876168,1.308108,1.085600,0.330094,-0.576045,-1.194478,-1.242030,-0.708265,0.155933,0.955096,1.318533,1.062484,0.284927,-0.657110,-1.300378,-1.304912,-0.646039,0.349052,1.366276,0.863984,-0.058038,-0.898556,-1.228254,-0.920503,-0.194267,0.540300,0.923919,0.828368,0.381825,-0.147801,-0.517324,-0.617260,-0.479204,-0.209523,0.084636,0.328210,0.469633,0.466506,0.296898,-0.007985,-0.345398,-0.569403,-0.561790,-0.303014},
  {1.191933,0.756918,-0.015711,-0.707300,-0.990146,-0.790842,-0.280918,0.266878,0.634838,0.730094,0.563062,0.201478,-0.244676,-0.619834,-0.754957,-0.554350,-0.081602,0.441251,0.749402,0.694387,0.329188,-0.142189,-0.502457,-0.634721,-0.538958,-0.274718,0.464238,0.721746,0.708553,0.348907,-0.253717,-0.816117,-1.016745,-0.699451,0.005571,0.738858,1.115023,0.939482,0.305755,-0.469889,-1.018431,-1.091532,-0.661579,0.077109,0.792972,1.156019,0.984457,0.339238,-0.487355,-1.100390,-1.194507,-0.711387,-0.164632,-0.884132,-1.115751,-0.789854,-0.132508,0.498459,0.824966,0.768312,0.426924,-0.027388,-0.436357,-0.680706,-0.677280,-0.400684,0.070499,0.542543,0.782192,0.652845,0.213022,-0.308878,-0.654171,-0.684679,-0.436475,-0.055736,0.307751,0.557448,0.498684,0.136102,-0.362304,-0.785761,-0.885957,-0.538450,0.136234,0.802432,1.093289,0.832037,0.141720,-0.625788,-1.087201,-1.025421,-0.482005,0.282514,0.917864,1.136419,0.832947,0.133526,-0.648582,-1.145274,-1.106786,-0.533230,0.311357,1.020795},
  {0.961383,0.936572,0.444530,-0.273630,-0.858430,-1.015559,-0.669262,-0.000472,0.652308,0.971798,0.819085,0.287998,-0.358358,-0.820789,-0.896453,-0.558531,0.037138,0.616142,0.902531,0.750103,0.227203,-0.402580,-0.813095,-0.796544,-0.382413,0.185914,0.681682,0.437015,0.043178,-0.296473,-0.458696,-0.428817,-0.260604,-0.025506,0.207547,0.369352,0.397941,0.269310,0.026244,-0.230004,-0.389755,-0.391836,-0.246130,-0.013240,0.230491,0.411548,0.461470,0.329531,0.021171,-0.363646,-0.642635,-0.637370,0.312390,-0.399962,-0.922551,-0.990268,-0.565299,0.139300,0.768222,1.009326,0.753867,0.143778,-0.513612,-0.906767,-0.866237,-0.428582,0.195833,0.721580,0.909364,0.668874,0.106777,-0.509214,-0.871888,-0.794187,-0.319252,0.295468,0.723401,0.757343,-0.072641,-0.458012,-0.578525,-0.438935,-0.156914,0.130963,0.332476,0.406651,0.344249,0.161529,-0.087861,-0.312023,-0.414191,-0.345674,-0.136777,0.121022,0.326415,0.412036,0.355085,0.166675,-0.111263,-0.394717,-0.559891,-0.490187,-0.157944,0.317937},
  {0.414940,0.776923,0.765051,0.389157,-0.159913,-0.624614,-0.807486,-0.642471,-0.200590,0.343369,0.764550,0.864533,0.564245,-0.029731,-0.645474,-0.971439,-0.827691,-0.274904,0.414060,0.902656,0.964158,0.581282,-0.064994,-0.687149,-1.009700,-0.876435,0.414612,0.982972,1.080212,0.630626,-0.147127,-0.845647,-1.099240,-0.794094,-0.120627,0.557901,0.919668,0.839096,0.406159,-0.160846,-0.626635,-0.817286,-0.662971,-0.221763,0.323719,0.725589,0.786754,0.475410,-0.045947,-0.511560,-0.706928,-0.579082,0.694914,0.262258,-0.304272,-0.723044,-0.799974,-0.516181,-0.012295,0.493495,0.794533,0.762030,0.389684,-0.186217,-0.716433,-0.937849,-0.712332,-0.123511,0.545892,0.959476,0.910161,0.427182,-0.251263,-0.808060,-0.995796,-0.733865,-0.131734,0.552530,0.996465,0.493016,-0.279243,-0.931725,-1.116353,-0.730525,0.015186,0.720504,1.030688,0.827603,0.262086,-0.366452,-0.779979,-0.834951,-0.544164,-0.040986,0.472120,0.783119,0.747949,0.368593,-0.182758,-0.636836,-0.772746,-0.543361,-0.091684,0.350050},
  {-0.307136,-0.371513,-0.263939,0.017901,0.364378,0.577693,0.484552,0.074261,-0.448488,-0.763632,-0.642356,-0.118676,0.507603,0.854001,0.703710,0.146769,-0.481902,-0.818896,-0.692103,-0.204171,0.355167,0.690259,0.654613,0.301609,-0.170917,-0.530662,-0.401694,0.000217,0.388145,0.567870,0.450722,0.104757,-0.277883,-0.487714,-0.419097,-0.130500,0.196114,0.371206,0.313291,0.089860,-0.139278,-0.233472,-0.160276,-0.003950,0.106782,0.096028,-0.007830,-0.101909,-0.094545,0.019786,0.154255,0.196876,-0.153596,0.077837,0.330819,0.472019,0.377812,0.034250,-0.405488,-0.678432,-0.574840,-0.101428,0.485395,0.824149,0.684754,0.131592,-0.507843,-0.851408,-0.704032,-0.169904,0.429657,0.762493,0.674124,0.249305,-0.265838,-0.610579,-0.635575,-0.354847,0.455605,0.594939,0.435329,0.062200,-0.329053,-0.532599,-0.445324,-0.127086,0.233790,0.433390,0.374011,0.117228,-0.164602,-0.303637,-0.240729,-0.051123,0.120120,0.163419,0.075980,-0.048331,-0.098536,-0.033929,0.086339,0.152695,0.094389,-0.061282}
};
# 2 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
# 3 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp" 2

int main() {

 float nrm = 0;
 float phf = 0;
 float errNorm;

 for(int i=0; i<200; i++) {

  hls::stream<axis_data> LS_stream;
  hls::stream<axis_data> DNN_out;

  COMPLEXD DNNOut[52];
  COMPLEXD GoldRef[52];


  COMPLEXD lsOut[52];
  for(int j=0; j<52; j++) {
   COMPLEXD z_pre(preamble[i][j], preamble[i][j+52]);
   COMPLEXD z_train(train_sym[j], train_sym[j+52]);
   lsOut[j] = z_pre/z_train;
  }


  for(int j=0; j<52; j++) {
   axis_data local_write;
   local_write.data = lsOut[j];
   local_write.last = (j==52 -1)?1:0;
   LS_stream.write(local_write);
  }
# 48 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
  DNN_wlo(LS_stream, DNN_out);



  for(int j=0; j<52; j++) {
   axis_data local_read = DNN_out.read();
   DNNOut[j] = local_read.data;
  }


  for(int j=0; j<52; j++) {
   COMPLEXD z(actin[i][j], actin[i][j+52]);
   GoldRef[j] = z;
  }


  COMPLEXD diff;
  float d;
  for(int j=0; j<52; j++) {
   diff = DNNOut[j] - GoldRef[j];
   d = pow(norm(diff), 2);
   nrm += d;
   d = pow(norm(GoldRef[j]), 2);
   phf += d;
  }

 }

 nrm = sqrt(nrm)/200;
 phf = sqrt(phf)/200;
 errNorm = nrm/phf;

 printf("Normalized error: %lf\n", errNorm);

 if(errNorm > 1e-5) {
  printf("FAILED\n");
  return -1;
 }

 printf("SUCCESS\n");

 return 0;
}
