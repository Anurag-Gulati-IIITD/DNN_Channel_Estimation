// ==============================================================
// Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC v2019.1 (64-bit)
// Copyright 1986-2019 Xilinx, Inc. All Rights Reserved.
// ==============================================================
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.h" 1
# 1 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 1
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 1 3
# 88 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
             
# 97 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_mac.h" 3
             
# 13 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 1 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3

# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_secapi.h" 3
extern "C++" {
template <bool __test, typename __dsttype>
  struct __if_array;
template <typename __dsttype>
  struct __if_array <true, __dsttype> {
    typedef __dsttype __type;
};
}
# 14 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 275 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 1 3
# 565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_directx.h" 1 3
# 566 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sdks/_mingw_ddk.h" 1 3
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 2 3




#pragma pack(push,_CRT_PACKING)



extern "C" {





  typedef __builtin_va_list __gnuc_va_list;






  typedef __gnuc_va_list va_list;
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/vadefs.h" 3
}



#pragma pack(pop)
# 276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 2 3
# 534 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw.h" 3
extern "C" {




void __attribute__((__cdecl__)) __debugbreak(void);
extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) void __attribute__((__cdecl__)) __debugbreak(void)
{
  __asm__ __volatile__("int {$}3":);
}




const char *__mingw_get_crt_info (void);


}
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 2 3




#pragma pack(push,_CRT_PACKING)
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef unsigned long long size_t;
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long ssize_t;






typedef size_t rsize_t;
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long intptr_t;
# 75 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef unsigned long long uintptr_t;
# 88 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
__extension__ typedef long long ptrdiff_t;
# 106 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
typedef unsigned short wint_t;
typedef unsigned short wctype_t;





typedef int errno_t;




typedef long __time32_t;




__extension__ typedef long long __time64_t;
# 138 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
typedef __time64_t time_t;
# 422 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/crtdefs.h" 3
struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct *pthreadlocinfo;
typedef struct threadmbcinfostruct *pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct {
  pthreadlocinfo locinfo;
  pthreadmbcinfo mbcinfo;
} _locale_tstruct,*_locale_t;



typedef struct tagLC_ID {
  unsigned short wLanguage;
  unsigned short wCountry;
  unsigned short wCodePage;
} LC_ID,*LPLC_ID;




typedef struct threadlocaleinfostruct {
  int refcount;
  unsigned int lc_codepage;
  unsigned int lc_collate_cp;
  unsigned long lc_handle[6];
  LC_ID lc_id[6];
  struct {
    char *locale;
    wchar_t *wlocale;
    int *refcount;
    int *wrefcount;
  } lc_category[6];
  int lc_clike;
  int mb_cur_max;
  int *lconv_intl_refcount;
  int *lconv_num_refcount;
  int *lconv_mon_refcount;
  struct lconv *lconv;
  int *ctype1_refcount;
  unsigned short *ctype1;
  const unsigned short *pctype;
  const unsigned char *pclmap;
  const unsigned char *pcumap;
  struct __lc_time_data *lc_time_curr;
} threadlocinfo;







#pragma pack(pop)
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

#pragma pack(push,_CRT_PACKING)


extern "C" {
# 26 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  struct _iobuf {
    char *_ptr;
    int _cnt;
    char *_base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char *_tmpfname;
  };
  typedef struct _iobuf FILE;
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 1 3




  typedef long _off_t;

  typedef long off32_t;





  __extension__ typedef long long _off64_t;

  __extension__ typedef long long off64_t;
# 26 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_off_t.h" 3
typedef off32_t off_t;
# 81 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) __iob_func(void);
# 103 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ typedef long long fpos_t;
# 139 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_scanf(const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vscanf(const char * __restrict__ Format, va_list argp);
extern
  __attribute__((__format__ (gnu_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
extern
  __attribute__((__format__ (gnu_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);

extern
  __attribute__((__format__ (gnu_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnprintf(char * __restrict__ _DstBuf,size_t _MaxCount,const char * __restrict__ _Format,
                               va_list _ArgList);
extern
  __attribute__((__format__ (gnu_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);
extern
  __attribute__((__format__ (gnu_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_printf(const char * __restrict__ , ... ) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vprintf (const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fprintf (FILE * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfprintf (FILE * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_sprintf (char * __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vsprintf (char * __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 3))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_asprintf(char ** __restrict__ , const char * __restrict__ , ...) __attribute__ ((__nothrow__));
extern
  __attribute__((__format__ (gnu_printf, 2, 0))) __attribute__((nonnull (1,2)))
  int __attribute__((__cdecl__)) __mingw_vasprintf(char ** __restrict__ , const char * __restrict__ , va_list) __attribute__ ((__nothrow__));
# 386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__((__format__ (ms_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) fprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,...);
  __attribute__((__format__ (ms_printf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) printf(const char * __restrict__ _Format,...);
  __attribute__((__format__ (ms_printf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) sprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,...) ;

  __attribute__((__format__ (ms_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) vfprintf(FILE * __restrict__ _File,const char * __restrict__ _Format,va_list _ArgList);
  __attribute__((__format__ (ms_printf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) vprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__((__format__ (ms_printf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) vsprintf(char * __restrict__ _Dest,const char * __restrict__ _Format,va_list _Args) ;

  __attribute__((__format__ (ms_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) fscanf(FILE * __restrict__ _File,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_scanf, 1, 2))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) scanf(const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_scanf, 2, 3))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) sscanf(const char * __restrict__ _Src,const char * __restrict__ _Format,...) ;






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


  __attribute__((__format__ (ms_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __ms_vscanf(const char * __restrict__ Format, va_list argp);
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_vfscanf (FILE * __restrict__ fp, const char * __restrict__ Format,va_list argp);
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __ms_vsscanf (const char * __restrict__ _Str,const char * __restrict__ Format,va_list argp);

  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int vfscanf (FILE *__stream, const char *__format, __builtin_va_list __local_argv)
  {
    return __ms_vfscanf (__stream, __format, __local_argv);
  }

  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_scanf, 2, 0))) __attribute__ ((__nonnull__ (2)))
  int vsscanf (const char * __restrict__ __source, const char * __restrict__ __format, __builtin_va_list __local_argv)
  {
    return __ms_vsscanf( __source, __format, __local_argv );
  }
  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_scanf, 1, 0))) __attribute__ ((__nonnull__ (1)))
  int vscanf(const char *__format, __builtin_va_list __local_argv)
  {
    return __ms_vscanf (__format, __local_argv);
  }


#pragma GCC diagnostic pop





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _filbuf(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flsbuf(int _Ch,FILE *_File);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fsopen(const char *_Filename,const char *_Mode,int _ShFlag);

  void __attribute__((__cdecl__)) clearerr(FILE *_File);
  int __attribute__((__cdecl__)) fclose(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fcloseall(void);



  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _fdopen(int _FileHandle,const char *_Mode);

  int __attribute__((__cdecl__)) feof(FILE *_File);
  int __attribute__((__cdecl__)) ferror(FILE *_File);
  int __attribute__((__cdecl__)) fflush(FILE *_File);
  int __attribute__((__cdecl__)) fgetc(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fgetchar(void);
  int __attribute__((__cdecl__)) fgetpos(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  int __attribute__((__cdecl__)) fgetpos64(FILE * __restrict__ _File ,fpos_t * __restrict__ _Pos);
  char *__attribute__((__cdecl__)) fgets(char * __restrict__ _Buf,int _MaxCount,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fileno(FILE *_File);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _tempnam(const char *_DirName,const char *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _flushall(void);
  FILE *__attribute__((__cdecl__)) fopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode) ;
  FILE *fopen64(const char * __restrict__ filename,const char * __restrict__ mode);
  int __attribute__((__cdecl__)) fputc(int _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fputchar(int _Ch);
  int __attribute__((__cdecl__)) fputs(const char * __restrict__ _Str,FILE * __restrict__ _File);
  size_t __attribute__((__cdecl__)) fread(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  FILE *__attribute__((__cdecl__)) freopen(const char * __restrict__ _Filename,const char * __restrict__ _Mode,FILE * __restrict__ _File) ;
  int __attribute__((__cdecl__)) fsetpos(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fsetpos64(FILE *_File,const fpos_t *_Pos);
  int __attribute__((__cdecl__)) fseek(FILE *_File,long _Offset,int _Origin);



  int fseeko64(FILE* stream, _off64_t offset, int whence);
  int fseeko(FILE* stream, _off_t offset, int whence);
# 502 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  long __attribute__((__cdecl__)) ftell(FILE *_File);

  _off_t ftello(FILE * stream);
  _off64_t ftello64(FILE * stream);
# 514 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __extension__ int __attribute__((__cdecl__)) _fseeki64(FILE *_File,long long _Offset,int _Origin);
  __extension__ long long __attribute__((__cdecl__)) _ftelli64(FILE *_File);
  size_t __attribute__((__cdecl__)) fwrite(const void * __restrict__ _Str,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) getc(FILE *_File);
  int __attribute__((__cdecl__)) getchar(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getmaxstdio(void);
  char *__attribute__((__cdecl__)) gets(char *_Buffer) ;
  int __attribute__((__cdecl__)) _getw(FILE *_File);


  void __attribute__((__cdecl__)) perror(const char *_ErrMsg);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _pclose(FILE *_File);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _popen(const char *_Command,const char *_Mode);




  int __attribute__((__cdecl__)) putc(int _Ch,FILE *_File);
  int __attribute__((__cdecl__)) putchar(int _Ch);
  int __attribute__((__cdecl__)) puts(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putw(int _Word,FILE *_File);


  int __attribute__((__cdecl__)) remove(const char *_Filename);
  int __attribute__((__cdecl__)) rename(const char *_OldFilename,const char *_NewFilename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _unlink(const char *_Filename);

  int __attribute__((__cdecl__)) unlink(const char *_Filename) ;


  void __attribute__((__cdecl__)) rewind(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _rmtmp(void);
  void __attribute__((__cdecl__)) setbuf(FILE * __restrict__ _File,char * __restrict__ _Buffer) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _setmaxstdio(int _Max);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_output_format(unsigned int _Format);
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _get_output_format(void);
  int __attribute__((__cdecl__)) setvbuf(FILE * __restrict__ _File,char * __restrict__ _Buf,int _Mode,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf(const char * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf(const char * __restrict__ _Src,size_t _MaxCount,const char * __restrict__ _Format,...) ;
  FILE *__attribute__((__cdecl__)) tmpfile(void) ;
  char *__attribute__((__cdecl__)) tmpnam(char *_Buffer);
  int __attribute__((__cdecl__)) ungetc(int _Ch,FILE *_File);

  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,...) ;
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf(char * __restrict__ _Dest,size_t _Count,const char * __restrict__ _Format,va_list _Args) ;






#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wshadow"


       
       


  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __ms_vsnprintf(char * __restrict__ d,size_t n,const char * __restrict__ format,va_list arg)
    ;

  inline __attribute__((__cdecl__))
  __attribute__((__format__ (ms_printf, 3, 0))) __attribute__ ((__nonnull__ (3)))
  int vsnprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, va_list __local_argv)
  {
    return __ms_vsnprintf (__stream, __n, __format, __local_argv);
  }

  __attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __ms_snprintf(char * __restrict__ s, size_t n, const char * __restrict__ format, ...);


inline __attribute__((__cdecl__))
__attribute__((__format__ (ms_printf, 3, 4))) __attribute__ ((__nonnull__ (3)))
int snprintf (char * __restrict__ __stream, size_t __n, const char * __restrict__ __format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv; __builtin_va_start( __local_argv, __format );
  __retval = __ms_vsnprintf (__stream, __n, __format, __local_argv);
  __builtin_va_end( __local_argv );
  return __retval;
}


       
       

#pragma GCC diagnostic pop



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf(const char * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_printf_count_output(int _Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _get_printf_count_output(void);




                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswscanf (const wchar_t * __restrict__ _Str,const wchar_t * __restrict__ Format,va_list argp);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wscanf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwscanf(const wchar_t * __restrict__ Format, va_list argp);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwscanf (FILE * __restrict__ fp, const wchar_t * __restrict__ Format,va_list argp);

                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
                                                      __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_wprintf(const wchar_t * __restrict__ _Format,...);
                                                     __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                     __attribute__ ((__nonnull__ (1)))
  int __attribute__((__cdecl__)) __mingw_vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
                                                      __attribute__ ((__nonnull__ (3)))
  int __attribute__((__cdecl__)) __mingw_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_swprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ , ...);
                                                      __attribute__ ((__nonnull__ (2)))
  int __attribute__((__cdecl__)) __mingw_vswprintf(wchar_t * __restrict__ , const wchar_t * __restrict__ ,va_list);
# 768 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  int __attribute__((__cdecl__)) fwscanf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) swscanf(const wchar_t * __restrict__ _Src,const wchar_t * __restrict__ _Format,...) ;
  int __attribute__((__cdecl__)) wscanf(const wchar_t * __restrict__ _Format,...) ;

  int __attribute__((__cdecl__)) __ms_vwscanf (const wchar_t * __restrict__ , va_list);
  int __attribute__((__cdecl__)) __ms_vfwscanf (FILE * __restrict__ ,const wchar_t * __restrict__ ,va_list);
  int __attribute__((__cdecl__)) __ms_vswscanf (const wchar_t * __restrict__ ,const wchar_t * __restrict__ ,va_list);

  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vfwscanf (FILE *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
  {
    return __ms_vfwscanf (__stream, __format, __local_argv);
  }

  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (2)))
  int vswscanf (const wchar_t * __restrict__ __source, const wchar_t * __restrict__ __format, __builtin_va_list __local_argv)
  {
    return __ms_vswscanf( __source, __format, __local_argv );
  }
  inline __attribute__((__cdecl__))
  __attribute__ ((__nonnull__ (1)))
  int vwscanf(const wchar_t *__format, __builtin_va_list __local_argv)
  {
    return __ms_vwscanf (__format, __local_argv);
  }



  int __attribute__((__cdecl__)) fwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) wprintf(const wchar_t * __restrict__ _Format,...);
  int __attribute__((__cdecl__)) vfwprintf(FILE * __restrict__ _File,const wchar_t * __restrict__ _Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
# 811 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfsopen(const wchar_t *_Filename,const wchar_t *_Mode,int _ShFlag);


  wint_t __attribute__((__cdecl__)) fgetwc(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwchar(void);
  wint_t __attribute__((__cdecl__)) fputwc(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) getwc(FILE *_File);
  wint_t __attribute__((__cdecl__)) getwchar(void);
  wint_t __attribute__((__cdecl__)) putwc(wchar_t _Ch,FILE *_File);
  wint_t __attribute__((__cdecl__)) putwchar(wchar_t _Ch);
  wint_t __attribute__((__cdecl__)) ungetwc(wint_t _Ch,FILE *_File);
  wchar_t *__attribute__((__cdecl__)) fgetws(wchar_t * __restrict__ _Dst,int _SizeInWords,FILE * __restrict__ _File);
  int __attribute__((__cdecl__)) fputws(const wchar_t * __restrict__ _Str,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putws(const wchar_t *_Str);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c(wchar_t * __restrict__ _DstBuf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf(wchar_t * __restrict__ _Dest,size_t _Count,const wchar_t * __restrict__ _Format,va_list _Args) ;




       
       


  int __attribute__((__cdecl__)) __ms_snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...);
  int __attribute__((__cdecl__)) __ms_vsnwprintf (wchar_t * __restrict__ , size_t, const wchar_t * __restrict__ , va_list);
  inline __attribute__((__cdecl__))
  int snwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, ...)
  {
    int r;
    va_list argp;
    __builtin_va_start (argp, format);
    r = _vsnwprintf (s, n, format, argp);
    __builtin_va_end (argp);
    return r;
  }
  inline __attribute__((__cdecl__))
  int __attribute__((__cdecl__)) vsnwprintf (wchar_t * __restrict__ s, size_t n, const wchar_t * __restrict__ format, va_list arg)
  {
    return _vsnwprintf(s,n,format,arg);
  }
       
       



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Format,va_list _Args);


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 1 3
# 21 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/swprintf.inl" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int vswprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, __builtin_va_list __local_argv)
{
  return vsnwprintf( __stream, __count, __format, __local_argv );
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (3)))
int swprintf (wchar_t *__stream, size_t __count, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __count, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}



extern "C++" {

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int vswprintf (wchar_t *__stream, const wchar_t *__format, __builtin_va_list __local_argv)
{



  return _vswprintf( __stream, __format, __local_argv );

}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
                                                      __attribute__ ((__nonnull__ (2)))
int swprintf (wchar_t *__stream, const wchar_t *__format, ...)
{
  register int __retval;
  __builtin_va_list __local_argv;

  __builtin_va_start( __local_argv, __format );
  __retval = vswprintf( __stream, __format, __local_argv );
  __builtin_va_end( __local_argv );
  return __retval;
}

}
# 868 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
# 877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtempnam(const wchar_t *_Directory,const wchar_t *_FilePrefix);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf(const wchar_t * __restrict__ _Src,size_t _MaxCount,const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfdopen(int _FileHandle ,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfopen(const wchar_t * __restrict__ _Filename,const wchar_t *__restrict__ _Mode) ;
  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wfreopen(const wchar_t * __restrict__ _Filename,const wchar_t * __restrict__ _Mode,FILE * __restrict__ _OldFile) ;



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wperror(const wchar_t *_ErrMsg);

  __attribute__ ((__dllimport__)) FILE *__attribute__((__cdecl__)) _wpopen(const wchar_t *_Command,const wchar_t *_Mode);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wremove(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wtmpnam(wchar_t *_Buffer);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fgetwc_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _fputwc_nolock(wchar_t _Ch,FILE *_File);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwc_nolock(wint_t _Ch,FILE *_File);
# 927 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _lock_file(FILE *_File);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _unlock_file(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fclose_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fflush_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock(void * __restrict__ _DstBuf,size_t _ElementSize,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseek_nolock(FILE *_File,long _Offset,int _Origin);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _ftell_nolock(FILE *_File);
  __extension__ __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fseeki64_nolock(FILE *_File,long long _Offset,int _Origin);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _ftelli64_nolock(FILE *_File);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fwrite_nolock(const void * __restrict__ _DstBuf,size_t _Size,size_t _Count,FILE * __restrict__ _File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ungetc_nolock(int _Ch,FILE *_File);





  char *__attribute__((__cdecl__)) tempnam(const char *_Directory,const char *_FilePrefix) ;
  int __attribute__((__cdecl__)) fcloseall(void) ;
  FILE *__attribute__((__cdecl__)) fdopen(int _FileHandle,const char *_Format) ;
  int __attribute__((__cdecl__)) fgetchar(void) ;
  int __attribute__((__cdecl__)) fileno(FILE *_File) ;
  int __attribute__((__cdecl__)) flushall(void) ;
  int __attribute__((__cdecl__)) fputchar(int _Ch) ;
  int __attribute__((__cdecl__)) getw(FILE *_File) ;
  int __attribute__((__cdecl__)) putw(int _Ch,FILE *_File) ;
  int __attribute__((__cdecl__)) rmtmp(void) ;
# 969 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_wide_utf8 (const wchar_t * const wptr, char **mbptr, size_t * buflen);
# 983 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
int __attribute__((__cdecl__)) __mingw_str_utf8_wide (const char *const mbptr, wchar_t ** wptr, size_t * buflen);
# 992 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
void __attribute__((__cdecl__)) __mingw_str_free(void *ptr);





  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnl(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnle(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlp(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnlpe(int _Mode,const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnv(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnve(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvp(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wspawnvpe(int _Mode,const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
# 1022 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 3
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnv(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnve(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvp(int _Mode,const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnvpe(int _Mode,const char *_Filename,const char *const *_ArgList,const char *const *_Env);



}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 2 3
# 23 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdio_s.h" 3
extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) clearerr_s(FILE *_File);
  int __attribute__((__cdecl__)) fprintf_s(FILE *_File,const char *_Format,...);
  size_t __attribute__((__cdecl__)) fread_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) printf_s(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scanf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c(char *_DstBuf,size_t _MaxCount,const char *_Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fscanf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sscanf_s_l(const char *_Src,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) sscanf_s(const char *_Src,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s(const char *_Src,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snscanf_s_l(const char *_Src,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  int __attribute__((__cdecl__)) vfprintf_s(FILE *_File,const char *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vprintf_s(const char *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, va_list _ArgList) { return _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__((dllimport)) int __attribute__((__cdecl__)) vsprintf_s(char *_DstBuf,size_t _Size,const char *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vsprintf_s(char (&_DstBuf)[__size], const char* _Format, va_list _ArgList) { return vsprintf_s(_DstBuf,__size,_Format,_ArgList); } }

  __attribute__((dllimport)) int __attribute__((__cdecl__)) sprintf_s(char *_DstBuf,size_t _DstSize,const char *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) sprintf_s(char (&_DstBuf)[__size], const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vsprintf_s(_DstBuf,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snprintf_s(char (&_DstBuf)[__size], size_t _MaxCount, const char* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p(FILE *_File,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p(const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p(FILE *_File,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p(char *_Dst,size_t _MaxCount,const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p(const char *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscprintf_p(const char *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_p_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_l(char *_DstBuf,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_l(char *_DstBuf,const char *_Format,_locale_t,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_p_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scprintf_p_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscprintf_p_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _printf_s_l(const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vprintf_s_l(const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfprintf_s_l(FILE *_File,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _sprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsprintf_s_l(char *_DstBuf,size_t _DstSize,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_s_l(char *_DstBuf,size_t _DstSize,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_l(char *_DstBuf,size_t _MaxCount,const char *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnprintf_c_l(char *_DstBuf,size_t _MaxCount,const char *,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) fopen_s(FILE **_File,const char *_Filename,const char *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) freopen_s(FILE** _File, const char *_Filename, const char *_Mode, FILE *_Stream);

  __attribute__ ((__dllimport__)) char* __attribute__((__cdecl__)) gets_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline char* __attribute__((__cdecl__)) get_s(char (&_DstBuf)[__size]) { return get_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) tmpnam_s(char*,rsize_t);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) tmpnam_s(char (&_DstBuf)[__size]) { return tmpnam_s(_DstBuf,__size); } }




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _getws_s(wchar_t *_Str,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline wchar_t* __attribute__((__cdecl__)) _getws_s(wchar_t (&_DstBuf)[__size]) { return _getws_s(_DstBuf,__size); } }

  int __attribute__((__cdecl__)) fwprintf_s(FILE *_File,const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) wprintf_s(const wchar_t *_Format,...);
  int __attribute__((__cdecl__)) vfwprintf_s(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  int __attribute__((__cdecl__)) vwprintf_s(const wchar_t *_Format,va_list _ArgList);

  int __attribute__((__cdecl__)) vswprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) vswprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, va_list _ArgList) { return vswprintf_s(_Dst,__size,_Format,_ArgList); } }

  int __attribute__((__cdecl__)) swprintf_s(wchar_t *_Dst,size_t _SizeInWords,const wchar_t *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) swprintf_s(wchar_t (&_Dst)[__size], const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = vswprintf_s(_Dst,__size,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _vsnwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, va_list _ArgList) { return _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,_ArgList); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s(wchar_t *_DstBuf,size_t _DstSizeInWords,size_t _MaxCount,const wchar_t *_Format,...);
  extern "C++" { template <size_t __size> inline int __attribute__((__cdecl__)) _snwprintf_s(wchar_t (&_DstBuf)[__size], size_t _MaxCount, const wchar_t* _Format, ...) { va_list __vaargs; __builtin_va_start(__vaargs,_Format); int __retval = _vsnwprintf_s(_DstBuf,__size,_MaxCount,_Format,__vaargs); __builtin_va_end(__vaargs); return __retval; } }


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_s_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_s_l(wchar_t *_DstBuf,size_t _DstSize,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_s_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_s_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) swscanf_s(const wchar_t *_Src,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_s_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wfreopen_s(FILE **_File,const wchar_t *_Filename,const wchar_t *_Mode,FILE *_OldFile);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t *_DstBuf,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wtmpnam_s(wchar_t (&_DstBuf)[__size]) { return _wtmpnam_s(_DstBuf,__size); } }

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p(FILE *_File,const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p(FILE *_File,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vswprintf_p(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p(const wchar_t *_Format,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vscwprintf_p(const wchar_t *_Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vfwprintf_p_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_c_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vswprintf_p_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _scwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_p_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vsnwprintf_l(wchar_t *_DstBuf,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __swprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __vswprintf_l(wchar_t *_Dest,const wchar_t *_Format,_locale_t _Plocinfo,va_list _Args);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vscwprintf_l(const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fwscanf_l(FILE *_File,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _swscanf_l(const wchar_t *_Src,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format,_locale_t _Locale,...);



  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);


}
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
# 2 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 1
# 79 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 1 3
# 196 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  typedef long long unsigned int size_t;
  typedef long long int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
namespace std
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
namespace __gnu_cxx
{
  inline namespace __cxx11 __attribute__((__abi_tag__ ("cxx11"))) { }
}
# 495 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/os_defines.h" 1 3
# 496 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cpu_defines.h" 1 3
# 499 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++config.h" 2 3
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 1 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_defines.h" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functexcept.h" 2 3

namespace std
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__gnu_printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
       
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
extern "C++" {

namespace std
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };





  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
# 261 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
template<> struct __is_integer<__int128> { enum { __value = 1 }; typedef __true_type __type; }; template<> struct __is_integer<unsigned __int128> { enum { __value = 1 }; typedef __true_type __type; };
# 278 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cpp_type_traits.h" 3
  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };



  template<typename _Iterator>
    inline _Iterator
    __miter_base(_Iterator __it)
    { return __it; }


}
}
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/type_traits.h" 3




extern "C++" {

namespace __gnu_cxx
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3




namespace __gnu_cxx
{

# 54 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/concept_check.h" 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 2 3

namespace std
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std
{

# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }




      constexpr value_type operator()() const { return value; }

    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;

  template<bool __v>
    using __bool_constant = integral_constant<bool, __v>;
# 103 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };
# 182 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };




  template<>
    struct __is_integral_helper<__int128>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned __int128>
    : public true_type { };
# 314 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };


  template<>
    struct __is_floating_point_helper<__float128>
    : public true_type { };



  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };



  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };


  template<typename _Tp>
    struct is_trivially_copyable
    : public integral_constant<bool, __is_trivially_copyable(_Tp)>
    { };


  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };




  template<typename _Tp>
    struct is_final
    : public integral_constant<bool, __is_final(_Tp)>
    { };



  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 926 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_trivially_constructible
    : public __and_<is_constructible<_Tp, _Args...>, integral_constant<bool,
   __is_trivially_constructible(_Tp, _Args...)>>
    { };


  template<typename _Tp>
    struct is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>::type
    { };

  struct __do_is_implicitly_default_constructible_impl
  {
    template <typename _Tp>
    static void __helper(const _Tp&);

    template <typename _Tp>
    static true_type __test(const _Tp&,
                            decltype(__helper<const _Tp&>({}))* = 0);

    static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_impl
      : public __do_is_implicitly_default_constructible_impl
  {
    typedef decltype(__test(declval<_Tp>())) type;
  };

  template<typename _Tp>
    struct __is_implicitly_default_constructible_safe
      : public __is_implicitly_default_constructible_impl<_Tp>::type
  { };

  template <typename _Tp>
    struct __is_implicitly_default_constructible
      : public __and_<is_default_constructible<_Tp>,
                      __is_implicitly_default_constructible_safe<_Tp>>
  { };


  template<typename _Tp>
    struct is_trivially_copy_constructible
    : public __and_<is_copy_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_constructible
    : public __and_<is_move_constructible<_Tp>,
      integral_constant<bool,
   __is_trivially_constructible(_Tp, _Tp&&)>>
    { };


  template<typename _Tp, typename _Up>
    struct is_trivially_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp, _Up)>>
    { };


  template<typename _Tp>
    struct is_trivially_copy_assignable
    : public __and_<is_copy_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, const _Tp&)>>
    { };


  template<typename _Tp>
    struct is_trivially_move_assignable
    : public __and_<is_move_assignable<_Tp>,
      integral_constant<bool,
   __is_trivially_assignable(_Tp&, _Tp&&)>>
    { };


  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { } __attribute__ ((__deprecated__));


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };






  template<typename _Tp>
    using remove_const_t = typename remove_const<_Tp>::type;


  template<typename _Tp>
    using remove_volatile_t = typename remove_volatile<_Tp>::type;


  template<typename _Tp>
    using remove_cv_t = typename remove_cv<_Tp>::type;


  template<typename _Tp>
    using add_const_t = typename add_const<_Tp>::type;


  template<typename _Tp>
    using add_volatile_t = typename add_volatile<_Tp>::type;


  template<typename _Tp>
    using add_cv_t = typename add_cv<_Tp>::type;





  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_reference_t = typename remove_reference<_Tp>::type;


  template<typename _Tp>
    using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;


  template<typename _Tp>
    using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;





  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1753 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<>
    struct __make_unsigned<__int128>
    { typedef unsigned __int128 __type; };
# 1774 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      static const bool __b3 = sizeof(_Tp) <= sizeof(unsigned long);
      typedef conditional<__b3, unsigned long, unsigned long long> __cond3;
      typedef typename __cond3::type __cond3_type;
      typedef conditional<__b2, unsigned int, __cond3_type> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

      typedef typename conditional<__b0, __smallest, __cond1_type>::type
 __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<short unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };



  template<>
    struct __make_signed<unsigned __int128>
    { typedef __int128 __type; };
# 1893 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {
      typedef typename __make_unsigned_selector<_Tp>::__type __unsigned_type;

    public:
      typedef typename __make_signed_selector<__unsigned_type>::__type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;



  template<typename _Tp>
    using make_signed_t = typename make_signed<_Tp>::type;


  template<typename _Tp>
    using make_unsigned_t = typename make_unsigned<_Tp>::type;





  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };



  template<typename _Tp>
    using remove_extent_t = typename remove_extent<_Tp>::type;


  template<typename _Tp>
    using remove_all_extents_t = typename remove_all_extents<_Tp>::type;




  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };



  template<typename _Tp>
    using remove_pointer_t = typename remove_pointer<_Tp>::type;


  template<typename _Tp>
    using add_pointer_t = typename add_pointer<_Tp>::type;


  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 2039 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };

  template <typename... _Types>
    struct __strictest_alignment
    {
      static const size_t _S_alignment = 0;
      static const size_t _S_size = 0;
    };

  template <typename _Tp, typename... _Types>
    struct __strictest_alignment<_Tp, _Types...>
    {
      static const size_t _S_alignment =
        alignof(_Tp) > __strictest_alignment<_Types...>::_S_alignment
 ? alignof(_Tp) : __strictest_alignment<_Types...>::_S_alignment;
      static const size_t _S_size =
        sizeof(_Tp) > __strictest_alignment<_Types...>::_S_size
 ? sizeof(_Tp) : __strictest_alignment<_Types...>::_S_size;
    };
# 2078 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template <size_t _Len, typename... _Types>
    struct aligned_union
    {
    private:
      static_assert(sizeof...(_Types) != 0, "At least one type is required");

      using __strictest = __strictest_alignment<_Types...>;
      static const size_t _S_len = _Len > __strictest::_S_size
 ? _Len : __strictest::_S_size;
    public:

      static const size_t alignment_value = __strictest::_S_alignment;

      typedef typename aligned_storage<_S_len, alignment_value>::type type;
    };

  template <size_t _Len, typename... _Types>
    const size_t aligned_union<_Len, _Types...>::alignment_value;



  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {
      typedef decltype(_S_test<_Tp, _Up>(0)) type;
    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;





  struct __invoke_memfun_ref { };
  struct __invoke_memfun_deref { };
  struct __invoke_memobj_ref { };
  struct __invoke_memobj_deref { };
  struct __invoke_other { };


  template<typename _Tp, typename _Tag>
    struct __result_of_success : __success_type<_Tp>
    { using __invoke_type = _Tag; };


  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_ref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __result_of_success<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      ), __invoke_memfun_deref> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      ), __invoke_memobj_ref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __result_of_success<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      ), __invoke_memobj_deref> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };





  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, const reference_wrapper<_Arg>&&>
    : __result_of_memobj_ref<_Res _Class::*, _Arg&>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>, _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, const reference_wrapper<_Arg>&&,
         _Args...>
    : __result_of_memfun_ref<_Res _Class::*, _Arg&, _Args...>
    { };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __result_of_success<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      ), __invoke_other> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };



  template<size_t _Len, size_t _Align =
     __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

  template <size_t _Len, typename... _Types>
    using aligned_union_t = typename aligned_union<_Len, _Types...>::type;


  template<typename _Tp>
    using decay_t = typename decay<_Tp>::type;


  template<bool _Cond, typename _Tp = void>
    using enable_if_t = typename enable_if<_Cond, _Tp>::type;


  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    using conditional_t = typename conditional<_Cond, _Iftrue, _Iffalse>::type;


  template<typename... _Tp>
    using common_type_t = typename common_type<_Tp...>::type;


  template<typename _Tp>
    using underlying_type_t = typename underlying_type<_Tp>::type;


  template<typename _Tp>
    using result_of_t = typename result_of<_Tp>::type;


  template<typename...> using __void_t = void;




  template<typename...> using void_t = void;



  template<typename _Default, typename _AlwaysVoid,
    template<typename...> class _Op, typename... _Args>
    struct __detector
    {
      using value_t = false_type;
      using type = _Default;
    };


  template<typename _Default, template<typename...> class _Op,
     typename... _Args>
    struct __detector<_Default, __void_t<_Op<_Args...>>, _Op, _Args...>
    {
      using value_t = true_type;
      using type = _Op<_Args...>;
    };


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or = __detector<_Default, void, _Op, _Args...>;


  template<typename _Default, template<typename...> class _Op,
    typename... _Args>
    using __detected_or_t
      = typename __detected_or<_Default, _Op, _Args...>::type;


  template<template<typename...> class _Default,
    template<typename...> class _Op, typename... _Args>
    using __detected_or_t_ =
      __detected_or_t<_Default<_Args...>, _Op, _Args...>;
# 2590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/type_traits" 3
  template <typename _Tp>
    struct __is_swappable;

  template <typename _Tp>
    struct __is_nothrow_swappable;

  template<typename _Tp>
    inline
    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp&, _Tp&)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value);

  template<typename _Tp, size_t _Nm>
    inline
    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value);

  namespace __swappable_details {
    using std::swap;

    struct __do_is_swappable_impl
    {
      template<typename _Tp, typename
               = decltype(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))>
        static true_type __test(int);

      template<typename>
        static false_type __test(...);
    };

    struct __do_is_nothrow_swappable_impl
    {
      template<typename _Tp>
        static __bool_constant<
          noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>()))
        > __test(int);

      template<typename>
        static false_type __test(...);
    };

  }

  template<typename _Tp>
    struct __is_swappable_impl
    : public __swappable_details::__do_is_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_nothrow_swappable_impl
    : public __swappable_details::__do_is_nothrow_swappable_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_swappable
    : public __is_swappable_impl<_Tp>::type
    { };

  template<typename _Tp>
    struct __is_nothrow_swappable
    : public __is_nothrow_swappable_impl<_Tp>::type
    { };


}
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 2 3

namespace std
{

# 74 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }


  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    __exchange(_Tp& __obj, _Up&& __new_val)
    {
      _Tp __old_val = std::move(__obj);
      __obj = std::forward<_Up>(__new_val);
      return __old_val;
    }



}
# 159 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
namespace std
{

# 174 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/move.h" 3
  template<typename _Tp>
    inline

    typename enable_if<__and_<is_move_constructible<_Tp>,
         is_move_assignable<_Tp>>::value>::type
    swap(_Tp& __a, _Tp& __b)
    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)




    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline

    typename enable_if<__is_swappable<_Tp>::value>::type
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])
    noexcept(__is_nothrow_swappable<_Tp>::value)




    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 2 3





namespace std
{

# 76 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  struct piecewise_construct_t { explicit piecewise_construct_t() = default; };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;






  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, const _U1&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, const _U2&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<const _U1&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<const _U2&, _T2>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _MoveConstructiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_constructible<_T1, _U1&&>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
   is_constructible<_T2, _U2&&>>>::value;
  }

  template <typename _T1, typename _T2, typename _U1, typename _U2>
  constexpr bool _ImplicitlyMoveConvertiblePair()
  {
    return __and_<__or_<is_same<typename decay<_T1>::type,
    typename decay<_U1>::type>,
   is_convertible<_U1&&, _T1>>,
    __or_<is_same<typename decay<_T2>::type,
    typename decay<_U2>::type>,
         is_convertible<_U2&&, _T2>>>::value;
  }
# 146 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;






      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr pair()
      : first(), second() { }


      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                       is_default_constructible<_U1>,
                       is_default_constructible<_U2>,
                       __not_<
                         __and_<__is_implicitly_default_constructible<_U1>,
                                __is_implicitly_default_constructible<_U2>>>>
                                   ::value, bool>::type = false>
      explicit constexpr pair()
      : first(), second() { }







      template<typename _U1 = _T1, typename _U2=_T2, typename
                enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }

       template<typename _U1 = _T1, typename _U2=_T2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
      explicit constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }
# 210 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
      template<typename _U1, typename _U2, typename
        enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=true>
        constexpr pair(const pair<_U1, _U2>& __p)
        : first(__p.first), second(__p.second) { }

      template<typename _U1, typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyConvertiblePair<_T1, _T2, _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && _ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
         _U1, _T2>(),
                         bool>::type=true>
       constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U1, typename
               enable_if<_ConstructiblePair<_T2, _T2, _T2, _T2>()
                         && _MoveConstructiblePair<_T1, _T2, _U1, _T2>()
                         && (!_ImplicitlyConvertiblePair<_T2, _T2, _T2, _T2>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _U1, _T2>()),
                         bool>::type=false>
       explicit constexpr pair(_U1&& __x, const _T2& __y)
       : first(std::forward<_U1>(__x)), second(__y) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && _ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                           _T1, _U2>(),
                         bool>::type=true>
       constexpr pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U2, typename
               enable_if<_ConstructiblePair<_T1, _T1, _T1, _T1>()
                         && _MoveConstructiblePair<_T1, _T2, _T1, _U2>()
                         && (!_ImplicitlyConvertiblePair<_T1, _T1, _T1, _T1>()
                             || !_ImplicitlyMoveConvertiblePair<_T1, _T2,
                                                                _T1, _U2>()),
                         bool>::type=false>
       explicit pair(const _T1& __x, _U2&& __y)
       : first(__x), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
           _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }


      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && _ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=true>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_MoveConstructiblePair<_T1, _T2, _U1, _U2>()
                         && !_ImplicitlyMoveConvertiblePair<_T1, _T2,
          _U1, _U2>(),
                         bool>::type=false>
 explicit constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<typename _U1, typename _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<typename _U1, typename _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(__is_nothrow_swappable<_T1>::value
               && __is_nothrow_swappable<_T2>::value)
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<typename _T1, typename _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<typename _T1, typename _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 422 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3
  template<typename _T1, typename _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 441 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_pair.h" 3

}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
       
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3







namespace std
{

# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator, typename = __void_t<>>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator,
        __void_t<typename _Iterator::iterator_category,
          typename _Iterator::value_type,
          typename _Iterator::difference_type,
          typename _Iterator::pointer,
          typename _Iterator::reference>>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }
# 230 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_types.h" 3
  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
       
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/debug/assertions.h" 1 3
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 2 3

namespace std
{


  template <typename> struct _List_iterator;
  template <typename> struct _List_const_iterator;




  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }



  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_iterator<_Tp>,
        std::_List_iterator<_Tp>,
        input_iterator_tag);

  template<typename _Tp>
    ptrdiff_t
    __distance(std::_List_const_iterator<_Tp>,
        std::_List_const_iterator<_Tp>,
        input_iterator_tag);
# 133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {

     

      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 1 3
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ptr_traits.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ptr_traits.h" 3
namespace std
{


  class __undefined;


  template<typename _Tp>
    struct __get_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Tp,
           typename... _Types>
    struct __get_first_arg<_Template<_Tp, _Types...>>
    { using type = _Tp; };

  template<typename _Tp>
    using __get_first_arg_t = typename __get_first_arg<_Tp>::type;


  template<typename _Tp, typename _Up>
    struct __replace_first_arg
    { using type = __undefined; };

  template<template<typename, typename...> class _Template, typename _Up,
           typename _Tp, typename... _Types>
    struct __replace_first_arg<_Template<_Tp, _Types...>, _Up>
    { using type = _Template<_Up, _Types...>; };

  template<typename _Tp, typename _Up>
    using __replace_first_arg_t = typename __replace_first_arg<_Tp, _Up>::type;

  template<typename _Tp>
    using __make_not_void
      = typename conditional<is_void<_Tp>::value, __undefined, _Tp>::type;





  template<typename _Ptr>
    struct pointer_traits
    {
    private:
      template<typename _Tp>
 using __element_type = typename _Tp::element_type;

      template<typename _Tp>
 using __difference_type = typename _Tp::difference_type;

      template<typename _Tp, typename _Up>
 using __rebind = typename _Tp::template rebind<_Up>;

    public:

      using pointer = _Ptr;


      using element_type
 = __detected_or_t_<__get_first_arg_t, __element_type, _Ptr>;


      using difference_type
 = __detected_or_t<ptrdiff_t, __difference_type, _Ptr>;


      template<typename _Up>
        using rebind
   = __detected_or_t_<__replace_first_arg_t, __rebind, _Ptr, _Up>;

      static _Ptr
      pointer_to(__make_not_void<element_type>& __e)
      { return _Ptr::pointer_to(__e); }

      static_assert(!is_same<element_type, __undefined>::value,
   "pointer type defines element_type or is like SomePointer<T, Args>");
      static_assert(!is_same<rebind<element_type>, __undefined>::value,
   "pointer type defines rebind<U> or is like SomePointer<T, Args>");
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(__make_not_void<element_type>& __r) noexcept
      { return std::addressof(__r); }
    };


  template<typename _Ptr, typename _Tp>
    using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;


}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 2 3

namespace std
{

# 96 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 160 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 290 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }




  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    __make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }







  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    make_reverse_iterator(_Iterator __i)
    { return reverse_iterator<_Iterator>(__i); }




  template<typename _Iterator>
    auto
    __niter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__niter_base(__it.base())))
    { return __make_reverse_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<reverse_iterator<_Iterator> >
      : __is_move_iterator<_Iterator>
    { };

  template<typename _Iterator>
    auto
    __miter_base(reverse_iterator<_Iterator> __it)
    -> decltype(__make_reverse_iterator(__miter_base(__it.base())))
    { return __make_reverse_iterator(__miter_base(__it.base())); }
# 441 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 476 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x)
      : container(std::__addressof(__x)) { }
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 609 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(std::__addressof(__x)), iter(__i) {}
# 679 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx
{

# 747 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 847 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}

namespace std
{


  template<typename _Iterator, typename _Container>
    _Iterator
    __niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container> __it)
    { return __it.base(); }


}



namespace std
{

# 999 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;
      typedef typename __traits_type::reference __base_ref;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;


      typedef typename conditional<is_reference<__base_ref>::value,
    typename remove_reference<__base_ref>::type&&,
    __base_ref>::type reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return static_cast<reference>(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }



  template<typename _Tp, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond<_Tp>::value,
      const _Tp*, move_iterator<_Tp*>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Tp* __i)
    { return _ReturnType(__i); }



  template<typename _Iterator>
    auto
    __niter_base(move_iterator<_Iterator> __it)
    -> decltype(make_move_iterator(__niter_base(__it.base())))
    { return make_move_iterator(__niter_base(__it.base())); }

  template<typename _Iterator>
    struct __is_move_iterator<move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<typename _Iterator>
    auto
    __miter_base(move_iterator<_Iterator> __it)
    -> decltype(__miter_base(__it.base()))
    { return __miter_base(__it.base()); }


}
# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/debug/debug.h" 1 3
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/predefined_ops.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      constexpr
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };
  constexpr
  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;
      constexpr
      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        constexpr
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    constexpr
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}
# 72 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 2 3

namespace std
{

# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 216 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 240 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 262 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    inline _Iterator
    __niter_base(_Iterator __it)
    { return __it; }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, (void)++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {

   using __assignable = conditional<_IsMove,
        is_move_assignable<_Tp>,
        is_copy_assignable<_Tp>>;

   static_assert( __assignable::type::value, "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 656 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      if (const size_t __len = __last - __first)
 __builtin_memset(__first, static_cast<unsigned char>(__tmp), __len);
    }
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, (void)++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   if (const size_t __len = (__last1 - __first1))
     return !__builtin_memcmp(__first1, __first2, sizeof(_Tp) * __len);
   return true;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, (void)++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   if (const size_t __len = std::min(__len1, __len2))
     if (int __result = __builtin_memcmp(__first1, __first2, __len))
       return __result < 0;
   return __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 982 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1039 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
    {

     
     
     


      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_II1>::iterator_category;
      using _Cat2 = typename iterator_traits<_II2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!(*__first1 == *__first2))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1153 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _IIter2 __last2, _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      using _RATag = random_access_iterator_tag;
      using _Cat1 = typename iterator_traits<_IIter1>::iterator_category;
      using _Cat2 = typename iterator_traits<_IIter2>::iterator_category;
      using _RAIters = __and_<is_same<_Cat1, _RATag>, is_same<_Cat2, _RATag>>;
      if (_RAIters())
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
   return std::equal(__first1, __last1, __first2,
           __binary_pred);
 }

      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return __first1 == __last1 && __first2 == __last2;
    }
# 1201 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1237 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __first2 != __last2
      && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1395 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _BinaryPredicate __binary_pred)
    {

     
     
      ;
      ;

      return std::__mismatch(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }



}
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 1 3
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3

#pragma GCC visibility push(default)


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/atomic_lockfree_defines.h" 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 2 3

extern "C++" {

namespace std
{
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char*
    what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 129 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));




  int uncaught_exceptions() noexcept __attribute__ ((__pure__));



}

namespace __gnu_cxx
{

# 160 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {
    using std::rethrow_exception;





    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 113 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 140 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {

      try
 {
   throw __ex;
 }
      catch(...)
 {
   return current_exception();
 }



    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) noexcept = default;

    nested_exception& operator=(const nested_exception&) noexcept = default;

    virtual ~nested_exception() noexcept;

    [[noreturn]]
    void
    rethrow_nested() const
    {
      if (_M_ptr)
 rethrow_exception(_M_ptr);
      std::terminate();
    }

    exception_ptr
    nested_ptr() const noexcept
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(const _Except& __ex)
      : _Except(__ex)
      { }

      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Tp,
    bool __with_nested = !__is_base_of(nested_exception, _Tp)>
    struct _Throw_with_nested_impl
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw _Nested_exception<_Tp>{static_cast<_Up&&>(__t)}; }
    };

  template<typename _Tp>
    struct _Throw_with_nested_impl<_Tp, false>
    {
      template<typename _Up>
 static void _S_throw(_Up&& __t)
 { throw static_cast<_Up&&>(__t); }
    };

  template<typename _Tp, bool = __is_class(_Tp) && !__is_final(_Tp)>
    struct _Throw_with_nested_helper : _Throw_with_nested_impl<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp, false>
    : _Throw_with_nested_impl<_Tp, false>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&, false>
    : _Throw_with_nested_helper<_Tp>
    { };

  template<typename _Tp>
    struct _Throw_with_nested_helper<_Tp&&, false>
    : _Throw_with_nested_helper<_Tp>
    { };



  template<typename _Tp>
    [[noreturn]]
    inline void
    throw_with_nested(_Tp&& __t)
    {
      _Throw_with_nested_helper<_Tp>::_S_throw(static_cast<_Tp&&>(__t));
    }

  template<typename _Tp, bool = __is_polymorphic(_Tp)>
    struct _Rethrow_if_nested_impl
    {
      static void _S_rethrow(const _Tp& __t)
      {
 if (auto __tp =
            dynamic_cast<const nested_exception*>(std::__addressof(__t)))
   __tp->rethrow_nested();
      }
    };

  template<typename _Tp>
    struct _Rethrow_if_nested_impl<_Tp, false>
    {
      static void _S_rethrow(const _Tp&) { }
    };


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      _Rethrow_if_nested_impl<_Ex>::_S_rethrow(__ex);
    }


}

}



#pragma GCC visibility pop
# 172 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/exception" 2 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };


  struct nothrow_t
  {

    explicit nothrow_t() = default;

  };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t) noexcept
  __attribute__((__externally_visible__));

void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));

void operator delete(void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));



inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 2 3






namespace __gnu_cxx
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 2 3


namespace std
{
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 1 3
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3
       
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3



namespace std
{

# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 2 3






namespace std
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      typedef true_type is_always_equal;

    };
# 96 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    noexcept
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    noexcept
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {

 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }



      }
    };



}
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 1 3
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
namespace std
{


  struct __allocator_traits_base
  {
    template<typename _Alloc, typename _Up>
      using __rebind = typename _Alloc::template rebind<_Up>::other;

  protected:
    template<typename _Tp>
      using __pointer = typename _Tp::pointer;
    template<typename _Tp>
      using __c_pointer = typename _Tp::const_pointer;
    template<typename _Tp>
      using __v_pointer = typename _Tp::void_pointer;
    template<typename _Tp>
      using __cv_pointer = typename _Tp::const_void_pointer;
    template<typename _Tp>
      using __diff_type = typename _Tp::difference_type;
    template<typename _Tp>
      using __size_type = typename _Tp::size_type;
    template<typename _Tp>
      using __pocca = typename _Tp::propagate_on_container_copy_assignment;
    template<typename _Tp>
      using __pocma = typename _Tp::propagate_on_container_move_assignment;
    template<typename _Tp>
      using __pocs = typename _Tp::propagate_on_container_swap;
    template<typename _Tp>
      using __equal = typename _Tp::is_always_equal;
  };

  template<typename _Alloc, typename _Up>
    using __alloc_rebind = __detected_or_t_<__replace_first_arg_t,
         __allocator_traits_base::__rebind,
         _Alloc, _Up>;





  template<typename _Alloc>
    struct allocator_traits : __allocator_traits_base
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;






      using pointer = __detected_or_t<value_type*, __pointer, _Alloc>;







      using const_pointer
 = __detected_or_t<__ptr_rebind<pointer, const value_type>,
     __c_pointer, _Alloc>;







      using void_pointer
 = __detected_or_t<__ptr_rebind<pointer, void>, __v_pointer, _Alloc>;







      using const_void_pointer
 = __detected_or_t<__ptr_rebind<pointer, const void>, __cv_pointer,
     _Alloc>;







      using difference_type
 = __detected_or_t<typename pointer_traits<pointer>::difference_type,
     __diff_type, _Alloc>;







      using size_type
 = __detected_or_t<typename make_unsigned<difference_type>::type,
     __size_type, _Alloc>;







      using propagate_on_container_copy_assignment
 = __detected_or_t<false_type, __pocca, _Alloc>;







      using propagate_on_container_move_assignment
 = __detected_or_t<false_type, __pocma, _Alloc>;







      using propagate_on_container_swap
 = __detected_or_t<false_type, __pocs, _Alloc>;







      using is_always_equal
 = __detected_or_t<typename is_empty<_Alloc>::type, __equal, _Alloc>;

      template<typename _Tp>
 using rebind_alloc = __alloc_rebind<_Alloc, _Tp>;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

      static_assert(!is_same<rebind_alloc<value_type>, __undefined>::value,
   "allocator defines rebind or is like Alloc<T, Args>");

    private:
      template<typename _Alloc2>
 static auto
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint, int)
 -> decltype(__a.allocate(__n, __hint))
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer, ...)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Alloc2, typename _Tp>
 static auto
 _S_destroy(_Alloc2& __a, _Tp* __p, int)
 -> decltype(__a.destroy(__p))
 { __a.destroy(__p); }

      template<typename _Alloc2, typename _Tp>
 static void
 _S_destroy(_Alloc2&, _Tp* __p, ...)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 static auto
 _S_max_size(_Alloc2& __a, int)
 -> decltype(__a.max_size())
 { return __a.max_size(); }

      template<typename _Alloc2>
 static size_type
 _S_max_size(_Alloc2&, ...)
 {


   return __gnu_cxx::__numeric_traits<size_type>::__max
     / sizeof(value_type);
 }

      template<typename _Alloc2>
 static auto
 _S_select(_Alloc2& __a, int)
 -> decltype(__a.select_on_container_copy_construction())
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 279 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 294 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint, 0); }
# 306 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p, 0); }
# 346 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };


  template<typename _Tp>
    struct allocator_traits<allocator<_Tp>>
    {

      using allocator_type = allocator<_Tp>;

      using value_type = _Tp;


      using pointer = _Tp*;


      using const_pointer = const _Tp*;


      using void_pointer = void*;


      using const_void_pointer = const void*;


      using difference_type = std::ptrdiff_t;


      using size_type = std::size_t;


      using propagate_on_container_copy_assignment = false_type;


      using propagate_on_container_move_assignment = true_type;


      using propagate_on_container_swap = false_type;


      using is_always_equal = true_type;

      template<typename _Up>
 using rebind_alloc = allocator<_Up>;

      template<typename _Up>
 using rebind_traits = allocator_traits<allocator<_Up>>;
# 414 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n)
      { return __a.allocate(__n); }
# 428 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static pointer
      allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)
      { return __a.allocate(__n, __hint); }
# 440 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      static void
      deallocate(allocator_type& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up, typename... _Args>
 static void
 construct(allocator_type& __a, _Up* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/alloc_traits.h" 3
      template<typename _Up>
 static void
 destroy(allocator_type& __a, _Up* __p)
 { __a.destroy(__p); }






      static size_type
      max_size(const allocator_type& __a) noexcept
      { return __a.max_size(); }






      static allocator_type
      select_on_container_copy_construction(const allocator_type& __rhs)
      { return __rhs; }
    };


  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 2 3




namespace __gnu_cxx
{






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return _Base_type::is_always_equal::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/alloc_traits.h" 3
  };


}
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 2 3

namespace std
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 90 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
namespace std
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, (void)++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType1;
      typedef typename iterator_traits<_ForwardIterator>::reference _RefType2;
      const bool __assignable = is_assignable<_RefType2, _RefType1>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static _ForwardIterator
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { return std::fill_n(__first, __n, __x); }
    };
# 234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, (void)++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline _ForwardIterator
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { return std::uninitialized_fill_n(__first, __n, __x); }
# 370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static _ForwardIterator
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   return std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline _ForwardIterator
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      return __uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline _ForwardIterator
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { return std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 677 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/initializer_list" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/initializer_list" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 2 3


namespace std
{

# 88 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  constexpr inline size_t
  __deque_buf_size(size_t __size)
  { return (__size < 512
     ? size_t(512 / __size) : size_t(1)); }
# 105 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Ref, typename _Ptr>
    struct _Deque_iterator
    {






    private:
      template<typename _Up>
 using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
      template<typename _CvTp>
 using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
    public:
      typedef __iter<_Tp> iterator;
      typedef __iter<const _Tp> const_iterator;
      typedef __ptr_to<_Tp> _Elt_pointer;
      typedef __ptr_to<_Elt_pointer> _Map_pointer;


      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }

      typedef std::random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Ptr pointer;
      typedef _Ref reference;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Deque_iterator _Self;

      _Elt_pointer _M_cur;
      _Elt_pointer _M_first;
      _Elt_pointer _M_last;
      _Map_pointer _M_node;

      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) noexcept
      : _M_cur(__x), _M_first(*__y),
        _M_last(*__y + _S_buffer_size()), _M_node(__y) { }

      _Deque_iterator() noexcept
      : _M_cur(), _M_first(), _M_last(), _M_node() { }

      _Deque_iterator(const iterator& __x) noexcept
      : _M_cur(__x._M_cur), _M_first(__x._M_first),
        _M_last(__x._M_last), _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(_M_cur, _M_node); }

      reference
      operator*() const noexcept
      { return *_M_cur; }

      pointer
      operator->() const noexcept
      { return _M_cur; }

      _Self&
      operator++() noexcept
      {
 ++_M_cur;
 if (_M_cur == _M_last)
   {
     _M_set_node(_M_node + 1);
     _M_cur = _M_first;
   }
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 ++*this;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 if (_M_cur == _M_first)
   {
     _M_set_node(_M_node - 1);
     _M_cur = _M_last;
   }
 --_M_cur;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 --*this;
 return __tmp;
      }

      _Self&
      operator+=(difference_type __n) noexcept
      {
 const difference_type __offset = __n + (_M_cur - _M_first);
 if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
   _M_cur += __n;
 else
   {
     const difference_type __node_offset =
       __offset > 0 ? __offset / difference_type(_S_buffer_size())
                    : -difference_type((-__offset - 1)
           / _S_buffer_size()) - 1;
     _M_set_node(_M_node + __node_offset);
     _M_cur = _M_first + (__offset - __node_offset
     * difference_type(_S_buffer_size()));
   }
 return *this;
      }

      _Self
      operator+(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp += __n;
      }

      _Self&
      operator-=(difference_type __n) noexcept
      { return *this += -__n; }

      _Self
      operator-(difference_type __n) const noexcept
      {
 _Self __tmp = *this;
 return __tmp -= __n;
      }

      reference
      operator[](difference_type __n) const noexcept
      { return *(*this + __n); }






      void
      _M_set_node(_Map_pointer __new_node) noexcept
      {
 _M_node = __new_node;
 _M_first = *__new_node;
 _M_last = _M_first + difference_type(_S_buffer_size());
      }
    };




  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x == __y); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                          : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
                                   : (__x._M_node < __y._M_node); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return __y < __x; }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__y < __x); }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
        const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    { return !(__x < __y); }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline bool
    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
        const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    { return !(__x < __y); }





  template<typename _Tp, typename _Ref, typename _Ptr>
    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
 (_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _RefL, typename _PtrL,
    typename _RefR, typename _PtrR>
    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) noexcept
    {
      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
 (_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
 * (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
 + (__y._M_last - __y._M_cur);
    }

  template<typename _Tp, typename _Ref, typename _Ptr>
    inline _Deque_iterator<_Tp, _Ref, _Ptr>
    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
    noexcept
    { return __x + __n; }

  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::copy_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
  _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
         _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
         __result); }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
    _Deque_iterator<_Tp, _Tp&, _Tp*>);

  template<typename _Tp>
    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    { return std::move_backward(_Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__first),
    _Deque_iterator<_Tp,
    const _Tp&, const _Tp*>(__last),
    __result); }
# 457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    class _Deque_base
    {
    protected:
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_Tp>::other _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;





      typedef typename _Alloc_traits::pointer _Ptr;
      typedef typename _Alloc_traits::const_pointer _Ptr_const;


      typedef typename _Alloc_traits::template rebind<_Ptr>::other
 _Map_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;

    public:
      typedef _Alloc allocator_type;
      typedef typename _Alloc_traits::size_type size_type;

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      typedef _Deque_iterator<_Tp, _Tp&, _Ptr> iterator;
      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const> const_iterator;

      _Deque_base()
      : _M_impl()
      { _M_initialize_map(0); }

      _Deque_base(size_t __num_elements)
      : _M_impl()
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a, size_t __num_elements)
      : _M_impl(__a)
      { _M_initialize_map(__num_elements); }

      _Deque_base(const allocator_type& __a)
      : _M_impl(__a)
      { }


      _Deque_base(_Deque_base&& __x, false_type)
      : _M_impl(__x._M_move_impl())
      { }

      _Deque_base(_Deque_base&& __x, true_type)
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      {
 _M_initialize_map(0);
 if (__x._M_impl._M_map)
   this->_M_impl._M_swap_data(__x._M_impl);
      }

      _Deque_base(_Deque_base&& __x)
      : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})
      { }

      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   {
     if (__x._M_impl._M_map)
       {
  _M_initialize_map(0);
  this->_M_impl._M_swap_data(__x._M_impl);
       }
   }
 else
   {
     _M_initialize_map(__n);
   }
      }


      ~_Deque_base() noexcept;

    protected:
      typedef typename iterator::_Map_pointer _Map_pointer;




      struct _Deque_impl
      : public _Tp_alloc_type
      {
 _Map_pointer _M_map;
 size_t _M_map_size;
 iterator _M_start;
 iterator _M_finish;

 _Deque_impl()
 : _Tp_alloc_type(), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }

 _Deque_impl(const _Tp_alloc_type& __a) noexcept
 : _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 _Deque_impl(_Deque_impl&&) = default;

 _Deque_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
   _M_start(), _M_finish()
 { }


 void _M_swap_data(_Deque_impl& __x) noexcept
 {
   using std::swap;
   swap(this->_M_start, __x._M_start);
   swap(this->_M_finish, __x._M_finish);
   swap(this->_M_map, __x._M_map);
   swap(this->_M_map_size, __x._M_map_size);
 }
      };

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      _Map_alloc_type
      _M_get_map_allocator() const noexcept
      { return _Map_alloc_type(_M_get_Tp_allocator()); }

      _Ptr
      _M_allocate_node()
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
      }

      void
      _M_deallocate_node(_Ptr __p) noexcept
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
 _Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
      }

      _Map_pointer
      _M_allocate_map(size_t __n)
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 return _Map_alloc_traits::allocate(__map_alloc, __n);
      }

      void
      _M_deallocate_map(_Map_pointer __p, size_t __n) noexcept
      {
 _Map_alloc_type __map_alloc = _M_get_map_allocator();
 _Map_alloc_traits::deallocate(__map_alloc, __p, __n);
      }

    protected:
      void _M_initialize_map(size_t);
      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
      void _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept;
      enum { _S_initial_map_size = 8 };

      _Deque_impl _M_impl;


    private:
      _Deque_impl
      _M_move_impl()
      {
 if (!_M_impl._M_map)
   return std::move(_M_impl);


 _Tp_alloc_type __alloc{_M_get_Tp_allocator()};

 _Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};

 _Deque_base __empty{__alloc};
 __empty._M_initialize_map(0);

 _Deque_impl __ret{std::move(_M_get_Tp_allocator())};
 _M_impl._M_swap_data(__ret);
 _M_impl._M_swap_data(__empty._M_impl);
 return __ret;
      }

    };

  template<typename _Tp, typename _Alloc>
    _Deque_base<_Tp, _Alloc>::
    ~_Deque_base() noexcept
    {
      if (this->_M_impl._M_map)
 {
   _M_destroy_nodes(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 }
    }
# 677 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_initialize_map(size_t __num_elements)
    {
      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
      + 1);

      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
        size_t(__num_nodes + 2));
      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);






      _Map_pointer __nstart = (this->_M_impl._M_map
          + (this->_M_impl._M_map_size - __num_nodes) / 2);
      _Map_pointer __nfinish = __nstart + __num_nodes;

      try
 { _M_create_nodes(__nstart, __nfinish); }
      catch(...)
 {
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
   this->_M_impl._M_map = _Map_pointer();
   this->_M_impl._M_map_size = 0;
   throw;
 }

      this->_M_impl._M_start._M_set_node(__nstart);
      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
     + __num_elements
     % __deque_buf_size(sizeof(_Tp)));
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
    {
      _Map_pointer __cur;
      try
 {
   for (__cur = __nstart; __cur < __nfinish; ++__cur)
     *__cur = this->_M_allocate_node();
 }
      catch(...)
 {
   _M_destroy_nodes(__nstart, __cur);
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    _Deque_base<_Tp, _Alloc>::
    _M_destroy_nodes(_Map_pointer __nstart,
       _Map_pointer __nfinish) noexcept
    {
      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
 _M_deallocate_node(*__n);
    }
# 828 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class deque : protected _Deque_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



     

      typedef _Deque_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Alloc_traits _Alloc_traits;
      typedef typename _Base::_Map_pointer _Map_pointer;

    public:
      typedef _Tp value_type;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Base::iterator iterator;
      typedef typename _Base::const_iterator const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      static size_t _S_buffer_size() noexcept
      { return __deque_buf_size(sizeof(_Tp)); }


      using _Base::_M_initialize_map;
      using _Base::_M_create_nodes;
      using _Base::_M_destroy_nodes;
      using _Base::_M_allocate_node;
      using _Base::_M_deallocate_node;
      using _Base::_M_allocate_map;
      using _Base::_M_deallocate_map;
      using _Base::_M_get_Tp_allocator;





      using _Base::_M_impl;

    public:






      deque() : _Base() { }





      explicit
      deque(const allocator_type& __a)
      : _Base(__a, 0) { }
# 903 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      explicit
      deque(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_default_initialize(); }
# 916 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(size_type __n, const value_type& __value,
     const allocator_type& __a = allocator_type())
      : _Base(__a, __n)
      { _M_fill_initialize(__value); }
# 943 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(const deque& __x)
      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
       __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }
# 958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(deque&& __x)
      : _Base(std::move(__x)) { }


      deque(const deque& __x, const allocator_type& __a)
      : _Base(__a, __x.size())
      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
        this->_M_impl._M_start,
        _M_get_Tp_allocator()); }


      deque(deque&& __x, const allocator_type& __a)
      : _Base(std::move(__x), __a, __x.size())
      {
 if (__x.get_allocator() != __a)
   {
     std::__uninitialized_move_a(__x.begin(), __x.end(),
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
     __x.clear();
   }
      }
# 992 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque(initializer_list<value_type> __l,
     const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        deque(_InputIterator __first, _InputIterator __last,
       const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 1040 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      ~deque()
      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
# 1050 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque&
      operator=(const deque& __x);
# 1062 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque&
      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
      {
 using __always_equal = typename _Alloc_traits::is_always_equal;
 _M_move_assign1(std::move(__x), __always_equal{});
 return *this;
      }
# 1081 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      deque&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 1099 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 1116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 1143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return this->_M_impl._M_start; }





      const_iterator
      begin() const noexcept
      { return this->_M_impl._M_start; }






      iterator
      end() noexcept
      { return this->_M_impl._M_finish; }






      const_iterator
      end() const noexcept
      { return this->_M_impl._M_finish; }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->_M_impl._M_start); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }






      const_iterator
      cbegin() const noexcept
      { return this->_M_impl._M_start; }






      const_iterator
      cend() const noexcept
      { return this->_M_impl._M_finish; }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->_M_impl._M_start); }




      size_type
      size() const noexcept
      { return this->_M_impl._M_finish - this->_M_impl._M_start; }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 1282 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size)
      {
 const size_type __len = size();
 if (__new_size > __len)
   _M_default_append(__new_size - __len);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 const size_type __len = size();
 if (__new_size > __len)
   insert(this->_M_impl._M_finish, __new_size - __len, __x);
 else if (__new_size < __len)
   _M_erase_at_end(this->_M_impl._M_start
     + difference_type(__new_size));
      }
# 1340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      shrink_to_fit() noexcept
      { _M_shrink_to_fit(); }






      bool
      empty() const noexcept
      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
# 1365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      reference
      operator[](size_type __n) noexcept
      { return this->_M_impl._M_start[difference_type(__n)]; }
# 1380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      { return this->_M_impl._M_start[difference_type(__n)]; }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("deque::_M_range_check: __n " "(which is %zu)>= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 1408 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 1426 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 1483 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      push_front(const value_type& __x)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                              __x);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(__x);
      }


      void
      push_front(value_type&& __x)
      { emplace_front(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args);
# 1516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur, __x);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(__x);
      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      pop_front() noexcept
      {
 if (this->_M_impl._M_start._M_cur
     != this->_M_impl._M_start._M_last - 1)
   {
     _Alloc_traits::destroy(this->_M_impl,
                            this->_M_impl._M_start._M_cur);
     ++this->_M_impl._M_start._M_cur;
   }
 else
   _M_pop_front_aux();
      }
# 1570 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      pop_back() noexcept
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_first)
   {
     --this->_M_impl._M_finish._M_cur;
     _Alloc_traits::destroy(this->_M_impl,
                            this->_M_impl._M_finish._M_cur);
   }
 else
   _M_pop_back_aux();
      }
# 1594 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 1607 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1633 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1646 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1662 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(__position._M_const_cast(), __n, __x);
 return begin() + __offset;
      }
# 1696 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(__position._M_const_cast(),
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1742 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __position)



      { return _M_erase(__position._M_const_cast()); }
# 1766 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)



      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
# 1783 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      swap(deque& __x) noexcept
      {
 _M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
      __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(begin()); }

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        {
   _M_initialize_map(static_cast<size_type>(__n));
   _M_fill_initialize(__x);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }
# 1839 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first, _InputIterator __last,
       std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
       std::forward_iterator_tag);
# 1861 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      _M_fill_initialize(const value_type& __value);



      void
      _M_default_initialize();
# 1877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag)
        {
   const size_type __len = std::distance(__first, __last);
   if (__len > size())
     {
       _ForwardIterator __mid = __first;
       std::advance(__mid, size());
       std::copy(__first, __mid, begin());
       insert(end(), __mid, __last);
     }
   else
     _M_erase_at_end(std::copy(__first, __last, begin()));
 }



      void
      _M_fill_assign(size_type __n, const value_type& __val)
      {
 if (__n > size())
   {
     std::fill(begin(), end(), __val);
     insert(end(), __n - size(), __val);
   }
 else
   {
     _M_erase_at_end(begin() + difference_type(__n));
     std::fill(begin(), end(), __val);
   }
      }
# 1941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename... _Args>
        void _M_push_back_aux(_Args&&... __args);

      template<typename... _Args>
        void _M_push_front_aux(_Args&&... __args);


      void _M_pop_back_aux();

      void _M_pop_front_aux();
# 1960 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos,
      _Integer __n, _Integer __x, __true_type)
        { _M_fill_insert(__pos, __n, __x); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos,
      _InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
          _M_range_insert_aux(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert_aux(iterator __pos, _InputIterator __first,
       _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert_aux(iterator __pos, _ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag);




      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);






      template<typename... _Args>
        iterator
        _M_insert_aux(iterator __pos, _Args&&... __args);



      void
      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);


      template<typename _ForwardIterator>
        void
        _M_insert_aux(iterator __pos,
        _ForwardIterator __first, _ForwardIterator __last,
        size_type __n);




      void
      _M_destroy_data_aux(iterator __first, iterator __last);



      template<typename _Alloc1>
        void
        _M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
        { _M_destroy_data_aux(__first, __last); }

      void
      _M_destroy_data(iterator __first, iterator __last,
        const std::allocator<_Tp>&)
      {
 if (!__has_trivial_destructor(value_type))
   _M_destroy_data_aux(__first, __last);
      }


      void
      _M_erase_at_begin(iterator __pos)
      {
 _M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
 _M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
 this->_M_impl._M_start = __pos;
      }



      void
      _M_erase_at_end(iterator __pos)
      {
 _M_destroy_data(__pos, end(), _M_get_Tp_allocator());
 _M_destroy_nodes(__pos._M_node + 1,
    this->_M_impl._M_finish._M_node + 1);
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __pos);

      iterator
      _M_erase(iterator __first, iterator __last);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();




      iterator
      _M_reserve_elements_at_front(size_type __n)
      {
 const size_type __vacancies = this->_M_impl._M_start._M_cur
                               - this->_M_impl._M_start._M_first;
 if (__n > __vacancies)
   _M_new_elements_at_front(__n - __vacancies);
 return this->_M_impl._M_start - difference_type(__n);
      }

      iterator
      _M_reserve_elements_at_back(size_type __n)
      {
 const size_type __vacancies = (this->_M_impl._M_finish._M_last
           - this->_M_impl._M_finish._M_cur) - 1;
 if (__n > __vacancies)
   _M_new_elements_at_back(__n - __vacancies);
 return this->_M_impl._M_finish + difference_type(__n);
      }

      void
      _M_new_elements_at_front(size_type __new_elements);

      void
      _M_new_elements_at_back(size_type __new_elements);
# 2111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
      void
      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add + 1 > this->_M_impl._M_map_size
     - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, false);
      }

      void
      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
      {
 if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
           - this->_M_impl._M_map))
   _M_reallocate_map(__nodes_to_add, true);
      }

      void
      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);





      void
      _M_move_assign1(deque&& __x, true_type) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 __x.clear();
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }




      void
      _M_move_assign1(deque&& __x, false_type)
      {
 constexpr bool __move_storage =
   _Alloc_traits::_S_propagate_on_move_assign();
 _M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
      }



      template<typename... _Args>
      void
      _M_replace_map(_Args&&... __args)
      {

 deque __newobj(std::forward<_Args>(__args)...);

 clear();
 _M_deallocate_node(*begin()._M_node);
 _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
 this->_M_impl._M_map = nullptr;
 this->_M_impl._M_map_size = 0;

 this->_M_impl._M_swap_data(__newobj._M_impl);
      }


      void
      _M_move_assign2(deque&& __x, true_type)
      {

 auto __alloc = __x._M_get_Tp_allocator();


 _M_replace_map(std::move(__x));

 _M_get_Tp_allocator() = std::move(__alloc);
      }



      void
      _M_move_assign2(deque&& __x, false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   {


     _M_replace_map(std::move(__x), __x.get_allocator());
   }
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }

    };
# 2218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const deque<_Tp, _Alloc>& __x,
                         const deque<_Tp, _Alloc>& __y)
    { return __x.size() == __y.size()
             && std::equal(__x.begin(), __x.end(), __y.begin()); }
# 2236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_deque.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const deque<_Tp, _Alloc>& __x,
       const deque<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const deque<_Tp, _Alloc>& __x,
        const deque<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }




}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3



namespace std
{







  template<typename _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<typename _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<typename _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<typename _Tp, size_t _Nm>
    inline constexpr _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }



  template<typename _Tp> class valarray;

  template<typename _Tp> _Tp* begin(valarray<_Tp>&);
  template<typename _Tp> const _Tp* begin(const valarray<_Tp>&);
  template<typename _Tp> _Tp* end(valarray<_Tp>&);
  template<typename _Tp> const _Tp* end(const valarray<_Tp>&);






  template<typename _Container>
    inline constexpr auto
    cbegin(const _Container& __cont) noexcept(noexcept(std::begin(__cont)))
      -> decltype(std::begin(__cont))
    { return std::begin(__cont); }






  template<typename _Container>
    inline constexpr auto
    cend(const _Container& __cont) noexcept(noexcept(std::end(__cont)))
      -> decltype(std::end(__cont))
    { return std::end(__cont); }






  template<typename _Container>
    inline auto
    rbegin(_Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rbegin(const _Container& __cont) -> decltype(__cont.rbegin())
    { return __cont.rbegin(); }






  template<typename _Container>
    inline auto
    rend(_Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Container>
    inline auto
    rend(const _Container& __cont) -> decltype(__cont.rend())
    { return __cont.rend(); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rbegin(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr + _Nm); }






  template<typename _Tp, size_t _Nm>
    inline reverse_iterator<_Tp*>
    rend(_Tp (&__arr)[_Nm])
    { return reverse_iterator<_Tp*>(__arr); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rbegin(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.end()); }






  template<typename _Tp>
    inline reverse_iterator<const _Tp*>
    rend(initializer_list<_Tp> __il)
    { return reverse_iterator<const _Tp*>(__il.begin()); }






  template<typename _Container>
    inline auto
    crbegin(const _Container& __cont) -> decltype(std::rbegin(__cont))
    { return std::rbegin(__cont); }






  template<typename _Container>
    inline auto
    crend(const _Container& __cont) -> decltype(std::rend(__cont))
    { return std::rend(__cont); }
# 319 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/range_access.h" 3

}
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/deque.tcc" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/deque.tcc" 3
namespace std
{



  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_initialize()
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_default_a(*__cur, *__cur + _S_buffer_size(),
        _M_get_Tp_allocator());
          std::__uninitialized_default_a(this->_M_impl._M_finish._M_first,
      this->_M_impl._M_finish._M_cur,
      _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }


  template <typename _Tp, typename _Alloc>
    deque<_Tp, _Alloc>&
    deque<_Tp, _Alloc>::
    operator=(const deque& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {


    _M_replace_map(__x, __x.get_allocator());
    std::__alloc_on_copy(_M_get_Tp_allocator(),
           __x._M_get_Tp_allocator());
    return *this;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __len = size();
   if (__len >= __x.size())
     _M_erase_at_end(std::copy(__x.begin(), __x.end(),
          this->_M_impl._M_start));
   else
     {
       const_iterator __mid = __x.begin() + difference_type(__len);
       std::copy(__x.begin(), __mid, this->_M_impl._M_start);
       insert(this->_M_impl._M_finish, __mid, __x.end());
     }
 }
      return *this;
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_front(_Args&&... __args)
      {
 if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur - 1,
                std::forward<_Args>(__args)...);
     --this->_M_impl._M_start._M_cur;
   }
 else
   _M_push_front_aux(std::forward<_Args>(__args)...);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish._M_cur
     != this->_M_impl._M_finish._M_last - 1)
   {
     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish._M_cur;
   }
 else
   _M_push_back_aux(std::forward<_Args>(__args)...);
      }



  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 if (__position._M_cur == this->_M_impl._M_start._M_cur)
   {
     emplace_front(std::forward<_Args>(__args)...);
     return this->_M_impl._M_start;
   }
 else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
   {
     emplace_back(std::forward<_Args>(__args)...);
     iterator __tmp = this->_M_impl._M_finish;
     --__tmp;
     return __tmp;
   }
 else
   return _M_insert_aux(__position._M_const_cast(),
          std::forward<_Args>(__args)...);
      }


  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      if (__position._M_cur == this->_M_impl._M_start._M_cur)
 {
   push_front(__x);
   return this->_M_impl._M_start;
 }
      else if (__position._M_cur == this->_M_impl._M_finish._M_cur)
 {
   push_back(__x);
   iterator __tmp = this->_M_impl._M_finish;
   --__tmp;
   return __tmp;
 }
      else
 return _M_insert_aux(__position._M_const_cast(), __x);
   }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      iterator __next = __position;
      ++__next;
      const difference_type __index = __position - begin();
      if (static_cast<size_type>(__index) < (size() >> 1))
 {
   if (__position != begin())
     std::move_backward(begin(), __position, __next);
   pop_front();
 }
      else
 {
   if (__next != end())
     std::move(__next, end(), __position);
   pop_back();
 }
      return begin() + __index;
    }

  template <typename _Tp, typename _Alloc>
    typename deque<_Tp, _Alloc>::iterator
    deque<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first == __last)
 return __first;
      else if (__first == begin() && __last == end())
 {
   clear();
   return end();
 }
      else
 {
   const difference_type __n = __last - __first;
   const difference_type __elems_before = __first - begin();
   if (static_cast<size_type>(__elems_before) <= (size() - __n) / 2)
     {
       if (__first != begin())
  std::move_backward(begin(), __first, __last);
       _M_erase_at_begin(begin() + __n);
     }
   else
     {
       if (__last != end())
  std::move(__last, end(), __first);
       _M_erase_at_end(end() - __n);
     }
   return begin() + __elems_before;
 }
    }

  template <typename _Tp, class _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
        iterator __cur = begin();
        for (; __first != __last && __cur != end(); ++__cur, ++__first)
          *__cur = *__first;
        if (__first == __last)
          _M_erase_at_end(__cur);
        else
          insert(end(), __first, __last);
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)
    {
      if (__pos._M_cur == this->_M_impl._M_start._M_cur)
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   try
     {
       std::__uninitialized_fill_a(__new_start, this->_M_impl._M_start,
       __x, _M_get_Tp_allocator());
       this->_M_impl._M_start = __new_start;
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_fill_a(this->_M_impl._M_finish,
       __new_finish, __x,
       _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
      else
        _M_insert_aux(__pos, __n, __x);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n)
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   try
     {
       std::__uninitialized_default_a(this->_M_impl._M_finish,
          __new_finish,
          _M_get_Tp_allocator());
       this->_M_impl._M_finish = __new_finish;
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    bool
    deque<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      const difference_type __front_capacity
 = (this->_M_impl._M_start._M_cur - this->_M_impl._M_start._M_first);
      if (__front_capacity == 0)
 return false;

      const difference_type __back_capacity
 = (this->_M_impl._M_finish._M_last - this->_M_impl._M_finish._M_cur);
      if (__front_capacity + __back_capacity < _S_buffer_size())
 return false;

      return std::__shrink_to_fit_aux<deque>::_S_do_it(*this);
    }


  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_fill_initialize(const value_type& __value)
    {
      _Map_pointer __cur;
      try
        {
          for (__cur = this->_M_impl._M_start._M_node;
        __cur < this->_M_impl._M_finish._M_node;
        ++__cur)
            std::__uninitialized_fill_a(*__cur, *__cur + _S_buffer_size(),
     __value, _M_get_Tp_allocator());
          std::__uninitialized_fill_a(this->_M_impl._M_finish._M_first,
          this->_M_impl._M_finish._M_cur,
          __value, _M_get_Tp_allocator());
        }
      catch(...)
        {
          std::_Destroy(this->_M_impl._M_start, iterator(*__cur, __cur),
   _M_get_Tp_allocator());
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      {
        this->_M_initialize_map(0);
        try
          {
            for (; __first != __last; ++__first)

       emplace_back(*__first);



          }
        catch(...)
          {
            clear();
            throw;
          }
      }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        this->_M_initialize_map(__n);

        _Map_pointer __cur_node;
        try
          {
            for (__cur_node = this->_M_impl._M_start._M_node;
                 __cur_node < this->_M_impl._M_finish._M_node;
                 ++__cur_node)
       {
  _ForwardIterator __mid = __first;
  std::advance(__mid, _S_buffer_size());
  std::__uninitialized_copy_a(__first, __mid, *__cur_node,
         _M_get_Tp_allocator());
  __first = __mid;
       }
            std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_finish._M_first,
     _M_get_Tp_allocator());
          }
        catch(...)
          {
            std::_Destroy(this->_M_impl._M_start,
     iterator(*__cur_node, __cur_node),
     _M_get_Tp_allocator());
            throw;
          }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_back_aux(_Args&&... __args)





      {
 _M_reserve_map_at_back();
 *(this->_M_impl._M_finish._M_node + 1) = this->_M_allocate_node();
 try
   {

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_finish._M_cur,
                std::forward<_Args>(__args)...);



     this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node
      + 1);
     this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_first;
   }
 catch(...)
   {
     _M_deallocate_node(*(this->_M_impl._M_finish._M_node + 1));
     throw;
   }
      }


  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      void
      deque<_Tp, _Alloc>::
      _M_push_front_aux(_Args&&... __args)





      {
 _M_reserve_map_at_front();
 *(this->_M_impl._M_start._M_node - 1) = this->_M_allocate_node();
 try
   {
     this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node
            - 1);
     this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_last - 1;

     _Alloc_traits::construct(this->_M_impl,
                              this->_M_impl._M_start._M_cur,
                std::forward<_Args>(__args)...);



   }
 catch(...)
   {
     ++this->_M_impl._M_start;
     _M_deallocate_node(*(this->_M_impl._M_start._M_node - 1));
     throw;
   }
      }


  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_back_aux()
    {
      _M_deallocate_node(this->_M_impl._M_finish._M_first);
      this->_M_impl._M_finish._M_set_node(this->_M_impl._M_finish._M_node - 1);
      this->_M_impl._M_finish._M_cur = this->_M_impl._M_finish._M_last - 1;
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_finish._M_cur);
    }






  template <typename _Tp, typename _Alloc>
    void deque<_Tp, _Alloc>::
    _M_pop_front_aux()
    {
      _Alloc_traits::destroy(_M_get_Tp_allocator(),
        this->_M_impl._M_start._M_cur);
      _M_deallocate_node(this->_M_impl._M_start._M_first);
      this->_M_impl._M_start._M_set_node(this->_M_impl._M_start._M_node + 1);
      this->_M_impl._M_start._M_cur = this->_M_impl._M_start._M_first;
    }

  template <typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _InputIterator __first, _InputIterator __last,
                          std::input_iterator_tag)
      { std::copy(__first, __last, std::inserter(*this, __pos)); }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_range_insert_aux(iterator __pos,
                          _ForwardIterator __first, _ForwardIterator __last,
                          std::forward_iterator_tag)
      {
        const size_type __n = std::distance(__first, __last);
        if (__pos._M_cur == this->_M_impl._M_start._M_cur)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last, __new_start,
         _M_get_Tp_allocator());
  this->_M_impl._M_start = __new_start;
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else if (__pos._M_cur == this->_M_impl._M_finish._M_cur)
   {
     iterator __new_finish = _M_reserve_elements_at_back(__n);
     try
       {
  std::__uninitialized_copy_a(__first, __last,
         this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  this->_M_impl._M_finish = __new_finish;
       }
     catch(...)
       {
  _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
     __new_finish._M_node + 1);
  throw;
       }
   }
        else
          _M_insert_aux(__pos, __first, __last, __n);
      }

  template<typename _Tp, typename _Alloc>

    template<typename... _Args>
      typename deque<_Tp, _Alloc>::iterator
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos, _Args&&... __args)
      {
 value_type __x_copy(std::forward<_Args>(__args)...);







 difference_type __index = __pos - this->_M_impl._M_start;
 if (static_cast<size_type>(__index) < size() / 2)
   {
     push_front(std::move(front()));
     iterator __front1 = this->_M_impl._M_start;
     ++__front1;
     iterator __front2 = __front1;
     ++__front2;
     __pos = this->_M_impl._M_start + __index;
     iterator __pos1 = __pos;
     ++__pos1;
     std::move(__front2, __pos1, __front1);
   }
 else
   {
     push_back(std::move(back()));
     iterator __back1 = this->_M_impl._M_finish;
     --__back1;
     iterator __back2 = __back1;
     --__back2;
     __pos = this->_M_impl._M_start + __index;
     std::move_backward(__pos, __back2, __back1);
   }
 *__pos = std::move(__x_copy);
 return __pos;
      }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)
    {
      const difference_type __elems_before = __pos - this->_M_impl._M_start;
      const size_type __length = this->size();
      value_type __x_copy = __x;
      if (__elems_before < difference_type(__length / 2))
 {
   iterator __new_start = _M_reserve_elements_at_front(__n);
   iterator __old_start = this->_M_impl._M_start;
   __pos = this->_M_impl._M_start + __elems_before;
   try
     {
       if (__elems_before >= difference_type(__n))
  {
    iterator __start_n = (this->_M_impl._M_start
     + difference_type(__n));
    std::__uninitialized_move_a(this->_M_impl._M_start,
           __start_n, __new_start,
           _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::move(__start_n, __pos, __old_start);
    std::fill(__pos - difference_type(__n), __pos, __x_copy);
  }
       else
  {
    std::__uninitialized_move_fill(this->_M_impl._M_start,
       __pos, __new_start,
       this->_M_impl._M_start,
       __x_copy,
       _M_get_Tp_allocator());
    this->_M_impl._M_start = __new_start;
    std::fill(__old_start, __pos, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(__new_start._M_node,
          this->_M_impl._M_start._M_node);
       throw;
     }
 }
      else
 {
   iterator __new_finish = _M_reserve_elements_at_back(__n);
   iterator __old_finish = this->_M_impl._M_finish;
   const difference_type __elems_after =
     difference_type(__length) - __elems_before;
   __pos = this->_M_impl._M_finish - __elems_after;
   try
     {
       if (__elems_after > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::fill(__pos, __pos + difference_type(__n), __x_copy);
  }
       else
  {
    std::__uninitialized_fill_move(this->_M_impl._M_finish,
       __pos + difference_type(__n),
       __x_copy, __pos,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::fill(__pos, __old_finish, __x_copy);
  }
     }
   catch(...)
     {
       _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
       throw;
     }
 }
    }

  template <typename _Tp, typename _Alloc>
    template <typename _ForwardIterator>
      void
      deque<_Tp, _Alloc>::
      _M_insert_aux(iterator __pos,
                    _ForwardIterator __first, _ForwardIterator __last,
                    size_type __n)
      {
        const difference_type __elemsbefore = __pos - this->_M_impl._M_start;
        const size_type __length = size();
        if (static_cast<size_type>(__elemsbefore) < __length / 2)
   {
     iterator __new_start = _M_reserve_elements_at_front(__n);
     iterator __old_start = this->_M_impl._M_start;
     __pos = this->_M_impl._M_start + __elemsbefore;
     try
       {
  if (__elemsbefore >= difference_type(__n))
    {
      iterator __start_n = (this->_M_impl._M_start
       + difference_type(__n));
      std::__uninitialized_move_a(this->_M_impl._M_start,
      __start_n, __new_start,
      _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::move(__start_n, __pos, __old_start);
      std::copy(__first, __last, __pos - difference_type(__n));
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, difference_type(__n) - __elemsbefore);
      std::__uninitialized_move_copy(this->_M_impl._M_start,
         __pos, __first, __mid,
         __new_start,
         _M_get_Tp_allocator());
      this->_M_impl._M_start = __new_start;
      std::copy(__mid, __last, __old_start);
    }
       }
     catch(...)
       {
  _M_destroy_nodes(__new_start._M_node,
     this->_M_impl._M_start._M_node);
  throw;
       }
   }
        else
        {
          iterator __new_finish = _M_reserve_elements_at_back(__n);
          iterator __old_finish = this->_M_impl._M_finish;
          const difference_type __elemsafter =
            difference_type(__length) - __elemsbefore;
          __pos = this->_M_impl._M_finish - __elemsafter;
          try
            {
              if (__elemsafter > difference_type(__n))
  {
    iterator __finish_n = (this->_M_impl._M_finish
      - difference_type(__n));
    std::__uninitialized_move_a(__finish_n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::move_backward(__pos, __finish_n, __old_finish);
    std::copy(__first, __last, __pos);
  }
              else
  {
    _ForwardIterator __mid = __first;
    std::advance(__mid, __elemsafter);
    std::__uninitialized_copy_move(__mid, __last, __pos,
       this->_M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
    this->_M_impl._M_finish = __new_finish;
    std::copy(__first, __mid, __pos);
  }
            }
          catch(...)
            {
              _M_destroy_nodes(this->_M_impl._M_finish._M_node + 1,
          __new_finish._M_node + 1);
              throw;
            }
        }
      }

   template<typename _Tp, typename _Alloc>
     void
     deque<_Tp, _Alloc>::
     _M_destroy_data_aux(iterator __first, iterator __last)
     {
       for (_Map_pointer __node = __first._M_node + 1;
     __node < __last._M_node; ++__node)
  std::_Destroy(*__node, *__node + _S_buffer_size(),
         _M_get_Tp_allocator());

       if (__first._M_node != __last._M_node)
  {
    std::_Destroy(__first._M_cur, __first._M_last,
    _M_get_Tp_allocator());
    std::_Destroy(__last._M_first, __last._M_cur,
    _M_get_Tp_allocator());
  }
       else
  std::_Destroy(__first._M_cur, __last._M_cur,
         _M_get_Tp_allocator());
     }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_front(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_front"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_front(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_start._M_node - __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_start._M_node - __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_new_elements_at_back(size_type __new_elems)
    {
      if (this->max_size() - this->size() < __new_elems)
 __throw_length_error(("deque::_M_new_elements_at_back"));

      const size_type __new_nodes = ((__new_elems + _S_buffer_size() - 1)
         / _S_buffer_size());
      _M_reserve_map_at_back(__new_nodes);
      size_type __i;
      try
        {
          for (__i = 1; __i <= __new_nodes; ++__i)
            *(this->_M_impl._M_finish._M_node + __i) = this->_M_allocate_node();
        }
      catch(...)
        {
          for (size_type __j = 1; __j < __i; ++__j)
            _M_deallocate_node(*(this->_M_impl._M_finish._M_node + __j));
          throw;
        }
    }

  template <typename _Tp, typename _Alloc>
    void
    deque<_Tp, _Alloc>::
    _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)
    {
      const size_type __old_num_nodes
 = this->_M_impl._M_finish._M_node - this->_M_impl._M_start._M_node + 1;
      const size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

      _Map_pointer __new_nstart;
      if (this->_M_impl._M_map_size > 2 * __new_num_nodes)
 {
   __new_nstart = this->_M_impl._M_map + (this->_M_impl._M_map_size
      - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   if (__new_nstart < this->_M_impl._M_start._M_node)
     std::copy(this->_M_impl._M_start._M_node,
        this->_M_impl._M_finish._M_node + 1,
        __new_nstart);
   else
     std::copy_backward(this->_M_impl._M_start._M_node,
          this->_M_impl._M_finish._M_node + 1,
          __new_nstart + __old_num_nodes);
 }
      else
 {
   size_type __new_map_size = this->_M_impl._M_map_size
                              + std::max(this->_M_impl._M_map_size,
      __nodes_to_add) + 2;

   _Map_pointer __new_map = this->_M_allocate_map(__new_map_size);
   __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
                  + (__add_at_front ? __nodes_to_add : 0);
   std::copy(this->_M_impl._M_start._M_node,
      this->_M_impl._M_finish._M_node + 1,
      __new_nstart);
   _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);

   this->_M_impl._M_map = __new_map;
   this->_M_impl._M_map_size = __new_map_size;
 }

      this->_M_impl._M_start._M_set_node(__new_nstart);
      this->_M_impl._M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
    }



  template<typename _Tp>
    void
    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>& __first,
  const _Deque_iterator<_Tp, _Tp&, _Tp*>& __last, const _Tp& __value)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;

      for (typename _Self::_Map_pointer __node = __first._M_node + 1;
           __node < __last._M_node; ++__node)
 std::fill(*__node, *__node + _Self::_S_buffer_size(), __value);

      if (__first._M_node != __last._M_node)
 {
   std::fill(__first._M_cur, __first._M_last, __value);
   std::fill(__last._M_first, __last._M_cur, __value);
 }
      else
 std::fill(__first._M_cur, __last._M_cur, __value);
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::copy(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::copy_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }


  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
  _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   const difference_type __clen
     = std::min(__len, std::min(__first._M_last - __first._M_cur,
           __result._M_last - __result._M_cur));
   std::move(__first._M_cur, __first._M_cur + __clen, __result._M_cur);
   __first += __clen;
   __result += __clen;
   __len -= __clen;
 }
      return __result;
    }

  template<typename _Tp>
    _Deque_iterator<_Tp, _Tp&, _Tp*>
    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*> __first,
    _Deque_iterator<_Tp, const _Tp&, const _Tp*> __last,
    _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
    {
      typedef typename _Deque_iterator<_Tp, _Tp&, _Tp*>::_Self _Self;
      typedef typename _Self::difference_type difference_type;

      difference_type __len = __last - __first;
      while (__len > 0)
 {
   difference_type __llen = __last._M_cur - __last._M_first;
   _Tp* __lend = __last._M_cur;

   difference_type __rlen = __result._M_cur - __result._M_first;
   _Tp* __rend = __result._M_cur;

   if (!__llen)
     {
       __llen = _Self::_S_buffer_size();
       __lend = *(__last._M_node - 1) + __llen;
     }
   if (!__rlen)
     {
       __rlen = _Self::_S_buffer_size();
       __rend = *(__result._M_node - 1) + __rlen;
     }

   const difference_type __clen = std::min(__len,
        std::min(__llen, __rlen));
   std::move_backward(__lend - __clen, __lend, __rend);
   __last -= __clen;
   __result -= __clen;
   __len -= __clen;
 }
      return __result;
    }



}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/deque" 2 3
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 3





# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 1 3
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
namespace std
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Vector_impl(_Tp_alloc_type const& __a) noexcept
 : _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Vector_impl(_Tp_alloc_type&& __a) noexcept
 : _Tp_alloc_type(std::move(__a)),
   _M_start(), _M_finish(), _M_end_of_storage()
 { }


 void _M_swap_data(_Vector_impl& __x) noexcept
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator() noexcept
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const noexcept
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a) noexcept
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }


      _Vector_base(_Tp_alloc_type&& __a) noexcept
      : _M_impl(std::move(__a)) { }

      _Vector_base(_Vector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_swap_data(__x._M_impl); }

      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
      : _M_impl(__a)
      {
 if (__x.get_allocator() == __a)
   this->_M_impl._M_swap_data(__x._M_impl);
 else
   {
     size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
     _M_create_storage(__n);
   }
      }


      ~_Vector_base() noexcept
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
      }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
 if (__p)
   _Tr::deallocate(_M_impl, __p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
# 213 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;



     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:






      vector()

      noexcept(is_nothrow_default_constructible<_Alloc>::value)

      : _Base() { }





      explicit
      vector(const allocator_type& __a) noexcept
      : _Base(__a) { }
# 278 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_default_initialize(__n); }
# 291 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(size_type __n, const value_type& __value,
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
# 337 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(vector&& __x) noexcept
      : _Base(std::move(__x)) { }


      vector(const vector& __x, const allocator_type& __a)
      : _Base(__x.size(), __a)
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }


      vector(vector&& __rv, const allocator_type& __m)
      noexcept(_Alloc_traits::_S_always_equal())
      : _Base(std::move(__rv), __m)
      {
 if (__rv.get_allocator() != __m)
   {
     this->_M_impl._M_finish =
       std::__uninitialized_move_a(__rv.begin(), __rv.end(),
       this->_M_impl._M_start,
       _M_get_Tp_allocator());
     __rv.clear();
   }
      }
# 375 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector(initializer_list<value_type> __l,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 _M_range_initialize(__l.begin(), __l.end(),
       random_access_iterator_tag());
      }
# 401 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 425 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      ~vector() noexcept
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
# 437 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
# 449 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector&
      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          _Alloc_traits::_S_propagate_on_move_assign()
          || _Alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__x), __bool_constant<__move_storage>());
 return *this;
      }
# 470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      vector&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 488 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 505 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      using _Base::get_allocator;







      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end() noexcept
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_start); }






      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_impl._M_finish); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }




      size_type
      size() const noexcept
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const noexcept
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
# 673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size)
      {
 if (__new_size > size())
   _M_default_append(__new_size - size());
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 693 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, const value_type& __x)
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
# 725 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      shrink_to_fit()
      { _M_shrink_to_fit(); }






      size_type
      capacity() const noexcept
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const noexcept
      { return begin() == end(); }
# 764 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
# 779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      reference
      operator[](size_type __n) noexcept
      { return *(this->_M_impl._M_start + __n); }
# 794 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const noexcept
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("vector::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
      }

    public:
# 822 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
# 840 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      { return *(end() - 1); }





      const_reference
      back() const noexcept
      { return *(end() - 1); }
# 887 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      _Tp*



      data() noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }


      const _Tp*



      data() const noexcept
      { return _M_data_ptr(this->_M_impl._M_start); }
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else

   _M_emplace_back_aux(__x);



      }


      void
      push_back(value_type&& __x)
      { emplace_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args);
# 949 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      pop_back() noexcept
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
# 969 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 984 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1014 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, initializer_list<value_type> __l)
      { return this->insert(__position, __l.begin(), __l.end()); }
# 1051 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x)
      {
 difference_type __offset = __position - cbegin();
 _M_fill_insert(begin() + __offset, __n, __x);
 return begin() + __offset;
      }
# 1093 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        iterator
        insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last)
        {
   difference_type __offset = __position - cbegin();
   _M_insert_dispatch(begin() + __offset,
        __first, __last, __false_type());
   return begin() + __offset;
 }
# 1145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __position)
      { return _M_erase(begin() + (__position - cbegin())); }
# 1172 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last)
      {
 const auto __beg = begin();
 const auto __cbeg = cbegin();
 return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
      }
# 1194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      void
      swap(vector& __x) noexcept
      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear() noexcept
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
# 1243 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
     _M_get_Tp_allocator());
      }



      void
      _M_default_initialize(size_type __n)
      {
 this->_M_impl._M_finish =
   std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
        _M_get_Tp_allocator());
      }
# 1321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
# 1361 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);



      void
      _M_default_append(size_type __n);

      bool
      _M_shrink_to_fit();







      template<typename... _Args>
        void
        _M_insert_aux(iterator __position, _Args&&... __args);

      template<typename... _Args>
        void
        _M_emplace_back_aux(_Args&&... __args);



      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos) noexcept
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }

      iterator
      _M_erase(iterator __position);

      iterator
      _M_erase(iterator __first, iterator __last);


    private:



      void
      _M_move_assign(vector&& __x, std::true_type) noexcept
      {
 vector __tmp(get_allocator());
 this->_M_impl._M_swap_data(__tmp._M_impl);
 this->_M_impl._M_swap_data(__x._M_impl);
 std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
      }



      void
      _M_move_assign(vector&& __x, std::false_type)
      {
 if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
   _M_move_assign(std::move(__x), std::true_type());
 else
   {


     this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
    std::__make_move_if_noexcept_iterator(__x.end()));
     __x.clear();
   }
      }



      template<typename _Up>
 _Up*
 _M_data_ptr(_Up* __ptr) const
 { return __ptr; }

      template<typename _Ptr>
 typename std::pointer_traits<_Ptr>::element_type*
 _M_data_ptr(_Ptr __ptr) const
 { return empty() ? nullptr : std::__addressof(*__ptr); }






    };
# 1507 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
# 1524 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }


}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
namespace std
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() noexcept : _M_p(0), _M_mask(0) { }

    operator bool() const noexcept
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x) noexcept
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x) noexcept
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip() noexcept
    { *_M_p ^= _M_mask; }
  };


  inline void
  swap(_Bit_reference __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(_Bit_reference __x, bool& __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }

  inline void
  swap(bool& __x, _Bit_reference __y) noexcept
  {
    bool __tmp = __x;
    __x = __y;
    __y = __tmp;
  }


  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    iterator
    _M_const_cast() const
    { return *this; }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    _Bit_iterator
    _M_const_cast() const
    { return _Bit_iterator(_M_p, _M_offset); }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Bit_type>::other _Bit_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Bit_alloc_type>
 _Bit_alloc_traits;
      typedef typename _Bit_alloc_traits::pointer _Bit_pointer;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_pointer _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
 { }


 _Bvector_impl(_Bit_alloc_type&& __a)
 : _Bit_alloc_type(std::move(__a)), _M_start(), _M_finish(),
   _M_end_of_storage()
 { }


 _Bit_type*
 _M_end_addr() const noexcept
 {
   if (_M_end_of_storage)
     return std::__addressof(_M_end_of_storage[-1]) + 1;
   return 0;
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator() noexcept
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const noexcept
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }


      _Bvector_base(_Bvector_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Bit_allocator()))
      {
 this->_M_impl._M_start = __x._M_impl._M_start;
 this->_M_impl._M_finish = __x._M_impl._M_finish;
 this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
 __x._M_impl._M_start = _Bit_iterator();
 __x._M_impl._M_finish = _Bit_iterator();
 __x._M_impl._M_end_of_storage = nullptr;
      }


      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_pointer
      _M_allocate(size_t __n)
      { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   {
     const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
     _Bit_alloc_traits::deallocate(_M_impl,
       _M_impl._M_end_of_storage - __n,
       __n);
   }
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std
{

# 540 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;
    typedef typename _Base::_Bit_pointer _Bit_pointer;
    typedef typename _Base::_Bit_alloc_traits _Bit_alloc_traits;


    template<typename> friend struct hash;


  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()

      noexcept(is_nothrow_default_constructible<allocator_type>::value)

    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }


    explicit
    vector(size_type __n, const allocator_type& __a = allocator_type())
    : vector(__n, false, __a)
    { }

    vector(size_type __n, const bool& __value,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_addr(),
  __value ? ~0 : 0);
    }
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    vector(const vector& __x)
    : _Base(_Bit_alloc_traits::_S_select_on_copy(__x._M_get_Bit_allocator()))
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }


    vector(vector&& __x) noexcept
    : _Base(std::move(__x)) { }

    vector(vector&& __x, const allocator_type& __a)
    noexcept(_Bit_alloc_traits::_S_always_equal())
    : _Base(__a)
    {
      if (__x.get_allocator() == __a)
 {
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
 }
      else
 {
   _M_initialize(__x.size());
   _M_copy_aligned(__x.begin(), __x.end(), begin());
   __x.clear();
 }
    }

    vector(const vector& __x, const allocator_type& __a)
    : _Base(__a)
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }

    vector(initializer_list<bool> __l,
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize_range(__l.begin(), __l.end(),
     random_access_iterator_tag());
    }



    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      { _M_initialize_dispatch(__first, __last, __false_type()); }
# 677 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    ~vector() noexcept { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;

      if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
 {
   if (this->_M_get_Bit_allocator() != __x._M_get_Bit_allocator())
     {
       this->_M_deallocate();
       std::__alloc_on_copy(_M_get_Bit_allocator(),
       __x._M_get_Bit_allocator());
       _M_initialize(__x.size());
     }
   else
     std::__alloc_on_copy(_M_get_Bit_allocator(),
     __x._M_get_Bit_allocator());
 }

      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }


    vector&
    operator=(vector&& __x) noexcept(_Bit_alloc_traits::_S_nothrow_move())
    {
      if (_Bit_alloc_traits::_S_propagate_on_move_assign()
   || this->_M_get_Bit_allocator() == __x._M_get_Bit_allocator())
 {
   this->_M_deallocate();
   this->_M_impl._M_start = __x._M_impl._M_start;
   this->_M_impl._M_finish = __x._M_impl._M_finish;
   this->_M_impl._M_end_of_storage = __x._M_impl._M_end_of_storage;
   __x._M_impl._M_start = _Bit_iterator();
   __x._M_impl._M_finish = _Bit_iterator();
   __x._M_impl._M_end_of_storage = nullptr;
   std::__alloc_on_move(_M_get_Bit_allocator(),
          __x._M_get_Bit_allocator());
 }
      else
 {
   if (__x.size() > capacity())
     {
       this->_M_deallocate();
       _M_initialize(__x.size());
     }
   this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
          begin());
   __x.clear();
 }
      return *this;
    }

    vector&
    operator=(initializer_list<bool> __l)
    {
      this->assign (__l.begin(), __l.end());
      return *this;
    }






    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      void
      assign(_InputIterator __first, _InputIterator __last)
      { _M_assign_dispatch(__first, __last, __false_type()); }
# 773 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    void
    assign(initializer_list<bool> __l)
    { this->assign(__l.begin(), __l.end()); }


    iterator
    begin() noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const noexcept
    { return this->_M_impl._M_start; }

    iterator
    end() noexcept
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const noexcept
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin() noexcept
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const noexcept
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend() noexcept
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const noexcept
    { return const_reverse_iterator(begin()); }


    const_iterator
    cbegin() const noexcept
    { return this->_M_impl._M_start; }

    const_iterator
    cend() const noexcept
    { return this->_M_impl._M_finish; }

    const_reverse_iterator
    crbegin() const noexcept
    { return const_reverse_iterator(end()); }

    const_reverse_iterator
    crend() const noexcept
    { return const_reverse_iterator(begin()); }


    size_type
    size() const noexcept
    { return size_type(end() - begin()); }

    size_type
    max_size() const noexcept
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize
 = _Bit_alloc_traits::max_size(_M_get_Bit_allocator());
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const noexcept
    { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
         - begin()); }

    bool
    empty() const noexcept
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
 __throw_out_of_range_fmt(("vector<bool>::_M_range_check: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                          ,
     __n, this->size());
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() noexcept { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x) noexcept
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);
      _Bit_alloc_traits::_S_on_swap(_M_get_Bit_allocator(),
        __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y) noexcept
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator

    insert(const_iterator __position, const bool& __x = bool())



    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr()
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position._M_const_cast(), __x);
      return begin() + __n;
    }


    template<typename _InputIterator,
      typename = std::_RequireInputIter<_InputIterator>>
      iterator
      insert(const_iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 difference_type __offset = __position - cbegin();
 _M_insert_dispatch(__position._M_const_cast(),
      __first, __last, __false_type());
 return begin() + __offset;
      }
# 989 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 3
    iterator
    insert(const_iterator __position, size_type __n, const bool& __x)
    {
      difference_type __offset = __position - cbegin();
      _M_fill_insert(__position._M_const_cast(), __n, __x);
      return begin() + __offset;
    }







    iterator
    insert(const_iterator __p, initializer_list<bool> __l)
    { return this->insert(__p, __l.begin(), __l.end()); }


    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator

    erase(const_iterator __position)



    { return _M_erase(__position._M_const_cast()); }

    iterator

    erase(const_iterator __first, const_iterator __last)



    { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }


    void
    shrink_to_fit()
    { _M_shrink_to_fit(); }


    void
    flip() noexcept
    {
      _Bit_type * const __end = this->_M_impl._M_end_addr();
      for (_Bit_type * __p = this->_M_impl._M_start._M_p; __p != __end; ++__p)
        *__p = ~*__p;
    }

    void
    clear() noexcept
    { _M_erase_at_end(begin()); }


    template<typename... _Args>
      void
      emplace_back(_Args&&... __args)
      { push_back(bool(__args...)); }

    template<typename... _Args>
      iterator
      emplace(const_iterator __pos, _Args&&... __args)
      { return insert(__pos, bool(__args...)); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);


    bool
    _M_shrink_to_fit();






    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_addr(), __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_addr(), __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }

    iterator
    _M_erase(iterator __pos);

    iterator
    _M_erase(iterator __first, iterator __last);
  };


}



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 2 3

namespace std
{

# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp, bool = is_enum<_Tp>::value>
    struct __hash_enum
    {
    private:

      __hash_enum(__hash_enum&&);
      ~__hash_enum();
    };


  template<typename _Tp>
    struct __hash_enum<_Tp, true> : public __hash_base<size_t, _Tp>
    {
      size_t
      operator()(_Tp __val) const noexcept
      {
       using __type = typename underlying_type<_Tp>::type;
       return hash<__type>{}(static_cast<__type>(__val));
      }
    };



  template<typename _Tp>
    struct hash : __hash_enum<_Tp>
    { };


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 108 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<__int128> : public __hash_base<size_t, __int128> { size_t operator()(__int128 __val) const noexcept { return static_cast<size_t>(__val); } };
  template<> struct hash<__int128 unsigned> : public __hash_base<size_t, __int128 unsigned> { size_t operator()(__int128 unsigned __val) const noexcept { return static_cast<size_t>(__val); } };
# 171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/functional_hash.h" 3
  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 1263 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_bvector.h" 2 3

namespace std
{




  template<typename _Alloc>
    struct hash<std::vector<bool, _Alloc>>
    : public __hash_base<size_t, std::vector<bool, _Alloc>>
    {
      size_t
      operator()(const std::vector<bool, _Alloc>&) const noexcept;
    };


}
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 2 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/vector.tcc" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/vector.tcc" 3
namespace std
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_start),
     std::__make_move_if_noexcept_iterator(this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      emplace_back(_Args&&... __args)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_emplace_back_aux(std::forward<_Args>(__args)...);
      }


  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {

   const auto __pos = begin() + (__position - cbegin());
   if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
     {
       _Tp __x_copy = __x;
       _M_insert_aux(__pos, std::move(__x_copy));
     }
   else
     _M_insert_aux(__pos, __x);



 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
 std::move(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::move(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {

   if (_Alloc_traits::_S_propagate_on_copy_assign())
     {
       if (!_Alloc_traits::_S_always_equal()
           && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
         {

    this->clear();
    _M_deallocate(this->_M_impl._M_start,
    this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start);
    this->_M_impl._M_start = nullptr;
    this->_M_impl._M_finish = nullptr;
    this->_M_impl._M_end_of_storage = nullptr;
  }
       std::__alloc_on_copy(_M_get_Tp_allocator(),
       __x._M_get_Tp_allocator());
     }

   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp._M_impl._M_swap_data(this->_M_impl);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   this->_M_impl._M_finish =
     std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
       __n - size(), __val,
       _M_get_Tp_allocator());
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename vector<_Tp, _Alloc>::iterator
      vector<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 const size_type __n = __position - begin();
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
     && __position == end())
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
         std::forward<_Args>(__args)...);
     ++this->_M_impl._M_finish;
   }
 else
   _M_insert_aux(begin() + (__position - cbegin()),
   std::forward<_Args>(__args)...);
 return iterator(this->_M_impl._M_start + __n);
      }

  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_insert_aux(iterator __position, _Args&&... __args)






    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              std::move(*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;



   std::move_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;



   *__position = _Tp(std::forward<_Args>(__args)...);

 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,

           std::forward<_Args>(__args)...);



       __new_finish = pointer();

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      void
      vector<_Tp, _Alloc>::
      _M_emplace_back_aux(_Args&&... __args)
      {
 const size_type __len =
   _M_check_len(size_type(1), "vector::_M_emplace_back_aux");
 pointer __new_start(this->_M_allocate(__len));
 pointer __new_finish(__new_start);
 try
   {
     _Alloc_traits::construct(this->_M_impl, __new_start + size(),
         std::forward<_Args>(__args)...);
     __new_finish = pointer();

     __new_finish
       = std::__uninitialized_move_if_noexcept_a
       (this->_M_impl._M_start, this->_M_impl._M_finish,
        __new_start, _M_get_Tp_allocator());

     ++__new_finish;
   }
 catch(...)
   {
     if (!__new_finish)
       _Alloc_traits::destroy(this->_M_impl, __new_start + size());
     else
       std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
     _M_deallocate(__new_start, __len);
     throw;
   }
 std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator());
 _M_deallocate(this->_M_impl._M_start,
        this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start);
 this->_M_impl._M_start = __new_start;
 this->_M_impl._M_finish = __new_finish;
 this->_M_impl._M_end_of_storage = __new_start + __len;
      }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    this->_M_impl._M_finish =
      std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
        __n - __elems_after,
        __x_copy,
        _M_get_Tp_allocator());
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = pointer();

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       this->_M_impl._M_finish =
  std::__uninitialized_default_n_a(this->_M_impl._M_finish,
       __n, _M_get_Tp_allocator());
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_default_append");
       const size_type __old_size = this->size();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {
    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, this->_M_impl._M_finish,
       __new_start, _M_get_Tp_allocator());
    __new_finish =
      std::__uninitialized_default_n_a(__new_finish, __n,
           _M_get_Tp_allocator());
  }
       catch(...)
  {
    std::_Destroy(__new_start, __new_finish,
    _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }

  template<typename _Tp, typename _Alloc>
    bool
    vector<_Tp, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() == size())
 return false;
      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
    }


  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::move_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_pointer __q = this->_M_allocate(__n);
      iterator __start(std::__addressof(*__q), 0);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(), __start);
      this->_M_deallocate();
      this->_M_impl._M_start = __start;
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_pointer __q = this->_M_allocate(__len);
  iterator __start(std::__addressof(*__q), 0);
  iterator __i = _M_copy_aligned(begin(), __position, __start);
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = __start;
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_pointer __q = this->_M_allocate(__len);
   iterator __start(std::__addressof(*__q), 0);
   iterator __i = _M_copy_aligned(begin(), __position, __start);
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = __start;
 }
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

  template<typename _Alloc>
    typename vector<bool, _Alloc>::iterator
    vector<bool, _Alloc>::
    _M_erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }


  template<typename _Alloc>
    bool
    vector<bool, _Alloc>::
    _M_shrink_to_fit()
    {
      if (capacity() - size() < int(_S_word_bit))
 return false;
      try
 {
   _M_reallocate(size());
   return true;
 }
      catch(...)
 { return false; }
    }



}



namespace std
{


  template<typename _Alloc>
    size_t
    hash<std::vector<bool, _Alloc>>::
    operator()(const std::vector<bool, _Alloc>& __b) const noexcept
    {
      size_t __hash = 0;
      using std::_S_word_bit;
      using std::_Bit_type;

      const size_t __words = __b.size() / _S_word_bit;
      if (__words)
 {
   const size_t __clength = __words * sizeof(_Bit_type);
   __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
 }

      const size_t __extrabits = __b.size() % _S_word_bit;
      if (__extrabits)
 {
   _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
   __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);

   const size_t __clength
     = (__extrabits + 8 - 1) / 8;
   if (__words)
     __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
   else
     __hash = std::_Hash_impl::hash(&__hiword, __clength);
 }

      return __hash;
    }


}
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/vector" 2 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
namespace std
{







  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    _Distance
    __is_heap_until(_RandomAccessIterator __first, _Distance __n,
      _Compare __comp)
    {
      _Distance __parent = 0;
      for (_Distance __child = 1; __child < __n; ++__child)
 {
   if (__comp(__first + __parent, __first + __child))
     return __child;
   if ((__child & 1) == 0)
     ++__parent;
 }
      return __n;
    }



  template<typename _RandomAccessIterator, typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
   __gnu_cxx::__ops::__iter_less_iter()) == __n;
    }

  template<typename _RandomAccessIterator, typename _Compare,
    typename _Distance>
    inline bool
    __is_heap(_RandomAccessIterator __first, _Compare __comp, _Distance __n)
    {
      return std::__is_heap_until(__first, __n,
 __gnu_cxx::__ops::__iter_comp_iter(__comp)) == __n;
    }

  template<typename _RandomAccessIterator>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::__is_heap(__first, std::distance(__first, __last)); }

  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }




  template<typename _RandomAccessIterator, typename _Distance, typename _Tp,
    typename _Compare>
    void
    __push_heap(_RandomAccessIterator __first,
  _Distance __holeIndex, _Distance __topIndex, _Tp __value,
  _Compare __comp)
    {
      _Distance __parent = (__holeIndex - 1) / 2;
      while (__holeIndex > __topIndex && __comp(__first + __parent, __value))
 {
   *(__first + __holeIndex) = std::move(*(__first + __parent));
   __holeIndex = __parent;
   __parent = (__holeIndex - 1) / 2;
 }
      *(__first + __holeIndex) = std::move(__value);
    }
# 148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

     
      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_less_val());
    }
# 183 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    push_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;


     

      ;
      ;
      ;

      _ValueType __value = std::move(*(__last - 1));
      std::__push_heap(__first, _DistanceType((__last - __first) - 1),
         _DistanceType(0), std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Tp, typename _Compare>
    void
    __adjust_heap(_RandomAccessIterator __first, _Distance __holeIndex,
    _Distance __len, _Tp __value, _Compare __comp)
    {
      const _Distance __topIndex = __holeIndex;
      _Distance __secondChild = __holeIndex;
      while (__secondChild < (__len - 1) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   if (__comp(__first + __secondChild,
       __first + (__secondChild - 1)))
     __secondChild--;
   *(__first + __holeIndex) = std::move(*(__first + __secondChild));
   __holeIndex = __secondChild;
 }
      if ((__len & 1) == 0 && __secondChild == (__len - 2) / 2)
 {
   __secondChild = 2 * (__secondChild + 1);
   *(__first + __holeIndex) = std::move(*(__first + (__secondChild - 1)))
                                  ;
   __holeIndex = __secondChild - 1;
 }
      std::__push_heap(__first, __holeIndex, __topIndex,
         std::move(__value),
         __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
        _RandomAccessIterator __result, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      _ValueType __value = std::move(*__result);
      *__result = std::move(*__first);
      std::__adjust_heap(__first, _DistanceType(0),
    _DistanceType(__last - __first),
    std::move(__value), __comp);
    }
# 263 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_less_iter());
 }
    }
# 296 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    pop_heap(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {

     

      ;
      ;
      ;
      ;

      if (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
 }
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
   _DistanceType;

      if (__last - __first < 2)
 return;

      const _DistanceType __len = __last - __first;
      _DistanceType __parent = (__len - 2) / 2;
      while (true)
 {
   _ValueType __value = std::move(*(__first + __parent));
   std::__adjust_heap(__first, __parent, __len, std::move(__value),
        __comp);
   if (__parent == 0)
     return;
   __parent--;
 }
    }
# 351 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 377 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;

      std::__make_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    void
    __sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {
      while (__last - __first > 1)
 {
   --__last;
   std::__pop_heap(__first, __last, __last, __comp);
 }
    }
# 412 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 439 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Compare __comp)
    {

     

      ;
      ;
      ;

      std::__sort_heap(__first, __last,
         __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 466 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      return __first +
 std::__is_heap_until(__first, std::distance(__first, __last),
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 494 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    is_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {

     

      ;
      ;

      return __first
 + std::__is_heap_until(__first, std::distance(__first, __last),
          __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 517 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)
    { return std::is_heap_until(__first, __last) == __last; }
# 530 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_heap.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline bool
    is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _Compare __comp)
    { return std::is_heap_until(__first, __last, __comp) == __last; }



}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
namespace std
{

# 104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 144 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  struct __is_transparent;

  template<typename _Tp = void>
    struct plus;

  template<typename _Tp = void>
    struct minus;

  template<typename _Tp = void>
    struct multiplies;

  template<typename _Tp = void>
    struct divides;

  template<typename _Tp = void>
    struct modulus;

  template<typename _Tp = void>
    struct negate;



  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };





  template<>
    struct plus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) + std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) + std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) + std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct minus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) - std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) - std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) - std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct multiplies<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) * std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) * std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) * std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct divides<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) / std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) / std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) / std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct modulus<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) % std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) % std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) % std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct negate<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(-std::forward<_Tp>(__t)))
 -> decltype(-std::forward<_Tp>(__t))
 { return -std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 330 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct equal_to;

  template<typename _Tp = void>
    struct not_equal_to;

  template<typename _Tp = void>
    struct greater;

  template<typename _Tp = void>
    struct less;

  template<typename _Tp = void>
    struct greater_equal;

  template<typename _Tp = void>
    struct less_equal;



  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };



  template<>
    struct equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) == std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) == std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) == std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct not_equal_to<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) != std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) != std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) != std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) > std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) > std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) > std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) < std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) < std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) < std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct greater_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) >= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) >= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) >= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct less_equal<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) <= std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) <= std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) <= std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };
# 512 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Tp = void>
    struct logical_and;

  template<typename _Tp = void>
    struct logical_or;

  template<typename _Tp = void>
    struct logical_not;



  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      constexpr
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };



  template<>
    struct logical_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) && std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) && std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) && std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) || std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) || std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) || std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };


  template<>
    struct logical_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(!std::forward<_Tp>(__t)))
 -> decltype(!std::forward<_Tp>(__t))
 { return !std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };




  template<typename _Tp = void>
    struct bit_and;

  template<typename _Tp = void>
    struct bit_or;

  template<typename _Tp = void>
    struct bit_xor;

  template<typename _Tp = void>
    struct bit_not;




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      constexpr
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
    constexpr
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };


  template <>
    struct bit_and<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) & std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) & std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) & std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_or<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) | std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) | std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) | std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_xor<void>
    {
      template <typename _Tp, typename _Up>
 constexpr
 auto
 operator()(_Tp&& __t, _Up&& __u) const
 noexcept(noexcept(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u)))
 -> decltype(std::forward<_Tp>(__t) ^ std::forward<_Up>(__u))
 { return std::forward<_Tp>(__t) ^ std::forward<_Up>(__u); }

      typedef __is_transparent is_transparent;
    };

  template <>
    struct bit_not<void>
    {
      template <typename _Tp>
 constexpr
 auto
 operator()(_Tp&& __t) const
 noexcept(noexcept(~std::forward<_Tp>(__t)))
 -> decltype(~std::forward<_Tp>(__t))
 { return ~std::forward<_Tp>(__t); }

      typedef __is_transparent is_transparent;
    };
# 740 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    constexpr
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      constexpr
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      constexpr
      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    constexpr
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 817 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 937 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 1 3
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 3
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

namespace std
{

# 107 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}

#pragma GCC diagnostic pop
# 1128 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_function.h" 2 3
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uses_allocator.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uses_allocator.h" 3
namespace std
{


  struct __erased_type { };

  template<typename _Alloc, typename _Tp>
    using __is_erased_or_convertible
      = __or_<is_same<_Tp, __erased_type>, is_convertible<_Alloc, _Tp>>;


  struct allocator_arg_t { explicit allocator_arg_t() = default; };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

  template<typename _Tp, typename _Alloc, typename = __void_t<>>
    struct __uses_allocator_helper
    : false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc,
       __void_t<typename _Tp::allocator_type>>
    : __is_erased_or_convertible<_Alloc, typename _Tp::allocator_type>::type
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : __uses_allocator_helper<_Tp, _Alloc>::type
    { };

  struct __uses_alloc_base { };

  struct __uses_alloc0 : __uses_alloc_base
  {
    struct _Sink { void operator=(const void*) { } } _M_a;
  };

  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };

  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    {
      static_assert(__or_<
   is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>,
   is_constructible<_Tp, _Args..., _Alloc>>::value, "construction with"
   " an allocator must be possible if uses_allocator is true");
    };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    using __uses_alloc_t =
      __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>;

  template<typename _Tp, typename _Alloc, typename... _Args>
    inline __uses_alloc_t<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_t<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = std::__addressof(__a);
      return __ret;
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 2 3


namespace std
{

# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = deque<_Tp> >
    class queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     
     

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);

      template<typename _Tp1, typename _Seq1>
        friend bool
        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);


      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:
# 135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      _Sequence c;

    public:
# 146 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      explicit
      queue(const _Sequence& __c)
      : c(__c) { }

      explicit
      queue(_Sequence&& __c = _Sequence())
      : c(std::move(__c)) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 queue(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const _Sequence& __c, const _Alloc& __a)
 : c(__c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(_Sequence&& __c, const _Alloc& __a)
 : c(std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(const queue& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 queue(queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      reference
      front()
      {
 ;
 return c.front();
      }





      const_reference
      front() const
      {
 ;
 return c.front();
      }





      reference
      back()
      {
 ;
 return c.back();
      }





      const_reference
      back() const
      {
 ;
 return c.back();
      }
# 241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      { c.push_back(__x); }


      void
      push(value_type&& __x)
      { c.push_back(std::move(__x)); }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 { c.emplace_back(std::forward<_Args>(__args)...); }
# 267 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 c.pop_front();
      }


      void
      swap(queue& __q)
      noexcept(__is_nothrow_swappable<_Tp>::value)
      {
 using std::swap;
 swap(c, __q.c);
      }

    };
# 296 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c == __y.c; }
# 314 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Seq>
    inline bool
    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __x.c < __y.c; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Seq>
    inline bool
    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Seq>
    inline bool
    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Seq>
    inline void
    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Seq, typename _Alloc>
    struct uses_allocator<queue<_Tp, _Seq>, _Alloc>
    : public uses_allocator<_Seq, _Alloc>::type { };
# 395 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
  template<typename _Tp, typename _Sequence = vector<_Tp>,
    typename _Compare = less<typename _Sequence::value_type> >
    class priority_queue
    {

      typedef typename _Sequence::value_type _Sequence_value_type;
     
     
     
     
     



      template<typename _Alloc>
 using _Uses = typename
   enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;


    public:
      typedef typename _Sequence::value_type value_type;
      typedef typename _Sequence::reference reference;
      typedef typename _Sequence::const_reference const_reference;
      typedef typename _Sequence::size_type size_type;
      typedef _Sequence container_type;

    protected:

      _Sequence c;
      _Compare comp;

    public:
# 437 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      explicit
      priority_queue(const _Compare& __x,
       const _Sequence& __s)
      : c(__s), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      explicit
      priority_queue(const _Compare& __x = _Compare(),
       _Sequence&& __s = _Sequence())
      : c(std::move(__s)), comp(__x)
      { std::make_heap(c.begin(), c.end(), comp); }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 explicit
 priority_queue(const _Alloc& __a)
 : c(__a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Alloc& __a)
 : c(__x, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, const _Sequence& __c,
         const _Alloc& __a)
 : c(__x, __c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
 : c(__x, std::move(__c), __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(const priority_queue& __q, const _Alloc& __a)
 : c(__q.c, __a) { }

      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
 priority_queue(priority_queue&& __q, const _Alloc& __a)
 : c(std::move(__q.c), __a) { }
# 503 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x,
         const _Sequence& __s)
 : c(__s), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }

      template<typename _InputIterator>
        priority_queue(_InputIterator __first, _InputIterator __last,
         const _Compare& __x = _Compare(),
         _Sequence&& __s = _Sequence())
 : c(std::move(__s)), comp(__x)
        {
   ;
   c.insert(c.end(), __first, __last);
   std::make_heap(c.begin(), c.end(), comp);
 }





      bool
      empty() const
      { return c.empty(); }


      size_type
      size() const
      { return c.size(); }





      const_reference
      top() const
      {
 ;
 return c.front();
      }
# 557 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      push(const value_type& __x)
      {
 c.push_back(__x);
 std::push_heap(c.begin(), c.end(), comp);
      }


      void
      push(value_type&& __x)
      {
 c.push_back(std::move(__x));
 std::push_heap(c.begin(), c.end(), comp);
      }

      template<typename... _Args>
        void
        emplace(_Args&&... __args)
 {
   c.emplace_back(std::forward<_Args>(__args)...);
   std::push_heap(c.begin(), c.end(), comp);
 }
# 592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_queue.h" 3
      void
      pop()
      {
 ;
 std::pop_heap(c.begin(), c.end(), comp);
 c.pop_back();
      }


      void
      swap(priority_queue& __pq)
      noexcept(__is_nothrow_swappable<_Tp>::value
               && __is_nothrow_swappable<_Compare>::value)
      {
 using std::swap;
 swap(c, __pq.c);
 swap(comp, __pq.comp);
      }

    };




  template<typename _Tp, typename _Sequence, typename _Compare>
    inline void
    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
  priority_queue<_Tp, _Sequence, _Compare>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }

  template<typename _Tp, typename _Sequence, typename _Compare,
    typename _Alloc>
    struct uses_allocator<priority_queue<_Tp, _Sequence, _Compare>, _Alloc>
    : public uses_allocator<_Sequence, _Alloc>::type { };



}
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/queue" 2 3
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 3




namespace std
{








  template<class _CharT>
    struct char_traits;

  template<> struct char_traits<char>;


  template<> struct char_traits<wchar_t>;




  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;


  typedef basic_string<char> string;



  typedef basic_string<wchar_t> wstring;





  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;


}




}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 1 3
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
       
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_push.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3
# 25 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned long _fsize_t;




  struct _wfinddata32_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata32i64_t {
    unsigned attrib;
    __time32_t time_create;
    __time32_t time_access;
    __time32_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };

  struct _wfinddata64i32_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    _fsize_t size;
    wchar_t name[260];
  };

  struct _wfinddata64_t {
    unsigned attrib;
    __time64_t time_create;
    __time64_t time_access;
    __time64_t time_write;
    __extension__ long long size;
    wchar_t name[260];
  };
# 178 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pctype;
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__wctype;
# 207 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  extern unsigned short ** __imp__pwctype;
# 231 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  int __attribute__((__cdecl__)) iswalpha(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalpha_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswupper(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswupper_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswlower(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswxdigit(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswxdigit_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswspace(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswspace_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswpunct(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswpunct_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswalnum(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswalnum_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswprint(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswprint_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswgraph(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswgraph_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswcntrl(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcntrl_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswascii(wint_t _C);
  int __attribute__((__cdecl__)) isleadbyte(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isleadbyte_l(int _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towupper(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towupper_l(wint_t _C,_locale_t _Locale);
  wint_t __attribute__((__cdecl__)) towlower(wint_t _C);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _towlower_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) iswctype(wint_t _C,wctype_t _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswctype_l(wint_t _C,wctype_t _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsymf(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsymf_l(wint_t _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iswcsym(wint_t _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iswcsym_l(wint_t _C,_locale_t _Locale);
  int __attribute__((__cdecl__)) is_wctype(wint_t _C,wctype_t _Type);


  int __attribute__((__cdecl__)) iswblank(wint_t _C);







  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetcwd(wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetdcwd(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  wchar_t *__attribute__((__cdecl__)) _wgetdcwd_nolock(int _Drive,wchar_t *_DstBuf,int _SizeInWords);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wmkdir(const wchar_t *_Path);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrmdir(const wchar_t *_Path);





  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _waccess(const wchar_t *_Filename,int _AccessMode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wchmod(const wchar_t *_Filename,int _Mode);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcreat(const wchar_t *_Filename,int _PermissionMode) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32(const wchar_t *_Filename,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32(intptr_t _FindHandle,struct _wfinddata32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wunlink(const wchar_t *_Filename);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wrename(const wchar_t *_OldFilename,const wchar_t *_NewFilename);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wmktemp(wchar_t *_TemplateName) ;
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst32i64(const wchar_t *_Filename,struct _wfinddata32i64_t *_FindData);
  intptr_t __attribute__((__cdecl__)) _wfindfirst64i32(const wchar_t *_Filename,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wfindfirst64(const wchar_t *_Filename,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext32i64(intptr_t _FindHandle,struct _wfinddata32i64_t *_FindData);
  int __attribute__((__cdecl__)) _wfindnext64i32(intptr_t _FindHandle,struct _wfinddata64i32_t *_FindData);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wfindnext64(intptr_t _FindHandle,struct _wfinddata64_t *_FindData);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsopen_s(int *_FileHandle,const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,int _PermissionFlag);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wopen(const wchar_t *_Filename,int _OpenFlag,...) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsopen(const wchar_t *_Filename,int _OpenFlag,int _ShareFlag,...) ;




  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wsetlocale(int _Category,const wchar_t *_Locale);




  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecl(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecle(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclp(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexeclpe(const wchar_t *_Filename,const wchar_t *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecv(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecve(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvp(const wchar_t *_Filename,const wchar_t *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _wexecvpe(const wchar_t *_Filename,const wchar_t *const *_ArgList,const wchar_t *const *_Env);
# 338 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wsystem(const wchar_t *_Command);
# 378 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef unsigned short _ino_t;

  typedef unsigned short ino_t;





  typedef unsigned int _dev_t;

  typedef unsigned int dev_t;




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_stat64.h" 1 3
# 19 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_stat64.h" 3
  struct _stat32 {
    _dev_t st_dev;
   _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };


  struct stat {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    time_t st_atime;
    time_t st_mtime;
    time_t st_ctime;
  };


  struct _stat32i64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time32_t st_atime;
    __time32_t st_mtime;
    __time32_t st_ctime;
  };

  struct _stat64i32 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    _off_t st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };

  struct _stat64 {
    _dev_t st_dev;
    _ino_t st_ino;
    unsigned short st_mode;
    short st_nlink;
    short st_uid;
    short st_gid;
    _dev_t st_rdev;
    __extension__ long long st_size;
    __time64_t st_atime;
    __time64_t st_mtime;
    __time64_t st_ctime;
  };
# 394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32(const wchar_t *_Name,struct _stat32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat32i64(const wchar_t *_Name,struct _stat32i64 *_Stat);
  int __attribute__((__cdecl__)) _wstat64i32(const wchar_t *_Name,struct _stat64i32 *_Stat);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wstat64(const wchar_t *_Name,struct _stat64 *_Stat);
# 412 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *_cgetws(wchar_t *_Buffer) ;
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwch(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _getwche(void);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _putwch(wchar_t _WCh);
  __attribute__ ((__dllimport__)) wint_t __attribute__((__cdecl__)) _ungetwch(wint_t _WCh);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cputws(const wchar_t *_String);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf(const wchar_t * __restrict__ _Format,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p(const wchar_t * __restrict__ _Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p(const wchar_t * __restrict__ _Format,va_list _ArgList);

  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _vcwprintf_p_l(const wchar_t * __restrict__ _Format,_locale_t _Locale,va_list _ArgList);
  wint_t __attribute__((__cdecl__)) _putwch_nolock(wchar_t _WCh);
  wint_t __attribute__((__cdecl__)) _getwch_nolock(void);
  wint_t __attribute__((__cdecl__)) _getwche_nolock(void);
  wint_t __attribute__((__cdecl__)) _ungetwch_nolock(wint_t _WCh);
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _itow(int _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ltow(long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ultow(unsigned long _Value,wchar_t *_Dest,int _Radix) ;
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wcstod_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,_locale_t _Locale);

  double __attribute__((__cdecl__)) __mingw_wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr);
  float __attribute__((__cdecl__)) __mingw_wcstof(const wchar_t * __restrict__ nptr, wchar_t ** __restrict__ endptr);
  long double __attribute__((__cdecl__)) __mingw_wcstold(const wchar_t * __restrict__, wchar_t ** __restrict__);


  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  double __attribute__((__cdecl__)) wcstod(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstod(_Str,_EndPtr);
  }
  static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
  float __attribute__((__cdecl__)) wcstof(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr){
    return __mingw_wcstof(_Str,_EndPtr);
  }






  long double __attribute__((__cdecl__)) wcstold (const wchar_t * __restrict__, wchar_t ** __restrict__);

  long __attribute__((__cdecl__)) wcstol(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wcstol_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) wcstoul(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _wcstoul_l(const wchar_t * __restrict__ _Str,wchar_t ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wgetenv(const wchar_t *_VarName) ;




  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _wtof_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wtoi_l(const wchar_t *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol(const wchar_t *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _wtol_l(const wchar_t *_Str,_locale_t _Locale);

  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _i64tow(long long _Val,wchar_t *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _ui64tow(unsigned long long _Val,wchar_t *_DstBuf,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64(const wchar_t *_Str);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wtoi64_l(const wchar_t *_Str,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _wcstoi64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _wcstoui64_l(const wchar_t *_Str,wchar_t **_EndPtr,int _Radix,_locale_t _Locale);





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wfullpath(wchar_t *_FullPath,const wchar_t *_Path,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wmakepath(wchar_t *_ResultPath,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);




  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsearchenv(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _wsplitpath(const wchar_t *_FullPath,wchar_t *_Drive,wchar_t *_Dir,wchar_t *_Filename,wchar_t *_Ext) ;





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsdup(const wchar_t *_Str);
  wchar_t *__attribute__((__cdecl__)) wcscat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  wchar_t *__attribute__((__cdecl__)) wcschr(const wchar_t *_Str,wchar_t _Ch);
  int __attribute__((__cdecl__)) wcscmp(const wchar_t *_Str1,const wchar_t *_Str2);
  wchar_t *__attribute__((__cdecl__)) wcscpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source) ;
  size_t __attribute__((__cdecl__)) wcscspn(const wchar_t *_Str,const wchar_t *_Control);
  size_t __attribute__((__cdecl__)) wcslen(const wchar_t *_Str);
  size_t __attribute__((__cdecl__)) wcsnlen(const wchar_t *_Src,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncat(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) wcsncmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  wchar_t *__attribute__((__cdecl__)) wcsncpy(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count) ;
  wchar_t *__attribute__((__cdecl__)) _wcsncpy_l(wchar_t * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _Count,_locale_t _Locale) ;
  wchar_t *__attribute__((__cdecl__)) wcspbrk(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsrchr(const wchar_t *_Str,wchar_t _Ch);
  size_t __attribute__((__cdecl__)) wcsspn(const wchar_t *_Str,const wchar_t *_Control);
  wchar_t *__attribute__((__cdecl__)) wcsstr(const wchar_t *_Str,const wchar_t *_SubStr);
  wchar_t *__attribute__((__cdecl__)) wcstok(wchar_t * __restrict__ _Str,const wchar_t * __restrict__ _Delim) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcserror(int _ErrNum) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) __wcserror(const wchar_t *_Str) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicmp_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsrev(wchar_t *_Str);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsset(wchar_t *_Str,wchar_t _Val) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcslwr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcslwr_l(wchar_t *_String,_locale_t _Locale) ;
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcsupr(wchar_t *_String) ;
  __attribute__ ((__dllimport__)) wchar_t *_wcsupr_l(wchar_t *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcsxfrm(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsxfrm_l(wchar_t * __restrict__ _Dst,const wchar_t * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) wcscoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcscoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsncoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wcsnicoll_l(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount,_locale_t _Locale);


  wchar_t *__attribute__((__cdecl__)) wcsdup(const wchar_t *_Str) ;

  int __attribute__((__cdecl__)) wcsicmp(const wchar_t *_Str1,const wchar_t *_Str2) ;
  int __attribute__((__cdecl__)) wcsnicmp(const wchar_t *_Str1,const wchar_t *_Str2,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsnset(wchar_t *_Str,wchar_t _Val,size_t _MaxCount) ;
  wchar_t *__attribute__((__cdecl__)) wcsrev(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsset(wchar_t *_Str,wchar_t _Val) ;
  wchar_t *__attribute__((__cdecl__)) wcslwr(wchar_t *_Str) ;
  wchar_t *__attribute__((__cdecl__)) wcsupr(wchar_t *_Str) ;
  int __attribute__((__cdecl__)) wcsicoll(const wchar_t *_Str1,const wchar_t *_Str2) ;





  struct tm {
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
  };





  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wasctime(const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  wchar_t *__attribute__((__cdecl__)) _wctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) wcsftime(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcsftime_l(wchar_t * __restrict__ _Buf,size_t _SizeInWords,const wchar_t * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrdate(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wstrtime(wchar_t *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);



  wchar_t *__attribute__((__cdecl__)) _wctime(const time_t *_Time) ;
# 951 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  errno_t __attribute__((__cdecl__)) _wctime_s(wchar_t *, size_t, const time_t *);
# 963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
  typedef int mbstate_t;
  typedef wchar_t _Wint_t;

  wint_t __attribute__((__cdecl__)) btowc(int);
  size_t __attribute__((__cdecl__)) mbrlen(const char * __restrict__ _Ch,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbrtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SizeInBytes,mbstate_t * __restrict__ _State);
  size_t __attribute__((__cdecl__)) mbsrtowcs(wchar_t * __restrict__ _Dest,const char ** __restrict__ _PSrc,size_t _Count,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcrtomb(char * __restrict__ _Dest,wchar_t _Source,mbstate_t * __restrict__ _State) ;
  size_t __attribute__((__cdecl__)) wcsrtombs(char * __restrict__ _Dest,const wchar_t ** __restrict__ _PSource,size_t _Count,mbstate_t * __restrict__ _State) ;
  int __attribute__((__cdecl__)) wctob(wint_t _WCh);


  wchar_t *__attribute__((__cdecl__)) wmemset(wchar_t *s, wchar_t c, size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemchr(const wchar_t *s, wchar_t c, size_t n);
  int __attribute__((__cdecl__)) wmemcmp(const wchar_t *s1, const wchar_t *s2,size_t n);
  wchar_t *__attribute__((__cdecl__)) wmemcpy(wchar_t * __restrict__ s1,const wchar_t * __restrict__ s2,size_t n) ;
  wchar_t * __attribute__((__cdecl__)) wmempcpy (wchar_t *_Dst, const wchar_t *_Src, size_t _Size);
  wchar_t *__attribute__((__cdecl__)) wmemmove(wchar_t *s1, const wchar_t *s2, size_t n) ;
  int __attribute__((__cdecl__)) fwide(FILE *stream,int mode);
  int __attribute__((__cdecl__)) mbsinit(const mbstate_t *ps);
  __extension__ long long __attribute__((__cdecl__)) wcstoll(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);
  __extension__ unsigned long long __attribute__((__cdecl__)) wcstoull(const wchar_t * __restrict__ nptr,wchar_t ** __restrict__ endptr, int base);


  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _MaxCount) ;
# 1066 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 3
}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 2 3
# 23 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
extern "C" {




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _waccess_s (const wchar_t *_Filename,int _AccessMode);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wmktemp_s (wchar_t *_TemplateName,size_t _SizeInWords);




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _cgetws_s (wchar_t *_Buffer,size_t _SizeInWords,size_t *_SizeRead);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s (const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s(const wchar_t *_Format,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _cwscanf_s_l(const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s (const wchar_t *_Format,va_list _ArgList);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _cwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__((dllimport)) int __attribute__((__cdecl__)) _vcwprintf_s_l (const wchar_t *_Format,_locale_t _Locale,va_list _ArgList);
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itow_s (int _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _itow_s(int _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _itow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltow_s (long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ltow_s(long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ltow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultow_s (unsigned long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _ultow_s(unsigned long _Val, wchar_t (&_DstBuf)[__size], int _Radix) { return _ultow_s(_Val, _DstBuf, __size, _Radix); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t *_ReturnSize,wchar_t *_DstBuf,size_t _DstSizeInWords,const wchar_t *_VarName);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wgetenv_s(size_t* _ReturnSize, wchar_t (&_DstBuf)[__size], const wchar_t* _VarName) { return _wgetenv_s(_ReturnSize, _DstBuf, __size, _VarName); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wdupenv_s(wchar_t **_Buffer,size_t *_BufferSizeInWords,const wchar_t *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64tow_s(long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64tow_s(unsigned long long _Val,wchar_t *_DstBuf,size_t _SizeInWords,int _Radix);





  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t *_PathResult,size_t _SizeInWords,const wchar_t *_Drive,const wchar_t *_Dir,const wchar_t *_Filename,const wchar_t *_Ext);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wmakepath_s(wchar_t (&_PathResult)[__size], const wchar_t* _Drive, const wchar_t* _Dir, const wchar_t* _Filename, const wchar_t* _Ext) { return _wmakepath_s(_PathResult,__size,_Drive,_Dir,_Filename,_Ext); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wputenv_s(const wchar_t *_Name,const wchar_t *_Value);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t *_Filename,const wchar_t *_EnvVar,wchar_t *_ResultPath,size_t _SizeInWords);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _wsearchenv_s(const wchar_t* _Filename, const wchar_t* _EnvVar, wchar_t (&_ResultPath)[__size]) { return _wsearchenv_s(_Filename, _EnvVar, _ResultPath, __size); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_FullPath,wchar_t *_Drive,size_t _DriveSizeInWords,wchar_t *_Dir,size_t _DirSizeInWords,wchar_t *_Filename,size_t _FilenameSizeInWords,wchar_t *_Ext,size_t _ExtSizeInWords);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _wsplitpath_s(const wchar_t *_Dest, wchar_t (&__drive)[__drive_size], wchar_t (&__dir)[__dir_size], wchar_t (&__name)[__name_size], wchar_t (&__ext)[__ext_size]) { return _wsplitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }






  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) wcstok_s(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcserror_s(wchar_t *_Buf,size_t _SizeInWords,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) __wcserror_s(wchar_t *_Buffer,size_t _SizeInWords,const wchar_t *_ErrMsg);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s(wchar_t *_Dst,size_t _DstSizeInWords,wchar_t _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s(wchar_t *_Str,size_t _SizeInWords,wchar_t _Val);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s(wchar_t *_Str,size_t _SizeInWords);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcslwr_s_l(wchar_t *_Str,size_t _SizeInWords,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s(wchar_t *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsupr_s_l(wchar_t *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscat_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscat_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t *_Dst, rsize_t _DstSize, const wchar_t *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcscpy_s(wchar_t (&_Dest)[__size], const wchar_t * _Source) { return wcscpy_s(_Dest,__size,_Source); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncat_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncat_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsncpy_s(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsncpy_s_l(wchar_t *_Dst,size_t _DstSizeInChars,const wchar_t *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) wchar_t *__attribute__((__cdecl__)) _wcstok_s_l(wchar_t *_Str,const wchar_t *_Delim,wchar_t **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcsnset_s_l(wchar_t *_Str,size_t _SizeInChars,unsigned int _Val, size_t _Count,_locale_t _Locale);

  inline __attribute__((__always_inline__)) size_t __attribute__((__cdecl__)) wcsnlen_s(const wchar_t * _src, size_t _count) {
    return _src ? wcsnlen(_src, _count) : 0;
  }




  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wasctime_s (wchar_t *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime32_s (wchar_t *_Buf,size_t _SizeInWords,const __time32_t *_Time);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrdate_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wstrtime_s (wchar_t *_Buf,size_t _SizeInWords);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _wctime64_s (wchar_t *_Buf,size_t _SizeInWords,const __time64_t *_Time);
# 165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/wchar_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t *_Retval,wchar_t *_Dst,size_t _SizeInWords,const char **_PSrc,size_t _N,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dst)[__size], const char** _PSrc, size_t _N, mbstate_t _State) { return mbsrtowcs_s(_Retval, _Dst, __size, _PSrc, _N, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,wchar_t _Ch,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcrtomb_s(size_t* _Retval, char (&_Dst)[__size], wchar_t _Ch, mbstate_t _State) { return wcrtomb_s(_Retval, _Dst, __size, _Ch, _State); } }

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t *_Retval,char *_Dst,size_t _SizeInBytes,const wchar_t **_Src,size_t _Size,mbstate_t *_State);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) wcsrtombs_s(size_t _Retval, char (&_Dst)[__size], const wchar_t** _Src, size_t _Size, mbstate_t _State) { return wcsrtombs_s(_Retval, _Dst, __size, _Src, _Size, _State); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemcpy_s (wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) wmemmove_s(wchar_t *_dest,size_t _numberOfElements,const wchar_t *_src,size_t _count);



}
# 1072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1074 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wchar.h" 2 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 2 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}







namespace __gnu_cxx
{





  using ::wcstold;
# 257 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
# 277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
namespace std
{

  using std::wcstof;


  using std::vfwscanf;


  using std::vswscanf;


  using std::vwscanf;



  using std::wcstold;
  using std::wcstoll;
  using std::wcstoull;

}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 2 3
# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
namespace std
{

# 90 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 2 3

namespace std
{

# 74 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;


namespace __cxx11 {

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

}

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace __gnu_cxx
{

# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std
{

# 226 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return __builtin_memcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n));
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return static_cast<char_type*>(__builtin_memset(__s, __a, __n));
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return 0;
 return wmemcmp(__s1, __s2, __n);
      }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 if (__n == 0)
   return 0;
 return wmemchr(__s, __a, __n);
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemmove(__s1, __s2, __n);
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return wmemcpy(__s1, __s2, __n);
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 if (__n == 0)
   return __s;
 return wmemset(__s, __a, __n);
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>((wint_t)(0xFFFF)); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 1 3 4
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 1 3 4
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 13 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 3 4
extern "C" {




  __attribute__ ((__dllimport__)) extern int *__attribute__((__cdecl__)) _errno(void);

  errno_t __attribute__((__cdecl__)) _set_errno(int _Value);
  errno_t __attribute__((__cdecl__)) _get_errno(int *_Value);


  __attribute__ ((__dllimport__)) extern unsigned long __attribute__((__cdecl__)) __threadid(void);

  __attribute__ ((__dllimport__)) extern uintptr_t __attribute__((__cdecl__)) __threadhandle(void);


}
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 427 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdint.h" 2 3 4


typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned uint32_t;
__extension__ typedef long long int64_t;
__extension__ typedef unsigned long long uint64_t;


typedef signed char int_least8_t;
typedef unsigned char uint_least8_t;
typedef short int_least16_t;
typedef unsigned short uint_least16_t;
typedef int int_least32_t;
typedef unsigned uint_least32_t;
__extension__ typedef long long int_least64_t;
__extension__ typedef unsigned long long uint_least64_t;





typedef signed char int_fast8_t;
typedef unsigned char uint_fast8_t;
typedef short int_fast16_t;
typedef unsigned short uint_fast16_t;
typedef int int_fast32_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef long long int_fast64_t;
__extension__ typedef unsigned long long uint_fast64_t;


__extension__ typedef long long intmax_t;
__extension__ typedef unsigned long long uintmax_t;
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdint.h" 2 3 4
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdint" 2 3




namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 421 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/char_traits.h" 2 3

namespace std
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 if (__n == 0)
   return __s1;
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 1 3
# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
  struct lconv {
    char *decimal_point;
    char *thousands_sep;
    char *grouping;
    char *int_curr_symbol;
    char *currency_symbol;
    char *mon_decimal_point;
    char *mon_thousands_sep;
    char *mon_grouping;
    char *positive_sign;
    char *negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
  };
# 79 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/locale.h" 3
  int __attribute__((__cdecl__)) _configthreadlocale(int _Flag);
  char *__attribute__((__cdecl__)) setlocale(int _Category,const char *_Locale);
  __attribute__ ((__dllimport__)) struct lconv *__attribute__((__cdecl__)) localeconv(void);
  _locale_t __attribute__((__cdecl__)) _get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) _create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) _free_locale(_locale_t _Locale);
  _locale_t __attribute__((__cdecl__)) __get_current_locale(void);
  _locale_t __attribute__((__cdecl__)) __create_locale(int _Category,const char *_Locale);
  void __attribute__((__cdecl__)) __free_locale(_locale_t _Locale);







}


#pragma pack(pop)
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 2 3
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/c++locale.h" 2 3



namespace std
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(4, 0);
    char* __sav = 0;
    if (__builtin_strcmp(__old, "C"))
      {
 const size_t __len = __builtin_strlen(__old) + 1;
 __sav = new char[__len];
 __builtin_memcpy(__sav, __old, __len);
 std::setlocale(4, "C");
      }

    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(4, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
extern "C" {
# 72 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  extern const unsigned char __newclmap[];
  extern const unsigned char __newcumap[];
  extern pthreadlocinfo __ptlocinfo;
  extern pthreadmbcinfo __ptmbcinfo;
  extern int __globallocalestatus;
  extern int __locale_changed;
  extern struct threadlocaleinfostruct __initiallocinfo;
  extern _locale_tstruct __initiallocalestructinfo;
  pthreadlocinfo __attribute__((__cdecl__)) __updatetlocinfo(void);
  pthreadmbcinfo __attribute__((__cdecl__)) __updatetmbcinfo(void);
# 100 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype(int _C,int _Type);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isctype_l(int _C,int _Type,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalpha(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalpha_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) islower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _islower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isxdigit(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isxdigit_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isspace(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isspace_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) ispunct(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _ispunct_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isalnum(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isalnum_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isprint(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isprint_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) isgraph(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isgraph_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) iscntrl(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _iscntrl_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _tolower_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _toupper_l(int _C,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __isascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __toascii(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsymf(int _C);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) __iscsym(int _C);


int __attribute__((__cdecl__)) isblank(int _C);
# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
  extern int * __imp___mb_cur_max;
# 276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/ctype.h" 3
}
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 2 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 2 3

namespace std
{

# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);


  template<typename _CharT>
    bool
    isblank(_CharT, const locale&);


  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

namespace __cxx11 {
  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;
}

namespace __cxx11 {

  template<typename _CharT>
    class collate;
  template<typename _CharT>
    class collate_byname;
}


  class time_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
}
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;
namespace __cxx11 {
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;
}
namespace __cxx11 {
  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;
}


  class messages_base;
namespace __cxx11 {
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;
}


}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 1 3
# 30 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 1 3
# 12 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 3
extern "C" {
# 239 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/errno.h" 3
}
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/types.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/types.h" 3
__extension__
typedef long long _pid_t;




typedef _pid_t pid_t;





typedef unsigned short _mode_t;


typedef _mode_t mode_t;






typedef unsigned int useconds_t;




struct timespec {
  time_t tv_sec;
  long tv_nsec;
};

struct itimerspec {
  struct timespec it_interval;
  struct timespec it_value;
};





__extension__
typedef unsigned long long _sigset_t;
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 1 3
# 16 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
extern "C" {
# 31 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthread(void (__attribute__((__cdecl__)) *_StartAddress) (void *),unsigned _StackSize,void *_ArgList);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthread(void) __attribute__ ((__noreturn__));
  __attribute__ ((__dllimport__)) uintptr_t __attribute__((__cdecl__)) _beginthreadex(void *_Security,unsigned _StackSize,unsigned ( *_StartAddress) (void *),void *_ArgList,unsigned _InitFlag,unsigned *_ThrdAddr);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _endthreadex(unsigned _Retval) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) exit(int _Code) __attribute__ ((__noreturn__));
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _exit(int _Code) __attribute__ ((__noreturn__));



  void __attribute__((__cdecl__)) _Exit(int) __attribute__ ((__noreturn__));






       

  void __attribute__((__cdecl__)) __attribute__((noreturn)) abort(void);
       



  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _cexit(void);
  void __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) _c_exit(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _getpid(void);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _cwait(int *_TermStat,intptr_t _ProcHandle,int _Action);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execl(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execle(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlp(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execlpe(const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execv(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execve(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvp(const char *_Filename,const char *const *_ArgList);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _execvpe(const char *_Filename,const char *const *_ArgList,const char *const *_Env);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnl(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnle(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlp(int _Mode,const char *_Filename,const char *_ArgList,...);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _spawnlpe(int _Mode,const char *_Filename,const char *_ArgList,...);
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  int __attribute__((__cdecl__)) system(const char *_Command);
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  void __attribute__((__cdecl__)) __security_init_cookie(void);




  void __attribute__((__cdecl__)) __security_check_cookie(uintptr_t _StackCookie);
  __attribute__((noreturn)) void __attribute__((__cdecl__)) __report_gsfailure(uintptr_t _StackCookie);

  extern uintptr_t __security_cookie;

  intptr_t __attribute__((__cdecl__)) _loaddll(char *_Filename);
  int __attribute__((__cdecl__)) _unloaddll(intptr_t _Handle);
  int (__attribute__((__cdecl__)) *__attribute__((__cdecl__)) _getdllprocaddr(intptr_t _Handle,char *_ProcedureName,intptr_t _Ordinal))(void);
# 154 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/process.h" 3
  intptr_t __attribute__((__cdecl__)) cwait(int *_TermStat,intptr_t _ProcHandle,int _Action) ;

  int __attribute__((__cdecl__)) execl(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execle(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlp(const char *_Filename,const char *_ArgList,...) ;
  int __attribute__((__cdecl__)) execlpe(const char *_Filename,const char *_ArgList,...) ;






  intptr_t __attribute__((__cdecl__)) spawnl(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnle(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlp(int,const char *_Filename,const char *_ArgList,...) ;
  intptr_t __attribute__((__cdecl__)) spawnlpe(int,const char *_Filename,const char *_ArgList,...) ;


  int __attribute__((__cdecl__)) getpid(void) ;






  int __attribute__((__cdecl__)) execv(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execve(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  int __attribute__((__cdecl__)) execvp(const char *_Filename,char *const _ArgList[]) ;
  int __attribute__((__cdecl__)) execvpe(const char *_Filename,char *const _ArgList[],char *const _Env[]) ;






  intptr_t __attribute__((__cdecl__)) spawnv(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnve(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvp(int,const char *_Filename,char *const _ArgList[]) ;
  intptr_t __attribute__((__cdecl__)) spawnvpe(int,const char *_Filename,char *const _ArgList[],char *const _Env[]) ;



}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/syslimits.h" 1 3 4






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/limits.h" 1 3 4
# 169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 2 3 4
# 8 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/syslimits.h" 2 3 4
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 2 3 4
# 68 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_signal.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 2 3


extern "C" {




  typedef int sig_atomic_t;
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
  typedef void (*__p_sig_fn_t)(int);
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/signal.h" 3
  extern void **__attribute__((__cdecl__)) __pxcptinfoptrs(void);


  __p_sig_fn_t __attribute__((__cdecl__)) signal(int _SigNum,__p_sig_fn_t _Func);
  int __attribute__((__cdecl__)) raise(int _SigNum);


}
# 69 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 53 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
  struct __timeb32 {
    __time32_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct timeb {
    time_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };


  struct __timeb64 {
    __time64_t time;
    unsigned short millitm;
    short timezone;
    short dstflag;
  };



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime64(struct __timeb64 *_Time);



  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _ftime(struct __timeb64 *);
# 102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
  void __attribute__((__cdecl__)) ftime (struct timeb *);
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 3
}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/sys/timeb_s.h" 2 3


extern "C" {




  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime_s(struct __timeb32 *_Time);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ftime64_s(struct __timeb64 *_Time);







}
# 125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sys/timeb.h" 2 3
# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_compat.h" 1 3
# 73 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3


extern "C" {
# 160 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
void * pthread_timechange_handler_np(void * dummy);
int pthread_delay_np (const struct timespec *interval);
int pthread_num_processors_np(void);
int pthread_set_num_processors_np(int n);
# 180 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
typedef long pthread_once_t;
typedef unsigned pthread_mutexattr_t;
typedef unsigned pthread_key_t;
typedef void *pthread_barrierattr_t;
typedef int pthread_condattr_t;
typedef int pthread_rwlockattr_t;
# 196 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
typedef uintptr_t pthread_t;

typedef struct _pthread_cleanup _pthread_cleanup;
struct _pthread_cleanup
{
    void (*func)(void *);
    void *arg;
    _pthread_cleanup *next;
};
# 239 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
struct sched_param {
  int sched_priority;
};

int sched_yield(void);
int sched_get_priority_min(int pol);
int sched_get_priority_max(int pol);
int sched_getscheduler(pid_t pid);
int sched_setscheduler(pid_t pid, int pol, const struct sched_param *param);



typedef struct pthread_attr_t pthread_attr_t;
struct pthread_attr_t
{
    unsigned p_state;
    void *stack;
    size_t s_size;
    struct sched_param param;
};

int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
int pthread_getschedparam(pthread_t thread, int *pol, struct sched_param *param);
int pthread_setschedparam(pthread_t thread, int pol, const struct sched_param *param);
int pthread_attr_setschedpolicy (pthread_attr_t *attr, int pol);
int pthread_attr_getschedpolicy (pthread_attr_t *attr, int *pol);


typedef void *pthread_spinlock_t;
typedef void *pthread_mutex_t;
typedef void *pthread_cond_t;
typedef void *pthread_rwlock_t;
typedef void *pthread_barrier_t;
# 291 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
extern void (**_pthread_key_dest)(void *);
int pthread_key_create(pthread_key_t *key, void (* dest)(void *));
int pthread_key_delete(pthread_key_t key);
void * pthread_getspecific(pthread_key_t key);
int pthread_setspecific(pthread_key_t key, const void *value);

pthread_t pthread_self(void);
int pthread_once(pthread_once_t *o, void (*func)(void));
void pthread_testcancel(void);
int pthread_equal(pthread_t t1, pthread_t t2);
void pthread_tls_init(void);
void _pthread_cleanup_dest(pthread_t t);
int pthread_get_concurrency(int *val);
int pthread_set_concurrency(int val);
void pthread_exit(void *res);
void _pthread_invoke_cancel(void);
int pthread_cancel(pthread_t t);
int pthread_kill(pthread_t t, int sig);
unsigned _pthread_get_state(const pthread_attr_t *attr, unsigned flag);
int _pthread_set_state(pthread_attr_t *attr, unsigned flag, unsigned val);
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
int pthread_create_wrapper(void *args);
int pthread_create(pthread_t *th, const pthread_attr_t *attr, void *(* func)(void *), void *arg);
int pthread_join(pthread_t t, void **res);
int pthread_detach(pthread_t t);
int pthread_setname_np(pthread_t thread, const char *name);
int pthread_getname_np(pthread_t thread, char *name, size_t len);


int pthread_rwlock_init(pthread_rwlock_t *rwlock_, const pthread_rwlockattr_t *attr);
int pthread_rwlock_wrlock(pthread_rwlock_t *l);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *ts);
int pthread_rwlock_rdlock(pthread_rwlock_t *l);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *l, const struct timespec *ts);
int pthread_rwlock_unlock(pthread_rwlock_t *l);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *l);
int pthread_rwlock_trywrlock(pthread_rwlock_t *l);
int pthread_rwlock_destroy (pthread_rwlock_t *l);

int pthread_cond_init(pthread_cond_t *cv, const pthread_condattr_t *a);
int pthread_cond_destroy(pthread_cond_t *cv);
int pthread_cond_signal (pthread_cond_t *cv);
int pthread_cond_broadcast (pthread_cond_t *cv);
int pthread_cond_wait (pthread_cond_t *cv, pthread_mutex_t *external_mutex);
int pthread_cond_timedwait(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);
int pthread_cond_timedwait_relative_np(pthread_cond_t *cv, pthread_mutex_t *external_mutex, const struct timespec *t);

int pthread_mutex_lock(pthread_mutex_t *m);
int pthread_mutex_timedlock(pthread_mutex_t *m, const struct timespec *ts);
int pthread_mutex_unlock(pthread_mutex_t *m);
int pthread_mutex_trylock(pthread_mutex_t *m);
int pthread_mutex_init(pthread_mutex_t *m, const pthread_mutexattr_t *a);
int pthread_mutex_destroy(pthread_mutex_t *m);

int pthread_barrier_destroy(pthread_barrier_t *b);
int pthread_barrier_init(pthread_barrier_t *b, const void *attr, unsigned int count);
int pthread_barrier_wait(pthread_barrier_t *b);

int pthread_spin_init(pthread_spinlock_t *l, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *l);

int pthread_spin_lock(pthread_spinlock_t *l);
int pthread_spin_trylock(pthread_spinlock_t *l);
int pthread_spin_unlock(pthread_spinlock_t *l);

int pthread_attr_init(pthread_attr_t *attr);
int pthread_attr_destroy(pthread_attr_t *attr);
int pthread_attr_setdetachstate(pthread_attr_t *a, int flag);
int pthread_attr_getdetachstate(const pthread_attr_t *a, int *flag);
int pthread_attr_setinheritsched(pthread_attr_t *a, int flag);
int pthread_attr_getinheritsched(const pthread_attr_t *a, int *flag);
int pthread_attr_setscope(pthread_attr_t *a, int flag);
int pthread_attr_getscope(const pthread_attr_t *a, int *flag);
int pthread_attr_getstackaddr(pthread_attr_t *attr, void **stack);
int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stack);
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *size);
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t size);

int pthread_mutexattr_init(pthread_mutexattr_t *a);
int pthread_mutexattr_destroy(pthread_mutexattr_t *a);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getpshared(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setpshared(pthread_mutexattr_t * a, int type);
int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *a, int *type);
int pthread_mutexattr_setprotocol(pthread_mutexattr_t *a, int type);
int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *a, int * prio);
int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *a, int prio);
int pthread_getconcurrency(void);
int pthread_setconcurrency(int new_level);

int pthread_condattr_destroy(pthread_condattr_t *a);
int pthread_condattr_init(pthread_condattr_t *a);
int pthread_condattr_getpshared(const pthread_condattr_t *a, int *s);
int pthread_condattr_setpshared(pthread_condattr_t *a, int s);


typedef int clockid_t;



int pthread_condattr_getclock (const pthread_condattr_t *attr,
       clockid_t *clock_id);
int pthread_condattr_setclock(pthread_condattr_t *attr,
       clockid_t clock_id);
int __pthread_clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *rqtp, struct timespec *rmtp);

int pthread_barrierattr_init(void **attr);
int pthread_barrierattr_destroy(void **attr);
int pthread_barrierattr_setpshared(void **attr, int s);
int pthread_barrierattr_getpshared(void **attr, int *s);


struct _pthread_cleanup ** pthread_getclean (void);
void * pthread_gethandle (pthread_t t);
void * pthread_getevent ();

unsigned long long _pthread_rel_time_in_ms(const struct timespec *ts);
unsigned long long _pthread_time_in_ms(void);
unsigned long long _pthread_time_in_ms_from_timespec(const struct timespec *ts);
int _pthread_tryjoin (pthread_t t, void **res);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *a);
int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *a, int *s);
int pthread_rwlockattr_init(pthread_rwlockattr_t *a);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *a, int s);
# 428 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_unistd.h" 1 3
# 429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 2 3
# 689 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread.h" 3
}
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 2 3
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 101 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3



































# 298 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}



static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;

      __r = pthread_mutexattr_init (&__attr);
      if (!__r)
 __r = pthread_mutexattr_settype (&__attr,
         2);
      if (!__r)
 __r = pthread_mutex_init (__mutex, &__attr);
      if (!__r)
 __r = pthread_mutexattr_destroy (&__attr);
      return __r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 849 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
# 149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/atomic_word.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 2 3

namespace __gnu_cxx
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 3







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 3
       
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream_insert.h" 2 3

namespace std
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 2 3







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
namespace std
{



namespace __cxx11 {
# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
 rebind<_CharT>::other _Char_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Char_alloc_type> _Alloc_traits;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Char_alloc_type allocator_type;
      typedef typename _Alloc_traits::size_type size_type;
      typedef typename _Alloc_traits::difference_type difference_type;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef typename _Alloc_traits::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
       const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;


      static const size_type npos = static_cast<size_type>(-1);

    private:




      typedef const_iterator __const_iterator;



      struct _Alloc_hider : allocator_type
      {
 _Alloc_hider(pointer __dat, const _Alloc& __a = _Alloc())
 : allocator_type(__a), _M_p(__dat) { }

 pointer _M_p;
      };

      _Alloc_hider _M_dataplus;
      size_type _M_string_length;

      enum { _S_local_capacity = 15 / sizeof(_CharT) };

      union
      {
 _CharT _M_local_buf[_S_local_capacity + 1];
 size_type _M_allocated_capacity;
      };

      void
      _M_data(pointer __p)
      { _M_dataplus._M_p = __p; }

      void
      _M_length(size_type __length)
      { _M_string_length = __length; }

      pointer
      _M_data() const
      { return _M_dataplus._M_p; }

      pointer
      _M_local_data()
      {

 return std::pointer_traits<pointer>::pointer_to(*_M_local_buf);



      }

      const_pointer
      _M_local_data() const
      {

 return std::pointer_traits<const_pointer>::pointer_to(*_M_local_buf);



      }

      void
      _M_capacity(size_type __capacity)
      { _M_allocated_capacity = __capacity; }

      void
      _M_set_length(size_type __n)
      {
 _M_length(__n);
 traits_type::assign(_M_data()[__n], _CharT());
      }

      bool
      _M_is_local() const
      { return _M_data() == _M_local_data(); }


      pointer
      _M_create(size_type&, size_type);

      void
      _M_dispose()
      {
 if (!_M_is_local())
   _M_destroy(_M_allocated_capacity);
      }

      void
      _M_destroy(size_type __size) throw()
      { _Alloc_traits::deallocate(_M_get_allocator(), _M_data(), __size + 1); }



      template<typename _InIterator>
        void
        _M_construct_aux(_InIterator __beg, _InIterator __end,
    std::__false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          _M_construct(__beg, __end, _Tag());
 }



      template<typename _Integer>
        void
        _M_construct_aux(_Integer __beg, _Integer __end, std::__true_type)
 { _M_construct_aux_2(static_cast<size_type>(__beg), __end); }

      void
      _M_construct_aux_2(size_type __req, _CharT __c)
      { _M_construct(__req, __c); }

      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   _M_construct_aux(__beg, __end, _Integral());
        }


      template<typename _InIterator>
        void
        _M_construct(_InIterator __beg, _InIterator __end,
       std::input_iterator_tag);



      template<typename _FwdIterator>
        void
        _M_construct(_FwdIterator __beg, _FwdIterator __end,
       std::forward_iterator_tag);

      void
      _M_construct(size_type __req, _CharT __c);

      allocator_type&
      _M_get_allocator()
      { return _M_dataplus; }

      const allocator_type&
      _M_get_allocator() const
      { return _M_dataplus; }

    private:
# 258 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }



      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _S_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _S_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _S_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, (void)++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _S_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_assign(const basic_string& __rcs);

      void
      _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
  size_type __len2);

      void
      _M_erase(size_type __pos, size_type __n);

    public:







      basic_string()
      noexcept(is_nothrow_default_constructible<_Alloc>::value)
      : _M_dataplus(_M_local_data())
      { _M_set_length(0); }




      explicit
      basic_string(const _Alloc& __a) noexcept
      : _M_dataplus(_M_local_data(), __a)
      { _M_set_length(0); }





      basic_string(const basic_string& __str)
      : _M_dataplus(_M_local_data(),
      _Alloc_traits::_S_select_on_copy(__str._M_get_allocator()))
      { _M_construct(__str._M_data(), __str._M_data() + __str.length()); }
# 410 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos)
      : _M_dataplus(_M_local_data())
      {
 const _CharT* __start = __str._M_data()
   + __str._M_check(__pos, "basic_string::basic_string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 426 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      {
 const _CharT* __start
   = __str._M_data() + __str._M_check(__pos, "string::string");
 _M_construct(__start, __start + __str._M_limit(__pos, __n));
      }
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s + __n); }






      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__s, __s ? __s + traits_type::length(__s) : __s+npos); }







      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__n, __c); }
# 476 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string(basic_string&& __str) noexcept
      : _M_dataplus(_M_local_data(), std::move(__str._M_get_allocator()))
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
   }
 else
   {
     _M_data(__str._M_data());
     _M_capacity(__str._M_allocated_capacity);
   }




 _M_length(__str.length());
 __str._M_data(__str._M_local_data());
 __str._M_set_length(0);
      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__l.begin(), __l.end()); }

      basic_string(const basic_string& __str, const _Alloc& __a)
      : _M_dataplus(_M_local_data(), __a)
      { _M_construct(__str.begin(), __str.end()); }

      basic_string(basic_string&& __str, const _Alloc& __a)
      noexcept(_Alloc_traits::_S_always_equal())
      : _M_dataplus(_M_local_data(), __a)
      {
 if (__str._M_is_local())
   {
     traits_type::copy(_M_local_buf, __str._M_local_buf,
         _S_local_capacity + 1);
     _M_length(__str.length());
     __str._M_set_length(0);
   }
 else if (_Alloc_traits::_S_always_equal()
     || __str.get_allocator() == __a)
   {
     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     __str._M_data(__str._M_local_buf);
     __str._M_set_length(0);
   }
 else
   _M_construct(__str.begin(), __str.end());
      }
# 544 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc())
 : _M_dataplus(_M_local_data(), __a)
 { _M_construct(__beg, __end); }




      ~basic_string()
      { _M_dispose(); }





      basic_string&
      operator=(const basic_string& __str)
      {

 if (_Alloc_traits::_S_propagate_on_copy_assign())
   {
     if (!_Alloc_traits::_S_always_equal() && !_M_is_local()
  && _M_get_allocator() != __str._M_get_allocator())
       {

  _M_destroy(_M_allocated_capacity);
  _M_data(_M_local_data());
  _M_set_length(0);
       }
     std::__alloc_on_copy(_M_get_allocator(), __str._M_get_allocator());
   }

 return this->assign(__str);
      }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 599 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {
 if (!_M_is_local() && _Alloc_traits::_S_propagate_on_move_assign()
     && !_Alloc_traits::_S_always_equal()
     && _M_get_allocator() != __str._M_get_allocator())
   {

     _M_destroy(_M_allocated_capacity);
     _M_data(_M_local_data());
     _M_set_length(0);
   }

 std::__alloc_on_move(_M_get_allocator(), __str._M_get_allocator());

 if (!__str._M_is_local()
     && (_Alloc_traits::_S_propagate_on_move_assign()
       || _Alloc_traits::_S_always_equal()))
   {
     pointer __data = nullptr;
     size_type __capacity;
     if (!_M_is_local())
       {
  if (_Alloc_traits::_S_always_equal())
    {
      __data = _M_data();
      __capacity = _M_allocated_capacity;
    }
  else
    _M_destroy(_M_allocated_capacity);
       }

     _M_data(__str._M_data());
     _M_length(__str.length());
     _M_capacity(__str._M_allocated_capacity);
     if (__data)
       {
  __str._M_data(__data);
  __str._M_capacity(__capacity);
       }
     else
       __str._M_data(__str._M_local_buf);
   }
 else
     assign(__str);
 __str.clear();
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin() noexcept
      { return iterator(_M_data()); }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end() noexcept
      { return iterator(_M_data() + this->size()); }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_string_length; }



      size_type
      length() const noexcept
      { return _M_string_length; }


      size_type
      max_size() const noexcept
      { return (_Alloc_traits::max_size(_M_get_allocator()) - 1) / 2; }
# 813 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 826 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {

 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }

      }






      size_type
      capacity() const noexcept
      {
 return _M_is_local() ? size_type(_S_local_capacity)
                      : _M_allocated_capacity;
      }
# 875 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear() noexcept
      { _M_set_length(0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 904 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 921 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 return _M_data()[__pos];
      }
# 942 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }






      reference
      front() noexcept
      {
 ;
 return operator[](0);
      }





      const_reference
      front() const noexcept
      {
 ;
 return operator[](0);
      }





      reference
      back() noexcept
      {
 ;
 return operator[](this->size() - 1);
      }





      const_reference
      back() const noexcept
      {
 ;
 return operator[](this->size() - 1);
      }
# 1026 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str)
      { return _M_append(__str._M_data(), __str.size()); }
# 1084 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_append(__str._M_data()
    + __str._M_check(__pos, "basic_string::append"),
    __str._M_limit(__pos, __n)); }







      basic_string&
      append(const _CharT* __s, size_type __n)
      {
 ;
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }






      basic_string&
      append(const _CharT* __s)
      {
 ;
 const size_type __n = traits_type::length(__s);
 _M_check_length(size_type(0), __n, "basic_string::append");
 return _M_append(__s, __n);
      }
# 1126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c)
      { return _M_replace_aux(this->size(), size_type(0), __n, __c); }







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1150 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(end(), end(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __size = this->size();
 if (__size + 1 > this->capacity())
   this->_M_mutate(__size, size_type(0), 0, size_type(1));
 traits_type::assign(this->_M_data()[__size], __c);
 this->_M_set_length(__size + 1);
      }






      basic_string&
      assign(const basic_string& __str)
      {
 this->_M_assign(__str);
 return *this;
      }
# 1194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      noexcept(_Alloc_traits::_S_nothrow_move())
      {


 return *this = std::move(__str);
      }
# 1217 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return _M_replace(size_type(0), this->size(), __str._M_data()
     + __str._M_check(__pos, "basic_string::assign"),
     __str._M_limit(__pos, __n)); }
# 1233 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s, __n);
      }
# 1249 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return _M_replace(size_type(0), this->size(), __s,
     traits_type::length(__s));
      }
# 1266 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1279 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>



        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(begin(), end(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1315 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(const_iterator __p, size_type __n, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 this->replace(__p, __p, __n, __c);
 return iterator(this->_M_data() + __pos);
      }
# 1357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
        insert(const_iterator __p, _InputIterator __beg, _InputIterator __end)
        {
   ;
   const size_type __pos = __p - begin();
   this->replace(__p, __p, __beg, __end);
   return iterator(this->_M_data() + __pos);
 }
# 1393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - begin(), __l.begin(), __l.size());
      }
# 1413 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->replace(__pos1, size_type(0),
        __str._M_data(), __str.size()); }
# 1436 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->replace(__pos1, size_type(0), __str._M_data()
        + __str._M_check(__pos2, "basic_string::insert"),
        __str._M_limit(__pos2, __n)); }
# 1459 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n)
      { return this->replace(__pos, size_type(0), __s, __n); }
# 1478 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->replace(__pos, size_type(0), __s,
        traits_type::length(__s));
      }
# 1502 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1520 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      insert(__const_iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - begin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 return iterator(_M_data() + __pos);
      }
# 1544 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 this->_M_erase(_M_check(__pos, "basic_string::erase"),
         _M_limit(__pos, __n));
 return *this;
      }
# 1560 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __position)
      {

                           ;
 const size_type __pos = __position - begin();
 this->_M_erase(__pos, size_type(1));
 return iterator(_M_data() + __pos);
      }
# 1579 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      iterator
      erase(__const_iterator __first, __const_iterator __last)
      {

                        ;
        const size_type __pos = __first - begin();
 this->_M_erase(__pos, __last - __first);
 return iterator(this->_M_data() + __pos);
      }







      void
      pop_back() noexcept
      {
 ;
 _M_erase(size() - 1, 1);
      }
# 1620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1667 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2)
      {
 ;
 return _M_replace(_M_check(__pos, "basic_string::replace"),
     _M_limit(__pos, __n1), __s, __n2);
      }
# 1692 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1716 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1734 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1754 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __s, size_type __n)
      {

                      ;
 return this->replace(__i1 - begin(), __i2 - __i1, __s, __n);
      }
# 1776 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1797 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2, size_type __n,
       _CharT __c)
      {

                      ;
 return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __c);
      }
# 1822 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      template<class _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        basic_string&
        replace(const_iterator __i1, const_iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                        ;
   ;
   return this->_M_replace_dispatch(__i1, __i2, __k1, __k2,
        std::__false_type());
 }
# 1854 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       _CharT* __k1, _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       iterator __k1, iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(__const_iterator __i1, __const_iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                      ;
 ;
 return this->replace(__i1 - begin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string& replace(const_iterator __i1, const_iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _Integer __n, _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - begin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
       _InputIterator __k1, _InputIterator __k2,
       __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
   const size_type __len2);

      basic_string&
      _M_append(const _CharT* __s, size_type __n);

    public:
# 1956 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      void
      swap(basic_string& __s) noexcept;
# 1976 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_get_allocator(); }
# 2009 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 2022 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 2037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 2054 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 2067 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 2084 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 2097 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 2114 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 2128 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 2145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2209 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2222 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2255 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2286 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2303 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2318 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2335 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2366 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2382 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2401 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2433 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2459 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2501 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
}
# 4927 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 5048 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs) noexcept
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 5095 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 5133 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 5171 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 5209 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 5247 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 5285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    noexcept(noexcept(__lhs.swap(__rhs)))
    { __lhs.swap(__rhs); }
# 5305 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 5323 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 5346 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 5363 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 75 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 25 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef int (__attribute__((__cdecl__)) *_onexit_t)(void);
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef struct _div_t {
    int quot;
    int rem;
  } div_t;

  typedef struct _ldiv_t {
    long quot;
    long rem;
  } ldiv_t;





#pragma pack(4)
  typedef struct {
    unsigned char ld[10];
  } _LDOUBLE;
#pragma pack()



  typedef struct {
    double x;
  } _CRT_DOUBLE;

  typedef struct {
    float f;
  } _CRT_FLOAT;

       


  typedef struct {
    long double x;
  } _LONGDOUBLE;

       

#pragma pack(4)
  typedef struct {
    unsigned char ld12[12];
  } _LDBL12;
#pragma pack()
# 140 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  typedef void (__attribute__((__cdecl__)) *_purecall_handler)(void);

  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _set_purecall_handler(_purecall_handler _Handler);
  __attribute__ ((__dllimport__)) _purecall_handler __attribute__((__cdecl__)) _get_purecall_handler(void);

  typedef void (__attribute__((__cdecl__)) *_invalid_parameter_handler)(const wchar_t *,const wchar_t *,const wchar_t *,unsigned int,uintptr_t);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);
  __attribute__ ((__dllimport__)) _invalid_parameter_handler __attribute__((__cdecl__)) _get_invalid_parameter_handler(void);
# 156 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned long *__attribute__((__cdecl__)) __doserrno(void);

  errno_t __attribute__((__cdecl__)) _set_doserrno(unsigned long _Value);
  errno_t __attribute__((__cdecl__)) _get_doserrno(unsigned long *_Value);




  extern __attribute__((dllimport)) char *_sys_errlist[1];
  extern __attribute__((dllimport)) int _sys_nerr;
# 180 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern int * __imp___argc;







  extern char *** __imp___argv;







  extern wchar_t *** __imp___wargv;
# 208 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char *** __imp__environ;
# 217 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern wchar_t *** __imp__wenviron;
# 226 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern char ** __imp__pgmptr;
# 235 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern wchar_t ** __imp__wpgmptr;



  errno_t __attribute__((__cdecl__)) _get_pgmptr(char **_Value);
  errno_t __attribute__((__cdecl__)) _get_wpgmptr(wchar_t **_Value);




  extern int * __imp__fmode;



  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_fmode(int _Mode);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_fmode(int *_PMode);





  extern unsigned int * __imp__osplatform;
# 265 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__osver;
# 274 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winver;
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winmajor;
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  extern unsigned int * __imp__winminor;




  errno_t __attribute__((__cdecl__)) _get_osplatform(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_osver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winver(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winmajor(unsigned int *_Value);
  errno_t __attribute__((__cdecl__)) _get_winminor(unsigned int *_Value);




  extern "C++" {
    template <typename _CountofType,size_t _SizeOfArray> char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

  }
# 334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) unsigned int __attribute__((__cdecl__)) _set_abort_behavior(unsigned int _Flags,unsigned int _Mask);



  int __attribute__((__cdecl__)) abs(int _X);
  long __attribute__((__cdecl__)) labs(long _X);


  __extension__ long long __attribute__((__cdecl__)) _abs64(long long);

  extern __inline__ __attribute__((__always_inline__,__gnu_inline__)) long long __attribute__((__cdecl__)) _abs64(long long x) {
    return __builtin_llabs(x);
  }


  int __attribute__((__cdecl__)) atexit(void (__attribute__((__cdecl__)) *)(void));


  double __attribute__((__cdecl__)) atof(const char *_String);
  double __attribute__((__cdecl__)) _atof_l(const char *_String,_locale_t _Locale);

  int __attribute__((__cdecl__)) atoi(const char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoi_l(const char *_Str,_locale_t _Locale);
  long __attribute__((__cdecl__)) atol(const char *_Str);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _atol_l(const char *_Str,_locale_t _Locale);


  void *__attribute__((__cdecl__)) bsearch(const void *_Key,const void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));
  void __attribute__((__cdecl__)) qsort(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(const void *,const void *));

  unsigned short __attribute__((__cdecl__)) _byteswap_ushort(unsigned short _Short);
  unsigned long __attribute__((__cdecl__)) _byteswap_ulong (unsigned long _Long);
  __extension__ unsigned long long __attribute__((__cdecl__)) _byteswap_uint64(unsigned long long _Int64);
  div_t __attribute__((__cdecl__)) div(int _Numerator,int _Denominator);
  char *__attribute__((__cdecl__)) getenv(const char *_VarName) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _itoa(int _Value,char *_Dest,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _i64toa(long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ui64toa(unsigned long long _Val,char *_DstBuf,int _Radix) ;
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64(const char *_String);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _atoi64_l(const char *_String,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) long long __attribute__((__cdecl__)) _strtoi64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64(const char *_String,char **_EndPtr,int _Radix);
  __extension__ __attribute__ ((__dllimport__)) unsigned long long __attribute__((__cdecl__)) _strtoui64_l(const char *_String,char **_EndPtr,int _Radix,_locale_t _Locale);
  ldiv_t __attribute__((__cdecl__)) ldiv(long _Numerator,long _Denominator);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ltoa(long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) mblen(const char *_Ch,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mblen_l(const char *_Ch,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen(const char *_Str);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrlen_l(const char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen(const char *_Str,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstrnlen_l(const char *_Str,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mbtowc(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _mbtowc_l(wchar_t * __restrict__ _DstCh,const char * __restrict__ _SrcCh,size_t _SrcSizeInBytes,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) mbstowcs(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _mbstowcs_l(wchar_t * __restrict__ _Dest,const char * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale);
  int __attribute__((__cdecl__)) mkstemp(char *template_name);
  int __attribute__((__cdecl__)) rand(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_error_mode(int _Mode);
  void __attribute__((__cdecl__)) srand(unsigned int _Seed);
# 404 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtod(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  return __mingw_strtod( _Str, _EndPtr);
}

static __attribute__ ((__unused__)) __inline__ __attribute__((__cdecl__))
float __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtof(const char * __restrict__ _Str,char ** __restrict__ _EndPtr)
{
  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  return __mingw_strtof( _Str, _EndPtr);
}






  long double __attribute__((__cdecl__)) __attribute__ ((__nothrow__)) strtold(const char * __restrict__ , char ** __restrict__ );


  extern double __attribute__((__cdecl__)) __attribute__ ((__nothrow__))
  __strtod (const char * __restrict__ , char ** __restrict__);






  float __attribute__((__cdecl__)) __mingw_strtof (const char * __restrict__, char ** __restrict__);
  double __attribute__((__cdecl__)) __mingw_strtod (const char * __restrict__, char ** __restrict__);
  long double __attribute__((__cdecl__)) __mingw_strtold(const char * __restrict__, char ** __restrict__);

  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _strtod_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,_locale_t _Locale);
  long __attribute__((__cdecl__)) strtol(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) long __attribute__((__cdecl__)) _strtol_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);
  unsigned long __attribute__((__cdecl__)) strtoul(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _strtoul_l(const char * __restrict__ _Str,char ** __restrict__ _EndPtr,int _Radix,_locale_t _Locale);




  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ultoa(unsigned long _Value,char *_Dest,int _Radix) ;
  int __attribute__((__cdecl__)) wctomb(char *_MbCh,wchar_t _WCh) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wctomb_l(char *_MbCh,wchar_t _WCh,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) wcstombs(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _wcstombs_l(char * __restrict__ _Dest,const wchar_t * __restrict__ _Source,size_t _MaxCount,_locale_t _Locale) ;



  void *__attribute__((__cdecl__)) calloc(size_t _NumOfElements,size_t _SizeOfElements);
  void __attribute__((__cdecl__)) free(void *_Memory);
  void *__attribute__((__cdecl__)) malloc(size_t _Size);
  void *__attribute__((__cdecl__)) realloc(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _recalloc(void *_Memory,size_t _Count,size_t _Size);


       
       


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _aligned_free(void *_Memory);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_malloc(size_t _Size,size_t _Alignment);
       
       

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_malloc(size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_realloc(void *_Memory,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_realloc(void *_Memory,size_t _Size,size_t _Alignment,size_t _Offset);
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _aligned_offset_recalloc(void *_Memory,size_t _Count,size_t _Size,size_t _Alignment,size_t _Offset);
# 533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _putenv(const char *_EnvString);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wputenv(const wchar_t *_EnvString);



  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fullpath(char *_FullPath,const char *_Path,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl(_CRT_DOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl(_LDOUBLE *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt(_CRT_FLOAT *_Result,char *_Str);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atodbl_l(_CRT_DOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoldbl_l(_LDOUBLE *_Result,char *_Str,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _atoflt_l(_CRT_FLOAT *_Result,char *_Str,_locale_t _Locale);
# 563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
unsigned long __attribute__((__cdecl__)) _lrotl(unsigned long,int);
unsigned long __attribute__((__cdecl__)) _lrotr(unsigned long,int);





  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _makepath(char *_Path,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  _onexit_t __attribute__((__cdecl__)) _onexit(_onexit_t _Func);





       
       


  __extension__ unsigned long long __attribute__((__cdecl__)) _rotl64(unsigned long long _Val,int _Shift);
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long Value,int Shift);
       
       
       
       


  unsigned int __attribute__((__cdecl__)) _rotr(unsigned int _Val,int _Shift);
  unsigned int __attribute__((__cdecl__)) _rotl(unsigned int _Val,int _Shift);
       
       
  __extension__ unsigned long long __attribute__((__cdecl__)) _rotr64(unsigned long long _Val,int _Shift);
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _searchenv(const char *_Filename,const char *_EnvVar,char *_ResultPath) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _splitpath(const char *_FullPath,char *_Drive,char *_Dir,char *_Filename,char *_Ext) ;
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _swab(char *_Buf1,char *_Buf2,int _SizeInBytes);
# 610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _beep(unsigned _Frequency,unsigned _Duration) __attribute__ ((__deprecated__));

  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _seterrormode(int _Mode) __attribute__ ((__deprecated__));
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _sleep(unsigned long _Duration) __attribute__ ((__deprecated__));
# 634 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
  char *__attribute__((__cdecl__)) ecvt(double _Val,int _NumOfDigits,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) fcvt(double _Val,int _NumOfDec,int *_PtDec,int *_PtSign) ;
  char *__attribute__((__cdecl__)) gcvt(double _Val,int _NumOfDigits,char *_DstBuf) ;
  char *__attribute__((__cdecl__)) itoa(int _Val,char *_DstBuf,int _Radix) ;
  char *__attribute__((__cdecl__)) ltoa(long _Val,char *_DstBuf,int _Radix) ;
  int __attribute__((__cdecl__)) putenv(const char *_EnvString) ;



  void __attribute__((__cdecl__)) swab(char *_Buf1,char *_Buf2,int _SizeInBytes) ;


  char *__attribute__((__cdecl__)) ultoa(unsigned long _Val,char *_Dstbuf,int _Radix) ;
  _onexit_t __attribute__((__cdecl__)) onexit(_onexit_t _Func);





  typedef struct { __extension__ long long quot, rem; } lldiv_t;

  __extension__ lldiv_t __attribute__((__cdecl__)) lldiv(long long, long long);

  __extension__ long long __attribute__((__cdecl__)) llabs(long long);




  __extension__ long long __attribute__((__cdecl__)) strtoll(const char * __restrict__, char ** __restrict, int);
  __extension__ unsigned long long __attribute__((__cdecl__)) strtoull(const char * __restrict__, char ** __restrict__, int);


  __extension__ long long __attribute__((__cdecl__)) atoll (const char *);


  __extension__ long long __attribute__((__cdecl__)) wtoll (const wchar_t *);
  __extension__ char *__attribute__((__cdecl__)) lltoa (long long, char *, int);
  __extension__ char *__attribute__((__cdecl__)) ulltoa (unsigned long long , char *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) lltow (long long, wchar_t *, int);
  __extension__ wchar_t *__attribute__((__cdecl__)) ulltow (unsigned long long, wchar_t *, int);
# 689 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 3
}


#pragma pack(pop)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 30 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 1 3
# 31 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 2 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 2 3




extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _dupenv_s(char **_PBuffer,size_t *_PBufferSizeInBytes,const char *_VarName);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _itoa_s(int _Value,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _i64toa_s(long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ui64toa_s(unsigned long long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ltoa_s(long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) mbstowcs_s(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _mbstowcs_s_l(size_t *_PtNumOfCharConverted,wchar_t *_DstBuf,size_t _SizeInWords,const char *_SrcBuf,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ultoa_s(unsigned long _Val,char *_DstBuf,size_t _Size,int _Radix);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wctomb_s_l(int *_SizeConverted,char *_MbCh,size_t _SizeInBytes,wchar_t _WCh,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) wcstombs_s(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _wcstombs_s_l(size_t *_PtNumOfCharConverted,char *_Dst,size_t _DstSizeInBytes,const wchar_t *_Src,size_t _MaxCountInBytes,_locale_t _Locale);
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _ecvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDights,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _fcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDec,int *_PtDec,int *_PtSign);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _gcvt_s(char *_DstBuf,size_t _Size,double _Val,int _NumOfDigits);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _makepath_s(char *_PathResult,size_t _Size,const char *_Drive,const char *_Dir,const char *_Filename,const char *_Ext);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _putenv_s(const char *_Name,const char *_Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _searchenv_s(const char *_Filename,const char *_EnvVar,char *_ResultPath,size_t _SizeInBytes);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_FullPath,char *_Drive,size_t _DriveSize,char *_Dir,size_t _DirSize,char *_Filename,size_t _FilenameSize,char *_Ext,size_t _ExtSize);
  extern "C++" { template <size_t __drive_size, size_t __dir_size, size_t __name_size, size_t __ext_size> inline errno_t __attribute__((__cdecl__)) _splitpath_s(const char *_Dest, char (&__drive)[__drive_size], char (&__dir)[__dir_size], char (&__name)[__name_size], char (&__ext)[__ext_size]) { return _splitpath_s(_Dest, __drive, __drive_size, __dir, __dir_size, __name, __name_size, __ext, __ext_size); } }
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/stdlib_s.h" 3
  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) qsort_s(void *_Base,size_t _NumOfElements,size_t _SizeOfElements,int (__attribute__((__cdecl__)) *_PtFuncCompare)(void *,const void *,const void *),void *_Context);





}
# 695 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 1 3
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  typedef struct _heapinfo {
    int *_pentry;
    size_t _size;
    int _useflag;
  } _HEAPINFO;


  extern unsigned int _amblksiz;
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
       
       
# 97 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
       
       




void * __mingw_aligned_malloc (size_t _Size, size_t _Alignment);
void __mingw_aligned_free (void *_Memory);
void * __mingw_aligned_offset_realloc (void *_Memory, size_t _Size, size_t _Alignment, size_t _Offset);
void * __mingw_aligned_realloc (void *_Memory, size_t _Size, size_t _Offset);



  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _resetstkoflw (void);
  __attribute__ ((__dllimport__)) unsigned long __attribute__((__cdecl__)) _set_malloc_crt_max_wait(unsigned long _NewValue);

  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _expand(void *_Memory,size_t _NewSize);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _msize(void *_Memory);






  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _get_sbh_threshold(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _set_sbh_threshold(size_t _NewValue);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _set_amblksiz(size_t _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_amblksiz(size_t *_Value);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapadd(void *_Memory,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapchk(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapmin(void);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapset(unsigned int _Fill);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _heapwalk(_HEAPINFO *_EntryInfo);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _heapused(size_t *_Used,size_t *_Commit);
  __attribute__ ((__dllimport__)) intptr_t __attribute__((__cdecl__)) _get_heap_handle(void);
# 144 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void *_MarkAllocaS(void *_Ptr,unsigned int _Marker) {
    if(_Ptr) {
      *((unsigned int*)_Ptr) = _Marker;
      _Ptr = (char*)_Ptr + 16;
    }
    return _Ptr;
  }
# 163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
  static __inline void __attribute__((__cdecl__)) _freea(void *_Memory) {
    unsigned int _Marker;
    if(_Memory) {
      _Memory = (char*)_Memory - 16;
      _Marker = *(unsigned int *)_Memory;
      if(_Marker==0xDDDD) {
 free(_Memory);
      }





    }
  }
# 206 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/malloc.h" 3
}


#pragma pack(pop)
# 696 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stdlib.h" 2 3
# 76 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 2 3
# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
extern "C++"
{
namespace std
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }
# 201 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3

}
# 215 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
namespace __gnu_cxx
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
# 247 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}



}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwchar" 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 96 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
namespace std
{
  using ::FILE;
  using ::fpos_t;

  using ::clearerr;
  using ::fclose;
  using ::feof;
  using ::ferror;
  using ::fflush;
  using ::fgetc;
  using ::fgetpos;
  using ::fgets;
  using ::fopen;
  using ::fprintf;
  using ::fputc;
  using ::fputs;
  using ::fread;
  using ::freopen;
  using ::fscanf;
  using ::fseek;
  using ::fsetpos;
  using ::ftell;
  using ::fwrite;
  using ::getc;
  using ::getchar;




  using ::perror;
  using ::printf;
  using ::putc;
  using ::putchar;
  using ::puts;
  using ::remove;
  using ::rename;
  using ::rewind;
  using ::scanf;
  using ::setbuf;
  using ::setvbuf;
  using ::sprintf;
  using ::sscanf;
  using ::tmpfile;

  using ::tmpnam;

  using ::ungetc;
  using ::vfprintf;
  using ::vprintf;
  using ::vsprintf;
}
# 157 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
namespace __gnu_cxx
{
# 175 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
  using ::snprintf;
  using ::vfscanf;
  using ::vscanf;
  using ::vsnprintf;
  using ::vsscanf;

}

namespace std
{
  using ::__gnu_cxx::snprintf;
  using ::__gnu_cxx::vfscanf;
  using ::__gnu_cxx::vscanf;
  using ::__gnu_cxx::vsnprintf;
  using ::__gnu_cxx::vsscanf;
}
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ext/string_conversions.h" 2 3

namespace __gnu_cxx
{



  template<typename _TRet, typename _Ret = _TRet, typename _CharT,
    typename... _Base>
    _Ret
    __stoa(_TRet (*__convf) (const _CharT*, _CharT**, _Base...),
    const char* __name, const _CharT* __str, std::size_t* __idx,
    _Base... __base)
    {
      _Ret __ret;

      _CharT* __endptr;

      struct _Save_errno {
 _Save_errno() : _M_errno((*_errno())) { (*_errno()) = 0; }
 ~_Save_errno() { if ((*_errno()) == 0) (*_errno()) = _M_errno; }
 int _M_errno;
      } const __save_errno;

      const _TRet __tmp = __convf(__str, &__endptr, __base...);

      if (__endptr == __str)
 std::__throw_invalid_argument(__name);
      else if ((*_errno()) == 34
        || (std::__are_same<_Ret, int>::__value
     && (__tmp < __numeric_traits<int>::__min
         || __tmp > __numeric_traits<int>::__max)))
 std::__throw_out_of_range(__name);
      else
 __ret = __tmp;

      if (__idx)
 *__idx = __endptr - __str;

      return __ret;
    }


  template<typename _String, typename _CharT = typename _String::value_type>
    _String
    __to_xstring(int (*__convf) (_CharT*, std::size_t, const _CharT*,
     __builtin_va_list), std::size_t __n,
   const _CharT* __fmt, ...)
    {


      _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
         * __n));

      __builtin_va_list __args;
      __builtin_va_start(__args, __fmt);

      const int __len = __convf(__s, __n, __fmt, __args);

      __builtin_va_end(__args);

      return _String(__s, __s + __len);
    }


}
# 5403 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.h" 2 3

namespace std
{

namespace __cxx11 {



  inline int
  stoi(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::strtol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const string& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::strtoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const string& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::strtold, "stold", __str.c_str(), __idx); }






  inline string
  to_string(int __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(int),
        "%d", __val); }

  inline string
  to_string(unsigned __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned),
        "%u", __val); }

  inline string
  to_string(long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, 4 * sizeof(long),
        "%ld", __val); }

  inline string
  to_string(unsigned long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long),
        "%lu", __val); }

  inline string
  to_string(long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(long long),
        "%lld", __val); }

  inline string
  to_string(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<string>(&std::vsnprintf,
        4 * sizeof(unsigned long long),
        "%llu", __val); }

  inline string
  to_string(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%f", __val);
  }

  inline string
  to_string(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<string>(&std::vsnprintf, __n,
        "%Lf", __val);
  }



  inline int
  stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa<long, int>(&std::wcstol, "stoi", __str.c_str(),
     __idx, __base); }

  inline long
  stol(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstol, "stol", __str.c_str(),
        __idx, __base); }

  inline unsigned long
  stoul(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoul, "stoul", __str.c_str(),
        __idx, __base); }

  inline long long
  stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoll, "stoll", __str.c_str(),
        __idx, __base); }

  inline unsigned long long
  stoull(const wstring& __str, size_t* __idx = 0, int __base = 10)
  { return __gnu_cxx::__stoa(&std::wcstoull, "stoull", __str.c_str(),
        __idx, __base); }


  inline float
  stof(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstof, "stof", __str.c_str(), __idx); }

  inline double
  stod(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstod, "stod", __str.c_str(), __idx); }

  inline long double
  stold(const wstring& __str, size_t* __idx = 0)
  { return __gnu_cxx::__stoa(&std::wcstold, "stold", __str.c_str(), __idx); }



  inline wstring
  to_wstring(int __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(int),
         L"%d", __val); }

  inline wstring
  to_wstring(unsigned __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned),
         L"%u", __val); }

  inline wstring
  to_wstring(long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, 4 * sizeof(long),
         L"%ld", __val); }

  inline wstring
  to_wstring(unsigned long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long),
         L"%lu", __val); }

  inline wstring
  to_wstring(long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(long long),
         L"%lld", __val); }

  inline wstring
  to_wstring(unsigned long long __val)
  { return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf,
         4 * sizeof(unsigned long long),
         L"%llu", __val); }

  inline wstring
  to_wstring(float __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<float>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%f", __val);
  }

  inline wstring
  to_wstring(long double __val)
  {
    const int __n =
      __gnu_cxx::__numeric_traits<long double>::__max_exponent10 + 20;
    return __gnu_cxx::__to_xstring<wstring>(&std::vswprintf, __n,
         L"%Lf", __val);
  }



}

}







namespace std
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };






  inline namespace literals
  {
  inline namespace string_literals
  {

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char>
    operator""s(const char* __str, size_t __len)
    { return basic_string<char>{__str, __len}; }


    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<wchar_t>
    operator""s(const wchar_t* __str, size_t __len)
    { return basic_string<wchar_t>{__str, __len}; }



    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char16_t>
    operator""s(const char16_t* __str, size_t __len)
    { return basic_string<char16_t>{__str, __len}; }

    __attribute ((__abi_tag__ ("cxx11")))
    inline basic_string<char32_t>
    operator""s(const char32_t* __str, size_t __len)
    { return basic_string<char32_t>{__str, __len}; }


  }
  }




}
# 53 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 1 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3
       
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3



namespace std
{




  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s) noexcept
    {
      if (this == &__s)
 return;

      _Alloc_traits::_S_on_swap(_M_get_allocator(), __s._M_get_allocator());

      if (_M_is_local())
 if (__s._M_is_local())
   {
     if (length() && __s.length())
       {
  _CharT __tmp_data[_S_local_capacity + 1];
  traits_type::copy(__tmp_data, __s._M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  traits_type::copy(_M_local_buf, __tmp_data,
      _S_local_capacity + 1);
       }
     else if (__s.length())
       {
  traits_type::copy(_M_local_buf, __s._M_local_buf,
      _S_local_capacity + 1);
  _M_length(__s.length());
  __s._M_set_length(0);
  return;
       }
     else if (length())
       {
  traits_type::copy(__s._M_local_buf, _M_local_buf,
      _S_local_capacity + 1);
  __s._M_length(length());
  _M_set_length(0);
  return;
       }
   }
 else
   {
     const size_type __tmp_capacity = __s._M_allocated_capacity;
     traits_type::copy(__s._M_local_buf, _M_local_buf,
         _S_local_capacity + 1);
     _M_data(__s._M_data());
     __s._M_data(__s._M_local_buf);
     _M_capacity(__tmp_capacity);
   }
      else
 {
   const size_type __tmp_capacity = _M_allocated_capacity;
   if (__s._M_is_local())
     {
       traits_type::copy(_M_local_buf, __s._M_local_buf,
    _S_local_capacity + 1);
       __s._M_data(_M_data());
       _M_data(_M_local_buf);
     }
   else
     {
       pointer __tmp_ptr = _M_data();
       _M_data(__s._M_data());
       __s._M_data(__tmp_ptr);
       _M_capacity(__s._M_allocated_capacity);
     }
   __s._M_capacity(__tmp_capacity);
 }

      const size_type __tmp_length = length();
      _M_length(__s.length());
      __s._M_length(__tmp_length);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::pointer
    basic_string<_CharT, _Traits, _Alloc>::
    _M_create(size_type& __capacity, size_type __old_capacity)
    {


      if (__capacity > max_size())
 std::__throw_length_error(("basic_string::_M_create"));




      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 {
   __capacity = 2 * __old_capacity;

   if (__capacity > max_size())
     __capacity = max_size();
 }



      return _Alloc_traits::allocate(_M_get_allocator(), __capacity + 1);
    }





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::input_iterator_tag)
      {
 size_type __len = 0;
 size_type __capacity = size_type(_S_local_capacity);

 while (__beg != __end && __len < __capacity)
   {
     _M_data()[__len++] = *__beg;
     ++__beg;
   }

 try
   {
     while (__beg != __end)
       {
  if (__len == __capacity)
    {

      __capacity = __len + 1;
      pointer __another = _M_create(__capacity, __len);
      this->_S_copy(__another, _M_data(), __len);
      _M_dispose();
      _M_data(__another);
      _M_capacity(__capacity);
    }
  _M_data()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__len);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      void
      basic_string<_CharT, _Traits, _Alloc>::
      _M_construct(_InIterator __beg, _InIterator __end,
     std::forward_iterator_tag)
      {

 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   std::__throw_logic_error(("basic_string::" "_M_construct null not valid")
                                         );

 size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));

 if (__dnew > size_type(_S_local_capacity))
   {
     _M_data(_M_create(__dnew, size_type(0)));
     _M_capacity(__dnew);
   }


 try
   { this->_S_copy_chars(_M_data(), __beg, __end); }
 catch(...)
   {
     _M_dispose();
     throw;
   }

 _M_set_length(__dnew);
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_construct(size_type __n, _CharT __c)
    {
      if (__n > size_type(_S_local_capacity))
 {
   _M_data(_M_create(__n, size_type(0)));
   _M_capacity(__n);
 }

      if (__n)
 this->_S_assign(_M_data(), __n, __c);

      _M_set_length(__n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_assign(const basic_string& __str)
    {
      if (this != &__str)
 {
   const size_type __rsize = __str.length();
   const size_type __capacity = capacity();

   if (__rsize > __capacity)
     {
       size_type __new_capacity = __rsize;
       pointer __tmp = _M_create(__new_capacity, __capacity);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__new_capacity);
     }

   if (__rsize)
     this->_S_copy(_M_data(), __str._M_data(), __rsize);

   _M_set_length(__rsize);
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {

      if (__res < length())
 __res = length();

      const size_type __capacity = capacity();
      if (__res != __capacity)
 {
   if (__res > __capacity
       || __res > size_type(_S_local_capacity))
     {
       pointer __tmp = _M_create(__res, __capacity);
       this->_S_copy(__tmp, _M_data(), length() + 1);
       _M_dispose();
       _M_data(__tmp);
       _M_capacity(__res);
     }
   else if (!_M_is_local())
     {
       this->_S_copy(_M_local_data(), _M_data(), length() + 1);
       _M_destroy(__capacity);
       _M_data(_M_local_data());
     }
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, const _CharT* __s,
       size_type __len2)
    {
      const size_type __how_much = length() - __pos - __len1;

      size_type __new_capacity = length() + __len2 - __len1;
      pointer __r = _M_create(__new_capacity, capacity());

      if (__pos)
 this->_S_copy(__r, _M_data(), __pos);
      if (__s && __len2)
 this->_S_copy(__r + __pos, __s, __len2);
      if (__how_much)
 this->_S_copy(__r + __pos + __len2,
        _M_data() + __pos + __len1, __how_much);

      _M_dispose();
      _M_data(__r);
      _M_capacity(__new_capacity);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_erase(size_type __pos, size_type __n)
    {
      const size_type __how_much = length() - __pos - __n;

      if (__how_much && __n)
 this->_S_move(_M_data() + __pos, _M_data() + __pos + __n, __how_much);

      _M_set_length(length() - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->_M_erase(__n, __size - __n);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_append(const _CharT* __s, size_type __n)
    {
      const size_type __len = __n + this->size();

      if (__len <= this->capacity())
 {
   if (__n)
     this->_S_copy(this->_M_data() + this->size(), __s, __n);
 }
      else
 this->_M_mutate(this->size(), size_type(0), __s, __n);

      this->_M_set_length(__len);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(const_iterator __i1, const_iterator __i2,
     _InputIterator __k1, _InputIterator __k2,
     std::__false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 return _M_replace(__i1 - begin(), __n1, __s._M_data(),
     __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __n2 - __n1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos1;

   const size_type __how_much = __old_size - __pos1 - __n1;
   if (__how_much && __n1 != __n2)
     this->_S_move(__p + __n2, __p + __n1, __how_much);
 }
      else
 this->_M_mutate(__pos1, __n1, 0, __n2);

      if (__n2)
 this->_S_assign(this->_M_data() + __pos1, __n2, __c);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace(size_type __pos, size_type __len1, const _CharT* __s,
        const size_type __len2)
    {
      _M_check_length(__len1, __len2, "basic_string::_M_replace");

      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;

      if (__new_size <= this->capacity())
 {
   pointer __p = this->_M_data() + __pos;

   const size_type __how_much = __old_size - __pos - __len1;
   if (_M_disjunct(__s))
     {
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2)
  this->_S_copy(__p, __s, __len2);
     }
   else
     {

       if (__len2 && __len2 <= __len1)
  this->_S_move(__p, __s, __len2);
       if (__how_much && __len1 != __len2)
  this->_S_move(__p + __len2, __p + __len1, __how_much);
       if (__len2 > __len1)
  {
    if (__s + __len2 <= __p + __len1)
      this->_S_move(__p, __s, __len2);
    else if (__s >= __p + __len1)
      this->_S_copy(__p, __s + __len2 - __len1, __len2);
    else
      {
        const size_type __nleft = (__p + __len1) - __s;
        this->_S_move(__p, __s, __nleft);
        this->_S_copy(__p + __nleft, __p + __len2,
        __len2 - __nleft);
      }
  }
     }
 }
      else
 this->_M_mutate(__pos, __len1, __s, __len2);

      this->_M_set_length(__new_size);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _S_copy(__s, _M_data() + __pos, __n);

      return __n;
    }
# 1145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/string" 2 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 2 3


namespace std
{

# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale
  {
  public:


    typedef int category;


    class facet;
    class id;
    class _Impl;

    friend class facet;
    friend class _Impl;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;
# 98 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    static const category none = 0;
    static const category ctype = 1L << 0;
    static const category numeric = 1L << 1;
    static const category collate = 1L << 2;
    static const category time = 1L << 3;
    static const category monetary = 1L << 4;
    static const category messages = 1L << 5;
    static const category all = (ctype | numeric | collate |
        time | monetary | messages);
# 117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale() throw();
# 126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __other) throw();
# 136 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    locale(const char* __s);
# 151 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const char* __s, category __cat);
# 162 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    locale(const std::string& __s) : locale(__s.c_str()) { }
# 177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const std::string& __s, category __cat)
    : locale(__base, __s.c_str(), __cat) { }
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    locale(const locale& __base, const locale& __add, category __cat);
# 205 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale(const locale& __other, _Facet* __f);


    ~locale() throw();
# 219 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    const locale&
    operator=(const locale& __other) throw();
# 234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Facet>
      locale
      combine(const locale& __other) const;






    __attribute ((__abi_tag__ ("cxx11")))
    string
    name() const;
# 254 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    bool
    operator==(const locale& __other) const throw();







    bool
    operator!=(const locale& __other) const throw()
    { return !(this->operator==(__other)); }
# 282 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    template<typename _Char, typename _Traits, typename _Alloc>
      bool
      operator()(const basic_string<_Char, _Traits, _Alloc>& __s1,
   const basic_string<_Char, _Traits, _Alloc>& __s2) const;
# 298 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    static locale
    global(const locale& __loc);




    static const locale&
    classic();

  private:

    _Impl* _M_impl;


    static _Impl* _S_classic;


    static _Impl* _S_global;





    static const char* const* const _S_categories;
# 333 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    enum { _S_categories_size = 6 + 0 };


    static __gthread_once_t _S_once;


    explicit
    locale(_Impl*) throw();

    static void
    _S_initialize();

    static void
    _S_initialize_once() throw();

    static category
    _S_normalize_category(category);

    void
    _M_coalesce(const locale& __base, const locale& __add, category __cat);


    static const id* const _S_twinned_facets[];

  };
# 371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale::facet
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    mutable _Atomic_word _M_refcount;


    static __c_locale _S_c_locale;


    static const char _S_c_name[2];


    static __gthread_once_t _S_once;


    static void
    _S_initialize_once();

  protected:
# 402 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    explicit
    facet(size_t __refs = 0) throw() : _M_refcount(__refs ? 1 : 0)
    { }


    virtual
    ~facet();

    static void
    _S_create_c_locale(__c_locale& __cloc, const char* __s,
         __c_locale __old = 0);

    static __c_locale
    _S_clone_c_locale(__c_locale& __cloc) throw();

    static void
    _S_destroy_c_locale(__c_locale& __cloc);

    static __c_locale
    _S_lc_ctype_c_locale(__c_locale __cloc, const char* __s);



    static __c_locale
    _S_get_c_locale();

    __attribute__ ((__const__)) static const char*
    _S_get_c_name() throw();
# 438 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
    facet(const facet&) = delete;

    facet&
    operator=(const facet&) = delete;


  private:
    void
    _M_add_reference() const throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() const throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    class __shim;

    const facet* _M_sso_shim(const id*) const;
    const facet* _M_cow_shim(const id*) const;
  };
# 482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  class locale::id
  {
  private:
    friend class locale;
    friend class locale::_Impl;

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();




    mutable size_t _M_index;


    static _Atomic_word _S_refcount;

    void
    operator=(const id&);

    id(const id&);

  public:



    id() { }

    size_t
    _M_id() const throw();
  };



  class locale::_Impl
  {
  public:

    friend class locale;
    friend class locale::facet;

    template<typename _Facet>
      friend bool
      has_facet(const locale&) throw();

    template<typename _Facet>
      friend const _Facet&
      use_facet(const locale&);

    template<typename _Cache>
      friend struct __use_cache;

  private:

    _Atomic_word _M_refcount;
    const facet** _M_facets;
    size_t _M_facets_size;
    const facet** _M_caches;
    char** _M_names;
    static const locale::id* const _S_id_ctype[];
    static const locale::id* const _S_id_numeric[];
    static const locale::id* const _S_id_collate[];
    static const locale::id* const _S_id_time[];
    static const locale::id* const _S_id_monetary[];
    static const locale::id* const _S_id_messages[];
    static const locale::id* const* const _S_facet_categories[];

    void
    _M_add_reference() throw()
    { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }

    void
    _M_remove_reference() throw()
    {

      ;
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1) == 1)
 {
          ;
   try
     { delete this; }
   catch(...)
     { }
 }
    }

    _Impl(const _Impl&, size_t);
    _Impl(const char*, size_t);
    _Impl(size_t) throw();

   ~_Impl() throw();

    _Impl(const _Impl&);

    void
    operator=(const _Impl&);

    bool
    _M_check_same_name()
    {
      bool __ret = true;
      if (_M_names[1])

 for (size_t __i = 0; __ret && __i < _S_categories_size - 1; ++__i)
   __ret = __builtin_strcmp(_M_names[__i], _M_names[__i + 1]) == 0;
      return __ret;
    }

    void
    _M_replace_categories(const _Impl*, category);

    void
    _M_replace_category(const _Impl*, const locale::id* const*);

    void
    _M_replace_facet(const _Impl*, const locale::id*);

    void
    _M_install_facet(const locale::id*, const facet*);

    template<typename _Facet>
      void
      _M_init_facet(_Facet* __facet)
      { _M_install_facet(&_Facet::id, __facet); }

    template<typename _Facet>
      void
      _M_init_facet_unchecked(_Facet* __facet)
      {
 __facet->_M_add_reference();
 _M_facets[_Facet::id._M_id()] = __facet;
      }

    void
    _M_install_cache(const facet*, size_t);

    void _M_init_extra(facet**);
    void _M_init_extra(void*, void*, const char*, const char*);
  };
# 640 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
  template<typename _CharT>
    class __cxx11:: collate : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_collate;

    public:

      static locale::id id;
# 667 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      explicit
      collate(size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_get_c_locale())
      { }
# 681 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      explicit
      collate(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_c_locale_collate(_S_clone_c_locale(__cloc))
      { }
# 698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      int
      compare(const _CharT* __lo1, const _CharT* __hi1,
       const _CharT* __lo2, const _CharT* __hi2) const
      { return this->do_compare(__lo1, __hi1, __lo2, __hi2); }
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      string_type
      transform(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_transform(__lo, __hi); }
# 731 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      long
      hash(const _CharT* __lo, const _CharT* __hi) const
      { return this->do_hash(__lo, __hi); }


      int
      _M_compare(const _CharT*, const _CharT*) const throw();

      size_t
      _M_transform(_CharT*, const _CharT*, size_t) const throw();

  protected:

      virtual
      ~collate()
      { _S_destroy_c_locale(_M_c_locale_collate); }
# 760 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual int
      do_compare(const _CharT* __lo1, const _CharT* __hi1,
   const _CharT* __lo2, const _CharT* __hi2) const;
# 774 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual string_type
      do_transform(const _CharT* __lo, const _CharT* __hi) const;
# 787 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 3
      virtual long
      do_hash(const _CharT* __lo, const _CharT* __hi) const;
    };

  template<typename _CharT>
    locale::id collate<_CharT>::id;


  template<>
    int
    collate<char>::_M_compare(const char*, const char*) const throw();

  template<>
    size_t
    collate<char>::_M_transform(char*, const char*, size_t) const throw();


  template<>
    int
    collate<wchar_t>::_M_compare(const wchar_t*, const wchar_t*) const throw();

  template<>
    size_t
    collate<wchar_t>::_M_transform(wchar_t*, const wchar_t*, size_t) const throw();



  template<typename _CharT>
    class __cxx11:: collate_byname : public collate<_CharT>
    {
    public:


      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


      explicit
      collate_byname(const char* __s, size_t __refs = 0)
      : collate<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_collate);
     this->_S_create_c_locale(this->_M_c_locale_collate, __s);
   }
      }


      explicit
      collate_byname(const string& __s, size_t __refs = 0)
      : collate_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~collate_byname() { }
    };


}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3

namespace std
{


  template<typename _Facet>
    locale::
    locale(const locale& __other, _Facet* __f)
    {
      _M_impl = new _Impl(*__other._M_impl, 1);

      try
 { _M_impl->_M_install_facet(&_Facet::id, __f); }
      catch(...)
 {
   _M_impl->_M_remove_reference();
   throw;
 }
      delete [] _M_impl->_M_names[0];
      _M_impl->_M_names[0] = 0;
    }

  template<typename _Facet>
    locale
    locale::
    combine(const locale& __other) const
    {
      _Impl* __tmp = new _Impl(*_M_impl, 1);
      try
 {
   __tmp->_M_replace_facet(__other._M_impl, &_Facet::id);
 }
      catch(...)
 {
   __tmp->_M_remove_reference();
   throw;
 }
      return locale(__tmp);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    bool
    locale::
    operator()(const basic_string<_CharT, _Traits, _Alloc>& __s1,
        const basic_string<_CharT, _Traits, _Alloc>& __s2) const
    {
      typedef std::collate<_CharT> __collate_type;
      const __collate_type& __collate = use_facet<__collate_type>(*this);
      return (__collate.compare(__s1.data(), __s1.data() + __s1.length(),
    __s2.data(), __s2.data() + __s2.length()) < 0);
    }
# 102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    bool
    has_facet(const locale& __loc) throw()
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      return (__i < __loc._M_impl->_M_facets_size

       && dynamic_cast<const _Facet*>(__facets[__i]));



    }
# 130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.tcc" 3
  template<typename _Facet>
    const _Facet&
    use_facet(const locale& __loc)
    {
      const size_t __i = _Facet::id._M_id();
      const locale::facet** __facets = __loc._M_impl->_M_facets;
      if (__i >= __loc._M_impl->_M_facets_size || !__facets[__i])
        __throw_bad_cast();

      return dynamic_cast<const _Facet&>(*__facets[__i]);



    }



  template<typename _CharT>
    int
    collate<_CharT>::_M_compare(const _CharT*, const _CharT*) const throw ()
    { return 0; }


  template<typename _CharT>
    size_t
    collate<_CharT>::_M_transform(_CharT*, const _CharT*, size_t) const throw ()
    { return 0; }

  template<typename _CharT>
    int
    collate<_CharT>::
    do_compare(const _CharT* __lo1, const _CharT* __hi1,
        const _CharT* __lo2, const _CharT* __hi2) const
    {


      const string_type __one(__lo1, __hi1);
      const string_type __two(__lo2, __hi2);

      const _CharT* __p = __one.c_str();
      const _CharT* __pend = __one.data() + __one.length();
      const _CharT* __q = __two.c_str();
      const _CharT* __qend = __two.data() + __two.length();




      for (;;)
 {
   const int __res = _M_compare(__p, __q);
   if (__res)
     return __res;

   __p += char_traits<_CharT>::length(__p);
   __q += char_traits<_CharT>::length(__q);
   if (__p == __pend && __q == __qend)
     return 0;
   else if (__p == __pend)
     return -1;
   else if (__q == __qend)
     return 1;

   __p++;
   __q++;
 }
    }

  template<typename _CharT>
    typename collate<_CharT>::string_type
    collate<_CharT>::
    do_transform(const _CharT* __lo, const _CharT* __hi) const
    {
      string_type __ret;


      const string_type __str(__lo, __hi);

      const _CharT* __p = __str.c_str();
      const _CharT* __pend = __str.data() + __str.length();

      size_t __len = (__hi - __lo) * 2;

      _CharT* __c = new _CharT[__len];

      try
 {



   for (;;)
     {

       size_t __res = _M_transform(__c, __p, __len);


       if (__res >= __len)
  {
    __len = __res + 1;
    delete [] __c, __c = 0;
    __c = new _CharT[__len];
    __res = _M_transform(__c, __p, __len);
  }

       __ret.append(__c, __res);
       __p += char_traits<_CharT>::length(__p);
       if (__p == __pend)
  break;

       __p++;
       __ret.push_back(_CharT());
     }
 }
      catch(...)
 {
   delete [] __c;
   throw;
 }

      delete [] __c;

      return __ret;
    }

  template<typename _CharT>
    long
    collate<_CharT>::
    do_hash(const _CharT* __lo, const _CharT* __hi) const
    {
      unsigned long __val = 0;
      for (; __lo < __hi; ++__lo)
 __val =
   *__lo + ((__val << 7)
     | (__val >> (__gnu_cxx::__numeric_traits<unsigned long>::
    __digits - 7)));
      return static_cast<long>(__val);
    }




  extern template class collate<char>;
  extern template class collate_byname<char>;

  extern template
    const collate<char>&
    use_facet<collate<char> >(const locale&);

  extern template
    bool
    has_facet<collate<char> >(const locale&);


  extern template class collate<wchar_t>;
  extern template class collate_byname<wchar_t>;

  extern template
    const collate<wchar_t>&
    use_facet<collate<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<collate<wchar_t> >(const locale&);




}
# 851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_classes.h" 2 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cerrno" 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/error_constants.h" 2 3

namespace std
{




  enum class errc
    {




      argument_list_too_long = 7,
      argument_out_of_domain = 33,
      bad_address = 14,
      bad_file_descriptor = 9,

      broken_pipe = 32,






      device_or_resource_busy = 16,
      directory_not_empty = 41,
      executable_format_error = 8,
      file_exists = 17,
      file_too_large = 27,
      filename_too_long = 38,
      function_not_supported = 40,


      illegal_byte_sequence = 42,
      inappropriate_io_control_operation = 25,
      interrupted = 4,
      invalid_argument = 22,
      invalid_seek = 29,
      io_error = 5,
      is_a_directory = 21,






      no_child_process = 10,


      no_lock_available = 39,




      no_space_on_device = 28,


      no_such_device_or_address = 6,
      no_such_device = 19,
      no_such_file_or_directory = 2,
      no_such_process = 3,
      not_a_directory = 20,



      not_enough_memory = 12,

      not_supported = 129,




      operation_not_permitted = 1,



      operation_would_block = 140,


      permission_denied = 13,


      read_only_file_system = 30,
      resource_deadlock_would_occur = 36,
      resource_unavailable_try_again = 11,
      result_out_of_range = 34,




      timed_out = 138,

      too_many_files_open_in_system = 23,
      too_many_files_open = 24,
      too_many_links = 31


 ,
      value_too_large = 132


   };


}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 3




namespace std
{





  struct __cow_string
  {
    union {
      const char* _M_p;
      char _M_bytes[sizeof(const char*)];
    };

    __cow_string();
    __cow_string(const std::string&);
    __cow_string(const char*, size_t);
    __cow_string(const __cow_string&) noexcept;
    __cow_string& operator=(const __cow_string&) noexcept;
    ~__cow_string();

    __cow_string(__cow_string&&) noexcept;
    __cow_string& operator=(__cow_string&&) noexcept;

  };

  typedef basic_string<char> __sso_string;
# 113 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdexcept" 3
  class logic_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    logic_error(const string& __arg) ;


    explicit
    logic_error(const char*) ;



    logic_error(const logic_error&) noexcept;
    logic_error& operator=(const logic_error&) noexcept;


    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;





  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg) ;

    explicit domain_error(const char*) ;

    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg) ;

    explicit invalid_argument(const char*) ;

    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg) ;

    explicit length_error(const char*) ;

    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg) ;

    explicit out_of_range(const char*) ;

    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    __cow_string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg) ;


    explicit
    runtime_error(const char*) ;



    runtime_error(const runtime_error&) noexcept;
    runtime_error& operator=(const runtime_error&) noexcept;


    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;





  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg) ;

    explicit range_error(const char*) ;

    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg) ;

    explicit overflow_error(const char*) ;

    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg) ;

    explicit underflow_error(const char*) ;

    virtual ~underflow_error() noexcept;
  };




}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 2 3

namespace std
{


  class error_code;
  class error_condition;
  class system_error;


  template<typename _Tp>
    struct is_error_code_enum : public false_type { };


  template<typename _Tp>
    struct is_error_condition_enum : public false_type { };

  template<>
    struct is_error_condition_enum<errc>
    : public true_type { };

  inline namespace _V2 {


  class error_category
  {
  public:
    constexpr error_category() noexcept = default;

    virtual ~error_category();

    error_category(const error_category&) = delete;
    error_category& operator=(const error_category&) = delete;

    virtual const char*
    name() const noexcept = 0;






  private:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual __cow_string
    _M_message(int) const;

  public:
    __attribute ((__abi_tag__ ("cxx11")))
    virtual string
    message(int) const = 0;
# 102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/system_error" 3
  public:
    virtual error_condition
    default_error_condition(int __i) const noexcept;

    virtual bool
    equivalent(int __i, const error_condition& __cond) const noexcept;

    virtual bool
    equivalent(const error_code& __code, int __i) const noexcept;

    bool
    operator<(const error_category& __other) const noexcept
    { return less<const error_category*>()(this, &__other); }

    bool
    operator==(const error_category& __other) const noexcept
    { return this == &__other; }

    bool
    operator!=(const error_category& __other) const noexcept
    { return this != &__other; }
  };


  __attribute__ ((__const__)) const error_category& system_category() noexcept;
  __attribute__ ((__const__)) const error_category& generic_category() noexcept;

  }

  error_code make_error_code(errc) noexcept;

  template<typename _Tp>
    struct hash;



  struct error_code
  {
    error_code() noexcept
    : _M_value(0), _M_cat(&system_category()) { }

    error_code(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorCodeEnum, typename = typename
      enable_if<is_error_code_enum<_ErrorCodeEnum>::value>::type>
      error_code(_ErrorCodeEnum __e) noexcept
      { *this = make_error_code(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }

    void
    clear() noexcept
    { assign(0, system_category()); }


    template<typename _ErrorCodeEnum>
      typename enable_if<is_error_code_enum<_ErrorCodeEnum>::value,
    error_code&>::type
      operator=(_ErrorCodeEnum __e) noexcept
      { return *this = make_error_code(__e); }

    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    error_condition
    default_error_condition() const noexcept;

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    friend class hash<error_code>;

    int _M_value;
    const error_category* _M_cat;
  };


  inline error_code
  make_error_code(errc __e) noexcept
  { return error_code(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_code& __lhs, const error_code& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __e)
    { return (__os << __e.category().name() << ':' << __e.value()); }

  error_condition make_error_condition(errc) noexcept;



  struct error_condition
  {
    error_condition() noexcept
    : _M_value(0), _M_cat(&generic_category()) { }

    error_condition(int __v, const error_category& __cat) noexcept
    : _M_value(__v), _M_cat(&__cat) { }

    template<typename _ErrorConditionEnum, typename = typename
  enable_if<is_error_condition_enum<_ErrorConditionEnum>::value>::type>
      error_condition(_ErrorConditionEnum __e) noexcept
      { *this = make_error_condition(__e); }

    void
    assign(int __v, const error_category& __cat) noexcept
    {
      _M_value = __v;
      _M_cat = &__cat;
    }


    template<typename _ErrorConditionEnum>
      typename enable_if<is_error_condition_enum
    <_ErrorConditionEnum>::value, error_condition&>::type
      operator=(_ErrorConditionEnum __e) noexcept
      { return *this = make_error_condition(__e); }

    void
    clear() noexcept
    { assign(0, generic_category()); }


    int
    value() const noexcept { return _M_value; }

    const error_category&
    category() const noexcept { return *_M_cat; }

    __attribute ((__abi_tag__ ("cxx11")))
    string
    message() const
    { return category().message(value()); }

    explicit operator bool() const noexcept
    { return _M_value != 0; }


  private:
    int _M_value;
    const error_category* _M_cat;
  };


  inline error_condition
  make_error_condition(errc __e) noexcept
  { return error_condition(static_cast<int>(__e), generic_category()); }

  inline bool
  operator<(const error_condition& __lhs,
     const error_condition& __rhs) noexcept
  {
    return (__lhs.category() < __rhs.category()
     || (__lhs.category() == __rhs.category()
  && __lhs.value() < __rhs.value()));
  }


  inline bool
  operator==(const error_code& __lhs, const error_code& __rhs) noexcept
  { return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value()); }

  inline bool
  operator==(const error_code& __lhs, const error_condition& __rhs) noexcept
  {
    return (__lhs.category().equivalent(__lhs.value(), __rhs)
     || __rhs.category().equivalent(__lhs, __rhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs, const error_code& __rhs) noexcept
  {
    return (__rhs.category().equivalent(__rhs.value(), __lhs)
     || __lhs.category().equivalent(__rhs, __lhs.value()));
  }

  inline bool
  operator==(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  {
    return (__lhs.category() == __rhs.category()
     && __lhs.value() == __rhs.value());
  }

  inline bool
  operator!=(const error_code& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_code& __lhs, const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs, const error_code& __rhs) noexcept
  { return !(__lhs == __rhs); }

  inline bool
  operator!=(const error_condition& __lhs,
      const error_condition& __rhs) noexcept
  { return !(__lhs == __rhs); }







  class system_error : public std::runtime_error
  {
  private:
    error_code _M_code;

  public:
    system_error(error_code __ec = error_code())
    : runtime_error(__ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const string& __what)
    : runtime_error(__what + ": " + __ec.message()), _M_code(__ec) { }

    system_error(error_code __ec, const char* __what)
    : runtime_error(__what + (": " + __ec.message())), _M_code(__ec) { }

    system_error(int __v, const error_category& __ecat, const char* __what)
    : system_error(error_code(__v, __ecat), __what) { }

    system_error(int __v, const error_category& __ecat)
    : runtime_error(error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    system_error(int __v, const error_category& __ecat, const string& __what)
    : runtime_error(__what + ": " + error_code(__v, __ecat).message()),
      _M_code(__v, __ecat) { }

    virtual ~system_error() noexcept;

    const error_code&
    code() const noexcept { return _M_code; }
  };


}





namespace std
{




  template<>
    struct hash<error_code>
    : public __hash_base<size_t, error_code>
    {
      size_t
      operator()(const error_code& __e) const noexcept
      {
 const size_t __tmp = std::_Hash_impl::hash(__e._M_value);
 return std::_Hash_impl::__hash_combine(__e._M_cat, __tmp);
      }
    };


}
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 2 3


namespace std
{






  enum _Ios_Fmtflags
    {
      _S_boolalpha = 1L << 0,
      _S_dec = 1L << 1,
      _S_fixed = 1L << 2,
      _S_hex = 1L << 3,
      _S_internal = 1L << 4,
      _S_left = 1L << 5,
      _S_oct = 1L << 6,
      _S_right = 1L << 7,
      _S_scientific = 1L << 8,
      _S_showbase = 1L << 9,
      _S_showpoint = 1L << 10,
      _S_showpos = 1L << 11,
      _S_skipws = 1L << 12,
      _S_unitbuf = 1L << 13,
      _S_uppercase = 1L << 14,
      _S_adjustfield = _S_left | _S_right | _S_internal,
      _S_basefield = _S_dec | _S_oct | _S_hex,
      _S_floatfield = _S_scientific | _S_fixed,
      _S_ios_fmtflags_end = 1L << 16,
      _S_ios_fmtflags_max = 0x7fffffff,
      _S_ios_fmtflags_min = ~0x7fffffff
    };

  inline constexpr _Ios_Fmtflags
  operator&(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator|(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator^(_Ios_Fmtflags __a, _Ios_Fmtflags __b)
  { return _Ios_Fmtflags(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Fmtflags
  operator~(_Ios_Fmtflags __a)
  { return _Ios_Fmtflags(~static_cast<int>(__a)); }

  inline const _Ios_Fmtflags&
  operator|=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a | __b; }

  inline const _Ios_Fmtflags&
  operator&=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a & __b; }

  inline const _Ios_Fmtflags&
  operator^=(_Ios_Fmtflags& __a, _Ios_Fmtflags __b)
  { return __a = __a ^ __b; }


  enum _Ios_Openmode
    {
      _S_app = 1L << 0,
      _S_ate = 1L << 1,
      _S_bin = 1L << 2,
      _S_in = 1L << 3,
      _S_out = 1L << 4,
      _S_trunc = 1L << 5,
      _S_ios_openmode_end = 1L << 16,
      _S_ios_openmode_max = 0x7fffffff,
      _S_ios_openmode_min = ~0x7fffffff
    };

  inline constexpr _Ios_Openmode
  operator&(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator|(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator^(_Ios_Openmode __a, _Ios_Openmode __b)
  { return _Ios_Openmode(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Openmode
  operator~(_Ios_Openmode __a)
  { return _Ios_Openmode(~static_cast<int>(__a)); }

  inline const _Ios_Openmode&
  operator|=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a | __b; }

  inline const _Ios_Openmode&
  operator&=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a & __b; }

  inline const _Ios_Openmode&
  operator^=(_Ios_Openmode& __a, _Ios_Openmode __b)
  { return __a = __a ^ __b; }


  enum _Ios_Iostate
    {
      _S_goodbit = 0,
      _S_badbit = 1L << 0,
      _S_eofbit = 1L << 1,
      _S_failbit = 1L << 2,
      _S_ios_iostate_end = 1L << 16,
      _S_ios_iostate_max = 0x7fffffff,
      _S_ios_iostate_min = ~0x7fffffff
    };

  inline constexpr _Ios_Iostate
  operator&(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) & static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator|(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) | static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator^(_Ios_Iostate __a, _Ios_Iostate __b)
  { return _Ios_Iostate(static_cast<int>(__a) ^ static_cast<int>(__b)); }

  inline constexpr _Ios_Iostate
  operator~(_Ios_Iostate __a)
  { return _Ios_Iostate(~static_cast<int>(__a)); }

  inline const _Ios_Iostate&
  operator|=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a | __b; }

  inline const _Ios_Iostate&
  operator&=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a & __b; }

  inline const _Ios_Iostate&
  operator^=(_Ios_Iostate& __a, _Ios_Iostate __b)
  { return __a = __a ^ __b; }


  enum _Ios_Seekdir
    {
      _S_beg = 0,
      _S_cur = 1,
      _S_end = 2,
      _S_ios_seekdir_end = 1L << 16
    };



  enum class io_errc { stream = 1 };

  template <> struct is_error_code_enum<io_errc> : public true_type { };

  const error_category& iostream_category() noexcept;

  inline error_code
  make_error_code(io_errc e) noexcept
  { return error_code(static_cast<int>(e), iostream_category()); }

  inline error_condition
  make_error_condition(io_errc e) noexcept
  { return error_condition(static_cast<int>(e), iostream_category()); }
# 228 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  class ios_base
  {
# 246 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  public:
# 255 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    class __attribute ((__abi_tag__ ("cxx11"))) failure : public system_error
    {
    public:
      explicit
      failure(const string& __str);


      explicit
      failure(const string&, const error_code&);

      explicit
      failure(const char*, const error_code& = io_errc::stream);


      virtual
      ~failure() throw();

      virtual const char*
      what() const throw();
    };
# 323 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Fmtflags fmtflags;


    static const fmtflags boolalpha = _S_boolalpha;


    static const fmtflags dec = _S_dec;


    static const fmtflags fixed = _S_fixed;


    static const fmtflags hex = _S_hex;




    static const fmtflags internal = _S_internal;



    static const fmtflags left = _S_left;


    static const fmtflags oct = _S_oct;



    static const fmtflags right = _S_right;


    static const fmtflags scientific = _S_scientific;



    static const fmtflags showbase = _S_showbase;



    static const fmtflags showpoint = _S_showpoint;


    static const fmtflags showpos = _S_showpos;


    static const fmtflags skipws = _S_skipws;


    static const fmtflags unitbuf = _S_unitbuf;



    static const fmtflags uppercase = _S_uppercase;


    static const fmtflags adjustfield = _S_adjustfield;


    static const fmtflags basefield = _S_basefield;


    static const fmtflags floatfield = _S_floatfield;
# 398 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Iostate iostate;



    static const iostate badbit = _S_badbit;


    static const iostate eofbit = _S_eofbit;




    static const iostate failbit = _S_failbit;


    static const iostate goodbit = _S_goodbit;
# 429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Openmode openmode;


    static const openmode app = _S_app;


    static const openmode ate = _S_ate;




    static const openmode binary = _S_bin;


    static const openmode in = _S_in;


    static const openmode out = _S_out;


    static const openmode trunc = _S_trunc;
# 461 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef _Ios_Seekdir seekdir;


    static const seekdir beg = _S_beg;


    static const seekdir cur = _S_cur;


    static const seekdir end = _S_end;


    typedef int io_state;
    typedef int open_mode;
    typedef int seek_dir;

    typedef std::streampos streampos;
    typedef std::streamoff streamoff;
# 487 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    enum event
    {
      erase_event,
      imbue_event,
      copyfmt_event
    };
# 504 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    typedef void (*event_callback) (event __e, ios_base& __b, int __i);
# 516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    void
    register_callback(event_callback __fn, int __index);

  protected:
    streamsize _M_precision;
    streamsize _M_width;
    fmtflags _M_flags;
    iostate _M_exception;
    iostate _M_streambuf_state;



    struct _Callback_list
    {

      _Callback_list* _M_next;
      ios_base::event_callback _M_fn;
      int _M_index;
      _Atomic_word _M_refcount;

      _Callback_list(ios_base::event_callback __fn, int __index,
       _Callback_list* __cb)
      : _M_next(__cb), _M_fn(__fn), _M_index(__index), _M_refcount(0) { }

      void
      _M_add_reference() { __gnu_cxx::__atomic_add_dispatch(&_M_refcount, 1); }


      int
      _M_remove_reference()
      {

        ;
        int __res = __gnu_cxx::__exchange_and_add_dispatch(&_M_refcount, -1);
        if (__res == 0)
          {
            ;
          }
        return __res;
      }
    };

     _Callback_list* _M_callbacks;

    void
    _M_call_callbacks(event __ev) throw();

    void
    _M_dispose_callbacks(void) throw();


    struct _Words
    {
      void* _M_pword;
      long _M_iword;
      _Words() : _M_pword(0), _M_iword(0) { }
    };


    _Words _M_word_zero;



    enum { _S_local_word_size = 8 };
    _Words _M_local_word[_S_local_word_size];


    int _M_word_size;
    _Words* _M_word;

    _Words&
    _M_grow_words(int __index, bool __iword);


    locale _M_ios_locale;

    void
    _M_init() throw();

  public:





    class Init
    {
      friend class ios_base;
    public:
      Init();
      ~Init();

    private:
      static _Atomic_word _S_refcount;
      static bool _S_synced_with_stdio;
    };






    fmtflags
    flags() const
    { return _M_flags; }
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    flags(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags = __fmtfl;
      return __old;
    }
# 645 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl)
    {
      fmtflags __old = _M_flags;
      _M_flags |= __fmtfl;
      return __old;
    }
# 662 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    fmtflags
    setf(fmtflags __fmtfl, fmtflags __mask)
    {
      fmtflags __old = _M_flags;
      _M_flags &= ~__mask;
      _M_flags |= (__fmtfl & __mask);
      return __old;
    }







    void
    unsetf(fmtflags __mask)
    { _M_flags &= ~__mask; }
# 688 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    streamsize
    precision() const
    { return _M_precision; }






    streamsize
    precision(streamsize __prec)
    {
      streamsize __old = _M_precision;
      _M_precision = __prec;
      return __old;
    }







    streamsize
    width() const
    { return _M_width; }






    streamsize
    width(streamsize __wide)
    {
      streamsize __old = _M_width;
      _M_width = __wide;
      return __old;
    }
# 739 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    static bool
    sync_with_stdio(bool __sync = true);
# 751 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    locale
    imbue(const locale& __loc) throw();
# 762 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    locale
    getloc() const
    { return _M_ios_locale; }
# 773 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    const locale&
    _M_getloc() const
    { return _M_ios_locale; }
# 792 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    static int
    xalloc() throw();
# 808 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    long&
    iword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, true);
      return __word._M_iword;
    }
# 829 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    void*&
    pword(int __ix)
    {
      _Words& __word = (__ix < _M_word_size)
   ? _M_word[__ix] : _M_grow_words(__ix, false);
      return __word._M_pword;
    }
# 846 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
    virtual ~ios_base();

  protected:
    ios_base() throw ();
# 860 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ios_base.h" 3
  public:
    ios_base(const ios_base&) = delete;

    ios_base&
    operator=(const ios_base&) = delete;

  protected:
    void
    _M_move(ios_base&) noexcept;

    void
    _M_swap(ios_base& __rhs) noexcept;

  };



  inline ios_base&
  boolalpha(ios_base& __base)
  {
    __base.setf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  noboolalpha(ios_base& __base)
  {
    __base.unsetf(ios_base::boolalpha);
    return __base;
  }


  inline ios_base&
  showbase(ios_base& __base)
  {
    __base.setf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  noshowbase(ios_base& __base)
  {
    __base.unsetf(ios_base::showbase);
    return __base;
  }


  inline ios_base&
  showpoint(ios_base& __base)
  {
    __base.setf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  noshowpoint(ios_base& __base)
  {
    __base.unsetf(ios_base::showpoint);
    return __base;
  }


  inline ios_base&
  showpos(ios_base& __base)
  {
    __base.setf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  noshowpos(ios_base& __base)
  {
    __base.unsetf(ios_base::showpos);
    return __base;
  }


  inline ios_base&
  skipws(ios_base& __base)
  {
    __base.setf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  noskipws(ios_base& __base)
  {
    __base.unsetf(ios_base::skipws);
    return __base;
  }


  inline ios_base&
  uppercase(ios_base& __base)
  {
    __base.setf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  nouppercase(ios_base& __base)
  {
    __base.unsetf(ios_base::uppercase);
    return __base;
  }


  inline ios_base&
  unitbuf(ios_base& __base)
  {
     __base.setf(ios_base::unitbuf);
     return __base;
  }


  inline ios_base&
  nounitbuf(ios_base& __base)
  {
     __base.unsetf(ios_base::unitbuf);
     return __base;
  }



  inline ios_base&
  internal(ios_base& __base)
  {
     __base.setf(ios_base::internal, ios_base::adjustfield);
     return __base;
  }


  inline ios_base&
  left(ios_base& __base)
  {
    __base.setf(ios_base::left, ios_base::adjustfield);
    return __base;
  }


  inline ios_base&
  right(ios_base& __base)
  {
    __base.setf(ios_base::right, ios_base::adjustfield);
    return __base;
  }



  inline ios_base&
  dec(ios_base& __base)
  {
    __base.setf(ios_base::dec, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  hex(ios_base& __base)
  {
    __base.setf(ios_base::hex, ios_base::basefield);
    return __base;
  }


  inline ios_base&
  oct(ios_base& __base)
  {
    __base.setf(ios_base::oct, ios_base::basefield);
    return __base;
  }



  inline ios_base&
  fixed(ios_base& __base)
  {
    __base.setf(ios_base::fixed, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  scientific(ios_base& __base)
  {
    __base.setf(ios_base::scientific, ios_base::floatfield);
    return __base;
  }






  inline ios_base&
  hexfloat(ios_base& __base)
  {
    __base.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);
    return __base;
  }


  inline ios_base&
  defaultfloat(ios_base& __base)
  {
    __base.unsetf(ios_base::floatfield);
    return __base;
  }



}
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>*,
     basic_streambuf<_CharT, _Traits>*, bool&);
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
  template<typename _CharT, typename _Traits>
    class basic_streambuf
    {
    public:






      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;




      typedef basic_streambuf<char_type, traits_type> __streambuf_type;


      friend class basic_ios<char_type, traits_type>;
      friend class basic_istream<char_type, traits_type>;
      friend class basic_ostream<char_type, traits_type>;
      friend class istreambuf_iterator<char_type, traits_type>;
      friend class ostreambuf_iterator<char_type, traits_type>;

      friend streamsize
      __copy_streambufs_eof<>(basic_streambuf*, basic_streambuf*, bool&);

      template<bool _IsMove, typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
        __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
        friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
      istreambuf_iterator<_CharT2> >::__type
        find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

      template<typename _CharT2, typename _Traits2>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&, _CharT2*);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        operator>>(basic_istream<_CharT2, _Traits2>&,
     basic_string<_CharT2, _Traits2, _Alloc>&);

      template<typename _CharT2, typename _Traits2, typename _Alloc>
        friend basic_istream<_CharT2, _Traits2>&
        getline(basic_istream<_CharT2, _Traits2>&,
  basic_string<_CharT2, _Traits2, _Alloc>&, _CharT2);

    protected:







      char_type* _M_in_beg;
      char_type* _M_in_cur;
      char_type* _M_in_end;
      char_type* _M_out_beg;
      char_type* _M_out_cur;
      char_type* _M_out_end;


      locale _M_buf_locale;

  public:

      virtual
      ~basic_streambuf()
      { }
# 208 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      locale
      pubimbue(const locale& __loc)
      {
 locale __tmp(this->getloc());
 this->imbue(__loc);
 _M_buf_locale = __loc;
 return __tmp;
      }
# 225 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      locale
      getloc() const
      { return _M_buf_locale; }
# 238 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      basic_streambuf*
      pubsetbuf(char_type* __s, streamsize __n)
      { return this->setbuf(__s, __n); }
# 250 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      pos_type
      pubseekoff(off_type __off, ios_base::seekdir __way,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekoff(__off, __way, __mode); }
# 262 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      pos_type
      pubseekpos(pos_type __sp,
   ios_base::openmode __mode = ios_base::in | ios_base::out)
      { return this->seekpos(__sp, __mode); }




      int
      pubsync() { return this->sync(); }
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      in_avail()
      {
 const streamsize __ret = this->egptr() - this->gptr();
 return __ret ? __ret : this->showmanyc();
      }
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      snextc()
      {
 int_type __ret = traits_type::eof();
 if (__builtin_expect(!traits_type::eq_int_type(this->sbumpc(),
             __ret), true))
   __ret = this->sgetc();
 return __ret;
      }
# 315 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sbumpc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 else
   __ret = this->uflow();
 return __ret;
      }
# 337 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sgetc()
      {
 int_type __ret;
 if (__builtin_expect(this->gptr() < this->egptr(), true))
   __ret = traits_type::to_int_type(*this->gptr());
 else
   __ret = this->underflow();
 return __ret;
      }
# 356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      sgetn(char_type* __s, streamsize __n)
      { return this->xsgetn(__s, __n); }
# 371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sputbackc(char_type __c)
      {
 int_type __ret;
 const bool __testpos = this->eback() < this->gptr();
 if (__builtin_expect(!__testpos ||
        !traits_type::eq(__c, this->gptr()[-1]), false))
   __ret = this->pbackfail(traits_type::to_int_type(__c));
 else
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 return __ret;
      }
# 396 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sungetc()
      {
 int_type __ret;
 if (__builtin_expect(this->eback() < this->gptr(), true))
   {
     this->gbump(-1);
     __ret = traits_type::to_int_type(*this->gptr());
   }
 else
   __ret = this->pbackfail();
 return __ret;
      }
# 423 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      int_type
      sputc(char_type __c)
      {
 int_type __ret;
 if (__builtin_expect(this->pptr() < this->epptr(), true))
   {
     *this->pptr() = __c;
     this->pbump(1);
     __ret = traits_type::to_int_type(__c);
   }
 else
   __ret = this->overflow(traits_type::to_int_type(__c));
 return __ret;
      }
# 449 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      streamsize
      sputn(const char_type* __s, streamsize __n)
      { return this->xsputn(__s, __n); }

    protected:
# 463 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      basic_streambuf()
      : _M_in_beg(0), _M_in_cur(0), _M_in_end(0),
      _M_out_beg(0), _M_out_cur(0), _M_out_end(0),
      _M_buf_locale(locale())
      { }
# 481 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      char_type*
      eback() const { return _M_in_beg; }

      char_type*
      gptr() const { return _M_in_cur; }

      char_type*
      egptr() const { return _M_in_end; }
# 497 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      gbump(int __n) { _M_in_cur += __n; }
# 508 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      setg(char_type* __gbeg, char_type* __gnext, char_type* __gend)
      {
 _M_in_beg = __gbeg;
 _M_in_cur = __gnext;
 _M_in_end = __gend;
      }
# 528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      char_type*
      pbase() const { return _M_out_beg; }

      char_type*
      pptr() const { return _M_out_cur; }

      char_type*
      epptr() const { return _M_out_end; }
# 544 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      pbump(int __n) { _M_out_cur += __n; }
# 554 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      setp(char_type* __pbeg, char_type* __pend)
      {
 _M_out_beg = _M_out_cur = __pbeg;
 _M_out_end = __pend;
      }
# 575 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual void
      imbue(const locale& __loc)
      { }
# 590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual basic_streambuf<char_type,_Traits>*
      setbuf(char_type*, streamsize)
      { return this; }
# 601 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual pos_type
      seekoff(off_type, ios_base::seekdir,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 613 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual pos_type
      seekpos(pos_type,
       ios_base::openmode = ios_base::in | ios_base::out)
      { return pos_type(off_type(-1)); }
# 626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int
      sync() { return 0; }
# 648 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      showmanyc() { return 0; }
# 664 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      xsgetn(char_type* __s, streamsize __n);
# 686 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      underflow()
      { return traits_type::eof(); }
# 699 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      uflow()
      {
 int_type __ret = traits_type::eof();
 const bool __testeof = traits_type::eq_int_type(this->underflow(),
       __ret);
 if (!__testeof)
   {
     __ret = traits_type::to_int_type(*this->gptr());
     this->gbump(1);
   }
 return __ret;
      }
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      pbackfail(int_type __c = traits_type::eof())
      { return traits_type::eof(); }
# 741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual streamsize
      xsputn(const char_type* __s, streamsize __n);
# 767 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      virtual int_type
      overflow(int_type __c = traits_type::eof())
      { return traits_type::eof(); }



    public:
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 3
      void
      stossc()
      {
 if (this->gptr() < this->egptr())
   this->gbump(1);
 else
   this->uflow();
      }



      void
      __safe_gbump(streamsize __n) { _M_in_cur += __n; }

      void
      __safe_pbump(streamsize __n) { _M_out_cur += __n; }




    protected:

      basic_streambuf(const basic_streambuf&);

      basic_streambuf&
      operator=(const basic_streambuf&);


      void
      swap(basic_streambuf& __sb)
      {
 std::swap(_M_in_beg, __sb._M_in_beg);
 std::swap(_M_in_cur, __sb._M_in_cur);
 std::swap(_M_in_end, __sb._M_in_end);
 std::swap(_M_out_beg, __sb._M_out_beg);
 std::swap(_M_out_cur, __sb._M_out_cur);
 std::swap(_M_out_end, __sb._M_out_end);
 std::swap(_M_buf_locale, __sb._M_buf_locale);
      }

    };


  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>::
    basic_streambuf(const basic_streambuf&) = default;

  template<typename _CharT, typename _Traits>
    std::basic_streambuf<_CharT, _Traits>&
    std::basic_streambuf<_CharT, _Traits>::
    operator=(const basic_streambuf&) = default;



  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>* __sbin,
     basic_streambuf<char>* __sbout, bool& __ineof);

  template<>
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>* __sbin,
     basic_streambuf<wchar_t>* __sbout, bool& __ineof);



}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsgetn(char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->egptr() - this->gptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(__s, this->gptr(), __len);
       __ret += __len;
       __s += __len;
       this->__safe_gbump(__len);
     }

   if (__ret < __n)
     {
       const int_type __c = this->uflow();
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    traits_type::assign(*__s++, traits_type::to_char_type(__c));
    ++__ret;
  }
       else
  break;
     }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_streambuf<_CharT, _Traits>::
    xsputn(const char_type* __s, streamsize __n)
    {
      streamsize __ret = 0;
      while (__ret < __n)
 {
   const streamsize __buf_len = this->epptr() - this->pptr();
   if (__buf_len)
     {
       const streamsize __remaining = __n - __ret;
       const streamsize __len = std::min(__buf_len, __remaining);
       traits_type::copy(this->pptr(), __s, __len);
       __ret += __len;
       __s += __len;
       this->__safe_pbump(__len);
     }

   if (__ret < __n)
     {
       int_type __c = this->overflow(traits_type::to_int_type(*__s));
       if (!traits_type::eq_int_type(__c, traits_type::eof()))
  {
    ++__ret;
    ++__s;
  }
       else
  break;
     }
 }
      return __ret;
    }




  template<typename _CharT, typename _Traits>
    streamsize
    __copy_streambufs_eof(basic_streambuf<_CharT, _Traits>* __sbin,
     basic_streambuf<_CharT, _Traits>* __sbout,
     bool& __ineof)
    {
      streamsize __ret = 0;
      __ineof = true;
      typename _Traits::int_type __c = __sbin->sgetc();
      while (!_Traits::eq_int_type(__c, _Traits::eof()))
 {
   __c = __sbout->sputc(_Traits::to_char_type(__c));
   if (_Traits::eq_int_type(__c, _Traits::eof()))
     {
       __ineof = false;
       break;
     }
   ++__ret;
   __c = __sbin->snextc();
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    inline streamsize
    __copy_streambufs(basic_streambuf<_CharT, _Traits>* __sbin,
        basic_streambuf<_CharT, _Traits>* __sbout)
    {
      bool __ineof;
      return __copy_streambufs_eof(__sbin, __sbout, __ineof);
    }




  extern template class basic_streambuf<char>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<char>*,
        basic_streambuf<char>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<char>*,
     basic_streambuf<char>*, bool&);


  extern template class basic_streambuf<wchar_t>;
  extern template
    streamsize
    __copy_streambufs(basic_streambuf<wchar_t>*,
        basic_streambuf<wchar_t>*);
  extern template
    streamsize
    __copy_streambufs_eof(basic_streambuf<wchar_t>*,
     basic_streambuf<wchar_t>*, bool&);




}
# 851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/streambuf" 2 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
# 50 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 1 3
# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 3
#pragma pack(push,_CRT_PACKING)


extern "C" {
# 166 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/wctype.h" 3
  typedef wchar_t wctrans_t;
  wint_t __attribute__((__cdecl__)) towctrans(wint_t,wctrans_t);
  wctrans_t __attribute__((__cdecl__)) wctrans(const char *);
  wctype_t __attribute__((__cdecl__)) wctype(const char *);


}


#pragma pack(pop)
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 2 3
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cwctype" 3
namespace std
{
  using ::wctrans_t;
  using ::wctype_t;
  using ::wint_t;

  using ::iswalnum;
  using ::iswalpha;

  using ::iswblank;

  using ::iswcntrl;
  using ::iswctype;
  using ::iswdigit;
  using ::iswgraph;
  using ::iswlower;
  using ::iswprint;
  using ::iswpunct;
  using ::iswspace;
  using ::iswupper;
  using ::iswxdigit;
  using ::towctrans;
  using ::towlower;
  using ::towupper;
  using ::wctrans;
  using ::wctype;
}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cctype" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_base.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_base.h" 3
namespace std
{



  struct ctype_base
  {

    typedef const int* __to_type;



    typedef unsigned short mask;
    static const mask upper = 1 << 0;
    static const mask lower = 1 << 1;
    static const mask alpha = 1 << 2;
    static const mask digit = 1 << 3;
    static const mask xdigit = 1 << 4;
    static const mask space = 1 << 5;
    static const mask print = 1 << 6;
    static const mask graph = (1 << 2) | (1 << 3) | (1 << 9);
    static const mask cntrl = 1 << 8;
    static const mask punct = 1 << 9;
    static const mask alnum = (1 << 2) | (1 << 3);

    static const mask blank = 1 << 10;

  };


}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3




namespace std
{

# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/streambuf_iterator.h" 3
  template<typename _CharT, typename _Traits>
    class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT, typename _Traits::off_type,
                      _CharT*,


        _CharT>



    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef typename _Traits::int_type int_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_istream<_CharT, _Traits> istream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

      template<bool _IsMove, typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
            _CharT2*>::__type
 __copy_move_a2(istreambuf_iterator<_CharT2>,
         istreambuf_iterator<_CharT2>, _CharT2*);

      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
               istreambuf_iterator<_CharT2> >::__type
 find(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      const _CharT2&);

    private:







      mutable streambuf_type* _M_sbuf;
      mutable int_type _M_c;

    public:

      constexpr istreambuf_iterator() noexcept
      : _M_sbuf(0), _M_c(traits_type::eof()) { }


      istreambuf_iterator(const istreambuf_iterator&) noexcept = default;

      ~istreambuf_iterator() = default;



      istreambuf_iterator(istream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_c(traits_type::eof()) { }


      istreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_c(traits_type::eof()) { }




      char_type
      operator*() const
      {







 return traits_type::to_char_type(_M_get());
      }


      istreambuf_iterator&
      operator++()
      {


                        ;
 if (_M_sbuf)
   {
     _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return *this;
      }


      istreambuf_iterator
      operator++(int)
      {


                        ;

 istreambuf_iterator __old = *this;
 if (_M_sbuf)
   {
     __old._M_c = _M_sbuf->sbumpc();
     _M_c = traits_type::eof();
   }
 return __old;
      }





      bool
      equal(const istreambuf_iterator& __b) const
      { return _M_at_eof() == __b._M_at_eof(); }

    private:
      int_type
      _M_get() const
      {
 const int_type __eof = traits_type::eof();
 int_type __ret = __eof;
 if (_M_sbuf)
   {
     if (!traits_type::eq_int_type(_M_c, __eof))
       __ret = _M_c;
     else if (!traits_type::eq_int_type((__ret = _M_sbuf->sgetc()),
            __eof))
       _M_c = __ret;
     else
       _M_sbuf = 0;
   }
 return __ret;
      }

      bool
      _M_at_eof() const
      {
 const int_type __eof = traits_type::eof();
 return traits_type::eq_int_type(_M_get(), __eof);
      }
    };

  template<typename _CharT, typename _Traits>
    inline bool
    operator==(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return __a.equal(__b); }

  template<typename _CharT, typename _Traits>
    inline bool
    operator!=(const istreambuf_iterator<_CharT, _Traits>& __a,
        const istreambuf_iterator<_CharT, _Traits>& __b)
    { return !__a.equal(__b); }


  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    public:



      typedef _CharT char_type;
      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> streambuf_type;
      typedef basic_ostream<_CharT, _Traits> ostream_type;


      template<typename _CharT2>
 friend typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value,
                      ostreambuf_iterator<_CharT2> >::__type
 copy(istreambuf_iterator<_CharT2>, istreambuf_iterator<_CharT2>,
      ostreambuf_iterator<_CharT2>);

    private:
      streambuf_type* _M_sbuf;
      bool _M_failed;

    public:

      ostreambuf_iterator(ostream_type& __s) noexcept
      : _M_sbuf(__s.rdbuf()), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator(streambuf_type* __s) noexcept
      : _M_sbuf(__s), _M_failed(!_M_sbuf) { }


      ostreambuf_iterator&
      operator=(_CharT __c)
      {
 if (!_M_failed &&
     _Traits::eq_int_type(_M_sbuf->sputc(__c), _Traits::eof()))
   _M_failed = true;
 return *this;
      }


      ostreambuf_iterator&
      operator*()
      { return *this; }


      ostreambuf_iterator&
      operator++(int)
      { return *this; }


      ostreambuf_iterator&
      operator++()
      { return *this; }


      bool
      failed() const noexcept
      { return _M_failed; }

      ostreambuf_iterator&
      _M_put(const _CharT* __ws, streamsize __len)
      {
 if (__builtin_expect(!_M_failed, true)
     && __builtin_expect(this->_M_sbuf->sputn(__ws, __len) != __len,
    false))
   _M_failed = true;
 return *this;
      }
    };


  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
                           ostreambuf_iterator<_CharT> >::__type
    copy(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last,
  ostreambuf_iterator<_CharT> __result)
    {
      if (__first._M_sbuf && !__last._M_sbuf && !__result._M_failed)
 {
   bool __ineof;
   __copy_streambufs_eof(__first._M_sbuf, __result._M_sbuf, __ineof);
   if (!__ineof)
     __result._M_failed = true;
 }
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(_CharT* __first, _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        ostreambuf_iterator<_CharT> >::__type
    __copy_move_a2(const _CharT* __first, const _CharT* __last,
     ostreambuf_iterator<_CharT> __result)
    {
      const streamsize __num = __last - __first;
      if (__num > 0)
 __result._M_put(__first, __num);
      return __result;
    }

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
            _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT> __first,
     istreambuf_iterator<_CharT> __last, _CharT* __result)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof()))
     {
       const streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    traits_type::copy(__result, __sb->gptr(), __n);
    __sb->__safe_gbump(__n);
    __result += __n;
    __c = __sb->underflow();
  }
       else
  {
    *__result++ = traits_type::to_char_type(__c);
    __c = __sb->snextc();
  }
     }
 }
      return __result;
    }

  template<typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
          istreambuf_iterator<_CharT> >::__type
    find(istreambuf_iterator<_CharT> __first,
  istreambuf_iterator<_CharT> __last, const _CharT& __val)
    {
      typedef istreambuf_iterator<_CharT> __is_iterator_type;
      typedef typename __is_iterator_type::traits_type traits_type;
      typedef typename __is_iterator_type::streambuf_type streambuf_type;
      typedef typename traits_type::int_type int_type;

      if (__first._M_sbuf && !__last._M_sbuf)
 {
   const int_type __ival = traits_type::to_int_type(__val);
   streambuf_type* __sb = __first._M_sbuf;
   int_type __c = __sb->sgetc();
   while (!traits_type::eq_int_type(__c, traits_type::eof())
   && !traits_type::eq_int_type(__c, __ival))
     {
       streamsize __n = __sb->egptr() - __sb->gptr();
       if (__n > 1)
  {
    const _CharT* __p = traits_type::find(__sb->gptr(),
       __n, __val);
    if (__p)
      __n = __p - __sb->gptr();
    __sb->__safe_gbump(__n);
    __c = __sb->sgetc();
  }
       else
  __c = __sb->snextc();
     }

   if (!traits_type::eq_int_type(__c, traits_type::eof()))
     __first._M_c = __c;
   else
     __first._M_sbuf = 0;
 }
      return __first;
    }




}
# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3

namespace std
{

# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _Tp>
    void
    __convert_to_v(const char*, _Tp&, ios_base::iostate&,
     const __c_locale&) throw();


  template<>
    void
    __convert_to_v(const char*, float&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, double&, ios_base::iostate&,
     const __c_locale&) throw();

  template<>
    void
    __convert_to_v(const char*, long double&, ios_base::iostate&,
     const __c_locale&) throw();



  template<typename _CharT, typename _Traits>
    struct __pad
    {
      static void
      _S_pad(ios_base& __io, _CharT __fill, _CharT* __news,
      const _CharT* __olds, streamsize __newlen, streamsize __oldlen);
    };






  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last);




  template<typename _CharT>
    inline
    ostreambuf_iterator<_CharT>
    __write(ostreambuf_iterator<_CharT> __s, const _CharT* __ws, int __len)
    {
      __s._M_put(__ws, __len);
      return __s;
    }


  template<typename _CharT, typename _OutIter>
    inline
    _OutIter
    __write(_OutIter __s, const _CharT* __ws, int __len)
    {
      for (int __j = 0; __j < __len; __j++, ++__s)
 *__s = __ws[__j];
      return __s;
    }
# 149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class __ctype_abstract_base : public locale::facet, public ctype_base
    {
    public:


      typedef _CharT char_type;
# 168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      bool
      is(mask __m, char_type __c) const
      { return this->do_is(__m, __c); }
# 185 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      is(const char_type *__lo, const char_type *__hi, mask *__vec) const
      { return this->do_is(__lo, __hi, __vec); }
# 201 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_is(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_is(__m, __lo, __hi); }
# 217 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      scan_not(mask __m, const char_type* __lo, const char_type* __hi) const
      { return this->do_scan_not(__m, __lo, __hi); }
# 231 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 246 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 260 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 275 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      { return this->do_widen(__c); }
# 311 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      { return this->do_widen(__lo, __hi, __to); }
# 330 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return this->do_narrow(__c, __dfault); }
# 352 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
       char __dfault, char* __to) const
      { return this->do_narrow(__lo, __hi, __dfault, __to); }

    protected:
      explicit
      __ctype_abstract_base(size_t __refs = 0): facet(__refs) { }

      virtual
      ~__ctype_abstract_base() { }
# 377 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const = 0;
# 396 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi,
     mask* __vec) const = 0;
# 415 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo,
   const char_type* __hi) const = 0;
# 434 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const = 0;
# 452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const = 0;
# 469 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const = 0;
# 485 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const = 0;
# 502 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const = 0;
# 521 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const = 0;
# 542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const = 0;
# 563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const = 0;
# 588 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const = 0;
    };
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class ctype : public __ctype_abstract_base<_CharT>
    {
    public:

      typedef _CharT char_type;
      typedef typename __ctype_abstract_base<_CharT>::mask mask;


      static locale::id id;

      explicit
      ctype(size_t __refs = 0) : __ctype_abstract_base<_CharT>(__refs) { }

   protected:
      virtual
      ~ctype();

      virtual bool
      do_is(mask __m, char_type __c) const;

      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;

      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;

      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;

      virtual char_type
      do_toupper(char_type __c) const;

      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_tolower(char_type __c) const;

      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;

      virtual char_type
      do_widen(char __c) const;

      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __dest) const;

      virtual char
      do_narrow(char_type, char __dfault) const;

      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;
    };

  template<typename _CharT>
    locale::id ctype<_CharT>::id;
# 680 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<char> : public locale::facet, public ctype_base
    {
    public:


      typedef char char_type;

    protected:

      __c_locale _M_c_locale_ctype;
      bool _M_del;
      __to_type _M_toupper;
      __to_type _M_tolower;
      const mask* _M_table;
      mutable char _M_widen_ok;
      mutable char _M_widen[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow[1 + static_cast<unsigned char>(-1)];
      mutable char _M_narrow_ok;


    public:

      static locale::id id;

      static const size_t table_size = 1 + static_cast<unsigned char>(-1);
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(const mask* __table = 0, bool __del = false, size_t __refs = 0);
# 730 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, const mask* __table = 0, bool __del = false,
     size_t __refs = 0);
# 743 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline bool
      is(mask __m, char __c) const;
# 758 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      is(const char* __lo, const char* __hi, mask* __vec) const;
# 772 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_is(mask __m, const char* __lo, const char* __hi) const;
# 786 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      inline const char*
      scan_not(mask __m, const char* __lo, const char* __hi) const;
# 801 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      toupper(char_type __c) const
      { return this->do_toupper(__c); }
# 818 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      toupper(char_type *__lo, const char_type* __hi) const
      { return this->do_toupper(__lo, __hi); }
# 834 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      tolower(char_type __c) const
      { return this->do_tolower(__c); }
# 851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      tolower(char_type* __lo, const char_type* __hi) const
      { return this->do_tolower(__lo, __hi); }
# 871 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      widen(char __c) const
      {
 if (_M_widen_ok)
   return _M_widen[static_cast<unsigned char>(__c)];
 this->_M_widen_init();
 return this->do_widen(__c);
      }
# 898 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char*
      widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 if (_M_widen_ok == 1)
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_widen_ok)
   _M_widen_init();
 return this->do_widen(__lo, __hi, __to);
      }
# 929 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char
      narrow(char_type __c, char __dfault) const
      {
 if (_M_narrow[static_cast<unsigned char>(__c)])
   return _M_narrow[static_cast<unsigned char>(__c)];
 const char __t = do_narrow(__c, __dfault);
 if (__t != __dfault)
   _M_narrow[static_cast<unsigned char>(__c)] = __t;
 return __t;
      }
# 962 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      const char_type*
      narrow(const char_type* __lo, const char_type* __hi,
      char __dfault, char* __to) const
      {
 if (__builtin_expect(_M_narrow_ok == 1, true))
   {
     __builtin_memcpy(__to, __lo, __hi - __lo);
     return __hi;
   }
 if (!_M_narrow_ok)
   _M_narrow_init();
 return this->do_narrow(__lo, __hi, __dfault, __to);
      }





      const mask*
      table() const throw()
      { return _M_table; }


      static const mask*
      classic_table() throw();
    protected:







      virtual
      ~ctype();
# 1011 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1028 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1044 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1061 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1081 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const
      { return __c; }
# 1104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }
# 1130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const
      { return __c; }
# 1156 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const
      {
 __builtin_memcpy(__to, __lo, __hi - __lo);
 return __hi;
      }

    private:
      void _M_narrow_init() const;
      void _M_widen_init() const;
    };
# 1181 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<>
    class ctype<wchar_t> : public __ctype_abstract_base<wchar_t>
    {
    public:


      typedef wchar_t char_type;
      typedef wctype_t __wmask_type;

    protected:
      __c_locale _M_c_locale_ctype;


      bool _M_narrow_ok;
      char _M_narrow[128];
      wint_t _M_widen[1 + static_cast<unsigned char>(-1)];


      mask _M_bit[16];
      __wmask_type _M_wmask[16];

    public:


      static locale::id id;
# 1214 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(size_t __refs = 0);
# 1225 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      ctype(__c_locale __cloc, size_t __refs = 0);

    protected:
      __wmask_type
      _M_convert_to_wmask(const mask __m) const throw();


      virtual
      ~ctype();
# 1249 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual bool
      do_is(mask __m, char_type __c) const;
# 1268 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_is(const char_type* __lo, const char_type* __hi, mask* __vec) const;
# 1286 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_is(mask __m, const char_type* __lo, const char_type* __hi) const;
# 1304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_scan_not(mask __m, const char_type* __lo,
    const char_type* __hi) const;
# 1321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_toupper(char_type __c) const;
# 1338 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_toupper(char_type* __lo, const char_type* __hi) const;
# 1354 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_tolower(char_type __c) const;
# 1371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_tolower(char_type* __lo, const char_type* __hi) const;
# 1391 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_widen(char __c) const;
# 1413 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char*
      do_widen(const char* __lo, const char* __hi, char_type* __to) const;
# 1436 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char
      do_narrow(char_type __c, char __dfault) const;
# 1462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual const char_type*
      do_narrow(const char_type* __lo, const char_type* __hi,
  char __dfault, char* __to) const;


      void
      _M_initialize_ctype() throw();
    };



  template<typename _CharT>
    class ctype_byname : public ctype<_CharT>
    {
    public:
      typedef typename ctype<_CharT>::mask mask;

      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0)
      : ctype_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~ctype_byname() { };
    };


  template<>
    class ctype_byname<char> : public ctype<char>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };


  template<>
    class ctype_byname<wchar_t> : public ctype<wchar_t>
    {
    public:
      explicit
      ctype_byname(const char* __s, size_t __refs = 0);


      explicit
      ctype_byname(const string& __s, size_t __refs = 0);


    protected:
      virtual
      ~ctype_byname();
    };



}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_inline.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/ctype_inline.h" 3
namespace std
{


  bool
  ctype<char>::
  is(mask __m, char __c) const
  { return (_M_table[static_cast<unsigned char>(__c) ] & __m); }


  const char*
  ctype<char>::
  is(const char* __low, const char* __high, mask* __vec) const
  {
    while (__low < __high)
      *__vec++ = _M_table[static_cast<unsigned char>(*__low++)];
    return __high;
  }

  const char*
  ctype<char>::
  scan_is(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && !this->is(__m, *__low))
      ++__low;
    return __low;
  }

  const char*
  ctype<char>::
  scan_not(mask __m, const char* __low, const char* __high) const
  {
    while (__low < __high && this->is(__m, *__low) != 0)
      ++__low;
    return __low;
  }


}
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3

namespace std
{



  class __num_base
  {
  public:


    enum
      {
 _S_ominus,
 _S_oplus,
 _S_ox,
 _S_oX,
 _S_odigits,
 _S_odigits_end = _S_odigits + 16,
 _S_oudigits = _S_odigits_end,
 _S_oudigits_end = _S_oudigits + 16,
 _S_oe = _S_odigits + 14,
 _S_oE = _S_oudigits + 14,
 _S_oend = _S_oudigits_end
      };






    static const char* _S_atoms_out;



    static const char* _S_atoms_in;

    enum
    {
      _S_iminus,
      _S_iplus,
      _S_ix,
      _S_iX,
      _S_izero,
      _S_ie = _S_izero + 14,
      _S_iE = _S_izero + 20,
      _S_iend = 26
    };



    static void
    _S_format_float(const ios_base& __io, char* __fptr, char __mod) throw();
  };

  template<typename _CharT>
    struct __numpunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      const _CharT* _M_truename;
      size_t _M_truename_size;
      const _CharT* _M_falsename;
      size_t _M_falsename_size;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;





      _CharT _M_atoms_out[__num_base::_S_oend];





      _CharT _M_atoms_in[__num_base::_S_iend];

      bool _M_allocated;

      __numpunct_cache(size_t __refs = 0)
      : facet(__refs), _M_grouping(0), _M_grouping_size(0),
 _M_use_grouping(false),
 _M_truename(0), _M_truename_size(0), _M_falsename(0),
 _M_falsename_size(0), _M_decimal_point(_CharT()),
 _M_thousands_sep(_CharT()), _M_allocated(false)
 { }

      ~__numpunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __numpunct_cache&
      operator=(const __numpunct_cache&);

      explicit
      __numpunct_cache(const __numpunct_cache&);
    };

  template<typename _CharT>
    __numpunct_cache<_CharT>::~__numpunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_truename;
   delete [] _M_falsename;
 }
    }

namespace __cxx11 {
# 1665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT>
    class numpunct : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __numpunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;

    public:

      static locale::id id;






      explicit
      numpunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(); }
# 1703 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_numpunct(); }
# 1717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      numpunct(__c_locale __cloc, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_numpunct(__cloc); }
# 1731 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1744 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1775 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1788 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string_type
      truename() const
      { return this->do_truename(); }
# 1801 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      string_type
      falsename() const
      { return this->do_falsename(); }

    protected:

      virtual
      ~numpunct();
# 1818 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1830 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1843 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1856 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_truename() const
      { return _M_data->_M_truename; }
# 1869 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual string_type
      do_falsename() const
      { return _M_data->_M_falsename; }


      void
      _M_initialize_numpunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id numpunct<_CharT>::id;

  template<>
    numpunct<char>::~numpunct();

  template<>
    void
    numpunct<char>::_M_initialize_numpunct(__c_locale __cloc);


  template<>
    numpunct<wchar_t>::~numpunct();

  template<>
    void
    numpunct<wchar_t>::_M_initialize_numpunct(__c_locale __cloc);



  template<typename _CharT>
    class numpunct_byname : public numpunct<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      numpunct_byname(const char* __s, size_t __refs = 0)
      : numpunct<_CharT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_numpunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      numpunct_byname(const string& __s, size_t __refs = 0)
      : numpunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~numpunct_byname() { }
    };

}


# 1947 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _InIter>
    class num_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 1968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      num_get(size_t __refs = 0) : facet(__refs) { }
# 1994 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, bool& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned short& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned int& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }


      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, unsigned long long& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2091 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, float& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, long double& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }
# 2134 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      get(iter_type __in, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, void*& __v) const
      { return this->do_get(__in, __end, __io, __err, __v); }

    protected:

      virtual ~num_get() { }

      __attribute ((__abi_tag__ ("cxx11")))
      iter_type
      _M_extract_float(iter_type, iter_type, ios_base&, ios_base::iostate&,
         string&) const;

      template<typename _ValueT>
 __attribute ((__abi_tag__ ("cxx11")))
 iter_type
 _M_extract_int(iter_type, iter_type, ios_base&, ios_base::iostate&,
         _ValueT&) const;

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<__is_char<_CharT2>::__value, int>::__type
 _M_find(const _CharT2*, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   if (__len <= 10)
     {
       if (__c >= _CharT2('0') && __c < _CharT2(_CharT2('0') + __len))
  __ret = __c - _CharT2('0');
     }
   else
     {
       if (__c >= _CharT2('0') && __c <= _CharT2('9'))
  __ret = __c - _CharT2('0');
       else if (__c >= _CharT2('a') && __c <= _CharT2('f'))
  __ret = 10 + (__c - _CharT2('a'));
       else if (__c >= _CharT2('A') && __c <= _CharT2('F'))
  __ret = 10 + (__c - _CharT2('A'));
     }
   return __ret;
 }

      template<typename _CharT2>
      typename __gnu_cxx::__enable_if<!__is_char<_CharT2>::__value,
          int>::__type
 _M_find(const _CharT2* __zero, size_t __len, _CharT2 __c) const
 {
   int __ret = -1;
   const char_type* __q = char_traits<_CharT2>::find(__zero, __len, __c);
   if (__q)
     {
       __ret = __q - __zero;
       if (__ret > 15)
  __ret -= 6;
     }
   return __ret;
 }
# 2207 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, bool&) const;

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned short& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned int& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }

      virtual iter_type
      do_get(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, unsigned long long& __v) const
      { return _M_extract_int(__beg, __end, __io, __err, __v); }


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, float&) const;

      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      double&) const;







      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&,
      long double&) const;


      virtual iter_type
      do_get(iter_type, iter_type, ios_base&, ios_base::iostate&, void*&) const;
# 2270 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
    };

  template<typename _CharT, typename _InIter>
    locale::id num_get<_CharT, _InIter>::id;
# 2288 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
  template<typename _CharT, typename _OutIter>
    class num_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 2309 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      explicit
      num_put(size_t __refs = 0) : facet(__refs) { }
# 2327 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2369 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long __v) const
      { return this->do_put(__s, __io, __fill, __v); }


      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   unsigned long long __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2432 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
      { return this->do_put(__s, __io, __fill, __v); }

      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   long double __v) const
      { return this->do_put(__s, __io, __fill, __v); }
# 2457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const void* __v) const
      { return this->do_put(__s, __io, __fill, __v); }

    protected:
      template<typename _ValueT>
 iter_type
 _M_insert_float(iter_type, ios_base& __io, char_type __fill,
   char __mod, _ValueT __v) const;

      void
      _M_group_float(const char* __grouping, size_t __grouping_size,
       char_type __sep, const char_type* __p, char_type* __new,
       char_type* __cs, int& __len) const;

      template<typename _ValueT>
 iter_type
 _M_insert_int(iter_type, ios_base& __io, char_type __fill,
        _ValueT __v) const;

      void
      _M_group_int(const char* __grouping, size_t __grouping_size,
     char_type __sep, ios_base& __io, char_type* __new,
     char_type* __cs, int& __len) const;

      void
      _M_pad(char_type __fill, streamsize __w, ios_base& __io,
      char_type* __new, const char_type* __cs, int& __len) const;


      virtual
      ~num_put() { };
# 2505 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const;

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }

      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill,
      unsigned long long __v) const
      { return _M_insert_int(__s, __io, __fill, __v); }


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, double) const;






      virtual iter_type
      do_put(iter_type, ios_base&, char_type, long double) const;


      virtual iter_type
      do_put(iter_type, ios_base&, char_type, const void*) const;







    };

  template <typename _CharT, typename _OutIter>
    locale::id num_put<_CharT, _OutIter>::id;









  template<typename _CharT>
    inline bool
    isspace(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c); }


  template<typename _CharT>
    inline bool
    isprint(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c); }


  template<typename _CharT>
    inline bool
    iscntrl(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c); }


  template<typename _CharT>
    inline bool
    isupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c); }


  template<typename _CharT>
    inline bool
    islower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c); }


  template<typename _CharT>
    inline bool
    isalpha(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c); }


  template<typename _CharT>
    inline bool
    isdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c); }


  template<typename _CharT>
    inline bool
    ispunct(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c); }


  template<typename _CharT>
    inline bool
    isxdigit(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c); }


  template<typename _CharT>
    inline bool
    isalnum(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c); }


  template<typename _CharT>
    inline bool
    isgraph(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c); }



  template<typename _CharT>
    inline bool
    isblank(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).is(ctype_base::blank, __c); }



  template<typename _CharT>
    inline _CharT
    toupper(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).toupper(__c); }


  template<typename _CharT>
    inline _CharT
    tolower(_CharT __c, const locale& __loc)
    { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }


}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3

namespace std
{




  template<typename _Facet>
    struct __use_cache
    {
      const _Facet*
      operator() (const locale& __loc) const;
    };


  template<typename _CharT>
    struct __use_cache<__numpunct_cache<_CharT> >
    {
      const __numpunct_cache<_CharT>*
      operator() (const locale& __loc) const
      {
 const size_t __i = numpunct<_CharT>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __numpunct_cache<_CharT>* __tmp = 0;
     try
       {
  __tmp = new __numpunct_cache<_CharT>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<const __numpunct_cache<_CharT>*>(__caches[__i]);
      }
    };

  template<typename _CharT>
    void
    __numpunct_cache<_CharT>::_M_cache(const locale& __loc)
    {
      const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);

      char* __grouping = 0;
      _CharT* __truename = 0;
      _CharT* __falsename = 0;
      try
 {
   const string& __g = __np.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __tn = __np.truename();
   _M_truename_size = __tn.size();
   __truename = new _CharT[_M_truename_size];
   __tn.copy(__truename, _M_truename_size);

   const basic_string<_CharT>& __fn = __np.falsename();
   _M_falsename_size = __fn.size();
   __falsename = new _CharT[_M_falsename_size];
   __fn.copy(__falsename, _M_falsename_size);

   _M_decimal_point = __np.decimal_point();
   _M_thousands_sep = __np.thousands_sep();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(__num_base::_S_atoms_out,
       __num_base::_S_atoms_out
       + __num_base::_S_oend, _M_atoms_out);
   __ct.widen(__num_base::_S_atoms_in,
       __num_base::_S_atoms_in
       + __num_base::_S_iend, _M_atoms_in);

   _M_grouping = __grouping;
   _M_truename = __truename;
   _M_falsename = __falsename;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __truename;
   delete [] __falsename;
   throw;
 }
    }
# 139 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  __attribute__ ((__pure__)) bool
  __verify_grouping(const char* __grouping, size_t __grouping_size,
      const string& __grouping_tmp) throw ();



  template<typename _CharT, typename _InIter>
    __attribute ((__abi_tag__ ("cxx11")))
    _InIter
    num_get<_CharT, _InIter>::
    _M_extract_float(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, string& __xtrc) const
    {
      typedef char_traits<_CharT> __traits_type;
      typedef __numpunct_cache<_CharT> __cache_type;
      __use_cache<__cache_type> __uc;
      const locale& __loc = __io._M_getloc();
      const __cache_type* __lc = __uc(__loc);
      const _CharT* __lit = __lc->_M_atoms_in;
      char_type __c = char_type();


      bool __testeof = __beg == __end;


      if (!__testeof)
 {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
     {
       __xtrc += __plus ? '+' : '-';
       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 }


      bool __found_mantissa = false;
      int __sep_pos = 0;
      while (!__testeof)
 {
   if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       || __c == __lc->_M_decimal_point)
     break;
   else if (__c == __lit[__num_base::_S_izero])
     {
       if (!__found_mantissa)
  {
    __xtrc += '0';
    __found_mantissa = true;
  }
       ++__sep_pos;

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
   else
     break;
 }


      bool __found_dec = false;
      bool __found_sci = false;
      string __found_grouping;
      if (__lc->_M_use_grouping)
 __found_grouping.reserve(32);
      const char_type* __lit_zero = __lit + __num_base::_S_izero;

      if (!__lc->_M_allocated)

 while (!__testeof)
   {
     const int __digit = _M_find(__lit_zero, 10, __c);
     if (__digit != -1)
       {
  __xtrc += '0' + __digit;
  __found_mantissa = true;
       }
     else if (__c == __lc->_M_decimal_point
       && !__found_dec && !__found_sci)
       {
  __xtrc += '.';
  __found_dec = true;
       }
     else if ((__c == __lit[__num_base::_S_ie]
        || __c == __lit[__num_base::_S_iE])
       && !__found_sci && __found_mantissa)
       {

  __xtrc += 'e';
  __found_sci = true;


  if (++__beg != __end)
    {
      __c = *__beg;
      const bool __plus = __c == __lit[__num_base::_S_iplus];
      if (__plus || __c == __lit[__num_base::_S_iminus])
        __xtrc += __plus ? '+' : '-';
      else
        continue;
    }
  else
    {
      __testeof = true;
      break;
    }
       }
     else
       break;

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }
      else
 while (!__testeof)
   {


     if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
       {
  if (!__found_dec && !__found_sci)
    {


      if (__sep_pos)
        {
   __found_grouping += static_cast<char>(__sep_pos);
   __sep_pos = 0;
        }
      else
        {


   __xtrc.clear();
   break;
        }
    }
  else
    break;
       }
     else if (__c == __lc->_M_decimal_point)
       {
  if (!__found_dec && !__found_sci)
    {



      if (__found_grouping.size())
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += '.';
      __found_dec = true;
    }
  else
    break;
       }
     else
       {
  const char_type* __q =
    __traits_type::find(__lit_zero, 10, __c);
  if (__q)
    {
      __xtrc += '0' + (__q - __lit_zero);
      __found_mantissa = true;
      ++__sep_pos;
    }
  else if ((__c == __lit[__num_base::_S_ie]
     || __c == __lit[__num_base::_S_iE])
    && !__found_sci && __found_mantissa)
    {

      if (__found_grouping.size() && !__found_dec)
        __found_grouping += static_cast<char>(__sep_pos);
      __xtrc += 'e';
      __found_sci = true;


      if (++__beg != __end)
        {
   __c = *__beg;
   const bool __plus = __c == __lit[__num_base::_S_iplus];
   if ((__plus || __c == __lit[__num_base::_S_iminus])
       && !(__lc->_M_use_grouping
     && __c == __lc->_M_thousands_sep)
       && !(__c == __lc->_M_decimal_point))
        __xtrc += __plus ? '+' : '-';
   else
     continue;
        }
      else
        {
   __testeof = true;
   break;
        }
    }
  else
    break;
       }

     if (++__beg != __end)
       __c = *__beg;
     else
       __testeof = true;
   }



      if (__found_grouping.size())
        {

   if (!__found_dec && !__found_sci)
     __found_grouping += static_cast<char>(__sep_pos);

          if (!std::__verify_grouping(__lc->_M_grouping,
          __lc->_M_grouping_size,
          __found_grouping))
     __err = ios_base::failbit;
        }

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    template<typename _ValueT>
      __attribute ((__abi_tag__ ("cxx11")))
      _InIter
      num_get<_CharT, _InIter>::
      _M_extract_int(_InIter __beg, _InIter __end, ios_base& __io,
       ios_base::iostate& __err, _ValueT& __v) const
      {
        typedef char_traits<_CharT> __traits_type;
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_in;
 char_type __c = char_type();


 const ios_base::fmtflags __basefield = __io.flags()
                                        & ios_base::basefield;
 const bool __oct = __basefield == ios_base::oct;
 int __base = __oct ? 8 : (__basefield == ios_base::hex ? 16 : 10);


 bool __testeof = __beg == __end;


 bool __negative = false;
 if (!__testeof)
   {
     __c = *__beg;
     __negative = __c == __lit[__num_base::_S_iminus];
     if ((__negative || __c == __lit[__num_base::_S_iplus])
  && !(__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  && !(__c == __lc->_M_decimal_point))
       {
  if (++__beg != __end)
    __c = *__beg;
  else
    __testeof = true;
       }
   }



 bool __found_zero = false;
 int __sep_pos = 0;
 while (!__testeof)
   {
     if ((__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  || __c == __lc->_M_decimal_point)
       break;
     else if (__c == __lit[__num_base::_S_izero]
       && (!__found_zero || __base == 10))
       {
  __found_zero = true;
  ++__sep_pos;
  if (__basefield == 0)
    __base = 8;
  if (__base == 8)
    __sep_pos = 0;
       }
     else if (__found_zero
       && (__c == __lit[__num_base::_S_ix]
    || __c == __lit[__num_base::_S_iX]))
       {
  if (__basefield == 0)
    __base = 16;
  if (__base == 16)
    {
      __found_zero = false;
      __sep_pos = 0;
    }
  else
    break;
       }
     else
       break;

     if (++__beg != __end)
       {
  __c = *__beg;
  if (!__found_zero)
    break;
       }
     else
       __testeof = true;
   }



 const size_t __len = (__base == 16 ? __num_base::_S_iend
         - __num_base::_S_izero : __base);


 string __found_grouping;
 if (__lc->_M_use_grouping)
   __found_grouping.reserve(32);
 bool __testfail = false;
 bool __testoverflow = false;
 const __unsigned_type __max =
   (__negative && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
   ? -__gnu_cxx::__numeric_traits<_ValueT>::__min
   : __gnu_cxx::__numeric_traits<_ValueT>::__max;
 const __unsigned_type __smax = __max / __base;
 __unsigned_type __result = 0;
 int __digit = 0;
 const char_type* __lit_zero = __lit + __num_base::_S_izero;

 if (!__lc->_M_allocated)

   while (!__testeof)
     {
       __digit = _M_find(__lit_zero, __len, __c);
       if (__digit == -1)
  break;

       if (__result > __smax)
  __testoverflow = true;
       else
  {
    __result *= __base;
    __testoverflow |= __result > __max - __digit;
    __result += __digit;
    ++__sep_pos;
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }
 else
   while (!__testeof)
     {


       if (__lc->_M_use_grouping && __c == __lc->_M_thousands_sep)
  {


    if (__sep_pos)
      {
        __found_grouping += static_cast<char>(__sep_pos);
        __sep_pos = 0;
      }
    else
      {
        __testfail = true;
        break;
      }
  }
       else if (__c == __lc->_M_decimal_point)
  break;
       else
  {
    const char_type* __q =
      __traits_type::find(__lit_zero, __len, __c);
    if (!__q)
      break;

    __digit = __q - __lit_zero;
    if (__digit > 15)
      __digit -= 6;
    if (__result > __smax)
      __testoverflow = true;
    else
      {
        __result *= __base;
        __testoverflow |= __result > __max - __digit;
        __result += __digit;
        ++__sep_pos;
      }
  }

       if (++__beg != __end)
  __c = *__beg;
       else
  __testeof = true;
     }



 if (__found_grouping.size())
   {

     __found_grouping += static_cast<char>(__sep_pos);

     if (!std::__verify_grouping(__lc->_M_grouping,
     __lc->_M_grouping_size,
     __found_grouping))
       __err = ios_base::failbit;
   }



 if ((!__sep_pos && !__found_zero && !__found_grouping.size())
     || __testfail)
   {
     __v = 0;
     __err = ios_base::failbit;
   }
 else if (__testoverflow)
   {
     if (__negative
  && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__min;
     else
       __v = __gnu_cxx::__numeric_traits<_ValueT>::__max;
     __err = ios_base::failbit;
   }
 else
   __v = __negative ? -__result : __result;

 if (__testeof)
   __err |= ios_base::eofbit;
 return __beg;
      }



  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, bool& __v) const
    {
      if (!(__io.flags() & ios_base::boolalpha))
        {



   long __l = -1;
          __beg = _M_extract_int(__beg, __end, __io, __err, __l);
   if (__l == 0 || __l == 1)
     __v = bool(__l);
   else
     {


       __v = true;
       __err = ios_base::failbit;
       if (__beg == __end)
  __err |= ios_base::eofbit;
     }
        }
      else
        {

   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   bool __testf = true;
   bool __testt = true;
   bool __donef = __lc->_M_falsename_size == 0;
   bool __donet = __lc->_M_truename_size == 0;
   bool __testeof = false;
   size_t __n = 0;
   while (!__donef || !__donet)
     {
       if (__beg == __end)
  {
    __testeof = true;
    break;
  }

       const char_type __c = *__beg;

       if (!__donef)
  __testf = __c == __lc->_M_falsename[__n];

       if (!__testf && __donet)
  break;

       if (!__donet)
  __testt = __c == __lc->_M_truename[__n];

       if (!__testt && __donef)
  break;

       if (!__testt && !__testf)
  break;

       ++__n;
       ++__beg;

       __donef = !__testf || __n >= __lc->_M_falsename_size;
       __donet = !__testt || __n >= __lc->_M_truename_size;
     }
   if (__testf && __n == __lc->_M_falsename_size && __n)
     {
       __v = false;
       if (__testt && __n == __lc->_M_truename_size)
  __err = ios_base::failbit;
       else
  __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else if (__testt && __n == __lc->_M_truename_size && __n)
     {
       __v = true;
       __err = __testeof ? ios_base::eofbit : ios_base::goodbit;
     }
   else
     {


       __v = false;
       __err = ios_base::failbit;
       if (__testeof)
  __err |= ios_base::eofbit;
     }
 }
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, float& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }
# 735 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, long double& __v) const
    {
      string __xtrc;
      __xtrc.reserve(32);
      __beg = _M_extract_float(__beg, __end, __io, __err, __xtrc);
      std::__convert_to_v(__xtrc.c_str(), __v, __err, _S_get_c_locale());
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    num_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, void*& __v) const
    {

      typedef ios_base::fmtflags fmtflags;
      const fmtflags __fmt = __io.flags();
      __io.flags((__fmt & ~ios_base::basefield) | ios_base::hex);

      typedef __gnu_cxx::__conditional_type<(sizeof(void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      _UIntPtrType __ul;
      __beg = _M_extract_int(__beg, __end, __io, __err, __ul);


      __io.flags(__fmt);

      __v = reinterpret_cast<void*>(__ul);
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_pad(_CharT __fill, streamsize __w, ios_base& __io,
    _CharT* __new, const _CharT* __cs, int& __len) const
    {


      __pad<_CharT, char_traits<_CharT> >::_S_pad(__io, __fill, __new,
        __cs, __w, __len);
      __len = static_cast<int>(__w);
    }



  template<typename _CharT, typename _ValueT>
    int
    __int_to_char(_CharT* __bufend, _ValueT __v, const _CharT* __lit,
    ios_base::fmtflags __flags, bool __dec)
    {
      _CharT* __buf = __bufend;
      if (__builtin_expect(__dec, true))
 {

   do
     {
       *--__buf = __lit[(__v % 10) + __num_base::_S_odigits];
       __v /= 10;
     }
   while (__v != 0);
 }
      else if ((__flags & ios_base::basefield) == ios_base::oct)
 {

   do
     {
       *--__buf = __lit[(__v & 0x7) + __num_base::_S_odigits];
       __v >>= 3;
     }
   while (__v != 0);
 }
      else
 {

   const bool __uppercase = __flags & ios_base::uppercase;
   const int __case_offset = __uppercase ? __num_base::_S_oudigits
                                         : __num_base::_S_odigits;
   do
     {
       *--__buf = __lit[(__v & 0xf) + __case_offset];
       __v >>= 4;
     }
   while (__v != 0);
 }
      return __bufend - __buf;
    }



  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_int(const char* __grouping, size_t __grouping_size, _CharT __sep,
   ios_base&, _CharT* __new, _CharT* __cs, int& __len) const
    {
      _CharT* __p = std::__add_grouping(__new, __sep, __grouping,
     __grouping_size, __cs, __cs + __len);
      __len = __p - __new;
    }

  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_int(_OutIter __s, ios_base& __io, _CharT __fill,
      _ValueT __v) const
      {
 using __gnu_cxx::__add_unsigned;
 typedef typename __add_unsigned<_ValueT>::__type __unsigned_type;
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);
 const _CharT* __lit = __lc->_M_atoms_out;
 const ios_base::fmtflags __flags = __io.flags();


 const int __ilen = 5 * sizeof(_ValueT);
 _CharT* __cs = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __ilen));



 const ios_base::fmtflags __basefield = __flags & ios_base::basefield;
 const bool __dec = (__basefield != ios_base::oct
       && __basefield != ios_base::hex);
 const __unsigned_type __u = ((__v > 0 || !__dec)
         ? __unsigned_type(__v)
         : -__unsigned_type(__v));
  int __len = __int_to_char(__cs + __ilen, __u, __lit, __flags, __dec);
 __cs += __ilen - __len;


 if (__lc->_M_use_grouping)
   {


     _CharT* __cs2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * (__len + 1)
          * 2));
     _M_group_int(__lc->_M_grouping, __lc->_M_grouping_size,
    __lc->_M_thousands_sep, __io, __cs2 + 2, __cs, __len);
     __cs = __cs2 + 2;
   }


 if (__builtin_expect(__dec, true))
   {

     if (__v >= 0)
       {
  if (bool(__flags & ios_base::showpos)
      && __gnu_cxx::__numeric_traits<_ValueT>::__is_signed)
    *--__cs = __lit[__num_base::_S_oplus], ++__len;
       }
     else
       *--__cs = __lit[__num_base::_S_ominus], ++__len;
   }
 else if (bool(__flags & ios_base::showbase) && __v)
   {
     if (__basefield == ios_base::oct)
       *--__cs = __lit[__num_base::_S_odigits], ++__len;
     else
       {

  const bool __uppercase = __flags & ios_base::uppercase;
  *--__cs = __lit[__num_base::_S_ox + __uppercase];

  *--__cs = __lit[__num_base::_S_odigits];
  __len += 2;
       }
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __cs3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __cs3, __cs, __len);
     __cs = __cs3;
   }
 __io.width(0);



 return std::__write(__s, __cs, __len);
      }

  template<typename _CharT, typename _OutIter>
    void
    num_put<_CharT, _OutIter>::
    _M_group_float(const char* __grouping, size_t __grouping_size,
     _CharT __sep, const _CharT* __p, _CharT* __new,
     _CharT* __cs, int& __len) const
    {



      const int __declen = __p ? __p - __cs : __len;
      _CharT* __p2 = std::__add_grouping(__new, __sep, __grouping,
      __grouping_size,
      __cs, __cs + __declen);


      int __newlen = __p2 - __new;
      if (__p)
 {
   char_traits<_CharT>::copy(__p2, __p, __len - __declen);
   __newlen += __len - __declen;
 }
      __len = __newlen;
    }
# 971 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    template<typename _ValueT>
      _OutIter
      num_put<_CharT, _OutIter>::
      _M_insert_float(_OutIter __s, ios_base& __io, _CharT __fill, char __mod,
         _ValueT __v) const
      {
 typedef __numpunct_cache<_CharT> __cache_type;
 __use_cache<__cache_type> __uc;
 const locale& __loc = __io._M_getloc();
 const __cache_type* __lc = __uc(__loc);


 const streamsize __prec = __io.precision() < 0 ? 6 : __io.precision();

 const int __max_digits =
   __gnu_cxx::__numeric_traits<_ValueT>::__digits10;


 int __len;

 char __fbuf[16];
 __num_base::_S_format_float(__io, __fbuf, __mod);



 const bool __use_prec =
   (__io.flags() & ios_base::floatfield) != ios_base::floatfield;



 int __cs_size = __max_digits * 3;
 char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));
 if (__use_prec)
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __prec, __v);
 else
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     __fbuf, __v);


 if (__len >= __cs_size)
   {
     __cs_size = __len + 1;
     __cs = static_cast<char*>(__builtin_alloca(__cs_size));
     if (__use_prec)
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __prec, __v);
     else
       __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
         __fbuf, __v);
   }
# 1044 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
            * __len));
 __ctype.widen(__cs, __cs + __len, __ws);


 _CharT* __wp = 0;
 const char* __p = char_traits<char>::find(__cs, __len, '.');
 if (__p)
   {
     __wp = __ws + (__p - __cs);
     *__wp = __lc->_M_decimal_point;
   }




 if (__lc->_M_use_grouping
     && (__wp || __len < 3 || (__cs[1] <= '9' && __cs[2] <= '9'
          && __cs[1] >= '0' && __cs[2] >= '0')))
   {


     _CharT* __ws2 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __len * 2));

     streamsize __off = 0;
     if (__cs[0] == '-' || __cs[0] == '+')
       {
  __off = 1;
  __ws2[0] = __ws[0];
  __len -= 1;
       }

     _M_group_float(__lc->_M_grouping, __lc->_M_grouping_size,
      __lc->_M_thousands_sep, __wp, __ws2 + __off,
      __ws + __off, __len);
     __len += __off;

     __ws = __ws2;
   }


 const streamsize __w = __io.width();
 if (__w > static_cast<streamsize>(__len))
   {
     _CharT* __ws3 = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
          * __w));
     _M_pad(__fill, __w, __io, __ws3, __ws, __len);
     __ws = __ws3;
   }
 __io.width(0);



 return std::__write(__s, __ws, __len);
      }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, bool __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      if ((__flags & ios_base::boolalpha) == 0)
        {
          const long __l = __v;
          __s = _M_insert_int(__s, __io, __fill, __l);
        }
      else
        {
   typedef __numpunct_cache<_CharT> __cache_type;
   __use_cache<__cache_type> __uc;
   const locale& __loc = __io._M_getloc();
   const __cache_type* __lc = __uc(__loc);

   const _CharT* __name = __v ? __lc->_M_truename
                              : __lc->_M_falsename;
   int __len = __v ? __lc->_M_truename_size
                   : __lc->_M_falsename_size;

   const streamsize __w = __io.width();
   if (__w > static_cast<streamsize>(__len))
     {
       const streamsize __plen = __w - __len;
       _CharT* __ps
  = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT)
       * __plen));

       char_traits<_CharT>::assign(__ps, __plen, __fill);
       __io.width(0);

       if ((__flags & ios_base::adjustfield) == ios_base::left)
  {
    __s = std::__write(__s, __name, __len);
    __s = std::__write(__s, __ps, __plen);
  }
       else
  {
    __s = std::__write(__s, __ps, __plen);
    __s = std::__write(__s, __name, __len);
  }
       return __s;
     }
   __io.width(0);
   __s = std::__write(__s, __name, __len);
 }
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill, double __v) const
    { return _M_insert_float(__s, __io, __fill, char(), __v); }
# 1169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
    long double __v) const
    { return _M_insert_float(__s, __io, __fill, 'L', __v); }

  template<typename _CharT, typename _OutIter>
    _OutIter
    num_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type __fill,
           const void* __v) const
    {
      const ios_base::fmtflags __flags = __io.flags();
      const ios_base::fmtflags __fmt = ~(ios_base::basefield
      | ios_base::uppercase);
      __io.flags((__flags & __fmt) | (ios_base::hex | ios_base::showbase));

      typedef __gnu_cxx::__conditional_type<(sizeof(const void*)
          <= sizeof(unsigned long)),
 unsigned long, unsigned long long>::__type _UIntPtrType;

      __s = _M_insert_int(__s, __io, __fill,
     reinterpret_cast<_UIntPtrType>(__v));
      __io.flags(__flags);
      return __s;
    }


# 1206 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.tcc" 3
  template<typename _CharT, typename _Traits>
    void
    __pad<_CharT, _Traits>::_S_pad(ios_base& __io, _CharT __fill,
       _CharT* __news, const _CharT* __olds,
       streamsize __newlen, streamsize __oldlen)
    {
      const size_t __plen = static_cast<size_t>(__newlen - __oldlen);
      const ios_base::fmtflags __adjust = __io.flags() & ios_base::adjustfield;


      if (__adjust == ios_base::left)
 {
   _Traits::copy(__news, __olds, __oldlen);
   _Traits::assign(__news + __oldlen, __plen, __fill);
   return;
 }

      size_t __mod = 0;
      if (__adjust == ios_base::internal)
 {



          const locale& __loc = __io._M_getloc();
   const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

   if (__ctype.widen('-') == __olds[0]
       || __ctype.widen('+') == __olds[0])
     {
       __news[0] = __olds[0];
       __mod = 1;
       ++__news;
     }
   else if (__ctype.widen('0') == __olds[0]
     && __oldlen > 1
     && (__ctype.widen('x') == __olds[1]
         || __ctype.widen('X') == __olds[1]))
     {
       __news[0] = __olds[0];
       __news[1] = __olds[1];
       __mod = 2;
       __news += 2;
     }

 }
      _Traits::assign(__news, __plen, __fill);
      _Traits::copy(__news + __plen, __olds + __mod, __oldlen - __mod);
    }

  template<typename _CharT>
    _CharT*
    __add_grouping(_CharT* __s, _CharT __sep,
     const char* __gbeg, size_t __gsize,
     const _CharT* __first, const _CharT* __last)
    {
      size_t __idx = 0;
      size_t __ctr = 0;

      while (__last - __first > __gbeg[__idx]
      && static_cast<signed char>(__gbeg[__idx]) > 0
      && __gbeg[__idx] != __gnu_cxx::__numeric_traits<char>::__max)
 {
   __last -= __gbeg[__idx];
   __idx < __gsize - 1 ? ++__idx : ++__ctr;
 }

      while (__first != __last)
 *__s++ = *__first++;

      while (__ctr--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      while (__idx--)
 {
   *__s++ = __sep;
   for (char __i = __gbeg[__idx]; __i > 0; --__i)
     *__s++ = *__first++;
 }

      return __s;
    }




  extern template class __cxx11:: numpunct<char>;
  extern template class __cxx11:: numpunct_byname<char>;
  extern template class num_get<char>;
  extern template class num_put<char>;
  extern template class ctype_byname<char>;

  extern template
    const ctype<char>&
    use_facet<ctype<char> >(const locale&);

  extern template
    const numpunct<char>&
    use_facet<numpunct<char> >(const locale&);

  extern template
    const num_put<char>&
    use_facet<num_put<char> >(const locale&);

  extern template
    const num_get<char>&
    use_facet<num_get<char> >(const locale&);

  extern template
    bool
    has_facet<ctype<char> >(const locale&);

  extern template
    bool
    has_facet<numpunct<char> >(const locale&);

  extern template
    bool
    has_facet<num_put<char> >(const locale&);

  extern template
    bool
    has_facet<num_get<char> >(const locale&);


  extern template class __cxx11:: numpunct<wchar_t>;
  extern template class __cxx11:: numpunct_byname<wchar_t>;
  extern template class num_get<wchar_t>;
  extern template class num_put<wchar_t>;
  extern template class ctype_byname<wchar_t>;

  extern template
    const ctype<wchar_t>&
    use_facet<ctype<wchar_t> >(const locale&);

  extern template
    const numpunct<wchar_t>&
    use_facet<numpunct<wchar_t> >(const locale&);

  extern template
    const num_put<wchar_t>&
    use_facet<num_put<wchar_t> >(const locale&);

  extern template
    const num_get<wchar_t>&
    use_facet<num_get<wchar_t> >(const locale&);

 extern template
    bool
    has_facet<ctype<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<numpunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<num_get<wchar_t> >(const locale&);




}
# 2652 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets.h" 2 3
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 2 3



namespace std
{


  template<typename _Facet>
    inline const _Facet&
    __check_facet(const _Facet* __f)
    {
      if (!__f)
 __throw_bad_cast();
      return *__f;
    }
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
  template<typename _CharT, typename _Traits>
    class basic_ios : public ios_base
    {
    public:






      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;






      typedef ctype<_CharT> __ctype_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
           __num_put_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
           __num_get_type;



    protected:
      basic_ostream<_CharT, _Traits>* _M_tie;
      mutable char_type _M_fill;
      mutable bool _M_fill_init;
      basic_streambuf<_CharT, _Traits>* _M_streambuf;


      const __ctype_type* _M_ctype;

      const __num_put_type* _M_num_put;

      const __num_get_type* _M_num_get;

    public:
# 117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      explicit operator bool() const
      { return !this->fail(); }





      bool
      operator!() const
      { return this->fail(); }
# 136 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      iostate
      rdstate() const
      { return _M_streambuf_state; }
# 147 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      void
      clear(iostate __state = goodbit);







      void
      setstate(iostate __state)
      { this->clear(this->rdstate() | __state); }




      void
      _M_setstate(iostate __state)
      {


 _M_streambuf_state |= __state;
 if (this->exceptions() & __state)
   throw;
      }







      bool
      good() const
      { return this->rdstate() == 0; }







      bool
      eof() const
      { return (this->rdstate() & eofbit) != 0; }
# 200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      bool
      fail() const
      { return (this->rdstate() & (badbit | failbit)) != 0; }







      bool
      bad() const
      { return (this->rdstate() & badbit) != 0; }
# 221 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      iostate
      exceptions() const
      { return _M_exception; }
# 256 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      void
      exceptions(iostate __except)
      {
        _M_exception = __except;
        this->clear(_M_streambuf_state);
      }







      explicit
      basic_ios(basic_streambuf<_CharT, _Traits>* __sb)
      : ios_base(), _M_tie(0), _M_fill(), _M_fill_init(false), _M_streambuf(0),
 _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { this->init(__sb); }







      virtual
      ~basic_ios() { }
# 294 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie() const
      { return _M_tie; }
# 306 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ostream<_CharT, _Traits>*
      tie(basic_ostream<_CharT, _Traits>* __tiestr)
      {
        basic_ostream<_CharT, _Traits>* __old = _M_tie;
        _M_tie = __tiestr;
        return __old;
      }







      basic_streambuf<_CharT, _Traits>*
      rdbuf() const
      { return _M_streambuf; }
# 346 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_streambuf<_CharT, _Traits>*
      rdbuf(basic_streambuf<_CharT, _Traits>* __sb);
# 360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      basic_ios&
      copyfmt(const basic_ios& __rhs);







      char_type
      fill() const
      {
 if (!_M_fill_init)
   {
     _M_fill = this->widen(' ');
     _M_fill_init = true;
   }
 return _M_fill;
      }
# 389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char_type
      fill(char_type __ch)
      {
 char_type __old = this->fill();
 _M_fill = __ch;
 return __old;
      }
# 409 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      locale
      imbue(const locale& __loc);
# 429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char
      narrow(char_type __c, char __dfault) const
      { return __check_facet(_M_ctype).narrow(__c, __dfault); }
# 448 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 3
      char_type
      widen(char __c) const
      { return __check_facet(_M_ctype).widen(__c); }

    protected:







      basic_ios()
      : ios_base(), _M_tie(0), _M_fill(char_type()), _M_fill_init(false),
 _M_streambuf(0), _M_ctype(0), _M_num_put(0), _M_num_get(0)
      { }







      void
      init(basic_streambuf<_CharT, _Traits>* __sb);


      basic_ios(const basic_ios&) = delete;
      basic_ios& operator=(const basic_ios&) = delete;

      void
      move(basic_ios& __rhs)
      {
 ios_base::_M_move(__rhs);
 _M_cache_locale(_M_ios_locale);
 this->tie(__rhs.tie(nullptr));
 _M_fill = __rhs._M_fill;
 _M_fill_init = __rhs._M_fill_init;
 _M_streambuf = nullptr;
      }

      void
      move(basic_ios&& __rhs)
      { this->move(__rhs); }

      void
      swap(basic_ios& __rhs) noexcept
      {
 ios_base::_M_swap(__rhs);
 _M_cache_locale(_M_ios_locale);
 __rhs._M_cache_locale(__rhs._M_ios_locale);
 std::swap(_M_tie, __rhs._M_tie);
 std::swap(_M_fill, __rhs._M_fill);
 std::swap(_M_fill_init, __rhs._M_fill_init);
      }

      void
      set_rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
      { _M_streambuf = __sb; }


      void
      _M_cache_locale(const locale& __loc);
    };


}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3

namespace std
{


  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::clear(iostate __state)
    {
      if (this->rdbuf())
 _M_streambuf_state = __state;
      else
   _M_streambuf_state = __state | badbit;
      if (this->exceptions() & this->rdstate())
 __throw_ios_failure(("basic_ios::clear"));
    }

  template<typename _CharT, typename _Traits>
    basic_streambuf<_CharT, _Traits>*
    basic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<_CharT, _Traits>* __sb)
    {
      basic_streambuf<_CharT, _Traits>* __old = _M_streambuf;
      _M_streambuf = __sb;
      this->clear();
      return __old;
    }

  template<typename _CharT, typename _Traits>
    basic_ios<_CharT, _Traits>&
    basic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)
    {


      if (this != &__rhs)
 {




   _Words* __words = (__rhs._M_word_size <= _S_local_word_size) ?
                      _M_local_word : new _Words[__rhs._M_word_size];


   _Callback_list* __cb = __rhs._M_callbacks;
   if (__cb)
     __cb->_M_add_reference();
   _M_call_callbacks(erase_event);
   if (_M_word != _M_local_word)
     {
       delete [] _M_word;
       _M_word = 0;
     }
   _M_dispose_callbacks();


   _M_callbacks = __cb;
   for (int __i = 0; __i < __rhs._M_word_size; ++__i)
     __words[__i] = __rhs._M_word[__i];
   _M_word = __words;
   _M_word_size = __rhs._M_word_size;

   this->flags(__rhs.flags());
   this->width(__rhs.width());
   this->precision(__rhs.precision());
   this->tie(__rhs.tie());
   this->fill(__rhs.fill());
   _M_ios_locale = __rhs.getloc();
   _M_cache_locale(_M_ios_locale);

   _M_call_callbacks(copyfmt_event);


   this->exceptions(__rhs.exceptions());
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    locale
    basic_ios<_CharT, _Traits>::imbue(const locale& __loc)
    {
      locale __old(this->getloc());
      ios_base::imbue(__loc);
      _M_cache_locale(__loc);
      if (this->rdbuf() != 0)
 this->rdbuf()->pubimbue(__loc);
      return __old;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::init(basic_streambuf<_CharT, _Traits>* __sb)
    {

      ios_base::_M_init();


      _M_cache_locale(_M_ios_locale);
# 146 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.tcc" 3
      _M_fill = _CharT();
      _M_fill_init = false;

      _M_tie = 0;
      _M_exception = goodbit;
      _M_streambuf = __sb;
      _M_streambuf_state = __sb ? goodbit : badbit;
    }

  template<typename _CharT, typename _Traits>
    void
    basic_ios<_CharT, _Traits>::_M_cache_locale(const locale& __loc)
    {
      if (__builtin_expect(has_facet<__ctype_type>(__loc), true))
 _M_ctype = &use_facet<__ctype_type>(__loc);
      else
 _M_ctype = 0;

      if (__builtin_expect(has_facet<__num_put_type>(__loc), true))
 _M_num_put = &use_facet<__num_put_type>(__loc);
      else
 _M_num_put = 0;

      if (__builtin_expect(has_facet<__num_get_type>(__loc), true))
 _M_num_get = &use_facet<__num_get_type>(__loc);
      else
 _M_num_get = 0;
    }




  extern template class basic_ios<char>;


  extern template class basic_ios<wchar_t>;




}
# 517 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/basic_ios.h" 2 3
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ios" 2 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 2 3


namespace std
{

# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    class basic_ostream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
             __num_put_type;
      typedef ctype<_CharT> __ctype_type;
# 83 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit
      basic_ostream(__streambuf_type* __sb)
      { this->init(__sb); }






      virtual
      ~basic_ostream() { }


      class sentry;
      friend class sentry;
# 107 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(__ostream_type& (*__pf)(__ostream_type&))
      {



 return __pf(*this);
      }

      __ostream_type&
      operator<<(__ios_type& (*__pf)(__ios_type&))
      {



 __pf(*this);
 return *this;
      }

      __ostream_type&
      operator<<(ios_base& (*__pf) (ios_base&))
      {



 __pf(*this);
 return *this;
      }
# 165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(bool __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(short __n);

      __ostream_type&
      operator<<(unsigned short __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }

      __ostream_type&
      operator<<(int __n);

      __ostream_type&
      operator<<(unsigned int __n)
      {


 return _M_insert(static_cast<unsigned long>(__n));
      }


      __ostream_type&
      operator<<(long long __n)
      { return _M_insert(__n); }

      __ostream_type&
      operator<<(unsigned long long __n)
      { return _M_insert(__n); }
# 219 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(double __f)
      { return _M_insert(__f); }

      __ostream_type&
      operator<<(float __f)
      {


 return _M_insert(static_cast<double>(__f));
      }

      __ostream_type&
      operator<<(long double __f)
      { return _M_insert(__f); }
# 244 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(const void* __p)
      { return _M_insert(__p); }
# 269 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      operator<<(__streambuf_type* __sb);
# 302 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      put(char_type __c);






      void
      _M_write(const char_type* __s, streamsize __n)
      {
 const streamsize __put = this->rdbuf()->sputn(__s, __n);
 if (__put != __n)
   this->setstate(ios_base::badbit);
      }
# 334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      write(const char_type* __s, streamsize __n);
# 347 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      flush();
# 357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      pos_type
      tellp();
# 368 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      __ostream_type&
      seekp(pos_type);
# 380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
       __ostream_type&
      seekp(off_type, ios_base::seekdir);

    protected:
      basic_ostream()
      { this->init(0); }



      basic_ostream(basic_iostream<_CharT, _Traits>&) { }

      basic_ostream(const basic_ostream&) = delete;

      basic_ostream(basic_ostream&& __rhs)
      : __ios_type()
      { __ios_type::move(__rhs); }



      basic_ostream& operator=(const basic_ostream&) = delete;

      basic_ostream&
      operator=(basic_ostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_ostream& __rhs)
      { __ios_type::swap(__rhs); }


      template<typename _ValueT>
 __ostream_type&
 _M_insert(_ValueT __v);
    };
# 425 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template <typename _CharT, typename _Traits>
    class basic_ostream<_CharT, _Traits>::sentry
    {

      bool _M_ok;
      basic_ostream<_CharT, _Traits>& _M_os;

    public:
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit
      sentry(basic_ostream<_CharT, _Traits>& __os);
# 454 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      ~sentry()
      {

 if (bool(_M_os.flags() & ios_base::unitbuf) && !uncaught_exception())
   {

     if (_M_os.rdbuf() && _M_os.rdbuf()->pubsync() == -1)
       _M_os.setstate(ios_base::badbit);
   }
      }
# 473 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 495 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, _CharT __c)
    { return __ostream_insert(__out, &__c, 1); }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, char __c)
    { return (__out << __out.widen(__c)); }


  template <class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, char __c)
    { return __ostream_insert(__out, &__c, 1); }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, signed char __c)
    { return (__out << static_cast<char>(__c)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, unsigned char __c)
    { return (__out << static_cast<char>(__c)); }
# 537 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const _CharT* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits> &
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s);


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 __ostream_insert(__out, __s,
    static_cast<streamsize>(_Traits::length(__s)));
      return __out;
    }


  template<class _Traits>
    inline basic_ostream<char, _Traits>&
    operator<<(basic_ostream<char, _Traits>& __out, const signed char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }

  template<class _Traits>
    inline basic_ostream<char, _Traits> &
    operator<<(basic_ostream<char, _Traits>& __out, const unsigned char* __s)
    { return (__out << reinterpret_cast<const char*>(__s)); }
# 588 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    endl(basic_ostream<_CharT, _Traits>& __os)
    { return flush(__os.put(__os.widen('\n'))); }
# 600 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    ends(basic_ostream<_CharT, _Traits>& __os)
    { return __os.put(_CharT()); }






  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    flush(basic_ostream<_CharT, _Traits>& __os)
    { return __os.flush(); }
# 626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>&& __os, const _Tp& __x)
    {
      __os << __x;
      return __os;
    }



}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/ostream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>::sentry::
    sentry(basic_ostream<_CharT, _Traits>& __os)
    : _M_ok(false), _M_os(__os)
    {

      if (__os.tie() && __os.good())
 __os.tie()->flush();

      if (__os.good())
 _M_ok = true;
      else
 __os.setstate(ios_base::failbit);
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_ostream<_CharT, _Traits>&
      basic_ostream<_CharT, _Traits>::
      _M_insert(_ValueT __v)
      {
 sentry __cerb(*this);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_put_type& __np = __check_facet(this->_M_num_put);
  if (__np.put(*this, *this, this->fill(), __v).failed())
    __err |= ios_base::badbit;
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(short __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned short>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(int __n)
    {


      const ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;
      if (__fmt == ios_base::oct || __fmt == ios_base::hex)
 return _M_insert(static_cast<long>(static_cast<unsigned int>(__n)));
      else
 return _M_insert(static_cast<long>(__n));
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    operator<<(__streambuf_type* __sbin)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this);
      if (__cerb && __sbin)
 {
   try
     {
       if (!__copy_streambufs(__sbin, this->rdbuf()))
  __err |= ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbin)
 __err |= ios_base::badbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    put(char_type __c)
    {






      sentry __cerb(*this);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __put = this->rdbuf()->sputc(__c);
       if (traits_type::eq_int_type(__put, traits_type::eof()))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    write(const _CharT* __s, streamsize __n)
    {







      sentry __cerb(*this);
      if (__cerb)
 {
   try
     { _M_write(__s, __n); }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    flush()
    {



      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (this->rdbuf() && this->rdbuf()->pubsync() == -1)
     __err |= ios_base::badbit;
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_ostream<_CharT, _Traits>::pos_type
    basic_ostream<_CharT, _Traits>::
    tellp()
    {
      pos_type __ret = pos_type(-1);
      try
 {
   if (!this->fail())
     __ret = this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(pos_type __pos)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekpos(__pos,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    basic_ostream<_CharT, _Traits>::
    seekp(off_type __off, ios_base::seekdir __dir)
    {
      ios_base::iostate __err = ios_base::goodbit;
      try
 {
   if (!this->fail())
     {


       const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
            ios_base::out);


       if (__p == pos_type(off_type(-1)))
  __err |= ios_base::failbit;
     }
 }
      catch(__cxxabiv1::__forced_unwind&)
 {
   this->_M_setstate(ios_base::badbit);
   throw;
 }
      catch(...)
 { this->_M_setstate(ios_base::badbit); }
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, const char* __s)
    {
      if (!__s)
 __out.setstate(ios_base::badbit);
      else
 {


   const size_t __clen = char_traits<char>::length(__s);
   try
     {
       struct __ptr_guard
       {
  _CharT *__p;
  __ptr_guard (_CharT *__ip): __p(__ip) { }
  ~__ptr_guard() { delete[] __p; }
  _CharT* __get() { return __p; }
       } __pg (new _CharT[__clen]);

       _CharT *__ws = __pg.__get();
       for (size_t __i = 0; __i < __clen; ++__i)
  __ws[__i] = __out.widen(__s[__i]);
       __ostream_insert(__out, __ws, __clen);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(ios_base::badbit); }
 }
      return __out;
    }




  extern template class basic_ostream<char>;
  extern template ostream& endl(ostream&);
  extern template ostream& ends(ostream&);
  extern template ostream& flush(ostream&);
  extern template ostream& operator<<(ostream&, char);
  extern template ostream& operator<<(ostream&, unsigned char);
  extern template ostream& operator<<(ostream&, signed char);
  extern template ostream& operator<<(ostream&, const char*);
  extern template ostream& operator<<(ostream&, const unsigned char*);
  extern template ostream& operator<<(ostream&, const signed char*);

  extern template ostream& ostream::_M_insert(long);
  extern template ostream& ostream::_M_insert(unsigned long);
  extern template ostream& ostream::_M_insert(bool);

  extern template ostream& ostream::_M_insert(long long);
  extern template ostream& ostream::_M_insert(unsigned long long);

  extern template ostream& ostream::_M_insert(double);
  extern template ostream& ostream::_M_insert(long double);
  extern template ostream& ostream::_M_insert(const void*);


  extern template class basic_ostream<wchar_t>;
  extern template wostream& endl(wostream&);
  extern template wostream& ends(wostream&);
  extern template wostream& flush(wostream&);
  extern template wostream& operator<<(wostream&, wchar_t);
  extern template wostream& operator<<(wostream&, char);
  extern template wostream& operator<<(wostream&, const wchar_t*);
  extern template wostream& operator<<(wostream&, const char*);

  extern template wostream& wostream::_M_insert(long);
  extern template wostream& wostream::_M_insert(unsigned long);
  extern template wostream& wostream::_M_insert(bool);

  extern template wostream& wostream::_M_insert(long long);
  extern template wostream& wostream::_M_insert(unsigned long long);

  extern template wostream& wostream::_M_insert(double);
  extern template wostream& wostream::_M_insert(long double);
  extern template wostream& wostream::_M_insert(const void*);




}
# 639 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ostream" 2 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3




namespace std
{

# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream : virtual public basic_ios<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_ios<_CharT, _Traits> __ios_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef num_get<_CharT, istreambuf_iterator<_CharT, _Traits> >
        __num_get_type;
      typedef ctype<_CharT> __ctype_type;

    protected:





      streamsize _M_gcount;

    public:







      explicit
      basic_istream(__streambuf_type* __sb)
      : _M_gcount(streamsize(0))
      { this->init(__sb); }






      virtual
      ~basic_istream()
      { _M_gcount = streamsize(0); }


      class sentry;
      friend class sentry;
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(__istream_type& (*__pf)(__istream_type&))
      { return __pf(*this); }

      __istream_type&
      operator>>(__ios_type& (*__pf)(__ios_type&))
      {
 __pf(*this);
 return *this;
      }

      __istream_type&
      operator>>(ios_base& (*__pf)(ios_base&))
      {
 __pf(*this);
 return *this;
      }
# 167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(bool& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(short& __n);

      __istream_type&
      operator>>(unsigned short& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(int& __n);

      __istream_type&
      operator>>(unsigned int& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long& __n)
      { return _M_extract(__n); }


      __istream_type&
      operator>>(long long& __n)
      { return _M_extract(__n); }

      __istream_type&
      operator>>(unsigned long long& __n)
      { return _M_extract(__n); }
# 213 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(float& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(double& __f)
      { return _M_extract(__f); }

      __istream_type&
      operator>>(long double& __f)
      { return _M_extract(__f); }
# 234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(void*& __p)
      { return _M_extract(__p); }
# 258 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      operator>>(__streambuf_type* __sb);
# 268 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      streamsize
      gcount() const
      { return _M_gcount; }
# 301 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      int_type
      get();
# 315 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type& __c);
# 342 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n, char_type __delim);
# 353 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(char_type* __s, streamsize __n)
      { return this->get(__s, __n, this->widen('\n')); }
# 376 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb, char_type __delim);
# 386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      get(__streambuf_type& __sb)
      { return this->get(__sb, this->widen('\n')); }
# 415 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n, char_type __delim);
# 426 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      getline(char_type* __s, streamsize __n)
      { return this->getline(__s, __n, this->widen('\n')); }
# 450 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      ignore(streamsize __n, int_type __delim);

      __istream_type&
      ignore(streamsize __n);

      __istream_type&
      ignore();
# 467 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      int_type
      peek();
# 485 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      read(char_type* __s, streamsize __n);
# 504 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      streamsize
      readsome(char_type* __s, streamsize __n);
# 521 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      putback(char_type __c);
# 537 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      unget();
# 555 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      int
      sync();
# 570 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      pos_type
      tellg();
# 585 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      seekg(pos_type);
# 601 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      __istream_type&
      seekg(off_type, ios_base::seekdir);


    protected:
      basic_istream()
      : _M_gcount(streamsize(0))
      { this->init(0); }


      basic_istream(const basic_istream&) = delete;

      basic_istream(basic_istream&& __rhs)
      : __ios_type(), _M_gcount(__rhs._M_gcount)
      {
 __ios_type::move(__rhs);
 __rhs._M_gcount = 0;
      }



      basic_istream& operator=(const basic_istream&) = delete;

      basic_istream&
      operator=(basic_istream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_istream& __rhs)
      {
 __ios_type::swap(__rhs);
 std::swap(_M_gcount, __rhs._M_gcount);
      }


      template<typename _ValueT>
 __istream_type&
 _M_extract(_ValueT& __v);
    };


  template<>
    basic_istream<char>&
    basic_istream<char>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n);

  template<>
    basic_istream<char>&
    basic_istream<char>::
    ignore(streamsize __n, int_type __delim);


  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    getline(char_type* __s, streamsize __n, char_type __delim);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n);

  template<>
    basic_istream<wchar_t>&
    basic_istream<wchar_t>::
    ignore(streamsize __n, int_type __delim);
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_istream<_CharT, _Traits>::sentry
    {

      bool _M_ok;

    public:

      typedef _Traits traits_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::__ctype_type __ctype_type;
      typedef typename _Traits::int_type __int_type;
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      explicit
      sentry(basic_istream<_CharT, _Traits>& __is, bool __noskipws = false);
# 732 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
      explicit

      operator bool() const
      { return _M_ok; }
    };
# 750 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char& __c)
    { return (__in >> reinterpret_cast<char&>(__c)); }
# 792 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s);


  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __in, char* __s);

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, unsigned char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }

  template<class _Traits>
    inline basic_istream<char, _Traits>&
    operator>>(basic_istream<char, _Traits>& __in, signed char* __s)
    { return (__in >> reinterpret_cast<char*>(__s)); }
# 823 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
    {
    public:



      typedef _CharT char_type;
      typedef typename _Traits::int_type int_type;
      typedef typename _Traits::pos_type pos_type;
      typedef typename _Traits::off_type off_type;
      typedef _Traits traits_type;


      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_ostream<_CharT, _Traits> __ostream_type;







      explicit
      basic_iostream(basic_streambuf<_CharT, _Traits>* __sb)
      : __istream_type(__sb), __ostream_type(__sb) { }




      virtual
      ~basic_iostream() { }

    protected:
      basic_iostream()
      : __istream_type(), __ostream_type() { }


      basic_iostream(const basic_iostream&) = delete;

      basic_iostream(basic_iostream&& __rhs)
      : __istream_type(std::move(__rhs)), __ostream_type(*this)
      { }



      basic_iostream& operator=(const basic_iostream&) = delete;

      basic_iostream&
      operator=(basic_iostream&& __rhs)
      {
 swap(__rhs);
 return *this;
      }

      void
      swap(basic_iostream& __rhs)
      { __istream_type::swap(__rhs); }

    };
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __is);
# 922 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 3
  template<typename _CharT, typename _Traits, typename _Tp>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>&& __is, _Tp& __x)
    {
      __is >> __x;
      return __is;
    }



}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3



namespace std
{


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>::sentry::
    sentry(basic_istream<_CharT, _Traits>& __in, bool __noskip) : _M_ok(false)
    {
      ios_base::iostate __err = ios_base::goodbit;
      if (__in.good())
 {
   if (__in.tie())
     __in.tie()->flush();
   if (!__noskip && bool(__in.flags() & ios_base::skipws))
     {
       const __int_type __eof = traits_type::eof();
       __streambuf_type* __sb = __in.rdbuf();
       __int_type __c = __sb->sgetc();

       const __ctype_type& __ct = __check_facet(__in._M_ctype);
       while (!traits_type::eq_int_type(__c, __eof)
       && __ct.is(ctype_base::space,
    traits_type::to_char_type(__c)))
  __c = __sb->snextc();




       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
 }

      if (__in.good() && __err == ios_base::goodbit)
 _M_ok = true;
      else
 {
   __err |= ios_base::failbit;
   __in.setstate(__err);
 }
    }

  template<typename _CharT, typename _Traits>
    template<typename _ValueT>
      basic_istream<_CharT, _Traits>&
      basic_istream<_CharT, _Traits>::
      _M_extract(_ValueT& __v)
      {
 sentry __cerb(*this, false);
 if (__cerb)
   {
     ios_base::iostate __err = ios_base::goodbit;
     try
       {
  const __num_get_type& __ng = __check_facet(this->_M_num_get);
  __ng.get(*this, 0, *this, __err, __v);
       }
     catch(__cxxabiv1::__forced_unwind&)
       {
  this->_M_setstate(ios_base::badbit);
  throw;
       }
     catch(...)
       { this->_M_setstate(ios_base::badbit); }
     if (__err)
       this->setstate(__err);
   }
 return *this;
      }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(short& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<short>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<short>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<short>::__max;
  }
       else
  __n = short(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(int& __n)
    {


      sentry __cerb(*this, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       long __l;
       const __num_get_type& __ng = __check_facet(this->_M_num_get);
       __ng.get(*this, 0, *this, __err, __l);



       if (__l < __gnu_cxx::__numeric_traits<int>::__min)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__min;
  }
       else if (__l > __gnu_cxx::__numeric_traits<int>::__max)
  {
    __err |= ios_base::failbit;
    __n = __gnu_cxx::__numeric_traits<int>::__max;
  }
       else
  __n = int(__l);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    operator>>(__streambuf_type* __sbout)
    {
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, false);
      if (__cerb && __sbout)
 {
   try
     {
       bool __ineof;
       if (!__copy_streambufs_eof(this->rdbuf(), __sbout, __ineof))
  __err |= ios_base::failbit;
       if (__ineof)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::failbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::failbit); }
 }
      else if (!__sbout)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    get(void)
    {
      const int_type __eof = traits_type::eof();
      int_type __c = __eof;
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       __c = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__c, __eof))
  _M_gcount = 1;
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type& __c)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __cb = this->rdbuf()->sbumpc();

       if (!traits_type::eq_int_type(__cb, traits_type::eof()))
  {
    _M_gcount = 1;
    __c = traits_type::to_char_type(__cb);
  }
       else
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       int_type __c = __sb->sgetc();

       while (_M_gcount + 1 < __n
       && !traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim))
  {
    *__s++ = traits_type::to_char_type(__c);
    ++_M_gcount;
    __c = __sb->snextc();
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    get(__streambuf_type& __sb, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       const int_type __idelim = traits_type::to_int_type(__delim);
       const int_type __eof = traits_type::eof();
       __streambuf_type* __this_sb = this->rdbuf();
       int_type __c = __this_sb->sgetc();
       char_type __c2 = traits_type::to_char_type(__c);

       while (!traits_type::eq_int_type(__c, __eof)
       && !traits_type::eq_int_type(__c, __idelim)
       && !traits_type::eq_int_type(__sb.sputc(__c2), __eof))
  {
    ++_M_gcount;
    __c = __this_sb->snextc();
    __c2 = traits_type::to_char_type(__c);
  }
       if (traits_type::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      if (!_M_gcount)
 __err |= ios_base::failbit;
      if (__err)
 this->setstate(__err);
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    getline(char_type* __s, streamsize __n, char_type __delim)
    {
      _M_gcount = 0;
      ios_base::iostate __err = ios_base::goodbit;
      sentry __cerb(*this, true);
      if (__cerb)
        {
          try
            {
              const int_type __idelim = traits_type::to_int_type(__delim);
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();

              while (_M_gcount + 1 < __n
                     && !traits_type::eq_int_type(__c, __eof)
                     && !traits_type::eq_int_type(__c, __idelim))
                {
                  *__s++ = traits_type::to_char_type(__c);
                  __c = __sb->snextc();
                  ++_M_gcount;
                }
              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
              else
                {
                  if (traits_type::eq_int_type(__c, __idelim))
                    {
                      __sb->sbumpc();
                      ++_M_gcount;
                    }
                  else
                    __err |= ios_base::failbit;
                }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
        }


      if (__n > 0)
 *__s = char_type();
      if (!_M_gcount)
        __err |= ios_base::failbit;
      if (__err)
        this->setstate(__err);
      return *this;
    }




  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(void)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();

       if (traits_type::eq_int_type(__sb->sbumpc(), __eof))
  __err |= ios_base::eofbit;
       else
  _M_gcount = 1;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();
# 513 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/istream.tcc" 3
       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

       if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    ignore(streamsize __n, int_type __delim)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb && __n > 0)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              const int_type __eof = traits_type::eof();
              __streambuf_type* __sb = this->rdbuf();
              int_type __c = __sb->sgetc();


       bool __large_ignore = false;
       while (true)
  {
    while (_M_gcount < __n
    && !traits_type::eq_int_type(__c, __eof)
    && !traits_type::eq_int_type(__c, __delim))
      {
        ++_M_gcount;
        __c = __sb->snextc();
      }
    if (__n == __gnu_cxx::__numeric_traits<streamsize>::__max
        && !traits_type::eq_int_type(__c, __eof)
        && !traits_type::eq_int_type(__c, __delim))
      {
        _M_gcount =
   __gnu_cxx::__numeric_traits<streamsize>::__min;
        __large_ignore = true;
      }
    else
      break;
  }

       if (__large_ignore)
  _M_gcount = __gnu_cxx::__numeric_traits<streamsize>::__max;

              if (traits_type::eq_int_type(__c, __eof))
                __err |= ios_base::eofbit;
       else if (traits_type::eq_int_type(__c, __delim))
  {
    if (_M_gcount
        < __gnu_cxx::__numeric_traits<streamsize>::__max)
      ++_M_gcount;
    __sb->sbumpc();
  }
            }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
          catch(...)
            { this->_M_setstate(ios_base::badbit); }
          if (__err)
            this->setstate(__err);
        }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::int_type
    basic_istream<_CharT, _Traits>::
    peek(void)
    {
      int_type __c = traits_type::eof();
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __c = this->rdbuf()->sgetc();
       if (traits_type::eq_int_type(__c, traits_type::eof()))
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __c;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    read(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       _M_gcount = this->rdbuf()->sgetn(__s, __n);
       if (_M_gcount != __n)
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    streamsize
    basic_istream<_CharT, _Traits>::
    readsome(char_type* __s, streamsize __n)
    {
      _M_gcount = 0;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {

       const streamsize __num = this->rdbuf()->in_avail();
       if (__num > 0)
  _M_gcount = this->rdbuf()->sgetn(__s, std::min(__num, __n));
       else if (__num == -1)
  __err |= ios_base::eofbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return _M_gcount;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    putback(char_type __c)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sputbackc(__c), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    unget(void)
    {


      _M_gcount = 0;

      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const int_type __eof = traits_type::eof();
       __streambuf_type* __sb = this->rdbuf();
       if (!__sb
    || traits_type::eq_int_type(__sb->sungetc(), __eof))
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    int
    basic_istream<_CharT, _Traits>::
    sync(void)
    {


      int __ret = -1;
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       __streambuf_type* __sb = this->rdbuf();
       if (__sb)
  {
    if (__sb->pubsync() == -1)
      __err |= ios_base::badbit;
    else
      __ret = 0;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    typename basic_istream<_CharT, _Traits>::pos_type
    basic_istream<_CharT, _Traits>::
    tellg(void)
    {


      pos_type __ret = pos_type(-1);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   try
     {
       if (!this->fail())
  __ret = this->rdbuf()->pubseekoff(0, ios_base::cur,
        ios_base::in);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(pos_type __pos)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekpos(__pos,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    basic_istream<_CharT, _Traits>::
    seekg(off_type __off, ios_base::seekdir __dir)
    {



      this->clear(this->rdstate() & ~ios_base::eofbit);
      sentry __cerb(*this, true);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       if (!this->fail())
  {

    const pos_type __p = this->rdbuf()->pubseekoff(__off, __dir,
         ios_base::in);


    if (__p == pos_type(off_type(-1)))
      __err |= ios_base::failbit;
  }
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       this->_M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { this->_M_setstate(ios_base::badbit); }
   if (__err)
     this->setstate(__err);
 }
      return *this;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT& __c)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef typename __istream_type::int_type __int_type;

      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       const __int_type __cb = __in.rdbuf()->sbumpc();
       if (!_Traits::eq_int_type(__cb, _Traits::eof()))
  __c = _Traits::to_char_type(__cb);
       else
  __err |= (ios_base::eofbit | ios_base::failbit);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
   if (__err)
     __in.setstate(__err);
 }
      return __in;
    }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in, _CharT* __s)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename _Traits::int_type int_type;
      typedef _CharT char_type;
      typedef ctype<_CharT> __ctype_type;

      streamsize __extracted = 0;
      ios_base::iostate __err = ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       streamsize __num = __in.width();
       if (__num <= 0)
  __num = __gnu_cxx::__numeric_traits<streamsize>::__max;

       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());

       const int_type __eof = _Traits::eof();
       __streambuf_type* __sb = __in.rdbuf();
       int_type __c = __sb->sgetc();

       while (__extracted < __num - 1
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    *__s++ = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __sb->snextc();
  }
       if (_Traits::eq_int_type(__c, __eof))
  __err |= ios_base::eofbit;



       *__s = char_type();
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __in._M_setstate(ios_base::badbit); }
 }
      if (!__extracted)
 __err |= ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }


  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    ws(basic_istream<_CharT, _Traits>& __in)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_streambuf<_CharT, _Traits> __streambuf_type;
      typedef typename __istream_type::int_type __int_type;
      typedef ctype<_CharT> __ctype_type;

      const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
      const __int_type __eof = _Traits::eof();
      __streambuf_type* __sb = __in.rdbuf();
      __int_type __c = __sb->sgetc();

      while (!_Traits::eq_int_type(__c, __eof)
      && __ct.is(ctype_base::space, _Traits::to_char_type(__c)))
 __c = __sb->snextc();

       if (_Traits::eq_int_type(__c, __eof))
  __in.setstate(ios_base::eofbit);
      return __in;
    }




  extern template class basic_istream<char>;
  extern template istream& ws(istream&);
  extern template istream& operator>>(istream&, char&);
  extern template istream& operator>>(istream&, char*);
  extern template istream& operator>>(istream&, unsigned char&);
  extern template istream& operator>>(istream&, signed char&);
  extern template istream& operator>>(istream&, unsigned char*);
  extern template istream& operator>>(istream&, signed char*);

  extern template istream& istream::_M_extract(unsigned short&);
  extern template istream& istream::_M_extract(unsigned int&);
  extern template istream& istream::_M_extract(long&);
  extern template istream& istream::_M_extract(unsigned long&);
  extern template istream& istream::_M_extract(bool&);

  extern template istream& istream::_M_extract(long long&);
  extern template istream& istream::_M_extract(unsigned long long&);

  extern template istream& istream::_M_extract(float&);
  extern template istream& istream::_M_extract(double&);
  extern template istream& istream::_M_extract(long double&);
  extern template istream& istream::_M_extract(void*&);

  extern template class basic_iostream<char>;


  extern template class basic_istream<wchar_t>;
  extern template wistream& ws(wistream&);
  extern template wistream& operator>>(wistream&, wchar_t&);
  extern template wistream& operator>>(wistream&, wchar_t*);

  extern template wistream& wistream::_M_extract(unsigned short&);
  extern template wistream& wistream::_M_extract(unsigned int&);
  extern template wistream& wistream::_M_extract(long&);
  extern template wistream& wistream::_M_extract(unsigned long&);
  extern template wistream& wistream::_M_extract(bool&);

  extern template wistream& wistream::_M_extract(long long&);
  extern template wistream& wistream::_M_extract(unsigned long long&);

  extern template wistream& wistream::_M_extract(float&);
  extern template wistream& wistream::_M_extract(double&);
  extern template wistream& wistream::_M_extract(long double&);
  extern template wistream& wistream::_M_extract(void*&);

  extern template class basic_iostream<wchar_t>;




}
# 935 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/istream" 2 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 2 3

namespace std
{

# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iostream" 3
  extern istream cin;
  extern ostream cout;
  extern ostream cerr;
  extern ostream clog;


  extern wistream wcin;
  extern wostream wcout;
  extern wostream wcerr;
  extern wostream wclog;




  static ios_base::Init __ioinit;


}
# 81 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3






#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }





    bool before(const type_info& __arg) const noexcept;
    bool operator==(const type_info& __arg) const noexcept;
# 136 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 82 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3




namespace std
{

namespace __cxx11 {
# 64 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringbuf : public basic_streambuf<_CharT, _Traits>
    {
      struct __xfer_bufptrs;
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;

      typedef basic_streambuf<char_type, traits_type> __streambuf_type;
      typedef basic_string<char_type, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;

    protected:

      ios_base::openmode _M_mode;


      __string_type _M_string;

    public:
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringbuf(ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(__mode), _M_string()
      { }
# 112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringbuf(const __string_type& __str,
        ios_base::openmode __mode = ios_base::in | ios_base::out)
      : __streambuf_type(), _M_mode(), _M_string(__str.data(), __str.size())
      { _M_stringbuf_init(__mode); }


      basic_stringbuf(const basic_stringbuf&) = delete;

      basic_stringbuf(basic_stringbuf&& __rhs)
      : basic_stringbuf(std::move(__rhs), __xfer_bufptrs(__rhs, this))
      { __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0); }



      basic_stringbuf&
      operator=(const basic_stringbuf&) = delete;

      basic_stringbuf&
      operator=(basic_stringbuf&& __rhs)
      {
 __xfer_bufptrs __st{__rhs, this};
 const __streambuf_type& __base = __rhs;
 __streambuf_type::operator=(__base);
 this->pubimbue(__rhs.getloc());
 _M_mode = __rhs._M_mode;
 _M_string = std::move(__rhs._M_string);
 __rhs._M_sync(const_cast<char_type*>(__rhs._M_string.data()), 0, 0);
 return *this;
      }

      void
      swap(basic_stringbuf& __rhs)
      {
 __xfer_bufptrs __l_st{*this, std::__addressof(__rhs)};
 __xfer_bufptrs __r_st{__rhs, this};
 __streambuf_type& __base = __rhs;
 __streambuf_type::swap(__base);
 __rhs.pubimbue(this->pubimbue(__rhs.getloc()));
 std::swap(_M_mode, __rhs._M_mode);
 std::swap(_M_string, __rhs._M_string);
      }
# 165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __string_type
      str() const
      {
 __string_type __ret;
 if (this->pptr())
   {

     if (this->pptr() > this->egptr())
       __ret = __string_type(this->pbase(), this->pptr());
     else
        __ret = __string_type(this->pbase(), this->egptr());
   }
 else
   __ret = _M_string;
 return __ret;
      }
# 189 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      void
      str(const __string_type& __s)
      {


 _M_string.assign(__s.data(), __s.size());
 _M_stringbuf_init(_M_mode);
      }

    protected:

      void
      _M_stringbuf_init(ios_base::openmode __mode)
      {
 _M_mode = __mode;
 __size_type __len = 0;
 if (_M_mode & (ios_base::ate | ios_base::app))
   __len = _M_string.size();
 _M_sync(const_cast<char_type*>(_M_string.data()), 0, __len);
      }

      virtual streamsize
      showmanyc()
      {
 streamsize __ret = -1;
 if (_M_mode & ios_base::in)
   {
     _M_update_egptr();
     __ret = this->egptr() - this->gptr();
   }
 return __ret;
      }

      virtual int_type
      underflow();

      virtual int_type
      pbackfail(int_type __c = traits_type::eof());

      virtual int_type
      overflow(int_type __c = traits_type::eof());
# 242 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      virtual __streambuf_type*
      setbuf(char_type* __s, streamsize __n)
      {
 if (__s && __n >= 0)
   {






     _M_string.clear();


     _M_sync(__s, __n, 0);
   }
 return this;
      }

      virtual pos_type
      seekoff(off_type __off, ios_base::seekdir __way,
       ios_base::openmode __mode = ios_base::in | ios_base::out);

      virtual pos_type
      seekpos(pos_type __sp,
       ios_base::openmode __mode = ios_base::in | ios_base::out);




      void
      _M_sync(char_type* __base, __size_type __i, __size_type __o);



      void
      _M_update_egptr()
      {
 const bool __testin = _M_mode & ios_base::in;
 if (this->pptr() && this->pptr() > this->egptr())
   {
     if (__testin)
       this->setg(this->eback(), this->gptr(), this->pptr());
     else
       this->setg(this->pptr(), this->pptr(), this->pptr());
   }
      }



      void
      _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off);

    private:




      struct __xfer_bufptrs
      {
 __xfer_bufptrs(const basic_stringbuf& __from, basic_stringbuf* __to)
 : _M_to{__to}, _M_goff{-1, -1, -1}, _M_poff{-1, -1, -1}
 {
   const _CharT* __str = __from._M_string.data();
   if (__from.eback())
     {
     _M_goff[0] = __from.eback() - __str;
     _M_goff[1] = __from.gptr() - __str;
     _M_goff[2] = __from.egptr() - __str;
     }
   if (__from.pbase())
     {
       _M_poff[0] = __from.pbase() - __str;
       _M_poff[1] = __from.pptr() - __from.pbase();
       _M_poff[2] = __from.epptr() - __str;
     }
 }

 ~__xfer_bufptrs()
 {
   char_type* __str = const_cast<char_type*>(_M_to->_M_string.data());
   if (_M_goff[0] != -1)
     _M_to->setg(__str+_M_goff[0], __str+_M_goff[1], __str+_M_goff[2]);
   if (_M_poff[0] != -1)
     _M_to->_M_pbump(__str+_M_poff[0], __str+_M_poff[2], _M_poff[1]);
 }

 basic_stringbuf* _M_to;
 off_type _M_goff[3];
 off_type _M_poff[3];
      };
# 343 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      basic_stringbuf(basic_stringbuf&& __rhs, __xfer_bufptrs&&)
      : __streambuf_type(static_cast<const __streambuf_type&>(__rhs)),
      _M_mode(__rhs._M_mode), _M_string(std::move(__rhs._M_string))
      { }

    };
# 366 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_istringstream : public basic_istream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_istream<char_type, traits_type> __istream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 402 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_istringstream(ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__mode | ios_base::in)
      { this->init(&_M_stringbuf); }
# 420 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_istringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::in)
      : __istream_type(), _M_stringbuf(__str, __mode | ios_base::in)
      { this->init(&_M_stringbuf); }







      ~basic_istringstream()
      { }


      basic_istringstream(const basic_istringstream&) = delete;

      basic_istringstream(basic_istringstream&& __rhs)
      : __istream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __istream_type::set_rdbuf(&_M_stringbuf); }



      basic_istringstream&
      operator=(const basic_istringstream&) = delete;

      basic_istringstream&
      operator=(basic_istringstream&& __rhs)
      {
 __istream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_istringstream& __rhs)
      {
 __istream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 471 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_ostringstream : public basic_ostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_ostream<char_type, traits_type> __ostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_ostringstream(ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__mode | ios_base::out)
      { this->init(&_M_stringbuf); }
# 564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_ostringstream(const __string_type& __str,
     ios_base::openmode __mode = ios_base::out)
      : __ostream_type(), _M_stringbuf(__str, __mode | ios_base::out)
      { this->init(&_M_stringbuf); }







      ~basic_ostringstream()
      { }


      basic_ostringstream(const basic_ostringstream&) = delete;

      basic_ostringstream(basic_ostringstream&& __rhs)
      : __ostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __ostream_type::set_rdbuf(&_M_stringbuf); }



      basic_ostringstream&
      operator=(const basic_ostringstream&) = delete;

      basic_ostringstream&
      operator=(basic_ostringstream&& __rhs)
      {
 __ostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_ostringstream& __rhs)
      {
 __ostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 615 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };
# 654 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
  template <typename _CharT, typename _Traits, typename _Alloc>
    class basic_stringstream : public basic_iostream<_CharT, _Traits>
    {
    public:

      typedef _CharT char_type;
      typedef _Traits traits_type;


      typedef _Alloc allocator_type;
      typedef typename traits_type::int_type int_type;
      typedef typename traits_type::pos_type pos_type;
      typedef typename traits_type::off_type off_type;


      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef basic_stringbuf<_CharT, _Traits, _Alloc> __stringbuf_type;
      typedef basic_iostream<char_type, traits_type> __iostream_type;

    private:
      __stringbuf_type _M_stringbuf;

    public:
# 689 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringstream(ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__m)
      { this->init(&_M_stringbuf); }
# 705 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      explicit
      basic_stringstream(const __string_type& __str,
    ios_base::openmode __m = ios_base::out | ios_base::in)
      : __iostream_type(), _M_stringbuf(__str, __m)
      { this->init(&_M_stringbuf); }







      ~basic_stringstream()
      { }


      basic_stringstream(const basic_stringstream&) = delete;

      basic_stringstream(basic_stringstream&& __rhs)
      : __iostream_type(std::move(__rhs)),
      _M_stringbuf(std::move(__rhs._M_stringbuf))
      { __iostream_type::set_rdbuf(&_M_stringbuf); }



      basic_stringstream&
      operator=(const basic_stringstream&) = delete;

      basic_stringstream&
      operator=(basic_stringstream&& __rhs)
      {
 __iostream_type::operator=(std::move(__rhs));
 _M_stringbuf = std::move(__rhs._M_stringbuf);
 return *this;
      }

      void
      swap(basic_stringstream& __rhs)
      {
 __iostream_type::swap(__rhs);
 _M_stringbuf.swap(__rhs._M_stringbuf);
      }
# 756 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 3
      __stringbuf_type*
      rdbuf() const
      { return const_cast<__stringbuf_type*>(&_M_stringbuf); }





      __string_type
      str() const
      { return _M_stringbuf.str(); }







      void
      str(const __string_type& __s)
      { _M_stringbuf.str(__s); }
    };



  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,
  basic_stringbuf<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,
  basic_istringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,
  basic_ostringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


  template <class _CharT, class _Traits, class _Allocator>
    inline void
    swap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,
  basic_stringstream<_CharT, _Traits, _Allocator>& __y)
    { __x.swap(__y); }


}

}

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3

namespace std
{


  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    pbackfail(int_type __c)
    {
      int_type __ret = traits_type::eof();
      if (this->eback() < this->gptr())
 {


   const bool __testeof = traits_type::eq_int_type(__c, __ret);
   if (!__testeof)
     {
       const bool __testeq = traits_type::eq(traits_type::
          to_char_type(__c),
          this->gptr()[-1]);
       const bool __testout = this->_M_mode & ios_base::out;
       if (__testeq || __testout)
  {
    this->gbump(-1);
    if (!__testeq)
      *this->gptr() = traits_type::to_char_type(__c);
    __ret = __c;
  }
     }
   else
     {
       this->gbump(-1);
       __ret = traits_type::not_eof(__c);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    overflow(int_type __c)
    {
      const bool __testout = this->_M_mode & ios_base::out;
      if (__builtin_expect(!__testout, false))
 return traits_type::eof();

      const bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());
      if (__builtin_expect(__testeof, false))
 return traits_type::not_eof(__c);

      const __size_type __capacity = _M_string.capacity();
      const __size_type __max_size = _M_string.max_size();
      const bool __testput = this->pptr() < this->epptr();
      if (__builtin_expect(!__testput && __capacity == __max_size, false))
 return traits_type::eof();



      const char_type __conv = traits_type::to_char_type(__c);
      if (!__testput)
 {
# 110 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/sstream.tcc" 3
   const __size_type __opt_len = std::max(__size_type(2 * __capacity),
       __size_type(512));
   const __size_type __len = std::min(__opt_len, __max_size);
   __string_type __tmp;
   __tmp.reserve(__len);
   if (this->pbase())
     __tmp.assign(this->pbase(), this->epptr() - this->pbase());
   __tmp.push_back(__conv);
   _M_string.swap(__tmp);
   _M_sync(const_cast<char_type*>(_M_string.data()),
    this->gptr() - this->eback(), this->pptr() - this->pbase());
 }
      else
 *this->pptr() = __conv;
      this->pbump(1);
      return __c;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::int_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    underflow()
    {
      int_type __ret = traits_type::eof();
      const bool __testin = this->_M_mode & ios_base::in;
      if (__testin)
 {

   _M_update_egptr();

   if (this->gptr() < this->egptr())
     __ret = traits_type::to_int_type(*this->gptr());
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;
      const bool __testboth = __testin && __testout && __way != ios_base::cur;
      __testin &= !(__mode & ios_base::out);
      __testout &= !(__mode & ios_base::in);



      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !__off) && (__testin || __testout || __testboth))
 {
   _M_update_egptr();

   off_type __newoffi = __off;
   off_type __newoffo = __newoffi;
   if (__way == ios_base::cur)
     {
       __newoffi += this->gptr() - __beg;
       __newoffo += this->pptr() - __beg;
     }
   else if (__way == ios_base::end)
     __newoffo = __newoffi += this->egptr() - __beg;

   if ((__testin || __testboth)
       && __newoffi >= 0
       && this->egptr() - __beg >= __newoffi)
     {
       this->setg(this->eback(), this->eback() + __newoffi,
    this->egptr());
       __ret = pos_type(__newoffi);
     }
   if ((__testout || __testboth)
       && __newoffo >= 0
       && this->egptr() - __beg >= __newoffo)
     {
       _M_pbump(this->pbase(), this->epptr(), __newoffo);
       __ret = pos_type(__newoffo);
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    typename basic_stringbuf<_CharT, _Traits, _Alloc>::pos_type
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    seekpos(pos_type __sp, ios_base::openmode __mode)
    {
      pos_type __ret = pos_type(off_type(-1));
      const bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;
      const bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;

      const char_type* __beg = __testin ? this->eback() : this->pbase();
      if ((__beg || !off_type(__sp)) && (__testin || __testout))
 {
   _M_update_egptr();

   const off_type __pos(__sp);
   const bool __testpos = (0 <= __pos
      && __pos <= this->egptr() - __beg);
   if (__testpos)
     {
       if (__testin)
  this->setg(this->eback(), this->eback() + __pos,
      this->egptr());
       if (__testout)
  _M_pbump(this->pbase(), this->epptr(), __pos);
       __ret = __sp;
     }
 }
      return __ret;
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_sync(char_type* __base, __size_type __i, __size_type __o)
    {
      const bool __testin = _M_mode & ios_base::in;
      const bool __testout = _M_mode & ios_base::out;
      char_type* __endg = __base + _M_string.size();
      char_type* __endp = __base + _M_string.capacity();

      if (__base != _M_string.data())
 {

   __endg += __i;
   __i = 0;
   __endp = __endg;
 }

      if (__testin)
 this->setg(__base, __base + __i, __endg);
      if (__testout)
 {
   _M_pbump(__base, __endp, __o);



   if (!__testin)
     this->setg(__endg, __endg, __endg);
 }
    }

  template <class _CharT, class _Traits, class _Alloc>
    void
    basic_stringbuf<_CharT, _Traits, _Alloc>::
    _M_pbump(char_type* __pbeg, char_type* __pend, off_type __off)
    {
      this->setp(__pbeg, __pend);
      while (__off > __gnu_cxx::__numeric_traits<int>::__max)
 {
   this->pbump(__gnu_cxx::__numeric_traits<int>::__max);
   __off -= __gnu_cxx::__numeric_traits<int>::__max;
 }
      this->pbump(__off);
    }




  extern template class basic_stringbuf<char>;
  extern template class basic_istringstream<char>;
  extern template class basic_ostringstream<char>;
  extern template class basic_stringstream<char>;


  extern template class basic_stringbuf<wchar_t>;
  extern template class basic_istringstream<wchar_t>;
  extern template class basic_ostringstream<wchar_t>;
  extern template class basic_stringstream<wchar_t>;




}
# 814 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/sstream" 2 3
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 1 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
       
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3

#pragma GCC visibility push(default)

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 49 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cxxabi_tweaks.h" 1 3
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cxxabi_tweaks.h" 3
namespace __cxxabiv1
{
  extern "C"
  {
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/cxxabi_tweaks.h" 3
  __extension__ typedef int __guard __attribute__((mode (__DI__)));


  typedef void __cxa_vec_ctor_return_type;


  typedef void __cxa_cdtor_return_type;


  }
}
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 2 3







namespace __cxxabiv1
{
  extern "C"
  {


  typedef __cxa_cdtor_return_type (*__cxa_cdtor_type)(void *);


  void*
  __cxa_vec_new(size_t __element_count, size_t __element_size,
  size_t __padding_size, __cxa_cdtor_type __constructor,
  __cxa_cdtor_type __destructor);

  void*
  __cxa_vec_new2(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*));

  void*
  __cxa_vec_new3(size_t __element_count, size_t __element_size,
   size_t __padding_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor, void *(*__alloc) (size_t),
   void (*__dealloc) (void*, size_t));


  __cxa_vec_ctor_return_type
  __cxa_vec_ctor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __constructor,
   __cxa_cdtor_type __destructor);

  __cxa_vec_ctor_return_type
  __cxa_vec_cctor(void* __dest_array, void* __src_array,
    size_t __element_count, size_t __element_size,
    __cxa_cdtor_return_type (*__constructor) (void*, void*),
    __cxa_cdtor_type __destructor);


  void
  __cxa_vec_dtor(void* __array_address, size_t __element_count,
   size_t __element_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_cleanup(void* __array_address, size_t __element_count, size_t __s,
      __cxa_cdtor_type __destructor) noexcept;


  void
  __cxa_vec_delete(void* __array_address, size_t __element_size,
     size_t __padding_size, __cxa_cdtor_type __destructor);

  void
  __cxa_vec_delete2(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*));

  void
  __cxa_vec_delete3(void* __array_address, size_t __element_size,
      size_t __padding_size, __cxa_cdtor_type __destructor,
      void (*__dealloc) (void*, size_t));

  int
  __cxa_guard_acquire(__guard*);

  void
  __cxa_guard_release(__guard*) noexcept;

  void
  __cxa_guard_abort(__guard*) noexcept;


  int
  __cxa_atexit(void (*)(void*), void*, void*) noexcept;

  int
  __cxa_finalize(void*);


  int
  __cxa_thread_atexit(void (*)(void*), void*, void *) noexcept;


  void
  __cxa_pure_virtual(void) __attribute__ ((__noreturn__));

  void
  __cxa_deleted_virtual(void) __attribute__ ((__noreturn__));


  void
  __cxa_bad_cast() __attribute__((__noreturn__));

  void
  __cxa_bad_typeid() __attribute__((__noreturn__));

  void
  __cxa_throw_bad_array_new_length() __attribute__((__noreturn__));
# 197 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  char*
  __cxa_demangle(const char* __mangled_name, char* __output_buffer,
   size_t* __length, int* __status);


  }
}






namespace __cxxabiv1
{

  class __fundamental_type_info : public std::type_info
  {
  public:
    explicit
    __fundamental_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__fundamental_type_info();
  };


  class __array_type_info : public std::type_info
  {
  public:
    explicit
    __array_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__array_type_info();
  };


  class __function_type_info : public std::type_info
  {
  public:
    explicit
    __function_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__function_type_info();

  protected:

    virtual bool
    __is_function_p() const;
  };


  class __enum_type_info : public std::type_info
  {
  public:
    explicit
    __enum_type_info(const char* __n) : std::type_info(__n) { }

    virtual
    ~__enum_type_info();
  };


  class __pbase_type_info : public std::type_info
  {
  public:
    unsigned int __flags;
    const std::type_info* __pointee;

    explicit
    __pbase_type_info(const char* __n, int __quals,
        const std::type_info* __type)
    : std::type_info(__n), __flags(__quals), __pointee(__type)
    { }

    virtual
    ~__pbase_type_info();


    enum __masks
      {
 __const_mask = 0x1,
 __volatile_mask = 0x2,
 __restrict_mask = 0x4,
 __incomplete_mask = 0x8,
 __incomplete_class_mask = 0x10,
 __transaction_safe_mask = 0x20
      };

  protected:
    __pbase_type_info(const __pbase_type_info&);

    __pbase_type_info&
    operator=(const __pbase_type_info&);


    virtual bool
    __do_catch(const std::type_info* __thr_type, void** __thr_obj,
        unsigned int __outer) const;

    inline virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  inline bool __pbase_type_info::
  __pointer_catch (const __pbase_type_info *thrown_type,
     void **thr_obj,
     unsigned outer) const
  {
    return __pointee->__do_catch (thrown_type->__pointee, thr_obj, outer + 2);
  }


  class __pointer_type_info : public __pbase_type_info
  {
  public:
    explicit
    __pointer_type_info(const char* __n, int __quals,
   const std::type_info* __type)
    : __pbase_type_info (__n, __quals, __type) { }


    virtual
    ~__pointer_type_info();

  protected:

    virtual bool
    __is_pointer_p() const;

    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };

  class __class_type_info;


  class __pointer_to_member_type_info : public __pbase_type_info
  {
  public:
    __class_type_info* __context;

    explicit
    __pointer_to_member_type_info(const char* __n, int __quals,
      const std::type_info* __type,
      __class_type_info* __klass)
    : __pbase_type_info(__n, __quals, __type), __context(__klass) { }

    virtual
    ~__pointer_to_member_type_info();

  protected:
    __pointer_to_member_type_info(const __pointer_to_member_type_info&);

    __pointer_to_member_type_info&
    operator=(const __pointer_to_member_type_info&);


    virtual bool
    __pointer_catch(const __pbase_type_info* __thr_type, void** __thr_obj,
      unsigned __outer) const;
  };


  class __base_class_type_info
  {
  public:
    const __class_type_info* __base_type;

    long long __offset_flags;




    enum __offset_flags_masks
      {
 __virtual_mask = 0x1,
 __public_mask = 0x2,
 __hwm_bit = 2,
 __offset_shift = 8
      };


    bool
    __is_virtual_p() const
    { return __offset_flags & __virtual_mask; }

    bool
    __is_public_p() const
    { return __offset_flags & __public_mask; }

    ptrdiff_t
    __offset() const
    {



      return static_cast<ptrdiff_t>(__offset_flags) >> __offset_shift;
    }
  };


  class __class_type_info : public std::type_info
  {
  public:
    explicit
    __class_type_info (const char *__n) : type_info(__n) { }

    virtual
    ~__class_type_info ();






    enum __sub_kind
      {

 __unknown = 0,



 __not_contained,


 __contained_ambig,


 __contained_virtual_mask = __base_class_type_info::__virtual_mask,


 __contained_public_mask = __base_class_type_info::__public_mask,


 __contained_mask = 1 << __base_class_type_info::__hwm_bit,

 __contained_private = __contained_mask,
 __contained_public = __contained_mask | __contained_public_mask
      };

    struct __upcast_result;
    struct __dyncast_result;

  protected:

    virtual bool
    __do_upcast(const __class_type_info* __dst_type, void**__obj_ptr) const;

    virtual bool
    __do_catch(const type_info* __thr_type, void** __thr_obj,
        unsigned __outer) const;

  public:


    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;







    inline __sub_kind
    __find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
        const __class_type_info* __src_type,
        const void* __src_ptr) const;
# 479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;





    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;
  };


  class __si_class_type_info : public __class_type_info
  {
  public:
    const __class_type_info* __base_type;

    explicit
    __si_class_type_info(const char *__n, const __class_type_info *__base)
    : __class_type_info(__n), __base_type(__base) { }

    virtual
    ~__si_class_type_info();

  protected:
    __si_class_type_info(const __si_class_type_info&);

    __si_class_type_info&
    operator=(const __si_class_type_info&);


    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __sub_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info*__dst, const void*__obj,
  __upcast_result& __restrict __result) const;
  };


  class __vmi_class_type_info : public __class_type_info
  {
  public:
    unsigned int __flags;
    unsigned int __base_count;




    __base_class_type_info __base_info[1];

    explicit
    __vmi_class_type_info(const char* __n, int ___flags)
    : __class_type_info(__n), __flags(___flags), __base_count(0) { }

    virtual
    ~__vmi_class_type_info();


    enum __flags_masks
      {
 __non_diamond_repeat_mask = 0x1,
 __diamond_shaped_mask = 0x2,
 __flags_unknown_mask = 0x10
      };

  protected:

    virtual bool
    __do_dyncast(ptrdiff_t __src2dst, __sub_kind __access_path,
   const __class_type_info* __dst_type, const void* __obj_ptr,
   const __class_type_info* __src_type, const void* __src_ptr,
   __dyncast_result& __result) const;

    virtual __sub_kind
    __do_find_public_src(ptrdiff_t __src2dst, const void* __obj_ptr,
    const __class_type_info* __src_type,
    const void* __src_ptr) const;

    virtual bool
    __do_upcast(const __class_type_info* __dst, const void* __obj,
  __upcast_result& __restrict __result) const;
  };


  struct __cxa_exception;
  struct __cxa_refcounted_exception;
  struct __cxa_dependent_exception;
  struct __cxa_eh_globals;

  extern "C"
  {
# 592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  void*
  __dynamic_cast(const void* __src_ptr,
   const __class_type_info* __src_type,
   const __class_type_info* __dst_type,
   ptrdiff_t __src2dst);
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  __cxa_eh_globals*
  __cxa_get_globals() noexcept __attribute__ ((__const__));

  __cxa_eh_globals*
  __cxa_get_globals_fast() noexcept __attribute__ ((__const__));


  void*
  __cxa_allocate_exception(size_t) noexcept;


  void
  __cxa_free_exception(void*) noexcept;


  void
  __cxa_throw(void*, std::type_info*, void ( *) (void *))
  __attribute__((__noreturn__));


  void*
  __cxa_get_exception_ptr(void*) noexcept __attribute__ ((__pure__));

  void*
  __cxa_begin_catch(void*) noexcept;

  void
  __cxa_end_catch();

  void
  __cxa_rethrow() __attribute__((__noreturn__));



  std::type_info*
  __cxa_current_exception_type() noexcept __attribute__ ((__pure__));




  __cxa_dependent_exception*
  __cxa_allocate_dependent_exception() noexcept;


  void
  __cxa_free_dependent_exception(__cxa_dependent_exception*) noexcept;

  }



  class __foreign_exception
  {
    virtual ~__foreign_exception() throw();
    virtual void __pure_dummy() = 0;
  };

}
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
namespace abi = __cxxabiv1;

namespace __gnu_cxx
{
# 700 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cxxabi.h" 3
  class recursive_init_error: public std::exception
  {
  public:
    recursive_init_error() throw() { }
    virtual ~recursive_init_error() throw ();
  };
}


#pragma GCC visibility pop
# 92 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 2 3

using std::abort;
using std::atexit;
using std::exit;
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 3
using std::div_t;
using std::ldiv_t;

using std::abs;
using std::atof;
using std::atoi;
using std::atol;
using std::bsearch;
using std::calloc;
using std::div;
using std::free;
using std::getenv;
using std::labs;
using std::ldiv;
using std::malloc;

using std::mblen;
using std::mbstowcs;
using std::mbtowc;

using std::qsort;
using std::rand;
using std::realloc;
using std::srand;
using std::strtod;
using std::strtol;
using std::strtoul;
using std::system;

using std::wcstombs;
using std::wctomb;
# 93 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h" 2



# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h"
namespace hls {

template<typename __STREAM_T__>
class stream
{
  protected:
    std::string _name;
    std::deque<__STREAM_T__> _data;





  public:


    stream() {
        static unsigned _counter = 1;
        std::stringstream ss;

        char* _demangle_name = abi::__cxa_demangle(typeid(*this).name(), 0, 0, 0);
        if (_demangle_name) {
            _name = _demangle_name;
            free(_demangle_name);
        }
        else {
            _name = "hls_stream";
        }




        ss << _counter++;
        _name += "." + ss.str();
    }

    stream(const std::string name) {


        _name = name;
    }


  private:
    stream(const stream< __STREAM_T__ >& chn):
        _name(chn._name), _data(chn._data) {
    }

    stream& operator = (const stream< __STREAM_T__ >& chn) {
        _name = chn._name;
        _data = chn._data;
        return *this;
    }

  public:

    void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:


    virtual ~stream() {
        if (!_data.empty())
        {
            std::cout << "WARNING: Hls::stream '"
                      << _name
                      << "' contains leftover data,"
                      << " which may result in RTL simulation hanging."
                      << std::endl;
        }
    }


    bool empty() {



        return _data.empty();
    }

    bool full() const { return false; }


    void read(__STREAM_T__& head) {
        head = read();
    }
# 202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_stream.h"
    __STREAM_T__ read() {
        __STREAM_T__ elem;




        if (_data.empty()) {
            std::cout << "WARNING: Hls::stream '"
                      << _name
                      << "' is read while empty,"
                      << " which may result in RTL simulation hanging."
                      << std::endl;
            elem = __STREAM_T__();
        } else {
            elem = _data.front();
            _data.pop_front();
        }
        return elem;
    }



    void write(const __STREAM_T__& tail) {



        _data.push_back(tail);



    }


    bool read_nb(__STREAM_T__& head) {



        bool is_empty = _data.empty();
        if (is_empty) {
            head = __STREAM_T__();
        } else {
            __STREAM_T__ elem(_data.front());
            _data.pop_front();
            head = elem;
        }
        return !is_empty;
    }


    bool write_nb(const __STREAM_T__& tail) {
        bool is_full = full();
        write(tail);
        return !is_full;
    }


    size_t size() {
        return _data.size();
    }
};

}
# 3 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3





# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
       
# 11 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3





# 15 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
struct _exception;

#pragma pack(push,_CRT_PACKING)
# 77 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
extern "C++" {
template <typename type1, typename type2> struct __mingw_types_compatible_p {
  static const bool result = false;
};

template <typename type1> struct __mingw_types_compatible_p<type1, type1> {
 static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<const type1, type1> {
  static const bool result = true;
};

template <typename type1> struct __mingw_types_compatible_p<type1, const type1> {
  static const bool result = true;
};
}
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
extern "C" {







  typedef union __mingw_dbl_type_t {
    double x;
    unsigned long long val;
    __extension__ struct {
      unsigned int low, high;
    } lh;
  } __mingw_dbl_type_t;

  typedef union __mingw_flt_type_t {
    float x;
    unsigned int val;
  } __mingw_flt_type_t;

  typedef union __mingw_ldbl_type_t
  {
    long double x;
    __extension__ struct {
      unsigned int low, high;
      int sign_exponent : 16;
      int res1 : 16;
      int res0 : 32;
    } lh;
  } __mingw_ldbl_type_t;

  typedef union __mingw_fp_types_t
  {
    long double *ld;
    double *d;
    float *f;
    __mingw_ldbl_type_t *ldt;
    __mingw_dbl_type_t *dt;
    __mingw_flt_type_t *ft;
  } __mingw_fp_types_t;




  extern double * __imp__HUGE;
# 168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  struct _exception {
    int type;
    const char *name;
    double arg1;
    double arg2;
    double retval;
  };

  void __mingw_raise_matherr (int typ, const char *name, double a1, double a2,
         double rslt);
  void __mingw_setusermatherr (int (__attribute__((__cdecl__)) *)(struct _exception *));
  __attribute__ ((__dllimport__)) void __setusermatherr(int (__attribute__((__cdecl__)) *)(struct _exception *));



  double __attribute__((__cdecl__)) sin(double _X);
  double __attribute__((__cdecl__)) cos(double _X);
  double __attribute__((__cdecl__)) tan(double _X);
  double __attribute__((__cdecl__)) sinh(double _X);
  double __attribute__((__cdecl__)) cosh(double _X);
  double __attribute__((__cdecl__)) tanh(double _X);
  double __attribute__((__cdecl__)) asin(double _X);
  double __attribute__((__cdecl__)) acos(double _X);
  double __attribute__((__cdecl__)) atan(double _X);
  double __attribute__((__cdecl__)) atan2(double _Y,double _X);
  double __attribute__((__cdecl__)) exp(double _X);
  double __attribute__((__cdecl__)) log(double _X);
  double __attribute__((__cdecl__)) log10(double _X);
  double __attribute__((__cdecl__)) pow(double _X,double _Y);
  double __attribute__((__cdecl__)) sqrt(double _X);
  double __attribute__((__cdecl__)) ceil(double _X);
  double __attribute__((__cdecl__)) floor(double _X);


  extern float __attribute__((__cdecl__)) fabsf (float x);
  extern long double __attribute__((__cdecl__)) fabsl (long double);
  extern double __attribute__((__cdecl__)) fabs (double _X);
# 243 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  double __attribute__((__cdecl__)) ldexp(double _X,int _Y);
  double __attribute__((__cdecl__)) frexp(double _X,int *_Y);
  double __attribute__((__cdecl__)) modf(double _X,double *_Y);
  double __attribute__((__cdecl__)) fmod(double _X,double _Y);

  void __attribute__((__cdecl__)) sincos (double __x, double *p_sin, double *p_cos);
  void __attribute__((__cdecl__)) sincosl (long double __x, long double *p_sin, long double *p_cos);
  void __attribute__((__cdecl__)) sincosf (float __x, float *p_sin, float *p_cos);
# 270 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  struct _complex {
    double x;
    double y;
  };


  double __attribute__((__cdecl__)) _cabs(struct _complex _ComplexA);
  double __attribute__((__cdecl__)) _hypot(double _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _j1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _jn(int _X,double _Y);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y0(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _y1(double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _yn(int _X,double _Y);


  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _matherr (struct _exception *);
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _chgsign (double _X);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _copysign (double _Number,double _Sign);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _logb (double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _nextafter (double, double);
  __attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) _scalb (double, long);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclass (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnan (double);






__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) j1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) jn (int, double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y0 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) y1 (double) ;
__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) yn (int, double) ;

__attribute__ ((__dllimport__)) double __attribute__((__cdecl__)) chgsign (double);
# 327 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) finite (double);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) fpclass (double);
# 372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
typedef float float_t;
typedef double double_t;
# 407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __fpclassifyl (long double);
  extern int __attribute__((__cdecl__)) __fpclassifyf (float);
  extern int __attribute__((__cdecl__)) __fpclassify (double);
# 520 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __isnan (double);
  extern int __attribute__((__cdecl__)) __isnanf (float);
  extern int __attribute__((__cdecl__)) __isnanl (long double);
# 607 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern int __attribute__((__cdecl__)) __signbit (double);
  extern int __attribute__((__cdecl__)) __signbitf (float);
  extern int __attribute__((__cdecl__)) __signbitl (long double);
# 664 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) sinf(float _X);
  extern long double __attribute__((__cdecl__)) sinl(long double);

  extern float __attribute__((__cdecl__)) cosf(float _X);
  extern long double __attribute__((__cdecl__)) cosl(long double);

  extern float __attribute__((__cdecl__)) tanf(float _X);
  extern long double __attribute__((__cdecl__)) tanl(long double);
  extern float __attribute__((__cdecl__)) asinf(float _X);
  extern long double __attribute__((__cdecl__)) asinl(long double);

  extern float __attribute__((__cdecl__)) acosf (float);
  extern long double __attribute__((__cdecl__)) acosl (long double);

  extern float __attribute__((__cdecl__)) atanf (float);
  extern long double __attribute__((__cdecl__)) atanl (long double);

  extern float __attribute__((__cdecl__)) atan2f (float, float);
  extern long double __attribute__((__cdecl__)) atan2l (long double, long double);


  extern float __attribute__((__cdecl__)) sinhf(float _X);



  extern long double __attribute__((__cdecl__)) sinhl(long double);

  extern float __attribute__((__cdecl__)) coshf(float _X);



  extern long double __attribute__((__cdecl__)) coshl(long double);

  extern float __attribute__((__cdecl__)) tanhf(float _X);



  extern long double __attribute__((__cdecl__)) tanhl(long double);



  extern double __attribute__((__cdecl__)) acosh (double);
  extern float __attribute__((__cdecl__)) acoshf (float);
  extern long double __attribute__((__cdecl__)) acoshl (long double);


  extern double __attribute__((__cdecl__)) asinh (double);
  extern float __attribute__((__cdecl__)) asinhf (float);
  extern long double __attribute__((__cdecl__)) asinhl (long double);


  extern double __attribute__((__cdecl__)) atanh (double);
  extern float __attribute__((__cdecl__)) atanhf (float);
  extern long double __attribute__((__cdecl__)) atanhl (long double);



  extern float __attribute__((__cdecl__)) expf(float _X);



  extern long double __attribute__((__cdecl__)) expl(long double);


  extern double __attribute__((__cdecl__)) exp2(double);
  extern float __attribute__((__cdecl__)) exp2f(float);
  extern long double __attribute__((__cdecl__)) exp2l(long double);



  extern double __attribute__((__cdecl__)) expm1(double);
  extern float __attribute__((__cdecl__)) expm1f(float);
  extern long double __attribute__((__cdecl__)) expm1l(long double);


  extern float frexpf(float _X,int *_Y);



  extern long double __attribute__((__cdecl__)) frexpl(long double,int *);




  extern int __attribute__((__cdecl__)) ilogb (double);
  extern int __attribute__((__cdecl__)) ilogbf (float);
  extern int __attribute__((__cdecl__)) ilogbl (long double);


  extern float __attribute__((__cdecl__)) ldexpf(float _X,int _Y);



  extern long double __attribute__((__cdecl__)) ldexpl (long double, int);


  extern float __attribute__((__cdecl__)) logf (float);
  extern long double __attribute__((__cdecl__)) logl(long double);


  extern float __attribute__((__cdecl__)) log10f (float);
  extern long double __attribute__((__cdecl__)) log10l(long double);


  extern double __attribute__((__cdecl__)) log1p(double);
  extern float __attribute__((__cdecl__)) log1pf(float);
  extern long double __attribute__((__cdecl__)) log1pl(long double);


  extern double __attribute__((__cdecl__)) log2 (double);
  extern float __attribute__((__cdecl__)) log2f (float);
  extern long double __attribute__((__cdecl__)) log2l (long double);


  extern double __attribute__((__cdecl__)) logb (double);
  extern float __attribute__((__cdecl__)) logbf (float);
  extern long double __attribute__((__cdecl__)) logbl (long double);
# 863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern float __attribute__((__cdecl__)) modff (float, float*);
  extern long double __attribute__((__cdecl__)) modfl (long double, long double*);


  extern double __attribute__((__cdecl__)) scalbn (double, int);
  extern float __attribute__((__cdecl__)) scalbnf (float, int);
  extern long double __attribute__((__cdecl__)) scalbnl (long double, int);

  extern double __attribute__((__cdecl__)) scalbln (double, long);
  extern float __attribute__((__cdecl__)) scalblnf (float, long);
  extern long double __attribute__((__cdecl__)) scalblnl (long double, long);



  extern double __attribute__((__cdecl__)) cbrt (double);
  extern float __attribute__((__cdecl__)) cbrtf (float);
  extern long double __attribute__((__cdecl__)) cbrtl (long double);


  extern double __attribute__((__cdecl__)) hypot (double, double) ;
  extern float __attribute__((__cdecl__)) hypotf (float x, float y);



  extern long double __attribute__((__cdecl__)) hypotl (long double, long double);


  extern float __attribute__((__cdecl__)) powf(float _X,float _Y);



  extern long double __attribute__((__cdecl__)) powl (long double, long double);


  extern float __attribute__((__cdecl__)) sqrtf (float);
  extern long double sqrtl(long double);


  extern double __attribute__((__cdecl__)) erf (double);
  extern float __attribute__((__cdecl__)) erff (float);
  extern long double __attribute__((__cdecl__)) erfl (long double);


  extern double __attribute__((__cdecl__)) erfc (double);
  extern float __attribute__((__cdecl__)) erfcf (float);
  extern long double __attribute__((__cdecl__)) erfcl (long double);


  extern double __attribute__((__cdecl__)) lgamma (double);
  extern float __attribute__((__cdecl__)) lgammaf (float);
  extern long double __attribute__((__cdecl__)) lgammal (long double);

  extern int signgam;


  extern double __attribute__((__cdecl__)) tgamma (double);
  extern float __attribute__((__cdecl__)) tgammaf (float);
  extern long double __attribute__((__cdecl__)) tgammal (long double);


  extern float __attribute__((__cdecl__)) ceilf (float);
  extern long double __attribute__((__cdecl__)) ceill (long double);


  extern float __attribute__((__cdecl__)) floorf (float);
  extern long double __attribute__((__cdecl__)) floorl (long double);


  extern double __attribute__((__cdecl__)) nearbyint ( double);
  extern float __attribute__((__cdecl__)) nearbyintf (float);
  extern long double __attribute__((__cdecl__)) nearbyintl (long double);



extern double __attribute__((__cdecl__)) rint (double);
extern float __attribute__((__cdecl__)) rintf (float);
extern long double __attribute__((__cdecl__)) rintl (long double);


extern long __attribute__((__cdecl__)) lrint (double);
extern long __attribute__((__cdecl__)) lrintf (float);
extern long __attribute__((__cdecl__)) lrintl (long double);

__extension__ long long __attribute__((__cdecl__)) llrint (double);
__extension__ long long __attribute__((__cdecl__)) llrintf (float);
__extension__ long long __attribute__((__cdecl__)) llrintl (long double);
# 1030 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) round (double);
  extern float __attribute__((__cdecl__)) roundf (float);
  extern long double __attribute__((__cdecl__)) roundl (long double);


  extern long __attribute__((__cdecl__)) lround (double);
  extern long __attribute__((__cdecl__)) lroundf (float);
  extern long __attribute__((__cdecl__)) lroundl (long double);
  __extension__ long long __attribute__((__cdecl__)) llround (double);
  __extension__ long long __attribute__((__cdecl__)) llroundf (float);
  __extension__ long long __attribute__((__cdecl__)) llroundl (long double);



  extern double __attribute__((__cdecl__)) trunc (double);
  extern float __attribute__((__cdecl__)) truncf (float);
  extern long double __attribute__((__cdecl__)) truncl (long double);


  extern float __attribute__((__cdecl__)) fmodf (float, float);
  extern long double __attribute__((__cdecl__)) fmodl (long double, long double);


  extern double __attribute__((__cdecl__)) remainder (double, double);
  extern float __attribute__((__cdecl__)) remainderf (float, float);
  extern long double __attribute__((__cdecl__)) remainderl (long double, long double);


  extern double __attribute__((__cdecl__)) remquo(double, double, int *);
  extern float __attribute__((__cdecl__)) remquof(float, float, int *);
  extern long double __attribute__((__cdecl__)) remquol(long double, long double, int *);


  extern double __attribute__((__cdecl__)) copysign (double, double);
  extern float __attribute__((__cdecl__)) copysignf (float, float);
  extern long double __attribute__((__cdecl__)) copysignl (long double, long double);
# 1087 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nan(const char *tagp);
  extern float __attribute__((__cdecl__)) nanf(const char *tagp);
  extern long double __attribute__((__cdecl__)) nanl(const char *tagp);
# 1098 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
  extern double __attribute__((__cdecl__)) nextafter (double, double);
  extern float __attribute__((__cdecl__)) nextafterf (float, float);
  extern long double __attribute__((__cdecl__)) nextafterl (long double, long double);


  extern double __attribute__((__cdecl__)) nexttoward (double, long double);
  extern float __attribute__((__cdecl__)) nexttowardf (float, long double);
  extern long double __attribute__((__cdecl__)) nexttowardl (long double, long double);



  extern double __attribute__((__cdecl__)) fdim (double x, double y);
  extern float __attribute__((__cdecl__)) fdimf (float x, float y);
  extern long double __attribute__((__cdecl__)) fdiml (long double x, long double y);







  extern double __attribute__((__cdecl__)) fmax (double, double);
  extern float __attribute__((__cdecl__)) fmaxf (float, float);
  extern long double __attribute__((__cdecl__)) fmaxl (long double, long double);


  extern double __attribute__((__cdecl__)) fmin (double, double);
  extern float __attribute__((__cdecl__)) fminf (float, float);
  extern long double __attribute__((__cdecl__)) fminl (long double, long double);



  extern double __attribute__((__cdecl__)) fma (double, double, double);
  extern float __attribute__((__cdecl__)) fmaf (float, float, float);
  extern long double __attribute__((__cdecl__)) fmal (long double, long double, long double);
# 1181 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _copysignf (float _Number,float _Sign);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _chgsignf (float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _logbf(float _X);
   __attribute__ ((__dllimport__)) float __attribute__((__cdecl__)) _nextafterf(float _X,float _Y);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _finitef(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _isnanf(float _X);
   __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _fpclassf(float _X);



   extern long double __attribute__((__cdecl__)) _chgsignl (long double);
# 1576 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/math.h" 3
}




#pragma pack(pop)
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 2 3
# 77 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
extern "C++"
{
namespace std
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 435 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 559 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
namespace std
{





  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x0100, (0x0100 | 0x0400), 0x0400,
    (0x0400 | 0x4000), 0x4000, __x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x0400 : 0x4000; }


  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }


  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }





  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }


  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }


  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }





  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }


  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }


  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }



  constexpr bool
  signbit(float __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbit(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }


  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }


  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }


  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }


  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }


  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 956 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3

}
# 1072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
namespace std
{



  using ::double_t;
  using ::float_t;


  using ::acosh;
  using ::acoshf;
  using ::acoshl;

  using ::asinh;
  using ::asinhf;
  using ::asinhl;

  using ::atanh;
  using ::atanhf;
  using ::atanhl;

  using ::cbrt;
  using ::cbrtf;
  using ::cbrtl;

  using ::copysign;
  using ::copysignf;
  using ::copysignl;

  using ::erf;
  using ::erff;
  using ::erfl;

  using ::erfc;
  using ::erfcf;
  using ::erfcl;

  using ::exp2;
  using ::exp2f;
  using ::exp2l;

  using ::expm1;
  using ::expm1f;
  using ::expm1l;

  using ::fdim;
  using ::fdimf;
  using ::fdiml;

  using ::fma;
  using ::fmaf;
  using ::fmal;

  using ::fmax;
  using ::fmaxf;
  using ::fmaxl;

  using ::fmin;
  using ::fminf;
  using ::fminl;

  using ::hypot;
  using ::hypotf;
  using ::hypotl;

  using ::ilogb;
  using ::ilogbf;
  using ::ilogbl;

  using ::lgamma;
  using ::lgammaf;
  using ::lgammal;

  using ::llrint;
  using ::llrintf;
  using ::llrintl;

  using ::llround;
  using ::llroundf;
  using ::llroundl;

  using ::log1p;
  using ::log1pf;
  using ::log1pl;

  using ::log2;
  using ::log2f;
  using ::log2l;

  using ::logb;
  using ::logbf;
  using ::logbl;

  using ::lrint;
  using ::lrintf;
  using ::lrintl;

  using ::lround;
  using ::lroundf;
  using ::lroundl;

  using ::nan;
  using ::nanf;
  using ::nanl;

  using ::nearbyint;
  using ::nearbyintf;
  using ::nearbyintl;

  using ::nextafter;
  using ::nextafterf;
  using ::nextafterl;

  using ::nexttoward;
  using ::nexttowardf;
  using ::nexttowardl;

  using ::remainder;
  using ::remainderf;
  using ::remainderl;

  using ::remquo;
  using ::remquof;
  using ::remquol;

  using ::rint;
  using ::rintf;
  using ::rintl;

  using ::round;
  using ::roundf;
  using ::roundl;

  using ::scalbln;
  using ::scalblnf;
  using ::scalblnl;

  using ::scalbn;
  using ::scalbnf;
  using ::scalbnl;

  using ::tgamma;
  using ::tgammaf;
  using ::tgammal;

  using ::trunc;
  using ::truncf;
  using ::truncl;



  constexpr float
  acosh(float __x)
  { return __builtin_acoshf(__x); }

  constexpr long double
  acosh(long double __x)
  { return __builtin_acoshl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    acosh(_Tp __x)
    { return __builtin_acosh(__x); }


  constexpr float
  asinh(float __x)
  { return __builtin_asinhf(__x); }

  constexpr long double
  asinh(long double __x)
  { return __builtin_asinhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    asinh(_Tp __x)
    { return __builtin_asinh(__x); }


  constexpr float
  atanh(float __x)
  { return __builtin_atanhf(__x); }

  constexpr long double
  atanh(long double __x)
  { return __builtin_atanhl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    atanh(_Tp __x)
    { return __builtin_atanh(__x); }


  constexpr float
  cbrt(float __x)
  { return __builtin_cbrtf(__x); }

  constexpr long double
  cbrt(long double __x)
  { return __builtin_cbrtl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    cbrt(_Tp __x)
    { return __builtin_cbrt(__x); }


  constexpr float
  copysign(float __x, float __y)
  { return __builtin_copysignf(__x, __y); }

  constexpr long double
  copysign(long double __x, long double __y)
  { return __builtin_copysignl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    copysign(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return copysign(__type(__x), __type(__y));
    }


  constexpr float
  erf(float __x)
  { return __builtin_erff(__x); }

  constexpr long double
  erf(long double __x)
  { return __builtin_erfl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erf(_Tp __x)
    { return __builtin_erf(__x); }


  constexpr float
  erfc(float __x)
  { return __builtin_erfcf(__x); }

  constexpr long double
  erfc(long double __x)
  { return __builtin_erfcl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    erfc(_Tp __x)
    { return __builtin_erfc(__x); }


  constexpr float
  exp2(float __x)
  { return __builtin_exp2f(__x); }

  constexpr long double
  exp2(long double __x)
  { return __builtin_exp2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    exp2(_Tp __x)
    { return __builtin_exp2(__x); }


  constexpr float
  expm1(float __x)
  { return __builtin_expm1f(__x); }

  constexpr long double
  expm1(long double __x)
  { return __builtin_expm1l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    expm1(_Tp __x)
    { return __builtin_expm1(__x); }


  constexpr float
  fdim(float __x, float __y)
  { return __builtin_fdimf(__x, __y); }

  constexpr long double
  fdim(long double __x, long double __y)
  { return __builtin_fdiml(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fdim(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fdim(__type(__x), __type(__y));
    }


  constexpr float
  fma(float __x, float __y, float __z)
  { return __builtin_fmaf(__x, __y, __z); }

  constexpr long double
  fma(long double __x, long double __y, long double __z)
  { return __builtin_fmal(__x, __y, __z); }


  template<typename _Tp, typename _Up, typename _Vp>
    constexpr typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type
    fma(_Tp __x, _Up __y, _Vp __z)
    {
      typedef typename __gnu_cxx::__promote_3<_Tp, _Up, _Vp>::__type __type;
      return fma(__type(__x), __type(__y), __type(__z));
    }


  constexpr float
  fmax(float __x, float __y)
  { return __builtin_fmaxf(__x, __y); }

  constexpr long double
  fmax(long double __x, long double __y)
  { return __builtin_fmaxl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmax(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmax(__type(__x), __type(__y));
    }


  constexpr float
  fmin(float __x, float __y)
  { return __builtin_fminf(__x, __y); }

  constexpr long double
  fmin(long double __x, long double __y)
  { return __builtin_fminl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmin(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmin(__type(__x), __type(__y));
    }


  constexpr float
  hypot(float __x, float __y)
  { return __builtin_hypotf(__x, __y); }

  constexpr long double
  hypot(long double __x, long double __y)
  { return __builtin_hypotl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    hypot(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return hypot(__type(__x), __type(__y));
    }


  constexpr int
  ilogb(float __x)
  { return __builtin_ilogbf(__x); }

  constexpr int
  ilogb(long double __x)
  { return __builtin_ilogbl(__x); }


  template<typename _Tp>
    constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    int>::__type
    ilogb(_Tp __x)
    { return __builtin_ilogb(__x); }


  constexpr float
  lgamma(float __x)
  { return __builtin_lgammaf(__x); }

  constexpr long double
  lgamma(long double __x)
  { return __builtin_lgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    lgamma(_Tp __x)
    { return __builtin_lgamma(__x); }


  constexpr long long
  llrint(float __x)
  { return __builtin_llrintf(__x); }

  constexpr long long
  llrint(long double __x)
  { return __builtin_llrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llrint(_Tp __x)
    { return __builtin_llrint(__x); }


  constexpr long long
  llround(float __x)
  { return __builtin_llroundf(__x); }

  constexpr long long
  llround(long double __x)
  { return __builtin_llroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long long>::__type
    llround(_Tp __x)
    { return __builtin_llround(__x); }


  constexpr float
  log1p(float __x)
  { return __builtin_log1pf(__x); }

  constexpr long double
  log1p(long double __x)
  { return __builtin_log1pl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log1p(_Tp __x)
    { return __builtin_log1p(__x); }



  constexpr float
  log2(float __x)
  { return __builtin_log2f(__x); }

  constexpr long double
  log2(long double __x)
  { return __builtin_log2l(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    log2(_Tp __x)
    { return __builtin_log2(__x); }


  constexpr float
  logb(float __x)
  { return __builtin_logbf(__x); }

  constexpr long double
  logb(long double __x)
  { return __builtin_logbl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    logb(_Tp __x)
    { return __builtin_logb(__x); }


  constexpr long
  lrint(float __x)
  { return __builtin_lrintf(__x); }

  constexpr long
  lrint(long double __x)
  { return __builtin_lrintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lrint(_Tp __x)
    { return __builtin_lrint(__x); }


  constexpr long
  lround(float __x)
  { return __builtin_lroundf(__x); }

  constexpr long
  lround(long double __x)
  { return __builtin_lroundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              long>::__type
    lround(_Tp __x)
    { return __builtin_lround(__x); }


  constexpr float
  nearbyint(float __x)
  { return __builtin_nearbyintf(__x); }

  constexpr long double
  nearbyint(long double __x)
  { return __builtin_nearbyintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nearbyint(_Tp __x)
    { return __builtin_nearbyint(__x); }


  constexpr float
  nextafter(float __x, float __y)
  { return __builtin_nextafterf(__x, __y); }

  constexpr long double
  nextafter(long double __x, long double __y)
  { return __builtin_nextafterl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    nextafter(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return nextafter(__type(__x), __type(__y));
    }


  constexpr float
  nexttoward(float __x, long double __y)
  { return __builtin_nexttowardf(__x, __y); }

  constexpr long double
  nexttoward(long double __x, long double __y)
  { return __builtin_nexttowardl(__x, __y); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    nexttoward(_Tp __x, long double __y)
    { return __builtin_nexttoward(__x, __y); }


  constexpr float
  remainder(float __x, float __y)
  { return __builtin_remainderf(__x, __y); }

  constexpr long double
  remainder(long double __x, long double __y)
  { return __builtin_remainderl(__x, __y); }


  template<typename _Tp, typename _Up>
    constexpr typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remainder(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remainder(__type(__x), __type(__y));
    }


  inline float
  remquo(float __x, float __y, int* __pquo)
  { return __builtin_remquof(__x, __y, __pquo); }

  inline long double
  remquo(long double __x, long double __y, int* __pquo)
  { return __builtin_remquol(__x, __y, __pquo); }


  template<typename _Tp, typename _Up>
    inline typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    remquo(_Tp __x, _Up __y, int* __pquo)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return remquo(__type(__x), __type(__y), __pquo);
    }


  constexpr float
  rint(float __x)
  { return __builtin_rintf(__x); }

  constexpr long double
  rint(long double __x)
  { return __builtin_rintl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    rint(_Tp __x)
    { return __builtin_rint(__x); }


  constexpr float
  round(float __x)
  { return __builtin_roundf(__x); }

  constexpr long double
  round(long double __x)
  { return __builtin_roundl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    round(_Tp __x)
    { return __builtin_round(__x); }


  constexpr float
  scalbln(float __x, long __ex)
  { return __builtin_scalblnf(__x, __ex); }

  constexpr long double
  scalbln(long double __x, long __ex)
  { return __builtin_scalblnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbln(_Tp __x, long __ex)
    { return __builtin_scalbln(__x, __ex); }


  constexpr float
  scalbn(float __x, int __ex)
  { return __builtin_scalbnf(__x, __ex); }

  constexpr long double
  scalbn(long double __x, int __ex)
  { return __builtin_scalbnl(__x, __ex); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    scalbn(_Tp __x, int __ex)
    { return __builtin_scalbn(__x, __ex); }


  constexpr float
  tgamma(float __x)
  { return __builtin_tgammaf(__x); }

  constexpr long double
  tgamma(long double __x)
  { return __builtin_tgammal(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    tgamma(_Tp __x)
    { return __builtin_tgamma(__x); }


  constexpr float
  trunc(float __x)
  { return __builtin_truncf(__x); }

  constexpr long double
  trunc(long double __x)
  { return __builtin_truncl(__x); }


  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              double>::__type
    trunc(_Tp __x)
    { return __builtin_trunc(__x); }


}
# 1797 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
}
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 2 3





namespace std
{

# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp> class complex;
  template<> class complex<float>;
  template<> class complex<double>;
  template<> class complex<long double>;


  template<typename _Tp> _Tp abs(const complex<_Tp>&);

  template<typename _Tp> _Tp arg(const complex<_Tp>&);

  template<typename _Tp> _Tp norm(const complex<_Tp>&);


  template<typename _Tp> complex<_Tp> conj(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> polar(const _Tp&, const _Tp& = 0);



  template<typename _Tp> complex<_Tp> cos(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> cosh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> exp(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> log10(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, int);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&, const _Tp&);

  template<typename _Tp> complex<_Tp> pow(const complex<_Tp>&,
                                          const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> pow(const _Tp&, const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sin(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sinh(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> sqrt(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tan(const complex<_Tp>&);

  template<typename _Tp> complex<_Tp> tanh(const complex<_Tp>&);
# 121 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    struct complex
    {

      typedef _Tp value_type;



      constexpr complex(const _Tp& __r = _Tp(), const _Tp& __i = _Tp())
      : _M_real(__r), _M_imag(__i) { }



      constexpr complex(const complex&) = default;



      template<typename _Up>
        constexpr complex(const complex<_Up>& __z)
 : _M_real(__z.real()), _M_imag(__z.imag()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      real() const { return _M_real; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr _Tp
      imag() const { return _M_imag; }
# 172 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(_Tp __val) { _M_real = __val; }

      void
      imag(_Tp __val) { _M_imag = __val; }


      complex<_Tp>& operator=(const _Tp&);



      complex<_Tp>&
      operator+=(const _Tp& __t)
      {
 _M_real += __t;
 return *this;
      }



      complex<_Tp>&
      operator-=(const _Tp& __t)
      {
 _M_real -= __t;
 return *this;
      }


      complex<_Tp>& operator*=(const _Tp&);

      complex<_Tp>& operator/=(const _Tp&);



      complex& operator=(const complex&) = default;



      template<typename _Up>
        complex<_Tp>& operator=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator+=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator-=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator*=(const complex<_Up>&);

      template<typename _Up>
        complex<_Tp>& operator/=(const complex<_Up>&);

      constexpr complex __rep() const
      { return *this; }

    private:
      _Tp _M_real;
      _Tp _M_imag;
    };

  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator=(const _Tp& __t)
    {
     _M_real = __t;
     _M_imag = _Tp();
     return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator*=(const _Tp& __t)
    {
      _M_real *= __t;
      _M_imag *= __t;
      return *this;
    }


  template<typename _Tp>
    complex<_Tp>&
    complex<_Tp>::operator/=(const _Tp& __t)
    {
      _M_real /= __t;
      _M_imag /= __t;
      return *this;
    }

  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator=(const complex<_Up>& __z)
    {
      _M_real = __z.real();
      _M_imag = __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator+=(const complex<_Up>& __z)
    {
      _M_real += __z.real();
      _M_imag += __z.imag();
      return *this;
    }


  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator-=(const complex<_Up>& __z)
    {
      _M_real -= __z.real();
      _M_imag -= __z.imag();
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator*=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
      _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
      _M_real = __r;
      return *this;
    }



  template<typename _Tp>
    template<typename _Up>
    complex<_Tp>&
    complex<_Tp>::operator/=(const complex<_Up>& __z)
    {
      const _Tp __r = _M_real * __z.real() + _M_imag * __z.imag();
      const _Tp __n = std::norm(__z);
      _M_imag = (_M_imag * __z.real() - _M_real * __z.imag()) / __n;
      _M_real = __r / __n;
      return *this;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r += __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator+(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r += __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r -= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator-(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r(__x, -__y.imag());
      __r -= __y.real();
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r *= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator*(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __y;
      __r *= __x;
      return __r;
    }




  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const complex<_Tp>& __x, const _Tp& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }

  template<typename _Tp>
    inline complex<_Tp>
    operator/(const _Tp& __x, const complex<_Tp>& __y)
    {
      complex<_Tp> __r = __x;
      __r /= __y;
      return __r;
    }



  template<typename _Tp>
    inline complex<_Tp>
    operator+(const complex<_Tp>& __x)
    { return __x; }


  template<typename _Tp>
    inline complex<_Tp>
    operator-(const complex<_Tp>& __x)
    { return complex<_Tp>(-__x.real(), -__x.imag()); }



  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() == __y.real() && __x.imag() == __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() == __y && __x.imag() == _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator==(const _Tp& __x, const complex<_Tp>& __y)
    { return __x == __y.real() && _Tp() == __y.imag(); }




  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x.real() != __y.real() || __x.imag() != __y.imag(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const complex<_Tp>& __x, const _Tp& __y)
    { return __x.real() != __y || __x.imag() != _Tp(); }

  template<typename _Tp>
    inline constexpr bool
    operator!=(const _Tp& __x, const complex<_Tp>& __y)
    { return __x != __y.real() || _Tp() != __y.imag(); }



  template<typename _Tp, typename _CharT, class _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, complex<_Tp>& __x)
    {
      _Tp __re_x, __im_x;
      _CharT __ch;
      __is >> __ch;
      if (__ch == '(')
 {
   __is >> __re_x >> __ch;
   if (__ch == ',')
     {
       __is >> __im_x >> __ch;
       if (__ch == ')')
  __x = complex<_Tp>(__re_x, __im_x);
       else
  __is.setstate(ios_base::failbit);
     }
   else if (__ch == ')')
     __x = __re_x;
   else
     __is.setstate(ios_base::failbit);
 }
      else
 {
   __is.putback(__ch);
   __is >> __re_x;
   __x = __re_x;
 }
      return __is;
    }


  template<typename _Tp, typename _CharT, class _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, const complex<_Tp>& __x)
    {
      basic_ostringstream<_CharT, _Traits> __s;
      __s.flags(__os.flags());
      __s.imbue(__os.getloc());
      __s.precision(__os.precision());
      __s << '(' << __x.real() << ',' << __x.imag() << ')';
      return __os << __s.str();
    }



  template<typename _Tp>
    constexpr _Tp
    real(const complex<_Tp>& __z)
    { return __z.real(); }

  template<typename _Tp>
    constexpr _Tp
    imag(const complex<_Tp>& __z)
    { return __z.imag(); }
# 570 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_abs(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();
      const _Tp __s = std::max(abs(__x), abs(__y));
      if (__s == _Tp())
        return __s;
      __x /= __s;
      __y /= __s;
      return __s * sqrt(__x * __x + __y * __y);
    }


  inline float
  __complex_abs(__complex__ float __z) { return __builtin_cabsf(__z); }

  inline double
  __complex_abs(__complex__ double __z) { return __builtin_cabs(__z); }

  inline long double
  __complex_abs(const __complex__ long double& __z)
  { return __builtin_cabsl(__z); }

  template<typename _Tp>
    inline _Tp
    abs(const complex<_Tp>& __z) { return __complex_abs(__z.__rep()); }
# 606 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline _Tp
    __complex_arg(const complex<_Tp>& __z)
    { return atan2(__z.imag(), __z.real()); }


  inline float
  __complex_arg(__complex__ float __z) { return __builtin_cargf(__z); }

  inline double
  __complex_arg(__complex__ double __z) { return __builtin_carg(__z); }

  inline long double
  __complex_arg(const __complex__ long double& __z)
  { return __builtin_cargl(__z); }

  template<typename _Tp>
    inline _Tp
    arg(const complex<_Tp>& __z) { return __complex_arg(__z.__rep()); }
# 636 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<bool>
    struct _Norm_helper
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          const _Tp __x = __z.real();
          const _Tp __y = __z.imag();
          return __x * __x + __y * __y;
        }
    };

  template<>
    struct _Norm_helper<true>
    {
      template<typename _Tp>
        static inline _Tp _S_do_it(const complex<_Tp>& __z)
        {
          _Tp __res = std::abs(__z);
          return __res * __res;
        }
    };

  template<typename _Tp>
    inline _Tp
    norm(const complex<_Tp>& __z)
    {
      return _Norm_helper<__is_floating<_Tp>::__value
 && !0>::_S_do_it(__z);
    }

  template<typename _Tp>
    inline complex<_Tp>
    polar(const _Tp& __rho, const _Tp& __theta)
    {
      ;
      return complex<_Tp>(__rho * cos(__theta), __rho * sin(__theta));
    }

  template<typename _Tp>
    inline complex<_Tp>
    conj(const complex<_Tp>& __z)
    { return complex<_Tp>(__z.real(), -__z.imag()); }




  template<typename _Tp>
    inline complex<_Tp>
    __complex_cos(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cos(__x) * cosh(__y), -sin(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_cos(__complex__ float __z) { return __builtin_ccosf(__z); }

  inline __complex__ double
  __complex_cos(__complex__ double __z) { return __builtin_ccos(__z); }

  inline __complex__ long double
  __complex_cos(const __complex__ long double& __z)
  { return __builtin_ccosl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cos(const complex<_Tp>& __z) { return __complex_cos(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_cosh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(cosh(__x) * cos(__y), sinh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_cosh(__complex__ float __z) { return __builtin_ccoshf(__z); }

  inline __complex__ double
  __complex_cosh(__complex__ double __z) { return __builtin_ccosh(__z); }

  inline __complex__ long double
  __complex_cosh(const __complex__ long double& __z)
  { return __builtin_ccoshl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    cosh(const complex<_Tp>& __z) { return __complex_cosh(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_exp(const complex<_Tp>& __z)
    { return std::polar<_Tp>(exp(__z.real()), __z.imag()); }


  inline __complex__ float
  __complex_exp(__complex__ float __z) { return __builtin_cexpf(__z); }

  inline __complex__ double
  __complex_exp(__complex__ double __z) { return __builtin_cexp(__z); }

  inline __complex__ long double
  __complex_exp(const __complex__ long double& __z)
  { return __builtin_cexpl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    exp(const complex<_Tp>& __z) { return __complex_exp(__z.__rep()); }
# 770 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_log(const complex<_Tp>& __z)
    { return complex<_Tp>(log(std::abs(__z)), std::arg(__z)); }


  inline __complex__ float
  __complex_log(__complex__ float __z) { return __builtin_clogf(__z); }

  inline __complex__ double
  __complex_log(__complex__ double __z) { return __builtin_clog(__z); }

  inline __complex__ long double
  __complex_log(const __complex__ long double& __z)
  { return __builtin_clogl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    log(const complex<_Tp>& __z) { return __complex_log(__z.__rep()); }






  template<typename _Tp>
    inline complex<_Tp>
    log10(const complex<_Tp>& __z)
    { return std::log(__z) / log(_Tp(10.0)); }


  template<typename _Tp>
    inline complex<_Tp>
    __complex_sin(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sin(__x) * cosh(__y), cos(__x) * sinh(__y));
    }


  inline __complex__ float
  __complex_sin(__complex__ float __z) { return __builtin_csinf(__z); }

  inline __complex__ double
  __complex_sin(__complex__ double __z) { return __builtin_csin(__z); }

  inline __complex__ long double
  __complex_sin(const __complex__ long double& __z)
  { return __builtin_csinl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sin(const complex<_Tp>& __z) { return __complex_sin(__z.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    __complex_sinh(const complex<_Tp>& __z)
    {
      const _Tp __x = __z.real();
      const _Tp __y = __z.imag();
      return complex<_Tp>(sinh(__x) * cos(__y), cosh(__x) * sin(__y));
    }


  inline __complex__ float
  __complex_sinh(__complex__ float __z) { return __builtin_csinhf(__z); }

  inline __complex__ double
  __complex_sinh(__complex__ double __z) { return __builtin_csinh(__z); }

  inline __complex__ long double
  __complex_sinh(const __complex__ long double& __z)
  { return __builtin_csinhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sinh(const complex<_Tp>& __z) { return __complex_sinh(__z.__rep()); }
# 862 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_sqrt(const complex<_Tp>& __z)
    {
      _Tp __x = __z.real();
      _Tp __y = __z.imag();

      if (__x == _Tp())
        {
          _Tp __t = sqrt(abs(__y) / 2);
          return complex<_Tp>(__t, __y < _Tp() ? -__t : __t);
        }
      else
        {
          _Tp __t = sqrt(2 * (std::abs(__z) + abs(__x)));
          _Tp __u = __t / 2;
          return __x > _Tp()
            ? complex<_Tp>(__u, __y / __t)
            : complex<_Tp>(abs(__y) / __t, __y < _Tp() ? -__u : __u);
        }
    }


  inline __complex__ float
  __complex_sqrt(__complex__ float __z) { return __builtin_csqrtf(__z); }

  inline __complex__ double
  __complex_sqrt(__complex__ double __z) { return __builtin_csqrt(__z); }

  inline __complex__ long double
  __complex_sqrt(const __complex__ long double& __z)
  { return __builtin_csqrtl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    sqrt(const complex<_Tp>& __z) { return __complex_sqrt(__z.__rep()); }
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tan(const complex<_Tp>& __z)
    { return std::sin(__z) / std::cos(__z); }


  inline __complex__ float
  __complex_tan(__complex__ float __z) { return __builtin_ctanf(__z); }

  inline __complex__ double
  __complex_tan(__complex__ double __z) { return __builtin_ctan(__z); }

  inline __complex__ long double
  __complex_tan(const __complex__ long double& __z)
  { return __builtin_ctanl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tan(const complex<_Tp>& __z) { return __complex_tan(__z.__rep()); }
# 934 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline complex<_Tp>
    __complex_tanh(const complex<_Tp>& __z)
    { return std::sinh(__z) / std::cosh(__z); }


  inline __complex__ float
  __complex_tanh(__complex__ float __z) { return __builtin_ctanhf(__z); }

  inline __complex__ double
  __complex_tanh(__complex__ double __z) { return __builtin_ctanh(__z); }

  inline __complex__ long double
  __complex_tanh(const __complex__ long double& __z)
  { return __builtin_ctanhl(__z); }

  template<typename _Tp>
    inline complex<_Tp>
    tanh(const complex<_Tp>& __z) { return __complex_tanh(__z.__rep()); }
# 963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    complex<_Tp>
    __complex_pow_unsigned(complex<_Tp> __x, unsigned __n)
    {
      complex<_Tp> __y = __n % 2 ? __x : complex<_Tp>(1);

      while (__n >>= 1)
        {
          __x *= __x;
          if (__n % 2)
            __y *= __x;
        }

      return __y;
    }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __z, int __n)
    {
      return __n < 0
 ? complex<_Tp>(1) / std::__complex_pow_unsigned(__z, -(unsigned)__n)
        : std::__complex_pow_unsigned(__z, __n);
    }

  template<typename _Tp>
    complex<_Tp>
    pow(const complex<_Tp>& __x, const _Tp& __y)
    {




      if (__x.imag() == _Tp() && __x.real() > _Tp())
        return pow(__x.real(), __y);

      complex<_Tp> __t = std::log(__x);
      return std::polar<_Tp>(exp(__y * __t.real()), __y * __t.imag());
    }

  template<typename _Tp>
    inline complex<_Tp>
    __complex_pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __x == _Tp() ? _Tp() : std::exp(__y * std::log(__x)); }


  inline __complex__ float
  __complex_pow(__complex__ float __x, __complex__ float __y)
  { return __builtin_cpowf(__x, __y); }

  inline __complex__ double
  __complex_pow(__complex__ double __x, __complex__ double __y)
  { return __builtin_cpow(__x, __y); }

  inline __complex__ long double
  __complex_pow(const __complex__ long double& __x,
  const __complex__ long double& __y)
  { return __builtin_cpowl(__x, __y); }

  template<typename _Tp>
    inline complex<_Tp>
    pow(const complex<_Tp>& __x, const complex<_Tp>& __y)
    { return __complex_pow(__x.__rep(), __y.__rep()); }







  template<typename _Tp>
    inline complex<_Tp>
    pow(const _Tp& __x, const complex<_Tp>& __y)
    {
      return __x > _Tp() ? std::polar<_Tp>(pow(__x, __y.real()),
        __y.imag() * log(__x))
                  : std::pow(complex<_Tp>(__x), __y);
    }



  template<>
    struct complex<float>
    {
      typedef float value_type;
      typedef __complex__ float _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(float __r = 0.0f, float __i = 0.0f)

      : _M_value{ __r, __i } { }







      explicit constexpr complex(const complex<double>&);
      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr float
      imag() const { return __imag__ _M_value; }
# 1097 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(float __val) { __real__ _M_value = __val; }

      void
      imag(float __val) { __imag__ _M_value = __val; }

      complex&
      operator=(float __f)
      {
 _M_value = __f;
 return *this;
      }

      complex&
      operator+=(float __f)
      {
 _M_value += __f;
 return *this;
      }

      complex&
      operator-=(float __f)
      {
 _M_value -= __f;
 return *this;
      }

      complex&
      operator*=(float __f)
      {
 _M_value *= __f;
 return *this;
      }

      complex&
      operator/=(float __f)
      {
 _M_value /= __f;
 return *this;
      }





      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<class _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<class _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<double>
    {
      typedef double value_type;
      typedef __complex__ double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(double __r = 0.0, double __i = 0.0)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      explicit constexpr complex(const complex<long double>&);




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr double
      imag() const { return __imag__ _M_value; }
# 1248 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(double __val) { __real__ _M_value = __val; }

      void
      imag(double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(double __d)
      {
 _M_value = __d;
 return *this;
      }

      complex&
      operator+=(double __d)
      {
 _M_value += __d;
 return *this;
      }

      complex&
      operator-=(double __d)
      {
 _M_value -= __d;
 return *this;
      }

      complex&
      operator*=(double __d)
      {
 _M_value *= __d;
 return *this;
      }

      complex&
      operator/=(double __d)
      {
 _M_value /= __d;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
        operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
        operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  template<>
    struct complex<long double>
    {
      typedef long double value_type;
      typedef __complex__ long double _ComplexT;

      constexpr complex(_ComplexT __z) : _M_value(__z) { }

      constexpr complex(long double __r = 0.0L,
     long double __i = 0.0L)

      : _M_value{ __r, __i } { }







      constexpr complex(const complex<float>& __z)
      : _M_value(__z.__rep()) { }

      constexpr complex(const complex<double>& __z)
      : _M_value(__z.__rep()) { }




      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      real() const { return __real__ _M_value; }

      __attribute ((__abi_tag__ ("cxx11")))
      constexpr long double
      imag() const { return __imag__ _M_value; }
# 1400 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
      void
      real(long double __val) { __real__ _M_value = __val; }

      void
      imag(long double __val) { __imag__ _M_value = __val; }

      complex&
      operator=(long double __r)
      {
 _M_value = __r;
 return *this;
      }

      complex&
      operator+=(long double __r)
      {
 _M_value += __r;
 return *this;
      }

      complex&
      operator-=(long double __r)
      {
 _M_value -= __r;
 return *this;
      }

      complex&
      operator*=(long double __r)
      {
 _M_value *= __r;
 return *this;
      }

      complex&
      operator/=(long double __r)
      {
 _M_value /= __r;
 return *this;
      }




      template<typename _Tp>
        complex&
        operator=(const complex<_Tp>& __z)
 {
   __real__ _M_value = __z.real();
   __imag__ _M_value = __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator+=(const complex<_Tp>& __z)
 {
   __real__ _M_value += __z.real();
   __imag__ _M_value += __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator-=(const complex<_Tp>& __z)
 {
   __real__ _M_value -= __z.real();
   __imag__ _M_value -= __z.imag();
   return *this;
 }

      template<typename _Tp>
        complex&
 operator*=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value *= __t;
   return *this;
 }

      template<typename _Tp>
        complex&
 operator/=(const complex<_Tp>& __z)
 {
   _ComplexT __t;
   __real__ __t = __z.real();
   __imag__ __t = __z.imag();
   _M_value /= __t;
   return *this;
 }

      constexpr _ComplexT __rep() const { return _M_value; }

    private:
      _ComplexT _M_value;
    };



  inline constexpr
  complex<float>::complex(const complex<double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<float>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }

  inline constexpr
  complex<double>::complex(const complex<long double>& __z)
  : _M_value(__z.__rep()) { }





  extern template istream& operator>>(istream&, complex<float>&);
  extern template ostream& operator<<(ostream&, const complex<float>&);
  extern template istream& operator>>(istream&, complex<double>&);
  extern template ostream& operator<<(ostream&, const complex<double>&);
  extern template istream& operator>>(istream&, complex<long double>&);
  extern template ostream& operator<<(ostream&, const complex<long double>&);


  extern template wistream& operator>>(wistream&, complex<float>&);
  extern template wostream& operator<<(wostream&, const complex<float>&);
  extern template wistream& operator>>(wistream&, complex<double>&);
  extern template wostream& operator<<(wostream&, const complex<double>&);
  extern template wistream& operator>>(wistream&, complex<long double>&);
  extern template wostream& operator<<(wostream&, const complex<long double>&);






}

namespace __gnu_cxx
{



  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, _Up>
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<_Tp, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };

  template<typename _Tp, typename _Up>
    struct __promote_2<std::complex<_Tp>, std::complex<_Up> >
    {
    public:
      typedef std::complex<typename __promote_2<_Tp, _Up>::__type> __type;
    };


}



namespace std
{



  template<typename _Tp> std::complex<_Tp> acos(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asin(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atan(const std::complex<_Tp>&);

  template<typename _Tp> std::complex<_Tp> acosh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> asinh(const std::complex<_Tp>&);
  template<typename _Tp> std::complex<_Tp> atanh(const std::complex<_Tp>&);

  template<typename _Tp> _Tp fabs(const std::complex<_Tp>&);

  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_acos(const std::complex<_Tp>& __z)
    {
      const std::complex<_Tp> __t = std::asin(__z);
      const _Tp __pi_2 = 1.5707963267948966192313216916397514L;
      return std::complex<_Tp>(__pi_2 - __t.real(), -__t.imag());
    }


  inline __complex__ float
  __complex_acos(__complex__ float __z)
  { return __builtin_cacosf(__z); }

  inline __complex__ double
  __complex_acos(__complex__ double __z)
  { return __builtin_cacos(__z); }

  inline __complex__ long double
  __complex_acos(const __complex__ long double& __z)
  { return __builtin_cacosl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acos(const std::complex<_Tp>& __z)
    { return __complex_acos(__z.__rep()); }
# 1621 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline std::complex<_Tp>
    __complex_asin(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t(-__z.imag(), __z.real());
      __t = std::asinh(__t);
      return std::complex<_Tp>(__t.imag(), -__t.real());
    }


  inline __complex__ float
  __complex_asin(__complex__ float __z)
  { return __builtin_casinf(__z); }

  inline __complex__ double
  __complex_asin(__complex__ double __z)
  { return __builtin_casin(__z); }

  inline __complex__ long double
  __complex_asin(const __complex__ long double& __z)
  { return __builtin_casinl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asin(const std::complex<_Tp>& __z)
    { return __complex_asin(__z.__rep()); }
# 1657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atan(const std::complex<_Tp>& __z)
    {
      const _Tp __r2 = __z.real() * __z.real();
      const _Tp __x = _Tp(1.0) - __r2 - __z.imag() * __z.imag();

      _Tp __num = __z.imag() + _Tp(1.0);
      _Tp __den = __z.imag() - _Tp(1.0);

      __num = __r2 + __num * __num;
      __den = __r2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.5) * atan2(_Tp(2.0) * __z.real(), __x),
          _Tp(0.25) * log(__num / __den));
    }


  inline __complex__ float
  __complex_atan(__complex__ float __z)
  { return __builtin_catanf(__z); }

  inline __complex__ double
  __complex_atan(__complex__ double __z)
  { return __builtin_catan(__z); }

  inline __complex__ long double
  __complex_atan(const __complex__ long double& __z)
  { return __builtin_catanl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atan(const std::complex<_Tp>& __z)
    { return __complex_atan(__z.__rep()); }
# 1701 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_acosh(const std::complex<_Tp>& __z)
    {

      return _Tp(2.0) * std::log(std::sqrt(_Tp(0.5) * (__z + _Tp(1.0)))
     + std::sqrt(_Tp(0.5) * (__z - _Tp(1.0))));
    }


  inline __complex__ float
  __complex_acosh(__complex__ float __z)
  { return __builtin_cacoshf(__z); }

  inline __complex__ double
  __complex_acosh(__complex__ double __z)
  { return __builtin_cacosh(__z); }

  inline __complex__ long double
  __complex_acosh(const __complex__ long double& __z)
  { return __builtin_cacoshl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    acosh(const std::complex<_Tp>& __z)
    { return __complex_acosh(__z.__rep()); }
# 1737 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_asinh(const std::complex<_Tp>& __z)
    {
      std::complex<_Tp> __t((__z.real() - __z.imag())
       * (__z.real() + __z.imag()) + _Tp(1.0),
       _Tp(2.0) * __z.real() * __z.imag());
      __t = std::sqrt(__t);

      return std::log(__t + __z);
    }


  inline __complex__ float
  __complex_asinh(__complex__ float __z)
  { return __builtin_casinhf(__z); }

  inline __complex__ double
  __complex_asinh(__complex__ double __z)
  { return __builtin_casinh(__z); }

  inline __complex__ long double
  __complex_asinh(const __complex__ long double& __z)
  { return __builtin_casinhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    asinh(const std::complex<_Tp>& __z)
    { return __complex_asinh(__z.__rep()); }
# 1776 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    std::complex<_Tp>
    __complex_atanh(const std::complex<_Tp>& __z)
    {
      const _Tp __i2 = __z.imag() * __z.imag();
      const _Tp __x = _Tp(1.0) - __i2 - __z.real() * __z.real();

      _Tp __num = _Tp(1.0) + __z.real();
      _Tp __den = _Tp(1.0) - __z.real();

      __num = __i2 + __num * __num;
      __den = __i2 + __den * __den;

      return std::complex<_Tp>(_Tp(0.25) * (log(__num) - log(__den)),
          _Tp(0.5) * atan2(_Tp(2.0) * __z.imag(), __x));
    }


  inline __complex__ float
  __complex_atanh(__complex__ float __z)
  { return __builtin_catanhf(__z); }

  inline __complex__ double
  __complex_atanh(__complex__ double __z)
  { return __builtin_catanh(__z); }

  inline __complex__ long double
  __complex_atanh(const __complex__ long double& __z)
  { return __builtin_catanhl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    atanh(const std::complex<_Tp>& __z)
    { return __complex_atanh(__z.__rep()); }
# 1820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline _Tp



    fabs(const std::complex<_Tp>& __z)
    { return std::abs(__z); }


  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    arg(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;

      return std::signbit(__x) ? __type(3.1415926535897932384626433832795029L)
                        : __type();



    }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    imag(_Tp)
    { return _Tp(); }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    norm(_Tp __x)
    {
      typedef typename __gnu_cxx::__promote<_Tp>::__type __type;
      return __type(__x) * __type(__x);
    }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    real(_Tp __x)
    { return __x; }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const _Up& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x), __type(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const _Tp& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(__type(__x), std::complex<__type>(__y));
    }

  template<typename _Tp, typename _Up>
    inline std::complex<typename __gnu_cxx::__promote_2<_Tp, _Up>::__type>
    pow(const std::complex<_Tp>& __x, const std::complex<_Up>& __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return std::pow(std::complex<__type>(__x),
        std::complex<__type>(__y));
    }



  template<typename _Tp> std::complex<_Tp> proj(const std::complex<_Tp>&);

  template<typename _Tp>
    std::complex<_Tp>
    __complex_proj(const std::complex<_Tp>& __z)
    {
      const _Tp __den = (__z.real() * __z.real()
    + __z.imag() * __z.imag() + _Tp(1.0));

      return std::complex<_Tp>((_Tp(2.0) * __z.real()) / __den,
          (_Tp(2.0) * __z.imag()) / __den);
    }


  inline __complex__ float
  __complex_proj(__complex__ float __z)
  { return __builtin_cprojf(__z); }

  inline __complex__ double
  __complex_proj(__complex__ double __z)
  { return __builtin_cproj(__z); }

  inline __complex__ long double
  __complex_proj(const __complex__ long double& __z)
  { return __builtin_cprojl(__z); }

  template<typename _Tp>
    inline std::complex<_Tp>
    proj(const std::complex<_Tp>& __z)
    { return __complex_proj(__z.__rep()); }
# 1925 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/complex" 3
  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    proj(_Tp __x)
    { return __x; }

  template<typename _Tp>
    inline typename __gnu_cxx::__promote<_Tp>::__type
    conj(_Tp __x)
    { return __x; }



inline namespace literals {
inline namespace complex_literals {



  constexpr std::complex<float>
  operator""if(long double __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<float>
  operator""if(unsigned long long __num)
  { return std::complex<float>{0.0F, static_cast<float>(__num)}; }

  constexpr std::complex<double>
  operator""i(long double __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<double>
  operator""i(unsigned long long __num)
  { return std::complex<double>{0.0, static_cast<double>(__num)}; }

  constexpr std::complex<long double>
  operator""il(long double __num)
  { return std::complex<long double>{0.0L, __num}; }

  constexpr std::complex<long double>
  operator""il(unsigned long long __num)
  { return std::complex<long double>{0.0L, static_cast<long double>(__num)}; }

}
}




}
# 4 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 1
# 54 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 1
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h" 1
# 100 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"

# 100 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
enum ap_q_mode {
  AP_RND,
  AP_RND_ZERO,
  AP_RND_MIN_INF,
  AP_RND_INF,
  AP_RND_CONV,
  AP_TRN,
  AP_TRN_ZERO,
};
# 122 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
enum ap_o_mode {
  AP_SAT,
  AP_SAT_ZERO,
  AP_SAT_SYM,
  AP_WRAP,
  AP_WRAP_SM,
};
# 179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
template <int _AP_W, bool _AP_S>
struct ap_int_base;

template <int _AP_W>
struct ap_int;

template <int _AP_W>
struct ap_uint;

template <int _AP_W, bool _AP_S>
struct ap_range_ref;

template <int _AP_W, bool _AP_S>
struct ap_bit_ref;

template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref;

template <int _AP_W, int _AP_I, bool _AP_S = true, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed_base;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_fixed;

template <int _AP_W, int _AP_I, ap_q_mode _AP_Q = AP_TRN,
          ap_o_mode _AP_O = AP_WRAP, int _AP_N = 0>
struct ap_ufixed;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref;

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref;


enum BaseMode { AP_BIN = 2, AP_OCT = 8, AP_DEC = 10, AP_HEX = 16 };
# 233 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h"
typedef signed long long ap_slong;
typedef unsigned long long ap_ulong;


enum {
  _AP_SIZE_char = 8,
  _AP_SIZE_short = sizeof(short) * 8,
  _AP_SIZE_int = sizeof(int) * 8,
  _AP_SIZE_long = sizeof(long) * 8,
  _AP_SIZE_ap_slong = sizeof(ap_slong) * 8
};
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 66 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
# 17 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 18 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 2 3




# 21 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
extern "C" {
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 3
extern void __attribute__((__cdecl__))
_wassert(const wchar_t *_Message,const wchar_t *_File,unsigned _Line);
extern void __attribute__((__cdecl__))
_assert (const char *_Message, const char *_File, unsigned _Line);


}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 77 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/stdlib.h" 1 3
# 78 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 157 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"

# 157 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
enum { CHAR_IS_SIGNED = (char)-1 < 0 };


namespace _ap_type {
template <typename _Tp>
struct is_signed {
  static const bool value = _Tp(-1) < _Tp(1);
};

template <typename _Tp>
struct is_integral {
  static const bool value = false;
};





template <> struct is_integral<bool> { static const bool value = true; };
template <> struct is_integral<char> { static const bool value = true; };
template <> struct is_integral<signed char> { static const bool value = true; };
template <> struct is_integral<unsigned char> { static const bool value = true; };
template <> struct is_integral<short> { static const bool value = true; };
template <> struct is_integral<unsigned short> { static const bool value = true; };
template <> struct is_integral<int> { static const bool value = true; };
template <> struct is_integral<unsigned int> { static const bool value = true; };
template <> struct is_integral<long> { static const bool value = true; };
template <> struct is_integral<unsigned long> { static const bool value = true; };
template <> struct is_integral<ap_slong> { static const bool value = true; };
template <> struct is_integral<ap_ulong> { static const bool value = true; };


template <bool, typename _Tp = void>
struct enable_if {};

template <typename _Tp>
struct enable_if<true, _Tp> {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const {
  typedef _Tp type;
};

template <typename _Tp>
struct remove_const<_Tp const> {
  typedef _Tp type;
};
}
# 574 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
static inline unsigned char guess_radix(const char* s) {
  unsigned char rd = 10;
  const char* p = s;

  if (p[0] == '-' || p[0] == '+') ++p;

  if (p[0] == '0') {
    if (p[1] == 'b' || p[1] == 'B') {
      rd = 2;
    } else if (p[1] == 'o' || p[1] == 'O') {
      rd = 8;
    } else if (p[1] == 'x' || p[1] == 'X') {
      rd = 16;
    } else if (p[1] == 'd' || p[1] == 'D') {
      rd = 10;
    }
  }
  return rd;
}
# 602 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
class half;






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
# 610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2
# 630 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
template <int _AP_W, bool _AP_S, bool _AP_C = _AP_W <= 64>
class ap_private;

template <int _AP_W, bool _AP_S>
struct ssdm_int_sim {

  ap_private<_AP_W, _AP_S> V;
  ssdm_int_sim() {}
};


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 1
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S>
struct _private_range_ref;
template <int _AP_W, bool _AP_S>
struct _private_bit_ref;
# 90 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 1
# 31 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 1 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 3
       
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 3







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 1 3 4
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/stddef.h" 1 3 4
# 2 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stddef.h" 2 3 4
# 51 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 2 3



# 53 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstddef" 3
namespace std
{

  using ::max_align_t;
}
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 1
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cmath" 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 2 3

using std::abs;
using std::acos;
using std::asin;
using std::atan;
using std::atan2;
using std::cos;
using std::sin;
using std::tan;
using std::cosh;
using std::sinh;
using std::tanh;
using std::exp;
using std::frexp;
using std::ldexp;
using std::log;
using std::log10;
using std::modf;
using std::pow;
using std::sqrt;
using std::ceil;
using std::fabs;
using std::floor;
using std::fmod;


using std::fpclassify;
using std::isfinite;
using std::isinf;
using std::isnan;
using std::isnormal;
using std::signbit;
using std::isgreater;
using std::isgreaterequal;
using std::isless;
using std::islessequal;
using std::islessgreater;
using std::isunordered;



using std::acosh;
using std::asinh;
using std::atanh;
using std::cbrt;
using std::copysign;
using std::erf;
using std::erfc;
using std::exp2;
using std::expm1;
using std::fdim;
using std::fma;
using std::fmax;
using std::fmin;
using std::hypot;
using std::ilogb;
using std::lgamma;
using std::llrint;
using std::llround;
using std::log1p;
using std::log2;
using std::logb;
using std::lrint;
using std::lround;
using std::nearbyint;
using std::nextafter;
using std::nexttoward;
using std::remainder;
using std::remquo;
using std::rint;
using std::round;
using std::scalbln;
using std::scalbn;
using std::tgamma;
using std::trunc;
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2
# 186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 1
# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"

# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int8_t xint8;
typedef int16_t xint16;
typedef int32_t xint32;
typedef int64_t xint64;
typedef uint8_t xuint8;
typedef uint16_t xuint16;
typedef uint32_t xuint32;
typedef uint64_t xuint64;


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include/stdbool.h" 1 3 4
# 126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 2
# 143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h" 1
# 27 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 28 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h" 2
# 198 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
typedef unsigned long long int mp_limb_t;
typedef long long int mp_limb_signed_t;







typedef unsigned long long int mp_bitcnt_t;







typedef struct
{
  int _mp_alloc;

  int _mp_size;


  mp_limb_t *_mp_d;
} __mpz_struct;



typedef __mpz_struct mpz_t[1];

typedef mp_limb_t * mp_ptr;
typedef const mp_limb_t * mp_srcptr;


typedef long long int mp_size_t;
typedef long int mp_exp_t;






typedef struct
{
  __mpz_struct _mp_num;
  __mpz_struct _mp_den;
} __mpq_struct;

typedef __mpq_struct mpq_t[1];

typedef struct
{
  int _mp_prec;



  int _mp_size;


  mp_exp_t _mp_exp;
  mp_limb_t *_mp_d;
} __mpf_struct;

typedef __mpf_struct mpf_t[1];


typedef enum
{
  GMP_RAND_ALG_DEFAULT = 0,
  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
} gmp_randalg_t;


typedef struct
{
  mpz_t _mp_seed;
  gmp_randalg_t _mp_alg;
  union {
    void *_mp_lc;
  } _mp_algdata;
} __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];



typedef const __mpz_struct *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef const __mpf_struct *mpf_srcptr;
typedef __mpf_struct *mpf_ptr;
typedef const __mpq_struct *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
# 532 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern "C" {
using std::FILE;



 void __gmp_set_memory_functions (void *(*) (size_t), void *(*) (void *, size_t, size_t), void (*) (void *, size_t))

                                      throw ();


 void __gmp_get_memory_functions (void *(**) (size_t), void *(**) (void *, size_t, size_t), void (**) (void *, size_t))

                                                                   throw ();


 extern const int __gmp_bits_per_limb;


 extern int __gmp_errno;


 extern const char * const __gmp_version;


 extern const char * const __mpir_version;





 void __gmp_randinit_default (gmp_randstate_t);


 void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t)

                          ;


 int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);


 void __gmp_randinit_mt (gmp_randstate_t);


 void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);


 void __gmp_randseed (gmp_randstate_t, mpz_srcptr);


 void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);


 void __gmp_randclear (gmp_randstate_t);


 unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);


 unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);





 int __gmp_asprintf (char **, const char *, ...);



 int __gmp_fprintf (FILE *, const char *, ...);
# 615 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 int __gmp_printf (const char *, ...);


 int __gmp_snprintf (char *, size_t, const char *, ...);


 int __gmp_sprintf (char *, const char *, ...);
# 653 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 int __gmp_fscanf (FILE *, const char *, ...);



 int __gmp_scanf (const char *, ...);


 int __gmp_sscanf (const char *, const char *, ...);
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 void *__gmpz_realloc (mpz_ptr, mp_size_t);




 void __gmpz_abs (mpz_ptr, mpz_srcptr);




 void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);


 void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, unsigned long);


 unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_clear (mpz_ptr);


 void __gmpz_clears (mpz_ptr, ...);


 void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_cmp (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmp_si (mpz_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpz_com (mpz_ptr, mpz_srcptr);


 void __gmpz_combit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));


 void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);


 int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_dump (mpz_srcptr);


 void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);


 void __gmpz_fac_ui (mpz_ptr, unsigned long int);


 void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_fib_ui (mpz_ptr, unsigned long int);


 void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_fits_sint_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_slong_p (mpz_srcptr) throw () __attribute__ ((__pure__));


 int __gmpz_fits_sshort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 int __gmpz_fits_uint_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ulong_p (mpz_srcptr) throw () __attribute__ ((__pure__));




 int __gmpz_fits_ushort_p (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));


 double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);


 long int __gmpz_get_si (mpz_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpz_get_str (char *, int, mpz_srcptr);



 unsigned long int __gmpz_get_ui (mpz_srcptr) throw () __attribute__ ((__pure__));




 mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) throw () __attribute__ ((__pure__));



 mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) throw () __attribute__ ((__pure__));


 void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);


 void __gmpz_init (mpz_ptr);


 void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);


 void __gmpz_inits (mpz_ptr, ...);


 void __gmpz_init_set (mpz_ptr, mpz_srcptr);


 void __gmpz_init_set_d (mpz_ptr, double);


 void __gmpz_init_set_si (mpz_ptr, signed long int);


 int __gmpz_init_set_str (mpz_ptr, const char *, int);


 void __gmpz_init_set_ui (mpz_ptr, unsigned long int);



 size_t __gmpz_inp_raw (mpz_ptr, FILE *);




 size_t __gmpz_inp_str (mpz_ptr, FILE *, int);



 int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));


 int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));


 void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);




 void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);


 void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);





 void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);



 void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);



 void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);




 void __gmpz_neg (mpz_ptr, mpz_srcptr);



 void __gmpz_nextprime (mpz_ptr, mpz_srcptr);


 void __gmpz_next_likely_prime (mpz_ptr, mpz_srcptr,gmp_randstate_t);



 size_t __gmpz_out_raw (FILE *, mpz_srcptr);




 size_t __gmpz_out_str (FILE *, int, mpz_srcptr);



 int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));



 int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));




 mp_bitcnt_t __gmpz_popcount (mpz_srcptr) throw () __attribute__ ((__pure__));



 void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);


 int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));


 int __gmpz_probable_prime_p (mpz_srcptr,gmp_randstate_t, int,unsigned long);


 int __gmpz_likely_prime_p (mpz_srcptr,gmp_randstate_t, unsigned long);


 void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);


 unsigned long int __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_nthroot (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rootrem (mpz_ptr,mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));



 void __gmpz_set (mpz_ptr, mpz_srcptr);


 void __gmpz_set_d (mpz_ptr, double);


 void __gmpz_set_f (mpz_ptr, mpf_srcptr);



 void __gmpz_set_q (mpz_ptr, mpq_srcptr);




 void __gmpz_set_si (mpz_ptr, signed long int);


 int __gmpz_set_str (mpz_ptr, const char *, int);



 void __gmpz_set_ui (mpz_ptr, unsigned long int);


 void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);



 size_t __gmpz_size (mpz_srcptr) throw () __attribute__ ((__pure__));



 size_t __gmpz_sizeinbase (mpz_srcptr, int) throw () __attribute__ ((__pure__));


 void __gmpz_sqrt (mpz_ptr, mpz_srcptr);


 void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);



 void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);



 void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);



 void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);


 void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_swap (mpz_ptr, mpz_ptr) throw ();


 unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) throw () __attribute__ ((__pure__));


 void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);



 void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);






 void __gmpq_abs (mpq_ptr, mpq_srcptr);



 void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_canonicalize (mpq_ptr);


 void __gmpq_clear (mpq_ptr);


 void __gmpq_clears (mpq_ptr, ...);


 int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


 int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));


 int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));


 void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);


 int __gmpq_equal (mpq_srcptr, mpq_srcptr) throw () __attribute__ ((__pure__));


 void __gmpq_get_num (mpz_ptr, mpq_srcptr);


 void __gmpq_get_den (mpz_ptr, mpq_srcptr);


 double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));


 char *__gmpq_get_str (char *, int, mpq_srcptr);


 void __gmpq_init (mpq_ptr);


 void __gmpq_inits (mpq_ptr, ...);



 size_t __gmpq_inp_str (mpq_ptr, FILE *, int);



 void __gmpq_inv (mpq_ptr, mpq_srcptr);


 void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);



 void __gmpq_neg (mpq_ptr, mpq_srcptr);




 size_t __gmpq_out_str (FILE *, int, mpq_srcptr);



 void __gmpq_set (mpq_ptr, mpq_srcptr);


 void __gmpq_set_d (mpq_ptr, double);


 void __gmpq_set_den (mpq_ptr, mpz_srcptr);


 void __gmpq_set_f (mpq_ptr, mpf_srcptr);


 void __gmpq_set_num (mpq_ptr, mpz_srcptr);


 void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);


 int __gmpq_set_str (mpq_ptr, const char *, int);


 void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);


 void __gmpq_set_z (mpq_ptr, mpz_srcptr);


 void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_swap (mpq_ptr, mpq_ptr) throw ();





 void __gmpf_abs (mpf_ptr, mpf_srcptr);


 void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);

 void __gmpf_ceil (mpf_ptr, mpf_srcptr);


 void __gmpf_clear (mpf_ptr);


 void __gmpf_clears (mpf_ptr, ...);


 int __gmpf_cmp (mpf_srcptr, mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));


 int __gmpf_cmp_si (mpf_srcptr, signed long int) throw () __attribute__ ((__pure__));


 int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) throw () __attribute__ ((__pure__));


 void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_dump (mpf_srcptr);


 int __gmpf_eq (mpf_srcptr, mpf_srcptr, unsigned long int) __attribute__ ((__pure__));


 int __gmpf_fits_sint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_slong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_sshort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_uint_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ulong_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 int __gmpf_fits_ushort_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_floor (mpf_ptr, mpf_srcptr);


 double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));


 double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);


 mp_bitcnt_t __gmpf_get_default_prec (void) throw () __attribute__ ((__pure__));


 mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) throw () __attribute__ ((__pure__));


 long __gmpf_get_si (mpf_srcptr) throw () __attribute__ ((__pure__));


 char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);


 unsigned long __gmpf_get_ui (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_init (mpf_ptr);


 void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);


 void __gmpf_inits (mpf_ptr, ...);


 void __gmpf_init_set (mpf_ptr, mpf_srcptr);


 void __gmpf_init_set_d (mpf_ptr, double);


 void __gmpf_init_set_si (mpf_ptr, signed long int);


 int __gmpf_init_set_str (mpf_ptr, const char *, int);


 void __gmpf_init_set_ui (mpf_ptr, unsigned long int);



 size_t __gmpf_inp_str (mpf_ptr, FILE *, int);



 int __gmpf_integer_p (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_neg (mpf_ptr, mpf_srcptr);



 size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);



 void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);


 void __gmpf_rrandomb (mpf_ptr, gmp_randstate_t, mp_size_t, mp_exp_t);


 void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_set (mpf_ptr, mpf_srcptr);


 void __gmpf_set_d (mpf_ptr, double);


 void __gmpf_set_default_prec (mp_bitcnt_t) throw ();


 void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);


 void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) throw ();


 void __gmpf_set_q (mpf_ptr, mpq_srcptr);


 void __gmpf_set_si (mpf_ptr, signed long int);


 int __gmpf_set_str (mpf_ptr, const char *, int);


 void __gmpf_set_ui (mpf_ptr, unsigned long int);


 void __gmpf_set_z (mpf_ptr, mpz_srcptr);


 size_t __gmpf_size (mpf_srcptr) throw () __attribute__ ((__pure__));


 void __gmpf_sqrt (mpf_ptr, mpf_srcptr);


 void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);


 void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_swap (mpf_ptr, mpf_ptr) throw ();


 void __gmpf_trunc (mpf_ptr, mpf_srcptr);


 void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
# 1516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_bdivmod (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, unsigned long int);


 mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);


 int __gmpn_mulmod_2expp1 (mp_ptr, mp_srcptr, mp_srcptr,int,unsigned long, mp_ptr);


 void __gmpn_mulmod_2expm1 (mp_ptr, mp_ptr, mp_ptr,unsigned long, mp_ptr);



 int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));






 mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);





 mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);


 void __gmpn_invert (mp_ptr xp, mp_srcptr ap, mp_size_t n);


 mp_limb_t __gmpn_sb_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dip)
                                               ;


 mp_limb_t __gmpn_dc_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dip, mp_ptr tp)
                                     ;


 void __gmpn_dc_bdiv_q_n (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr scratch)
                                                 ;


 mp_limb_t __gmpn_inv_divappr_q_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_srcptr dip)
                                        ;


 mp_limb_t __gmpn_dc_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_limb_t dinv)
                                 ;


 mp_limb_t __gmpn_dc_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_inv_divappr_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t n, mp_srcptr dinv)
                                 ;


 mp_limb_t __gmpn_inv_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_inv_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t dn, mp_srcptr dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_div_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                    ;


 mp_limb_t __gmpn_sb_div_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_sb_bdiv_q (mp_ptr qp, mp_ptr wp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_dc_bdiv_q (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_dc_bdiv_qr_n (mp_ptr qp, mp_ptr np, mp_srcptr dp, mp_size_t n, mp_limb_t dinv, mp_ptr tp)
                                                               ;


 mp_limb_t __gmpn_sb_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 mp_limb_t __gmpn_sb_bdiv_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn, mp_limb_t dinv)
                                                     ;


 void __gmpn_tdiv_q (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_divexact (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)
                                                               ;


 void __gmpn_redc_1 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);


 mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_neg_n (mp_ptr, mp_srcptr, mp_size_t);



 void __gmpn_com_n (mp_ptr, mp_srcptr, mp_size_t);


 int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) throw () __attribute__ ((__pure__));


 mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);



 mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));


 void __gmpn_random (mp_ptr, mp_size_t);


 void __gmpn_random2 (mp_ptr, mp_size_t);


 void __gmpn_urandomb (mp_ptr, gmp_randstate_t, unsigned long);


 void __gmpn_urandomm (mp_ptr, gmp_randstate_t, mp_srcptr, mp_size_t);


 void __gmpn_randomb (mp_ptr, gmp_randstate_t, mp_size_t);


 void __gmpn_rrandom (mp_ptr, gmp_randstate_t, mp_size_t);


 mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);


 mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr,mp_size_t);




 mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) throw ();



 mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_zero (mp_ptr, mp_size_t);
# 1799 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
}
# 1823 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_uint_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ulong_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z) throw ()
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
}




extern __inline__ __attribute__((__gnu_inline__))

unsigned long
__gmpz_get_ui (mpz_srcptr __gmp_z) throw ()
{
  mp_ptr __gmp_p = __gmp_z->_mp_d;
  mp_size_t __gmp_n = __gmp_z->_mp_size;
  mp_limb_t __gmp_l = __gmp_p[0];






  return (unsigned long)(__gmp_n != 0 ? __gmp_l : 0);
# 1879 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n) throw ()
{
  mp_limb_t __gmp_result = 0;
  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
    __gmp_result = __gmp_z->_mp_d[__gmp_n];
  return __gmp_result;
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;

  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_bitcnt_t
__gmpz_popcount (mpz_srcptr __gmp_u) throw ()
{
  mp_size_t __gmp_usize;
  mp_bitcnt_t __gmp_result;

  __gmp_usize = __gmp_u->_mp_size;
  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

void
__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
}




extern __inline__ __attribute__((__gnu_inline__))

size_t
__gmpz_size (mpz_srcptr __gmp_z) throw ()
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}






extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
}



extern __inline__ __attribute__((__gnu_inline__)) void
__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
}
# 2220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

int
__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size) throw ()
{
  int __gmp_result;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
  return __gmp_result;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ (static_cast<mp_limb_t> (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__ __attribute__((__gnu_inline__))

mp_limb_t
__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n) throw ()
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}



}
# 2328 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
 std::ostream& operator<< (std::ostream &, mpz_srcptr);
 std::ostream& operator<< (std::ostream &, mpq_srcptr);
 std::ostream& operator<< (std::ostream &, mpf_srcptr);
 std::istream& operator>> (std::istream &, mpz_ptr);
 std::istream& operator>> (std::istream &, mpq_ptr);
 std::istream& operator>> (std::istream &, mpf_ptr);
# 2348 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
typedef __mpz_struct MP_INT;
typedef __mpq_struct MP_RAT;
# 2358 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h"
enum
{
  GMP_ERROR_NONE = 0,
  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
  GMP_ERROR_DIVISION_BY_ZERO = 2,
  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
  GMP_ERROR_INVALID_ARGUMENT = 8
};
# 144 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 2




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h" 1
# 73 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef void mpfr_void;
typedef int mpfr_int;
typedef unsigned int mpfr_uint;
typedef long mpfr_long;
typedef unsigned long mpfr_ulong;
typedef size_t mpfr_size_t;
# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef enum {
  MPFR_RNDN=0,
  MPFR_RNDZ,
  MPFR_RNDU,
  MPFR_RNDD,
  MPFR_RNDA,
  MPFR_RNDF,
  MPFR_RNDNA=-1
} mpfr_rnd_t;
# 130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef long mpfr_prec_t;
typedef unsigned long mpfr_uprec_t;
# 143 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef int mpfr_sign_t;


typedef mp_exp_t mpfr_exp_t;






typedef struct {
  mpfr_prec_t _mpfr_prec;
  mpfr_sign_t _mpfr_sign;
  mpfr_exp_t _mpfr_exp;
  mp_limb_t *_mpfr_d;
} __mpfr_struct;
# 179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef __mpfr_struct mpfr_t[1];
typedef __mpfr_struct *mpfr_ptr;
typedef const __mpfr_struct *mpfr_srcptr;
# 192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
typedef enum {
  MPFR_NAN_KIND = 0,
  MPFR_INF_KIND = 1, MPFR_ZERO_KIND = 2, MPFR_REGULAR_KIND = 3
} mpfr_kind_t;
# 241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
extern "C" {


 const char * mpfr_get_version (void);
 const char * mpfr_get_patches (void);
 int mpfr_buildopt_tls_p (void);
 int mpfr_buildopt_decimal_p (void);

 mpfr_exp_t mpfr_get_emin (void);
 int mpfr_set_emin (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emin_min (void);
 mpfr_exp_t mpfr_get_emin_max (void);
 mpfr_exp_t mpfr_get_emax (void);
 int mpfr_set_emax (mpfr_exp_t);
 mpfr_exp_t mpfr_get_emax_min (void);
 mpfr_exp_t mpfr_get_emax_max (void);

 void mpfr_set_default_rounding_mode (mpfr_rnd_t);
 mpfr_rnd_t mpfr_get_default_rounding_mode (void);
 const char *
   mpfr_print_rnd_mode (mpfr_rnd_t);

 void mpfr_clear_flags (void);
 void mpfr_clear_underflow (void);
 void mpfr_clear_overflow (void);
 void mpfr_clear_nanflag (void);
 void mpfr_clear_inexflag (void);
 void mpfr_clear_erangeflag (void);

 void mpfr_set_underflow (void);
 void mpfr_set_overflow (void);
 void mpfr_set_nanflag (void);
 void mpfr_set_inexflag (void);
 void mpfr_set_erangeflag (void);

 int mpfr_underflow_p (void);
 int mpfr_overflow_p (void);
 int mpfr_nanflag_p (void);
 int mpfr_inexflag_p (void);
 int mpfr_erangeflag_p (void);

 int
  mpfr_check_range (mpfr_ptr, int, mpfr_rnd_t);

 void mpfr_init2 (mpfr_ptr, mpfr_prec_t);
 void mpfr_init (mpfr_ptr);
 void mpfr_clear (mpfr_ptr);

 void
  mpfr_inits2 (mpfr_prec_t, mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_inits (mpfr_ptr, ...) __attribute__ ((sentinel));
 void
  mpfr_clears (mpfr_ptr, ...) __attribute__ ((sentinel));

 int
  mpfr_prec_round (mpfr_ptr, mpfr_prec_t, mpfr_rnd_t);
 int
  mpfr_can_round (mpfr_srcptr, mpfr_exp_t, mpfr_rnd_t, mpfr_rnd_t, mpfr_prec_t)
                                            ;
 mpfr_prec_t mpfr_min_prec (mpfr_srcptr);

 mpfr_exp_t mpfr_get_exp (mpfr_srcptr);
 int mpfr_set_exp (mpfr_ptr, mpfr_exp_t);
 mpfr_prec_t mpfr_get_prec (mpfr_srcptr);
 void mpfr_set_prec (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_prec_raw (mpfr_ptr, mpfr_prec_t);
 void mpfr_set_default_prec (mpfr_prec_t);
 mpfr_prec_t mpfr_get_default_prec (void);

 int mpfr_set_d (mpfr_ptr, double, mpfr_rnd_t);
 int mpfr_set_flt (mpfr_ptr, float, mpfr_rnd_t);




 int
  mpfr_set_ld (mpfr_ptr, long double, mpfr_rnd_t);
 int
  mpfr_set_z (mpfr_ptr, mpz_srcptr, mpfr_rnd_t);
 int
  mpfr_set_z_2exp (mpfr_ptr, mpz_srcptr, mpfr_exp_t, mpfr_rnd_t);
 void mpfr_set_nan (mpfr_ptr);
 void mpfr_set_inf (mpfr_ptr, int);
 void mpfr_set_zero (mpfr_ptr, int);
 int
  mpfr_set_f (mpfr_ptr, mpf_srcptr, mpfr_rnd_t);
 int
  mpfr_get_f (mpf_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_set_si (mpfr_ptr, long, mpfr_rnd_t);
 int
  mpfr_set_ui (mpfr_ptr, unsigned long, mpfr_rnd_t);
 int
  mpfr_set_si_2exp (mpfr_ptr, long, mpfr_exp_t, mpfr_rnd_t);
 int
  mpfr_set_ui_2exp (mpfr_ptr,unsigned long,mpfr_exp_t,mpfr_rnd_t);
 int
  mpfr_set_q (mpfr_ptr, mpq_srcptr, mpfr_rnd_t);
 int
  mpfr_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t);
 int
  mpfr_init_set_str (mpfr_ptr, const char *, int, mpfr_rnd_t)
                                              ;
 int
  mpfr_set4 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t, int);
 int
  mpfr_abs (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int
  mpfr_set (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_neg (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_signbit (mpfr_srcptr);
 int
  mpfr_setsign (mpfr_ptr, mpfr_srcptr, int, mpfr_rnd_t);
 int
  mpfr_copysign (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t);
# 364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
 int __gmpfr_set_sj (mpfr_t, intmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_sj_2exp (mpfr_t, intmax_t, intmax_t, mpfr_rnd_t);
 int __gmpfr_set_uj (mpfr_t, uintmax_t, mpfr_rnd_t);
 int
  __gmpfr_set_uj_2exp (mpfr_t, uintmax_t, intmax_t, mpfr_rnd_t);
 intmax_t __gmpfr_mpfr_get_sj (mpfr_srcptr, mpfr_rnd_t);
 uintmax_t __gmpfr_mpfr_get_uj (mpfr_srcptr, mpfr_rnd_t);


 mpfr_exp_t mpfr_get_z_2exp (mpz_ptr, mpfr_srcptr);
 float mpfr_get_flt (mpfr_srcptr, mpfr_rnd_t);
 double mpfr_get_d (mpfr_srcptr, mpfr_rnd_t);




 long double mpfr_get_ld (mpfr_srcptr, mpfr_rnd_t)
                                                                  ;
 double mpfr_get_d1 (mpfr_srcptr);
 double mpfr_get_d_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                 ;
 long double mpfr_get_ld_2exp (long*, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 long mpfr_get_si (mpfr_srcptr, mpfr_rnd_t);
 unsigned long mpfr_get_ui (mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 char*mpfr_get_str (char*, mpfr_exp_t*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_get_z (mpz_ptr z, mpfr_srcptr f, mpfr_rnd_t)
                                                         ;

 void mpfr_free_str (char *);

 int mpfr_urandom (mpfr_ptr, gmp_randstate_t, mpfr_rnd_t)
                                                           ;
 int mpfr_urandomb (mpfr_ptr, gmp_randstate_t);

 void mpfr_nextabove (mpfr_ptr);
 void mpfr_nextbelow (mpfr_ptr);
 void mpfr_nexttoward (mpfr_ptr, mpfr_srcptr);




 size_t __gmpfr_inp_str (mpfr_ptr, FILE*, int, mpfr_rnd_t)
                                                              ;
 size_t __gmpfr_out_str (FILE*, int, size_t, mpfr_srcptr, mpfr_rnd_t)
                                                                           ;

 int __gmpfr_fprintf (FILE*, const char*, ...)
                                                    ;

 int mpfr_printf (const char*, ...);
 int mpfr_asprintf (char**, const char*, ...)
                                                     ;
 int mpfr_sprintf (char*, const char*, ...)
                                                    ;
 int mpfr_snprintf (char*, size_t, const char*, ...)
                                                                        ;
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h"
 int mpfr_pow (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_pow_ui (mpfr_ptr, mpfr_srcptr, unsigned long int, mpfr_rnd_t)
                                                                             ;
 int mpfr_ui_pow_ui (mpfr_ptr, unsigned long int, unsigned long int, mpfr_rnd_t)
                                                                            ;
 int mpfr_ui_pow (mpfr_ptr, unsigned long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_pow_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;

 int mpfr_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                        ;
 int mpfr_sqrt_ui (mpfr_ptr, unsigned long, mpfr_rnd_t)
                                                           ;
 int mpfr_rec_sqrt (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                            ;

 int mpfr_add (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_mul (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_div (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;

 int mpfr_add_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_sub_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_sub (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_div_ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                         ;
 int mpfr_ui_div (mpfr_ptr, unsigned long, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_sub_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_sub (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_div_si (mpfr_ptr, mpfr_srcptr, long int, mpfr_rnd_t)
                                                                    ;
 int mpfr_si_div (mpfr_ptr, long int, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_add_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_sub_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_sub (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_mul_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_div_d (mpfr_ptr, mpfr_srcptr, double, mpfr_rnd_t)
                                                                  ;
 int mpfr_d_div (mpfr_ptr, double, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;

 int mpfr_sqr (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_const_pi (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_log2 (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_euler (mpfr_ptr, mpfr_rnd_t);
 int mpfr_const_catalan (mpfr_ptr, mpfr_rnd_t);

 int mpfr_agm (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_log (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_log10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_log1p (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;

 int mpfr_exp (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_exp10 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_expm1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_eint (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_li2 (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);

 int mpfr_cmp (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp3 (mpfr_srcptr, mpfr_srcptr, int);
 int mpfr_cmp_d (mpfr_srcptr, double);
 int mpfr_cmp_ld (mpfr_srcptr, long double);
 int mpfr_cmpabs (mpfr_srcptr, mpfr_srcptr);
 int mpfr_cmp_ui (mpfr_srcptr, unsigned long);
 int mpfr_cmp_si (mpfr_srcptr, long);
 int mpfr_cmp_ui_2exp (mpfr_srcptr, unsigned long, mpfr_exp_t)
                                                               ;
 int mpfr_cmp_si_2exp (mpfr_srcptr, long, mpfr_exp_t)
                                                               ;
 void mpfr_reldiff (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                         ;
 int mpfr_eq (mpfr_srcptr, mpfr_srcptr, unsigned long)
                                                        ;
 int mpfr_sgn (mpfr_srcptr);

 int mpfr_mul_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_div_2exp (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                           ;
 int mpfr_mul_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_div_2ui (mpfr_ptr, mpfr_srcptr, unsigned long, mpfr_rnd_t)
                                                                          ;
 int mpfr_mul_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;
 int mpfr_div_2si (mpfr_ptr, mpfr_srcptr, long, mpfr_rnd_t)
                                                                 ;

 int mpfr_rint (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_round (mpfr_ptr, mpfr_srcptr);
 int mpfr_trunc (mpfr_ptr, mpfr_srcptr);
 int mpfr_ceil (mpfr_ptr, mpfr_srcptr);
 int mpfr_floor (mpfr_ptr, mpfr_srcptr);
 int mpfr_rint_round (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_trunc (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_rint_ceil (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                             ;
 int mpfr_rint_floor (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_frac (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_modf (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                              ;
 int mpfr_remquo (mpfr_ptr, long*, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                       ;
 int mpfr_remainder (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;
 int mpfr_fmod (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                          ;

 int mpfr_fits_ulong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_slong_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sint_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_ushort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_sshort_p (mpfr_srcptr, mpfr_rnd_t);
 int mpfr_fits_uintmax_p (mpfr_srcptr,mpfr_rnd_t);
 int mpfr_fits_intmax_p (mpfr_srcptr, mpfr_rnd_t);

 void mpfr_extract (mpz_ptr, mpfr_srcptr, unsigned int)
                                                              ;
 void mpfr_swap (mpfr_ptr, mpfr_ptr);
 void mpfr_dump (mpfr_srcptr);

 int mpfr_nan_p (mpfr_srcptr);
 int mpfr_inf_p (mpfr_srcptr);
 int mpfr_number_p (mpfr_srcptr);
 int mpfr_integer_p (mpfr_srcptr);
 int mpfr_zero_p (mpfr_srcptr);
 int mpfr_regular_p (mpfr_srcptr);

 int mpfr_greater_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_greaterequal_p (mpfr_srcptr, mpfr_srcptr)
                                                                   ;
 int mpfr_less_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessequal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_lessgreater_p (mpfr_srcptr,mpfr_srcptr);
 int mpfr_equal_p (mpfr_srcptr, mpfr_srcptr);
 int mpfr_unordered_p (mpfr_srcptr, mpfr_srcptr);

 int mpfr_atanh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_acosh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asinh (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cosh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_tanh (mpfr_ptr,mpfr_srcptr, mpfr_rnd_t);
 int mpfr_sinh_cosh (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;

 int mpfr_sech (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csch (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_coth (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_acos (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_asin (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_sin_cos (mpfr_ptr, mpfr_ptr, mpfr_srcptr, mpfr_rnd_t)
                                                                        ;
 int mpfr_cos (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_tan (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_atan2 (mpfr_ptr,mpfr_srcptr,mpfr_srcptr, mpfr_rnd_t)
                                                         ;
 int mpfr_sec (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_csc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cot (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);

 int mpfr_hypot (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                      ;
 int mpfr_erf (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_erfc (mpfr_ptr, mpfr_srcptr,mpfr_rnd_t);
 int mpfr_cbrt (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_root (mpfr_ptr,mpfr_srcptr,unsigned long,mpfr_rnd_t);
 int mpfr_gamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lngamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_lgamma (mpfr_ptr,int*,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_digamma (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta (mpfr_ptr,mpfr_srcptr,mpfr_rnd_t);
 int mpfr_zeta_ui (mpfr_ptr,unsigned long,mpfr_rnd_t);
 int mpfr_fac_ui (mpfr_ptr, unsigned long int, mpfr_rnd_t)
                                                          ;
 int mpfr_j0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_j1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_jn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;
 int mpfr_y0 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_y1 (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);
 int mpfr_yn (mpfr_ptr, long, mpfr_srcptr, mpfr_rnd_t)
                                                      ;

 int mpfr_ai (mpfr_ptr, mpfr_srcptr, mpfr_rnd_t);

 int mpfr_min (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_max (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;
 int mpfr_dim (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                       ;

 int mpfr_mul_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_z (mpfr_ptr, mpfr_srcptr, mpz_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_z (mpfr_srcptr, mpz_srcptr);

 int mpfr_mul_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_div_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_add_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_sub_q (mpfr_ptr, mpfr_srcptr, mpq_srcptr, mpfr_rnd_t)
                                                                     ;
 int mpfr_cmp_q (mpfr_srcptr, mpq_srcptr);

 int mpfr_cmp_f (mpfr_srcptr, mpf_srcptr);

 int mpfr_fma (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_fms (mpfr_ptr, mpfr_srcptr, mpfr_srcptr, mpfr_srcptr, mpfr_rnd_t)
                                                                    ;
 int mpfr_sum (mpfr_ptr, mpfr_ptr *const, unsigned long, mpfr_rnd_t)
                                                                      ;

 void mpfr_free_cache (void);

 int mpfr_subnormalize (mpfr_ptr, int, mpfr_rnd_t)
                                                                 ;

 int mpfr_strtofr (mpfr_ptr, const char *, char **, int, mpfr_rnd_t)
                                                                          ;

 size_t mpfr_custom_get_size (mpfr_prec_t);
 void mpfr_custom_init (void *, mpfr_prec_t);
 void * mpfr_custom_get_significand (mpfr_srcptr);
 mpfr_exp_t mpfr_custom_get_exp (mpfr_srcptr);
 void mpfr_custom_move (mpfr_ptr, void *);
 void mpfr_custom_init_set (mpfr_ptr, int, mpfr_exp_t, mpfr_prec_t, void *)
                                                                              ;
 int mpfr_custom_get_kind (mpfr_srcptr);


}
# 149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h" 2



typedef long xip_fpo_prec_t;


typedef int xip_fpo_sign_t;


typedef long xip_fpo_exp_t;


typedef struct {
  xip_fpo_prec_t _xip_fpo_exp_prec;
  xip_fpo_prec_t _xip_fpo_mant_prec;
  xip_fpo_sign_t _xip_fpo_sign;
  xip_fpo_exp_t _xip_fpo_exp;
  mp_limb_t *_xip_fpo_d;
} __xip_fpo_struct;


typedef struct {
  xip_fpo_prec_t _xip_fpo_i_prec;
  xip_fpo_prec_t _xip_fpo_frac_prec;
  xint64 _xip_fpo_i;
  xint64 _xip_fpo_frac;
} __xip_fpo_fix_struct;


typedef __xip_fpo_struct xip_fpo_t[1];
typedef __xip_fpo_fix_struct xip_fpo_fix_t[1];


typedef __xip_fpo_struct *xip_fpo_ptr;
typedef const __xip_fpo_struct *xip_fpo_srcptr;
typedef __xip_fpo_fix_struct *xip_fpo_fix_ptr;
typedef const __xip_fpo_fix_struct *xip_fpo_fix_srcptr;
# 197 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/floating_point_v7_0_bitacc_cmodel.h"
typedef int xip_fpo_exc_t;


extern "C" {


typedef struct xil_fpo_accum_state xil_fpo_accum_state;


 const char * xip_fpo_get_version (void);


 void xip_fpo_init2 (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_init2 (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_inits2 (xip_fpo_prec_t, xip_fpo_prec_t, xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_clear (xip_fpo_ptr);
 void xip_fpo_fix_clear (xip_fpo_fix_ptr);
 void xip_fpo_clears (xip_fpo_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_fix_clears (xip_fpo_fix_ptr, ...) __attribute__ ((sentinel));
 void xip_fpo_set_prec (xip_fpo_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 void xip_fpo_fix_set_prec (xip_fpo_fix_ptr, xip_fpo_prec_t, xip_fpo_prec_t);
 xip_fpo_prec_t xip_fpo_get_prec_mant (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_get_prec_exp (xip_fpo_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_frac (xip_fpo_fix_ptr);
 xip_fpo_prec_t xip_fpo_fix_get_prec_int (xip_fpo_fix_ptr);


 xip_fpo_exc_t xip_fpo_set (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set (xip_fpo_fix_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui (xip_fpo_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_fix_set_ui (xip_fpo_fix_ptr, unsigned long);
 xip_fpo_exc_t xip_fpo_set_si (xip_fpo_ptr, long);
 xip_fpo_exc_t xip_fpo_fix_set_si (xip_fpo_fix_ptr, long);
 xip_fpo_exc_t xip_fpo_set_uj (xip_fpo_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_uj (xip_fpo_fix_ptr, uintmax_t);
 xip_fpo_exc_t xip_fpo_set_sj (xip_fpo_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_fix_set_sj (xip_fpo_fix_ptr, intmax_t);
 xip_fpo_exc_t xip_fpo_set_flt (xip_fpo_ptr, float);
 xip_fpo_exc_t xip_fpo_fix_set_flt (xip_fpo_fix_ptr, float);
 xip_fpo_exc_t xip_fpo_set_d (xip_fpo_ptr, double);
 xip_fpo_exc_t xip_fpo_fix_set_d (xip_fpo_fix_ptr, double);
 xip_fpo_exc_t xip_fpo_set_z (xip_fpo_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_z (xip_fpo_fix_ptr, mpz_srcptr);
 xip_fpo_exc_t xip_fpo_set_q (xip_fpo_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_q (xip_fpo_fix_ptr, mpq_srcptr);
 xip_fpo_exc_t xip_fpo_set_f (xip_fpo_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_f (xip_fpo_fix_ptr, mpf_srcptr);
 xip_fpo_exc_t xip_fpo_set_fr (xip_fpo_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_fix_set_fr (xip_fpo_fix_ptr, mpfr_srcptr);
 xip_fpo_exc_t xip_fpo_set_ui_2exp (xip_fpo_ptr, unsigned long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_si_2exp (xip_fpo_ptr, long, xip_fpo_exp_t);
 xip_fpo_exc_t xip_fpo_set_uj_2exp (xip_fpo_ptr, uintmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_sj_2exp (xip_fpo_ptr, intmax_t, intmax_t);
 xip_fpo_exc_t xip_fpo_set_str (xip_fpo_ptr, const char *, int);
 xip_fpo_exc_t xip_fpo_fix_set_str (xip_fpo_fix_ptr, const char *, int);
 void xip_fpo_set_nan (xip_fpo_ptr);
 void xip_fpo_set_inf (xip_fpo_ptr, int);
 void xip_fpo_set_zero (xip_fpo_ptr, int);


 unsigned long xip_fpo_get_ui (xip_fpo_srcptr);
 unsigned long xip_fpo_fix_get_ui (xip_fpo_fix_srcptr);
 long xip_fpo_get_si (xip_fpo_srcptr);
 long xip_fpo_fix_get_si (xip_fpo_fix_srcptr);
 uintmax_t xip_fpo_get_uj (xip_fpo_srcptr);
 uintmax_t xip_fpo_fix_get_uj (xip_fpo_fix_srcptr);
 intmax_t xip_fpo_get_sj (xip_fpo_srcptr);
 intmax_t xip_fpo_fix_get_sj (xip_fpo_fix_srcptr);
 float xip_fpo_get_flt (xip_fpo_srcptr);
 float xip_fpo_fix_get_flt (xip_fpo_fix_srcptr);
 double xip_fpo_get_d (xip_fpo_srcptr);
 double xip_fpo_fix_get_d (xip_fpo_fix_srcptr);
 double xip_fpo_get_d_2exp (long *, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_get_z (mpz_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_z (mpz_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_f (mpf_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_f (mpf_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_get_fr (mpfr_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fix_get_fr (mpfr_ptr, xip_fpo_fix_srcptr);
 char * xip_fpo_get_str (char *, xip_fpo_exp_t *, int, int, xip_fpo_srcptr);
 char * xip_fpo_fix_get_str (char *, int, xip_fpo_fix_srcptr);
 void xip_fpo_free_str (char *);
 void xip_fpo_fix_free_str (char *);
 int xip_fpo_sizeinbase (xip_fpo_srcptr, int);
 int xip_fpo_fix_sizeinbase (xip_fpo_fix_srcptr, int);


 xip_fpo_exc_t xip_fpo_add (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_add_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_add_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_sub (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sub_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_sub_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_mul (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_mul_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_mul_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_fma (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fma_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fma_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_fms (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_fms_flt (float *, float, float, float);
 xip_fpo_exc_t xip_fpo_fms_d (double *, double, double, double);
 xip_fpo_exc_t xip_fpo_div (xip_fpo_ptr, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_div_flt (float *, float, float);
 xip_fpo_exc_t xip_fpo_div_d (double *, double, double);
 xip_fpo_exc_t xip_fpo_rec (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_rec_flt (float *, float);
 xip_fpo_exc_t xip_fpo_rec_d (double *, double);
 xip_fpo_exc_t xip_fpo_abs (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_abs_flt (float *, float);
 xip_fpo_exc_t xip_fpo_abs_d (double *, double);
 xip_fpo_exc_t xip_fpo_log (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_log_flt (float *, float);
 xip_fpo_exc_t xip_fpo_log_d (double *, double);
 int xip_fpo_exp_array (xip_fpo_t * , xip_fpo_t * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_flt_array (float * , float * , xip_fpo_exc_t *, unsigned long long);
 void xip_fpo_exp_d_array (double * , double * , xip_fpo_exc_t *, unsigned long long);
 xip_fpo_exc_t xip_fpo_exp (xip_fpo_ptr , xip_fpo_srcptr );
 xip_fpo_exc_t xip_fpo_exp_flt (float * , float );
 xip_fpo_exc_t xip_fpo_exp_d (double * , double );
 struct xil_fpo_accum_state * xip_fpo_accum_create_state (int , int , int , int , int);
 void xip_fpo_accum_reset_state (struct xil_fpo_accum_state *);
 void xip_fpo_accum_destroy_state (struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample (xip_fpo_t, xip_fpo_t, bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_flt (float *, float , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_accum_sample_d (double *, double , bool, struct xil_fpo_accum_state *);
 xip_fpo_exc_t xip_fpo_sqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_sqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_sqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_recsqrt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_recsqrt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_recsqrt_d (double *, double);
 xip_fpo_exc_t xip_fpo_unordered (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_unordered_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_unordered_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_equal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_equal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_equal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_less (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_less_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_less_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_lessequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_lessequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_lessequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greater (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greater_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greater_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_greaterequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_greaterequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_greaterequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_notequal (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_notequal_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_notequal_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_condcode (int *, xip_fpo_srcptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_condcode_flt (int *, float, float);
 xip_fpo_exc_t xip_fpo_condcode_d (int *, double, double);
 xip_fpo_exc_t xip_fpo_flttofix (xip_fpo_fix_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttofix_int_flt (int *, float);
 xip_fpo_exc_t xip_fpo_flttofix_int_d (int *, double);
 xip_fpo_exc_t xip_fpo_fixtoflt (xip_fpo_ptr, xip_fpo_fix_srcptr);
 xip_fpo_exc_t xip_fpo_fixtoflt_flt_int (float *, int);
 xip_fpo_exc_t xip_fpo_fixtoflt_d_int (double *, int);
 xip_fpo_exc_t xip_fpo_flttoflt (xip_fpo_ptr, xip_fpo_srcptr);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_flt (float *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_flt_d (float *, double);
 xip_fpo_exc_t xip_fpo_flttoflt_d_flt (double *, float);
 xip_fpo_exc_t xip_fpo_flttoflt_d_d (double *, double);


}
# 187 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/gmp.h" 1
# 188 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/mpfr.h" 1
# 189 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_fpo.h" 2





inline float xil_fpo_add_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_add_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_add_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_add_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_sub_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_sub_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_sub_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_sub_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_mul_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_mul_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_mul_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_mul_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_div_flt(float a, float b)
{
  float res_flt = 0.0f;


  xip_fpo_div_flt(&res_flt, a, b);
  return res_flt;
}

inline double xil_fpo_div_d(double a, double b)
{
  double res_d = 0.0;


  xip_fpo_div_d(&res_d, a, b);
  return res_d;
}





inline float xil_fpo_rec_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_rec_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_rec_d(double a)
{
  double res_d = 0.0;


  xip_fpo_rec_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_sqrt_flt(float a)
{

  float res_flt = 0.0f;


  xip_fpo_sqrt_flt(&res_flt, a);

  return res_flt;
}

inline double xil_fpo_sqrt_d(double a)
{
  double res_d = 0.0;


  xip_fpo_sqrt_d(&res_d, a);

  return res_d;
}





inline float xil_fpo_recsqrt_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_recsqrt_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_recsqrt_d(double a)
{
  double res_d = 0.0;


  xip_fpo_recsqrt_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_abs_flt(float a)
{
  float res_flt = 0.0f;

  xip_fpo_abs_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_abs_d(double a)
{
  double res_d = 0.0;

  xip_fpo_abs_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_log_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_log_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_log_d(double a)
{
  double res_d = 0.0;


  xip_fpo_log_d(&res_d, a);
  return res_d;
}





inline float xil_fpo_exp_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_exp_flt(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_exp_d(double a)
{
  double res_d = 0.0;


  xip_fpo_exp_d(&res_d, a);
  return res_d;
}





inline int xil_fpo_unordered_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_unordered_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_unordered_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_unordered_d(&res_int, a, b);
  return res_int;
}






inline int xil_fpo_equal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_equal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_equal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_equal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_less_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_less_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_less_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_less_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_lessequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_lessequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_lessequal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_lessequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greater_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_greater_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greater_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_greater_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_greaterequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_greaterequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_greaterequal_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_greaterequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_notequal_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_notequal_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_notequal_d(double a, double b)
{
  int res_int = 0;

  xip_fpo_notequal_d(&res_int, a, b);
  return res_int;
}





inline int xil_fpo_condcode_flt(float a, float b)
{
  int res_int = 0;


  xip_fpo_condcode_flt(&res_int, a, b);
  return res_int;
}

inline int xil_fpo_condcode_d(double a, double b)
{
  int res_int = 0;


  xip_fpo_condcode_d(&res_int, a, b);
  return res_int;
}




inline int xil_fpo_flttofix_int_flt(float a)
{
  int res_int = 0;


  xip_fpo_flttofix_int_flt(&res_int, a);
  return res_int;
}

inline int xil_fpo_flttofix_int_d(double a)
{
  int res_int = 0;


  xip_fpo_flttofix_int_d(&res_int, a);
  return res_int;
}

inline float xil_fpo_fixtoflt_flt_int(int a)
{
  float res_flt = 0.0f;


  xip_fpo_fixtoflt_flt_int(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_fixtoflt_d_int(int a)
{
  double res_d = 0.0;


  xip_fpo_fixtoflt_d_int(&res_d, a);
  return res_d;
}

inline float xil_fpo_flttoflt_flt_flt(float a)
{
  float res_flt = 0.0f;


  xip_fpo_flttoflt_flt_flt(&res_flt, a);
  return res_flt;
}

inline float xil_fpo_flttoflt_flt_d(double a)
{
  float res_flt = 0.0f;


  xip_fpo_flttoflt_flt_d(&res_flt, a);
  return res_flt;
}

inline double xil_fpo_flttoflt_d_flt(float a)
{
  double res_d = 0.0;


  xip_fpo_flttoflt_d_flt(&res_d, a);
  return res_d;
}

inline double xil_fpo_flttoflt_d_d(double a)
{
  double res_d = 0.0;


  xip_fpo_flttoflt_d_d(&res_d, a);
  return res_d;
}
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_decl.h" 1
# 48 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 129 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
# 69 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 1 3
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3

# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
namespace std
{
  namespace rel_ops
  {
 
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 2 3
# 78 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/utility" 3
namespace std
{



  template<typename _Tp>
    struct tuple_size;



  template<typename _Tp>
    struct tuple_size<const _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : integral_constant<size_t, tuple_size<_Tp>::value> { };


  template<std::size_t __i, typename _Tp>
    struct tuple_element;


  template<std::size_t __i, typename _Tp>
    using __tuple_element_t = typename tuple_element<__i, _Tp>::type;

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;
    };




  template<std::size_t __i, typename _Tp>
    using tuple_element_t = typename tuple_element<__i, _Tp>::type;


  template<typename>
    struct __is_tuple_like_impl : false_type
    { };




  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type
    { };


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };


  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };


  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }





  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Tp, _Up>& __p) noexcept
    { return __p.first; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Tp, _Up>&& __p) noexcept
    { return std::move(__p.first); }

  template <typename _Tp, typename _Up>
    constexpr _Tp&
    get(pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr const _Tp&
    get(const pair<_Up, _Tp>& __p) noexcept
    { return __p.second; }

  template <typename _Tp, typename _Up>
    constexpr _Tp&&
    get(pair<_Up, _Tp>&& __p) noexcept
    { return std::move(__p.second); }




  template <typename _Tp, typename _Up = _Tp>
    inline _Tp
    exchange(_Tp& __obj, _Up&& __new_val)
    { return std::__exchange(__obj, std::forward<_Up>(__new_val)); }




  template<size_t... _Indexes> struct _Index_tuple { };


  template<typename _Itup1, typename _Itup2> struct _Itup_cat;

  template<size_t... _Ind1, size_t... _Ind2>
    struct _Itup_cat<_Index_tuple<_Ind1...>, _Index_tuple<_Ind2...>>
    {
      using __type = _Index_tuple<_Ind1..., (_Ind2 + sizeof...(_Ind1))...>;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    : _Itup_cat<typename _Build_index_tuple<_Num / 2>::__type,
  typename _Build_index_tuple<_Num - _Num / 2>::__type>
    { };

  template<>
    struct _Build_index_tuple<1>
    {
      typedef _Index_tuple<0> __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };






  template<typename _Tp, _Tp... _Idx>
    struct integer_sequence
    {
      typedef _Tp value_type;
      static constexpr size_t size() { return sizeof...(_Idx); }
    };

  template<typename _Tp, _Tp _Num,
    typename _ISeq = typename _Build_index_tuple<_Num>::__type>
    struct _Make_integer_sequence;

  template<typename _Tp, _Tp _Num, size_t... _Idx>
    struct _Make_integer_sequence<_Tp, _Num, _Index_tuple<_Idx...>>
    {
      static_assert( _Num >= 0,
       "Cannot make integer sequence of negative length" );

      typedef integer_sequence<_Tp, static_cast<_Tp>(_Idx)...> __type;
    };


  template<typename _Tp, _Tp _Num>
    using make_integer_sequence
      = typename _Make_integer_sequence<_Tp, _Num>::__type;


  template<size_t... _Idx>
    using index_sequence = integer_sequence<size_t, _Idx...>;


  template<size_t _Num>
    using make_index_sequence = make_integer_sequence<size_t, _Num>;


  template<typename... _Types>
    using index_sequence_for = make_index_sequence<sizeof...(_Types)>;



}
# 130 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 210 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 1 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 3
       
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 1 3
# 59 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
namespace std
{

# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _IIter, typename _Predicate>
    bool
    all_of(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Predicate>
    bool
    any_of(_IIter, _IIter, _Predicate);


  template<typename _FIter, typename _Tp>
    bool
    binary_search(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    bool
    binary_search(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _IIter, typename _OIter>
    _OIter
    copy(_IIter, _IIter, _OIter);

  template<typename _BIter1, typename _BIter2>
    _BIter2
    copy_backward(_BIter1, _BIter1, _BIter2);


  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    copy_if(_IIter, _IIter, _OIter, _Predicate);

  template<typename _IIter, typename _Size, typename _OIter>
    _OIter
    copy_n(_IIter, _Size, _OIter);





  template<typename _FIter, typename _Tp>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    pair<_FIter, _FIter>
    equal_range(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _FIter, typename _Tp>
    void
    fill(_FIter, _FIter, const _Tp&);

  template<typename _OIter, typename _Size, typename _Tp>
    _OIter
    fill_n(_OIter, _Size, const _Tp&);



  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_end(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);





  template<typename _IIter, typename _Predicate>
    _IIter
    find_if_not(_IIter, _IIter, _Predicate);






  template<typename _IIter1, typename _IIter2>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    includes(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _BIter>
    void
    inplace_merge(_BIter, _BIter, _BIter);

  template<typename _BIter, typename _Compare>
    void
    inplace_merge(_BIter, _BIter, _BIter, _Compare);


  template<typename _RAIter>
    bool
    is_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    bool
    is_heap(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    _RAIter
    is_heap_until(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    _RAIter
    is_heap_until(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _Predicate>
    bool
    is_partitioned(_IIter, _IIter, _Predicate);

  template<typename _FIter1, typename _FIter2>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2);

  template<typename _FIter1, typename _FIter2,
    typename _BinaryPredicate>
    bool
    is_permutation(_FIter1, _FIter1, _FIter2, _BinaryPredicate);

  template<typename _FIter>
    bool
    is_sorted(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    bool
    is_sorted(_FIter, _FIter, _Compare);

  template<typename _FIter>
    _FIter
    is_sorted_until(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    _FIter
    is_sorted_until(_FIter, _FIter, _Compare);


  template<typename _FIter1, typename _FIter2>
    void
    iter_swap(_FIter1, _FIter2);

  template<typename _FIter, typename _Tp>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    lower_bound(_FIter, _FIter, const _Tp&, _Compare);

  template<typename _RAIter>
    void
    make_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    make_heap(_RAIter, _RAIter, _Compare);

  template<typename _Tp>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    max(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    const _Tp&
    min(const _Tp&, const _Tp&, _Compare);




  template<typename _Tp>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<const _Tp&, const _Tp&>
    minmax(const _Tp&, const _Tp&, _Compare);

  template<typename _FIter>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    pair<_FIter, _FIter>
    minmax_element(_FIter, _FIter, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    min(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    min(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    _Tp
    max(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    _Tp
    max(initializer_list<_Tp>, _Compare);

  template<typename _Tp>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>);

  template<typename _Tp, typename _Compare>
    constexpr
    pair<_Tp, _Tp>
    minmax(initializer_list<_Tp>, _Compare);




  template<typename _BIter>
    bool
    next_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    next_permutation(_BIter, _BIter, _Compare);


  template<typename _IIter, typename _Predicate>
    bool
    none_of(_IIter, _IIter, _Predicate);





  template<typename _IIter, typename _RAIter>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter);

  template<typename _IIter, typename _RAIter, typename _Compare>
    _RAIter
    partial_sort_copy(_IIter, _IIter, _RAIter, _RAIter, _Compare);




  template<typename _IIter, typename _OIter1,
    typename _OIter2, typename _Predicate>
    pair<_OIter1, _OIter2>
    partition_copy(_IIter, _IIter, _OIter1, _OIter2, _Predicate);

  template<typename _FIter, typename _Predicate>
    _FIter
    partition_point(_FIter, _FIter, _Predicate);


  template<typename _RAIter>
    void
    pop_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    pop_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter>
    bool
    prev_permutation(_BIter, _BIter);

  template<typename _BIter, typename _Compare>
    bool
    prev_permutation(_BIter, _BIter, _Compare);

  template<typename _RAIter>
    void
    push_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    push_heap(_RAIter, _RAIter, _Compare);



  template<typename _FIter, typename _Tp>
    _FIter
    remove(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Predicate>
    _FIter
    remove_if(_FIter, _FIter, _Predicate);

  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    remove_copy(_IIter, _IIter, _OIter, const _Tp&);

  template<typename _IIter, typename _OIter, typename _Predicate>
    _OIter
    remove_copy_if(_IIter, _IIter, _OIter, _Predicate);



  template<typename _IIter, typename _OIter, typename _Tp>
    _OIter
    replace_copy(_IIter, _IIter, _OIter, const _Tp&, const _Tp&);

  template<typename _Iter, typename _OIter, typename _Predicate, typename _Tp>
    _OIter
    replace_copy_if(_Iter, _Iter, _OIter, _Predicate, const _Tp&);



  template<typename _BIter>
    void
    reverse(_BIter, _BIter);

  template<typename _BIter, typename _OIter>
    _OIter
    reverse_copy(_BIter, _BIter, _OIter);

  inline namespace _V2
  {
    template<typename _FIter>
      _FIter
      rotate(_FIter, _FIter, _FIter);
  }

  template<typename _FIter, typename _OIter>
    _OIter
    rotate_copy(_FIter, _FIter, _FIter, _OIter);
# 552 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _RAIter, typename _UGenerator>
    void
    shuffle(_RAIter, _RAIter, _UGenerator&&);


  template<typename _RAIter>
    void
    sort_heap(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort_heap(_RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    stable_partition(_BIter, _BIter, _Predicate);
# 581 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/algorithmfwd.h" 3
  template<typename _FIter1, typename _FIter2>
    _FIter2
    swap_ranges(_FIter1, _FIter1, _FIter2);



  template<typename _FIter>
    _FIter
    unique(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    unique(_FIter, _FIter, _BinaryPredicate);



  template<typename _FIter, typename _Tp>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&);

  template<typename _FIter, typename _Tp, typename _Compare>
    _FIter
    upper_bound(_FIter, _FIter, const _Tp&, _Compare);





  template<typename _FIter>
    _FIter
    adjacent_find(_FIter, _FIter);

  template<typename _FIter, typename _BinaryPredicate>
    _FIter
    adjacent_find(_FIter, _FIter, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    typename iterator_traits<_IIter>::difference_type
    count(_IIter, _IIter, const _Tp&);

  template<typename _IIter, typename _Predicate>
    typename iterator_traits<_IIter>::difference_type
    count_if(_IIter, _IIter, _Predicate);

  template<typename _IIter1, typename _IIter2>
    bool
    equal(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    bool
    equal(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _IIter, typename _Tp>
    _IIter
    find(_IIter, _IIter, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    find_first_of(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _IIter, typename _Predicate>
    _IIter
    find_if(_IIter, _IIter, _Predicate);

  template<typename _IIter, typename _Funct>
    _Funct
    for_each(_IIter, _IIter, _Funct);

  template<typename _FIter, typename _Generator>
    void
    generate(_FIter, _FIter, _Generator);

  template<typename _OIter, typename _Size, typename _Generator>
    _OIter
    generate_n(_OIter, _Size, _Generator);

  template<typename _IIter1, typename _IIter2>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _Compare>
    bool
    lexicographical_compare(_IIter1, _IIter1, _IIter2, _IIter2, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    max_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    max_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    merge(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _FIter>
    constexpr
    _FIter
    min_element(_FIter, _FIter);

  template<typename _FIter, typename _Compare>
    constexpr
    _FIter
    min_element(_FIter, _FIter, _Compare);

  template<typename _IIter1, typename _IIter2>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2);

  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    pair<_IIter1, _IIter2>
    mismatch(_IIter1, _IIter1, _IIter2, _BinaryPredicate);

  template<typename _RAIter>
    void
    nth_element(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    nth_element(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    partial_sort(_RAIter, _RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    partial_sort(_RAIter, _RAIter, _RAIter, _Compare);

  template<typename _BIter, typename _Predicate>
    _BIter
    partition(_BIter, _BIter, _Predicate);

  template<typename _RAIter>
    void
    random_shuffle(_RAIter, _RAIter);

  template<typename _RAIter, typename _Generator>
    void
    random_shuffle(_RAIter, _RAIter,

     _Generator&&);




  template<typename _FIter, typename _Tp>
    void
    replace(_FIter, _FIter, const _Tp&, const _Tp&);

  template<typename _FIter, typename _Predicate, typename _Tp>
    void
    replace_if(_FIter, _FIter, _Predicate, const _Tp&);

  template<typename _FIter1, typename _FIter2>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2);

  template<typename _FIter1, typename _FIter2, typename _BinaryPredicate>
    _FIter1
    search(_FIter1, _FIter1, _FIter2, _FIter2, _BinaryPredicate);

  template<typename _FIter, typename _Size, typename _Tp>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&);

  template<typename _FIter, typename _Size, typename _Tp,
    typename _BinaryPredicate>
    _FIter
    search_n(_FIter, _FIter, _Size, const _Tp&, _BinaryPredicate);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_intersection(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_symmetric_difference(_IIter1, _IIter1, _IIter2, _IIter2,
        _OIter, _Compare);

  template<typename _IIter1, typename _IIter2, typename _OIter>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _Compare>
    _OIter
    set_union(_IIter1, _IIter1, _IIter2, _IIter2, _OIter, _Compare);

  template<typename _RAIter>
    void
    sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    sort(_RAIter, _RAIter, _Compare);

  template<typename _RAIter>
    void
    stable_sort(_RAIter, _RAIter);

  template<typename _RAIter, typename _Compare>
    void
    stable_sort(_RAIter, _RAIter, _Compare);

  template<typename _IIter, typename _OIter, typename _UnaryOperation>
    _OIter
    transform(_IIter, _IIter, _OIter, _UnaryOperation);

  template<typename _IIter1, typename _IIter2, typename _OIter,
    typename _BinaryOperation>
    _OIter
    transform(_IIter1, _IIter1, _IIter2, _OIter, _BinaryOperation);

  template<typename _IIter, typename _OIter>
    _OIter
    unique_copy(_IIter, _IIter, _OIter);

  template<typename _IIter, typename _OIter, typename _BinaryPredicate>
    _OIter
    unique_copy(_IIter, _IIter, _OIter, _BinaryPredicate);


}
# 61 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 1 3
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
namespace std
{

# 83 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 1 3
# 35 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 1 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
       
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
# 158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
namespace std
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 288 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 314 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -0x7f - 1; }

      static constexpr signed char
      max() noexcept { return 0x7f; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 0x7f * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -0x7fff - 1; }

      static constexpr short
      max() noexcept { return 0x7fff; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 0x7fff * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -0x7fffffff - 1; }

      static constexpr int
      max() noexcept { return 0x7fffffff; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 0x7fffffff * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -0x7fffffffL - 1; }

      static constexpr long
      max() noexcept { return 0x7fffffffL; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 0x7fffffffL * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -0x7fffffffffffffffLL - 1; }

      static constexpr long long
      max() noexcept { return 0x7fffffffffffffffLL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 0x7fffffffffffffffLL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1569 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<> struct numeric_limits<__int128> { static constexpr bool is_specialized = true; static constexpr __int128 min() noexcept { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); } static constexpr __int128 max() noexcept { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((128 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); } static constexpr int digits = 128 - 1; static constexpr int digits10 = (128 - 1) * 643L / 2136; static constexpr bool is_signed = true; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr __int128 epsilon() noexcept { return 0; } static constexpr __int128 round_error() noexcept { return 0; } static constexpr __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr __int128 infinity() noexcept { return static_cast<__int128>(0); } static constexpr __int128 quiet_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 signaling_NaN() noexcept { return static_cast<__int128>(0); } static constexpr __int128 denorm_min() noexcept { return static_cast<__int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = false; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; }; template<> struct numeric_limits<unsigned __int128> { static constexpr bool is_specialized = true; static constexpr unsigned __int128 min() noexcept { return 0; } static constexpr unsigned __int128 max() noexcept { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((128 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); } static constexpr unsigned __int128 lowest() noexcept { return min(); } static constexpr int max_digits10 = 0; static constexpr int digits = 128; static constexpr int digits10 = 128 * 643L / 2136; static constexpr bool is_signed = false; static constexpr bool is_integer = true; static constexpr bool is_exact = true; static constexpr int radix = 2; static constexpr unsigned __int128 epsilon() noexcept { return 0; } static constexpr unsigned __int128 round_error() noexcept { return 0; } static constexpr int min_exponent = 0; static constexpr int min_exponent10 = 0; static constexpr int max_exponent = 0; static constexpr int max_exponent10 = 0; static constexpr bool has_infinity = false; static constexpr bool has_quiet_NaN = false; static constexpr bool has_signaling_NaN = false; static constexpr float_denorm_style has_denorm = denorm_absent; static constexpr bool has_denorm_loss = false; static constexpr unsigned __int128 infinity() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 quiet_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 signaling_NaN() noexcept { return static_cast<unsigned __int128>(0); } static constexpr unsigned __int128 denorm_min() noexcept { return static_cast<unsigned __int128>(0); } static constexpr bool is_iec559 = false; static constexpr bool is_bounded = true; static constexpr bool is_modulo = true; static constexpr bool traps = true; static constexpr bool tinyness_before = false; static constexpr float_round_style round_style = round_toward_zero; };
# 1592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.17549435082228750797e-38F; }

      static constexpr float
      max() noexcept { return 3.40282346638528859812e+38F; }


      static constexpr float
      lowest() noexcept { return -3.40282346638528859812e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.19209289550781250000e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.40129846432481707092e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.22507385850720138309e-308L); }

      static constexpr double
      max() noexcept { return double(1.79769313486231570815e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.79769313486231570815e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.22044604925031308085e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.94065645841246544177e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 3.36210314311209350626e-4932L; }

      static constexpr long double
      max() noexcept { return 1.18973149535723176502e+4932L; }


      static constexpr long double
      lowest() noexcept { return -1.18973149535723176502e+4932L; }


      static constexpr int digits = 64;
      static constexpr int digits10 = 18;

      static constexpr int max_digits10
  = (2 + (64) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 1.08420217248550443401e-19L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-16381);
      static constexpr int min_exponent10 = (-4931);
      static constexpr int max_exponent = 16384;
      static constexpr int max_exponent10 = 4932;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 3.64519953188247460253e-4951L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 2 3

namespace std
{


  namespace __detail
  {

    template<typename _Tp>
      inline bool
      _Power_of_2(_Tp __x)
      {
 return ((__x - 1) & __x) == 0;
      };
  }






  template<typename _IntType = int>
    class uniform_int_distribution
    {
      static_assert(std::is_integral<_IntType>::value,
      "template argument not an integral type");

    public:

      typedef _IntType result_type;

      struct param_type
      {
 typedef uniform_int_distribution<_IntType> distribution_type;

 explicit
 param_type(_IntType __a = 0,
     _IntType __b = std::numeric_limits<_IntType>::max())
 : _M_a(__a), _M_b(__b)
 {
   ;
 }

 result_type
 a() const
 { return _M_a; }

 result_type
 b() const
 { return _M_b; }

 friend bool
 operator==(const param_type& __p1, const param_type& __p2)
 { return __p1._M_a == __p2._M_a && __p1._M_b == __p2._M_b; }

      private:
 _IntType _M_a;
 _IntType _M_b;
      };

    public:



      explicit
      uniform_int_distribution(_IntType __a = 0,
      _IntType __b = std::numeric_limits<_IntType>::max())
      : _M_param(__a, __b)
      { }

      explicit
      uniform_int_distribution(const param_type& __p)
      : _M_param(__p)
      { }






      void
      reset() { }

      result_type
      a() const
      { return _M_param.a(); }

      result_type
      b() const
      { return _M_param.b(); }




      param_type
      param() const
      { return _M_param; }





      void
      param(const param_type& __param)
      { _M_param = __param; }




      result_type
      min() const
      { return this->a(); }




      result_type
      max() const
      { return this->b(); }




      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng)
        { return this->operator()(__urng, _M_param); }

      template<typename _UniformRandomNumberGenerator>
 result_type
 operator()(_UniformRandomNumberGenerator& __urng,
     const param_type& __p);

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng)
 { this->__generate(__f, __t, __urng, _M_param); }

      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate(_ForwardIterator __f, _ForwardIterator __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }

      template<typename _UniformRandomNumberGenerator>
 void
 __generate(result_type* __f, result_type* __t,
     _UniformRandomNumberGenerator& __urng,
     const param_type& __p)
 { this->__generate_impl(__f, __t, __urng, __p); }





      friend bool
      operator==(const uniform_int_distribution& __d1,
   const uniform_int_distribution& __d2)
      { return __d1._M_param == __d2._M_param; }

    private:
      template<typename _ForwardIterator,
        typename _UniformRandomNumberGenerator>
 void
 __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
   _UniformRandomNumberGenerator& __urng,
   const param_type& __p);

      param_type _M_param;
    };

  template<typename _IntType>
    template<typename _UniformRandomNumberGenerator>
      typename uniform_int_distribution<_IntType>::result_type
      uniform_int_distribution<_IntType>::
      operator()(_UniformRandomNumberGenerator& __urng,
   const param_type& __param)
      {
 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {

     const __uctype __uerange = __urange + 1;
     const __uctype __scaling = __urngrange / __uerange;
     const __uctype __past = __uerange * __scaling;
     do
       __ret = __uctype(__urng()) - __urngmin;
     while (__ret >= __past);
     __ret /= __scaling;
   }
 else if (__urngrange < __urange)
   {
# 260 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     do
       {
  const __uctype __uerngrange = __urngrange + 1;
  __tmp = (__uerngrange * operator()
    (__urng, param_type(0, __urange / __uerngrange)));
  __ret = __tmp + (__uctype(__urng()) - __urngmin);
       }
     while (__ret > __urange || __ret < __tmp);
   }
 else
   __ret = __uctype(__urng()) - __urngmin;

 return __ret + __param.a();
      }


  template<typename _IntType>
    template<typename _ForwardIterator,
      typename _UniformRandomNumberGenerator>
      void
      uniform_int_distribution<_IntType>::
      __generate_impl(_ForwardIterator __f, _ForwardIterator __t,
        _UniformRandomNumberGenerator& __urng,
        const param_type& __param)
      {

 typedef typename _UniformRandomNumberGenerator::result_type
   _Gresult_type;
 typedef typename std::make_unsigned<result_type>::type __utype;
 typedef typename std::common_type<_Gresult_type, __utype>::type
   __uctype;

 const __uctype __urngmin = __urng.min();
 const __uctype __urngmax = __urng.max();
 const __uctype __urngrange = __urngmax - __urngmin;
 const __uctype __urange
   = __uctype(__param.b()) - __uctype(__param.a());

 __uctype __ret;

 if (__urngrange > __urange)
   {
     if (__detail::_Power_of_2(__urngrange + 1)
  && __detail::_Power_of_2(__urange + 1))
       {
  while (__f != __t)
    {
      __ret = __uctype(__urng()) - __urngmin;
      *__f++ = (__ret & __urange) + __param.a();
    }
       }
     else
       {

  const __uctype __uerange = __urange + 1;
  const __uctype __scaling = __urngrange / __uerange;
  const __uctype __past = __uerange * __scaling;
  while (__f != __t)
    {
      do
        __ret = __uctype(__urng()) - __urngmin;
      while (__ret >= __past);
      *__f++ = __ret / __scaling + __param.a();
    }
       }
   }
 else if (__urngrange < __urange)
   {
# 344 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/uniform_int_dist.h" 3
     __uctype __tmp;
     while (__f != __t)
       {
  do
    {
      const __uctype __uerngrange = __urngrange + 1;
      __tmp = (__uerngrange * operator()
        (__urng, param_type(0, __urange / __uerngrange)));
      __ret = __tmp + (__uctype(__urng()) - __urngmin);
    }
  while (__ret > __urange || __ret < __tmp);
  *__f++ = __ret;
       }
   }
 else
   while (__f != __t)
     *__f++ = __uctype(__urng()) - __urngmin + __param.a();
      }


}
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 2 3




namespace std
{



  template<typename _Iterator, typename _Compare>
    void
    __move_median_to_first(_Iterator __result,_Iterator __a, _Iterator __b,
      _Iterator __c, _Compare __comp)
    {
      if (__comp(__a, __b))
 {
   if (__comp(__b, __c))
     std::iter_swap(__result, __b);
   else if (__comp(__a, __c))
     std::iter_swap(__result, __c);
   else
     std::iter_swap(__result, __a);
 }
      else if (__comp(__a, __c))
 std::iter_swap(__result, __a);
      else if (__comp(__b, __c))
 std::iter_swap(__result, __c);
      else
 std::iter_swap(__result, __b);
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if(_InputIterator __first, _InputIterator __last,
       _Predicate __pred, input_iterator_tag)
    {
      while (__first != __last && !__pred(__first))
 ++__first;
      return __first;
    }


  template<typename _RandomAccessIterator, typename _Predicate>
    _RandomAccessIterator
    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
       _Predicate __pred, random_access_iterator_tag)
    {
      typename iterator_traits<_RandomAccessIterator>::difference_type
 __trip_count = (__last - __first) >> 2;

      for (; __trip_count > 0; --__trip_count)
 {
   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;

   if (__pred(__first))
     return __first;
   ++__first;
 }

      switch (__last - __first)
 {
 case 3:
   if (__pred(__first))
     return __first;
   ++__first;
 case 2:
   if (__pred(__first))
     return __first;
   ++__first;
 case 1:
   if (__pred(__first))
     return __first;
   ++__first;
 case 0:
 default:
   return __last;
 }
    }

  template<typename _Iterator, typename _Predicate>
    inline _Iterator
    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
    {
      return __find_if(__first, __last, __pred,
         std::__iterator_category(__first));
    }


  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    __find_if_not(_InputIterator __first, _InputIterator __last,
    _Predicate __pred)
    {
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__negate(__pred),
       std::__iterator_category(__first));
    }




  template<typename _InputIterator, typename _Predicate, typename _Distance>
    _InputIterator
    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)
    {
      for (; __len; --__len, ++__first)
 if (!__pred(__first))
   break;
      return __first;
    }
# 202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __predicate)
    {

      if (__first1 == __last1 || __first2 == __last2)
 return __first1;


      _ForwardIterator2 __p1(__first2);
      if (++__p1 == __last2)
 return std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));


      _ForwardIterator2 __p;
      _ForwardIterator1 __current = __first1;

      for (;;)
 {
   __first1 =
     std::__find_if(__first1, __last1,
  __gnu_cxx::__ops::__iter_comp_iter(__predicate, __first2));

   if (__first1 == __last1)
     return __last1;

   __p = __p1;
   __current = __first1;
   if (++__current == __last1)
     return __last1;

   while (__predicate(__current, __p))
     {
       if (++__p == __last2)
  return __first1;
       if (++__current == __last1)
  return __last1;
     }
   ++__first1;
 }
      return __first1;
    }






  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n_aux(_ForwardIterator __first, _ForwardIterator __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::forward_iterator_tag)
    {
      __first = std::__find_if(__first, __last, __unary_pred);
      while (__first != __last)
 {
   typename iterator_traits<_ForwardIterator>::difference_type
     __n = __count;
   _ForwardIterator __i = __first;
   ++__i;
   while (__i != __last && __n != 1 && __unary_pred(__i))
     {
       ++__i;
       --__n;
     }
   if (__n == 1)
     return __first;
   if (__i == __last)
     return __last;
   __first = std::__find_if(++__i, __last, __unary_pred);
 }
      return __last;
    }





  template<typename _RandomAccessIter, typename _Integer,
    typename _UnaryPredicate>
    _RandomAccessIter
    __search_n_aux(_RandomAccessIter __first, _RandomAccessIter __last,
     _Integer __count, _UnaryPredicate __unary_pred,
     std::random_access_iterator_tag)
    {
      typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 _DistanceType;

      _DistanceType __tailSize = __last - __first;
      _DistanceType __remainder = __count;

      while (__remainder <= __tailSize)
 {
   __first += __remainder;
   __tailSize -= __remainder;


   _RandomAccessIter __backTrack = __first;
   while (__unary_pred(--__backTrack))
     {
       if (--__remainder == 0)
  return (__first - __count);
     }
   __remainder = __count + 1 - (__first - __backTrack);
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _Integer,
    typename _UnaryPredicate>
    _ForwardIterator
    __search_n(_ForwardIterator __first, _ForwardIterator __last,
        _Integer __count,
        _UnaryPredicate __unary_pred)
    {
      if (__count <= 0)
 return __first;

      if (__count == 1)
 return std::__find_if(__first, __last, __unary_pred);

      return std::__search_n_aux(__first, __last, __count, __unary_pred,
     std::__iterator_category(__first));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    _ForwardIterator1
    __find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
        _ForwardIterator2 __first2, _ForwardIterator2 __last2,
        forward_iterator_tag, forward_iterator_tag,
        _BinaryPredicate __comp)
    {
      if (__first2 == __last2)
 return __last1;

      _ForwardIterator1 __result = __last1;
      while (1)
 {
   _ForwardIterator1 __new_result
     = std::__search(__first1, __last1, __first2, __last2, __comp);
   if (__new_result == __last1)
     return __result;
   else
     {
       __result = __new_result;
       __first1 = __new_result;
       ++__first1;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BinaryPredicate>
    _BidirectionalIterator1
    __find_end(_BidirectionalIterator1 __first1,
        _BidirectionalIterator1 __last1,
        _BidirectionalIterator2 __first2,
        _BidirectionalIterator2 __last2,
        bidirectional_iterator_tag, bidirectional_iterator_tag,
        _BinaryPredicate __comp)
    {

     

     


      typedef reverse_iterator<_BidirectionalIterator1> _RevIterator1;
      typedef reverse_iterator<_BidirectionalIterator2> _RevIterator2;

      _RevIterator1 __rlast1(__first1);
      _RevIterator2 __rlast2(__first2);
      _RevIterator1 __rresult = std::__search(_RevIterator1(__last1), __rlast1,
           _RevIterator2(__last2), __rlast2,
           __comp);

      if (__rresult == __rlast1)
 return __last1;
      else
 {
   _BidirectionalIterator1 __result = __rresult.base();
   std::advance(__result, -std::distance(__first2, __last2));
   return __result;
 }
    }
# 423 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 471 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
      _ForwardIterator2 __first2, _ForwardIterator2 __last2,
      _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      return std::__find_end(__first1, __last1, __first2, __last2,
        std::__iterator_category(__first1),
        std::__iterator_category(__first2),
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 506 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    all_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if_not(__first, __last, __pred); }
# 523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    none_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return __last == std::find_if(__first, __last, __pred); }
# 541 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    any_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    { return !std::none_of(__first, __last, __pred); }
# 556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if_not(_InputIterator __first, _InputIterator __last,
  _Predicate __pred)
    {

     
     

      ;
      return std::__find_if_not(__first, __last,
    __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 580 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline bool
    is_partitioned(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {
      __first = std::find_if_not(__first, __last, __pred);
      return std::none_of(__first, __last, __pred);
    }
# 598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    partition_point(_ForwardIterator __first, _ForwardIterator __last,
      _Predicate __pred)
    {

     
     



      ;

      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);
      _DistanceType __half;
      _ForwardIterator __middle;

      while (__len > 0)
 {
   __half = __len >> 1;
   __middle = __first;
   std::advance(__middle, __half);
   if (__pred(*__middle))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }


  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    __remove_copy_if(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _Predicate __pred)
    {
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }
# 665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    remove_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result, const _Tp& __value)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
 __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 697 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    inline _OutputIterator
    remove_copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      return std::__remove_copy_if(__first, __last, __result,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 731 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate>
    _OutputIterator
    copy_if(_InputIterator __first, _InputIterator __last,
     _OutputIterator __result, _Predicate __pred)
    {

     
     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__result = *__first;
     ++__result;
   }
      return __result;
    }

  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    _OutputIterator
    __copy_n(_InputIterator __first, _Size __n,
      _OutputIterator __result, input_iterator_tag)
    {
      if (__n > 0)
 {
   while (true)
     {
       *__result = *__first;
       ++__result;
       if (--__n > 0)
  ++__first;
       else
  break;
     }
 }
      return __result;
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _OutputIterator>
    inline _OutputIterator
    __copy_n(_RandomAccessIterator __first, _Size __n,
      _OutputIterator __result, random_access_iterator_tag)
    { return std::copy(__first, __first + __n, __result); }
# 794 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Size, typename _OutputIterator>
    inline _OutputIterator
    copy_n(_InputIterator __first, _Size __n, _OutputIterator __result)
    {

     
     


      return std::__copy_n(__first, __n, __result,
      std::__iterator_category(__first));
    }
# 822 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator1,
    typename _OutputIterator2, typename _Predicate>
    pair<_OutputIterator1, _OutputIterator2>
    partition_copy(_InputIterator __first, _InputIterator __last,
     _OutputIterator1 __out_true, _OutputIterator2 __out_false,
     _Predicate __pred)
    {

     
     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   {
     *__out_true = *__first;
     ++__out_true;
   }
 else
   {
     *__out_false = *__first;
     ++__out_false;
   }

      return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred)
    {
      __first = std::__find_if(__first, __last, __pred);
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      ++__first;
      for (; __first != __last; ++__first)
 if (!__pred(__first))
   {
     *__result = std::move(*__first);
     ++__result;
   }
      return __result;
    }
# 891 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    remove(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __value)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
  __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 924 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    remove_if(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__remove_if(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {
      if (__first == __last)
 return __last;
      _ForwardIterator __next = __first;
      while (++__next != __last)
 {
   if (__binary_pred(__first, __next))
     return __first;
   __first = __next;
 }
      return __last;
    }

  template<typename _ForwardIterator, typename _BinaryPredicate>
    _ForwardIterator
    __unique(_ForwardIterator __first, _ForwardIterator __last,
      _BinaryPredicate __binary_pred)
    {

      __first = std::__adjacent_find(__first, __last, __binary_pred);
      if (__first == __last)
 return __last;


      _ForwardIterator __dest = __first;
      ++__first;
      while (++__first != __last)
 if (!__binary_pred(__dest, __first))
   *++__dest = std::move(*__first);
      return ++__dest;
    }
# 990 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last)
    {

     

     

      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1020 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    unique(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     

     


      ;

      return std::__unique(__first, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }







  template<typename _ForwardIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    forward_iterator_tag, output_iterator_tag)
    {

     



      _ForwardIterator __next = __first;
      *__result = *__first;
      while (++__next != __last)
 if (!__binary_pred(__first, __next))
   {
     __first = __next;
     *++__result = *__first;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    _OutputIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _OutputIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, output_iterator_tag)
    {

     



      typename iterator_traits<_InputIterator>::value_type __value = *__first;
      __decltype(__gnu_cxx::__ops::__iter_comp_val(__binary_pred))
 __rebound_pred
 = __gnu_cxx::__ops::__iter_comp_val(__binary_pred);
      *__result = __value;
      while (++__first != __last)
 if (!__rebound_pred(__first, __value))
   {
     __value = *__first;
     *++__result = __value;
   }
      return ++__result;
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _ForwardIterator
    __unique_copy(_InputIterator __first, _InputIterator __last,
    _ForwardIterator __result, _BinaryPredicate __binary_pred,
    input_iterator_tag, forward_iterator_tag)
    {

     


      *__result = *__first;
      while (++__first != __last)
 if (!__binary_pred(__result, __first))
   *++__result = *__first;
      return ++__result;
    }






  template<typename _BidirectionalIterator>
    void
    __reverse(_BidirectionalIterator __first, _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {
      while (true)
 if (__first == __last || __first == --__last)
   return;
 else
   {
     std::iter_swap(__first, __last);
     ++__first;
   }
    }






  template<typename _RandomAccessIterator>
    void
    __reverse(_RandomAccessIterator __first, _RandomAccessIterator __last,
       random_access_iterator_tag)
    {
      if (__first == __last)
 return;
      --__last;
      while (__first < __last)
 {
   std::iter_swap(__first, __last);
   ++__first;
   --__last;
 }
    }
# 1175 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    reverse(_BidirectionalIterator __first, _BidirectionalIterator __last)
    {

     

      ;
      std::__reverse(__first, __last, std::__iterator_category(__first));
    }
# 1202 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _OutputIterator>
    _OutputIterator
    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
   _OutputIterator __result)
    {

     

     

      ;

      while (__first != __last)
 {
   --__last;
   *__result = *__last;
   ++__result;
 }
      return __result;
    }





  template<typename _EuclideanRingElement>
    _EuclideanRingElement
    __gcd(_EuclideanRingElement __m, _EuclideanRingElement __n)
    {
      while (__n != 0)
 {
   _EuclideanRingElement __t = __m % __n;
   __m = __n;
   __n = __t;
 }
      return __m;
    }

  inline namespace _V2
  {


  template<typename _ForwardIterator>
    _ForwardIterator
    __rotate(_ForwardIterator __first,
      _ForwardIterator __middle,
      _ForwardIterator __last,
      forward_iterator_tag)
    {
      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      _ForwardIterator __first2 = __middle;
      do
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
 }
      while (__first2 != __last);

      _ForwardIterator __ret = __first;

      __first2 = __middle;

      while (__first2 != __last)
 {
   std::iter_swap(__first, __first2);
   ++__first;
   ++__first2;
   if (__first == __middle)
     __middle = __first2;
   else if (__first2 == __last)
     __first2 = __middle;
 }
      return __ret;
    }


  template<typename _BidirectionalIterator>
    _BidirectionalIterator
    __rotate(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
       bidirectional_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      std::__reverse(__first, __middle, bidirectional_iterator_tag());
      std::__reverse(__middle, __last, bidirectional_iterator_tag());

      while (__first != __middle && __middle != __last)
 {
   std::iter_swap(__first, --__last);
   ++__first;
 }

      if (__first == __middle)
 {
   std::__reverse(__middle, __last, bidirectional_iterator_tag());
   return __last;
 }
      else
 {
   std::__reverse(__first, __middle, bidirectional_iterator_tag());
   return __first;
 }
    }


  template<typename _RandomAccessIterator>
    _RandomAccessIterator
    __rotate(_RandomAccessIterator __first,
      _RandomAccessIterator __middle,
      _RandomAccessIterator __last,
      random_access_iterator_tag)
    {

     


      if (__first == __middle)
 return __last;
      else if (__last == __middle)
 return __first;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;

      _Distance __n = __last - __first;
      _Distance __k = __middle - __first;

      if (__k == __n - __k)
 {
   std::swap_ranges(__first, __middle, __middle);
   return __middle;
 }

      _RandomAccessIterator __p = __first;
      _RandomAccessIterator __ret = __first + (__last - __middle);

      for (;;)
 {
   if (__k < __n - __k)
     {
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*__p);
    std::move(__p + 1, __p + __n, __p);
    *(__p + __n - 1) = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    std::iter_swap(__p, __q);
    ++__p;
    ++__q;
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
       __k = __n - __k;
     }
   else
     {
       __k = __n - __k;
       if (__is_pod(_ValueType) && __k == 1)
  {
    _ValueType __t = std::move(*(__p + __n - 1));
    std::move_backward(__p, __p + __n - 1, __p + __n);
    *__p = std::move(__t);
    return __ret;
  }
       _RandomAccessIterator __q = __p + __n;
       __p = __q - __k;
       for (_Distance __i = 0; __i < __n - __k; ++ __i)
  {
    --__p;
    --__q;
    std::iter_swap(__p, __q);
  }
       __n %= __k;
       if (__n == 0)
  return __ret;
       std::swap(__n, __k);
     }
 }
    }
# 1429 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    rotate(_ForwardIterator __first, _ForwardIterator __middle,
    _ForwardIterator __last)
    {

     

      ;
      ;

      return std::__rotate(__first, __middle, __last,
      std::__iterator_category(__first));
    }

  }
# 1466 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _OutputIterator>
    inline _OutputIterator
    rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
  _ForwardIterator __last, _OutputIterator __result)
    {

     
     

      ;
      ;

      return std::copy(__first, __middle,
         std::copy(__middle, __last, __result));
    }


  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __partition(_ForwardIterator __first, _ForwardIterator __last,
  _Predicate __pred, forward_iterator_tag)
    {
      if (__first == __last)
 return __first;

      while (__pred(*__first))
 if (++__first == __last)
   return __first;

      _ForwardIterator __next = __first;

      while (++__next != __last)
 if (__pred(*__next))
   {
     std::iter_swap(__first, __next);
     ++__first;
   }

      return __first;
    }


  template<typename _BidirectionalIterator, typename _Predicate>
    _BidirectionalIterator
    __partition(_BidirectionalIterator __first, _BidirectionalIterator __last,
  _Predicate __pred, bidirectional_iterator_tag)
    {
      while (true)
 {
   while (true)
     if (__first == __last)
       return __first;
     else if (__pred(*__first))
       ++__first;
     else
       break;
   --__last;
   while (true)
     if (__first == __last)
       return __first;
     else if (!bool(__pred(*__last)))
       --__last;
     else
       break;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Pointer, typename _Predicate,
    typename _Distance>
    _ForwardIterator
    __stable_partition_adaptive(_ForwardIterator __first,
    _ForwardIterator __last,
    _Predicate __pred, _Distance __len,
    _Pointer __buffer,
    _Distance __buffer_size)
    {
      if (__len == 1)
 return __first;

      if (__len <= __buffer_size)
 {
   _ForwardIterator __result1 = __first;
   _Pointer __result2 = __buffer;




   *__result2 = std::move(*__first);
   ++__result2;
   ++__first;
   for (; __first != __last; ++__first)
     if (__pred(__first))
       {
  *__result1 = std::move(*__first);
  ++__result1;
       }
     else
       {
  *__result2 = std::move(*__first);
  ++__result2;
       }

   std::move(__buffer, __result2, __result1);
   return __result1;
 }

      _ForwardIterator __middle = __first;
      std::advance(__middle, __len / 2);
      _ForwardIterator __left_split =
 std::__stable_partition_adaptive(__first, __middle, __pred,
      __len / 2, __buffer,
      __buffer_size);



      _Distance __right_len = __len - __len / 2;
      _ForwardIterator __right_split =
 std::__find_if_not_n(__middle, __right_len, __pred);

      if (__right_len)
 __right_split =
   std::__stable_partition_adaptive(__right_split, __last, __pred,
        __right_len,
        __buffer, __buffer_size);

      std::rotate(__left_split, __middle, __right_split);
      std::advance(__left_split, std::distance(__middle, __right_split));
      return __left_split;
    }

  template<typename _ForwardIterator, typename _Predicate>
    _ForwardIterator
    __stable_partition(_ForwardIterator __first, _ForwardIterator __last,
         _Predicate __pred)
    {
      __first = std::__find_if_not(__first, __last, __pred);

      if (__first == __last)
 return __first;

      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _Temporary_buffer<_ForwardIterator, _ValueType> __buf(__first, __last);
      return
 std::__stable_partition_adaptive(__first, __last, __pred,
      _DistanceType(__buf.requested_size()),
      __buf.begin(),
      _DistanceType(__buf.size()));
    }
# 1646 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    stable_partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__stable_partition(__first, __last,
         __gnu_cxx::__ops::__pred_iter(__pred));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __heap_select(_RandomAccessIterator __first,
    _RandomAccessIterator __middle,
    _RandomAccessIterator __last, _Compare __comp)
    {
      std::__make_heap(__first, __middle, __comp);
      for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)
 if (__comp(__i, __first))
   std::__pop_heap(__first, __middle, __i, __comp);
    }



  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    _RandomAccessIterator
    __partial_sort_copy(_InputIterator __first, _InputIterator __last,
   _RandomAccessIterator __result_first,
   _RandomAccessIterator __result_last,
   _Compare __comp)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _InputValueType;
      typedef iterator_traits<_RandomAccessIterator> _RItTraits;
      typedef typename _RItTraits::difference_type _DistanceType;

      if (__result_first == __result_last)
 return __result_last;
      _RandomAccessIterator __result_real_last = __result_first;
      while (__first != __last && __result_real_last != __result_last)
 {
   *__result_real_last = *__first;
   ++__result_real_last;
   ++__first;
 }

      std::__make_heap(__result_first, __result_real_last, __comp);
      while (__first != __last)
 {
   if (__comp(__first, __result_first))
     std::__adjust_heap(__result_first, _DistanceType(0),
          _DistanceType(__result_real_last
          - __result_first),
          _InputValueType(*__first), __comp);
   ++__first;
 }
      std::__sort_heap(__result_first, __result_real_last, __comp);
      return __result_real_last;
    }
# 1732 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last)
    {
# 1746 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
     
     

     

     
      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
          __gnu_cxx::__ops::__iter_less_iter());
    }
# 1781 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _RandomAccessIterator,
    typename _Compare>
    inline _RandomAccessIterator
    partial_sort_copy(_InputIterator __first, _InputIterator __last,
        _RandomAccessIterator __result_first,
        _RandomAccessIterator __result_last,
        _Compare __comp)
    {
# 1797 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
     
     

     

     

     

      ;
      ;
      ;

      return std::__partial_sort_copy(__first, __last,
          __result_first, __result_last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __unguarded_linear_insert(_RandomAccessIterator __last,
         _Compare __comp)
    {
      typename iterator_traits<_RandomAccessIterator>::value_type
 __val = std::move(*__last);
      _RandomAccessIterator __next = __last;
      --__next;
      while (__comp(__val, __next))
 {
   *__last = std::move(*__next);
   __last = __next;
   --__next;
 }
      *__last = std::move(__val);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __insertion_sort(_RandomAccessIterator __first,
       _RandomAccessIterator __last, _Compare __comp)
    {
      if (__first == __last) return;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   if (__comp(__i, __first))
     {
       typename iterator_traits<_RandomAccessIterator>::value_type
  __val = std::move(*__i);
       std::move_backward(__first, __i, __i + 1);
       *__first = std::move(__val);
     }
   else
     std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __unguarded_insertion_sort(_RandomAccessIterator __first,
          _RandomAccessIterator __last, _Compare __comp)
    {
      for (_RandomAccessIterator __i = __first; __i != __last; ++__i)
 std::__unguarded_linear_insert(__i,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }





  enum { _S_threshold = 16 };


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __final_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first > int(_S_threshold))
 {
   std::__insertion_sort(__first, __first + int(_S_threshold), __comp);
   std::__unguarded_insertion_sort(__first + int(_S_threshold), __last,
       __comp);
 }
      else
 std::__insertion_sort(__first, __last, __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    _RandomAccessIterator
    __unguarded_partition(_RandomAccessIterator __first,
     _RandomAccessIterator __last,
     _RandomAccessIterator __pivot, _Compare __comp)
    {
      while (true)
 {
   while (__comp(__first, __pivot))
     ++__first;
   --__last;
   while (__comp(__pivot, __last))
     --__last;
   if (!(__first < __last))
     return __first;
   std::iter_swap(__first, __last);
   ++__first;
 }
    }


  template<typename _RandomAccessIterator, typename _Compare>
    inline _RandomAccessIterator
    __unguarded_partition_pivot(_RandomAccessIterator __first,
    _RandomAccessIterator __last, _Compare __comp)
    {
      _RandomAccessIterator __mid = __first + (__last - __first) / 2;
      std::__move_median_to_first(__first, __first + 1, __mid, __last - 1,
      __comp);
      return std::__unguarded_partition(__first + 1, __last, __first, __comp);
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __partial_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __middle,
     _RandomAccessIterator __last,
     _Compare __comp)
    {
      std::__heap_select(__first, __middle, __last, __comp);
      std::__sort_heap(__first, __middle, __comp);
    }


  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introsort_loop(_RandomAccessIterator __first,
       _RandomAccessIterator __last,
       _Size __depth_limit, _Compare __comp)
    {
      while (__last - __first > int(_S_threshold))
 {
   if (__depth_limit == 0)
     {
       std::__partial_sort(__first, __last, __last, __comp);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   std::__introsort_loop(__cut, __last, __depth_limit, __comp);
   __last = __cut;
 }
    }



  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      if (__first != __last)
 {
   std::__introsort_loop(__first, __last,
    std::__lg(__last - __first) * 2,
    __comp);
   std::__final_insertion_sort(__first, __last, __comp);
 }
    }

  template<typename _RandomAccessIterator, typename _Size, typename _Compare>
    void
    __introselect(_RandomAccessIterator __first, _RandomAccessIterator __nth,
    _RandomAccessIterator __last, _Size __depth_limit,
    _Compare __comp)
    {
      while (__last - __first > 3)
 {
   if (__depth_limit == 0)
     {
       std::__heap_select(__first, __nth + 1, __last, __comp);

       std::iter_swap(__first, __nth);
       return;
     }
   --__depth_limit;
   _RandomAccessIterator __cut =
     std::__unguarded_partition_pivot(__first, __last, __comp);
   if (__cut <= __nth)
     __first = __cut;
   else
     __last = __cut;
 }
      std::__insertion_sort(__first, __last, __comp);
    }
# 2018 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp));
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __upper_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__val, __middle))
     __len = __half;
   else
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
 }
      return __first;
    }
# 2072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2102 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline _ForwardIterator
    upper_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;

      return std::__upper_bound(__first, __last, __val,
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Tp,
    typename _CompareItTp, typename _CompareTpIt>
    pair<_ForwardIterator, _ForwardIterator>
    __equal_range(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val,
    _CompareItTp __comp_it_val, _CompareTpIt __comp_val_it)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp_it_val(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else if (__comp_val_it(__val, __middle))
     __len = __half;
   else
     {
       _ForwardIterator __left
  = std::__lower_bound(__first, __middle, __val, __comp_it_val);
       std::advance(__first, __len);
       _ForwardIterator __right
  = std::__upper_bound(++__middle, __first, __val, __comp_val_it);
       return pair<_ForwardIterator, _ForwardIterator>(__left, __right);
     }
 }
      return pair<_ForwardIterator, _ForwardIterator>(__first, __first);
    }
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

     

      ;
      ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val(),
    __gnu_cxx::__ops::__val_less_iter());
    }
# 2209 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    inline pair<_ForwardIterator, _ForwardIterator>
    equal_range(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val, _Compare __comp)
    {

     
     

     

     
                    ;
     
                    ;

      return std::__equal_range(__first, __last, __val,
    __gnu_cxx::__ops::__iter_comp_val(__comp),
    __gnu_cxx::__ops::__val_comp_iter(__comp));
    }
# 2242 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val)
    {

     
     

      ;
      ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_less_val());
      return __i != __last && !(__val < *__i);
    }
# 2275 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    bool
    binary_search(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {

     
     

     
                    ;
     
                    ;

      _ForwardIterator __i
 = std::__lower_bound(__first, __last, __val,
        __gnu_cxx::__ops::__iter_comp_val(__comp));
      return __i != __last && !bool(__comp(__val, *__i));
    }




  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    void
    __move_merge_adaptive(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      if (__first1 != __last1)
 std::move(__first1, __last1, __result);
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _BidirectionalIterator3, typename _Compare>
    void
    __move_merge_adaptive_backward(_BidirectionalIterator1 __first1,
       _BidirectionalIterator1 __last1,
       _BidirectionalIterator2 __first2,
       _BidirectionalIterator2 __last2,
       _BidirectionalIterator3 __result,
       _Compare __comp)
    {
      if (__first1 == __last1)
 {
   std::move_backward(__first2, __last2, __result);
   return;
 }
      else if (__first2 == __last2)
 return;

      --__last1;
      --__last2;
      while (true)
 {
   if (__comp(__last2, __last1))
     {
       *--__result = std::move(*__last1);
       if (__first1 == __last1)
  {
    std::move_backward(__first2, ++__last2, __result);
    return;
  }
       --__last1;
     }
   else
     {
       *--__result = std::move(*__last2);
       if (__first2 == __last2)
  return;
       --__last2;
     }
 }
    }


  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,
    typename _Distance>
    _BidirectionalIterator1
    __rotate_adaptive(_BidirectionalIterator1 __first,
        _BidirectionalIterator1 __middle,
        _BidirectionalIterator1 __last,
        _Distance __len1, _Distance __len2,
        _BidirectionalIterator2 __buffer,
        _Distance __buffer_size)
    {
      _BidirectionalIterator2 __buffer_end;
      if (__len1 > __len2 && __len2 <= __buffer_size)
 {
   if (__len2)
     {
       __buffer_end = std::move(__middle, __last, __buffer);
       std::move_backward(__first, __middle, __last);
       return std::move(__buffer, __buffer_end, __first);
     }
   else
     return __first;
 }
      else if (__len1 <= __buffer_size)
 {
   if (__len1)
     {
       __buffer_end = std::move(__first, __middle, __buffer);
       std::move(__middle, __last, __first);
       return std::move_backward(__buffer, __buffer_end, __last);
     }
   else
     return __last;
 }
      else
 {
   std::rotate(__first, __middle, __last);
   std::advance(__first, std::distance(__middle, __last));
   return __first;
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Pointer, typename _Compare>
    void
    __merge_adaptive(_BidirectionalIterator __first,
       _BidirectionalIterator __middle,
       _BidirectionalIterator __last,
       _Distance __len1, _Distance __len2,
       _Pointer __buffer, _Distance __buffer_size,
       _Compare __comp)
    {
      if (__len1 <= __len2 && __len1 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__first, __middle, __buffer);
   std::__move_merge_adaptive(__buffer, __buffer_end, __middle, __last,
         __first, __comp);
 }
      else if (__len2 <= __buffer_size)
 {
   _Pointer __buffer_end = std::move(__middle, __last, __buffer);
   std::__move_merge_adaptive_backward(__first, __middle, __buffer,
           __buffer_end, __last, __comp);
 }
      else
 {
   _BidirectionalIterator __first_cut = __first;
   _BidirectionalIterator __second_cut = __middle;
   _Distance __len11 = 0;
   _Distance __len22 = 0;
   if (__len1 > __len2)
     {
       __len11 = __len1 / 2;
       std::advance(__first_cut, __len11);
       __second_cut
  = std::__lower_bound(__middle, __last, *__first_cut,
         __gnu_cxx::__ops::__iter_comp_val(__comp));
       __len22 = std::distance(__middle, __second_cut);
     }
   else
     {
       __len22 = __len2 / 2;
       std::advance(__second_cut, __len22);
       __first_cut
  = std::__upper_bound(__first, __middle, *__second_cut,
         __gnu_cxx::__ops::__val_comp_iter(__comp));
       __len11 = std::distance(__first, __first_cut);
     }

   _BidirectionalIterator __new_middle
     = std::__rotate_adaptive(__first_cut, __middle, __second_cut,
         __len1 - __len11, __len22, __buffer,
         __buffer_size);
   std::__merge_adaptive(__first, __first_cut, __new_middle, __len11,
    __len22, __buffer, __buffer_size, __comp);
   std::__merge_adaptive(__new_middle, __second_cut, __last,
    __len1 - __len11,
    __len2 - __len22, __buffer,
    __buffer_size, __comp);
 }
    }


  template<typename _BidirectionalIterator, typename _Distance,
    typename _Compare>
    void
    __merge_without_buffer(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Distance __len1, _Distance __len2,
      _Compare __comp)
    {
      if (__len1 == 0 || __len2 == 0)
 return;

      if (__len1 + __len2 == 2)
 {
   if (__comp(__middle, __first))
     std::iter_swap(__first, __middle);
   return;
 }

      _BidirectionalIterator __first_cut = __first;
      _BidirectionalIterator __second_cut = __middle;
      _Distance __len11 = 0;
      _Distance __len22 = 0;
      if (__len1 > __len2)
 {
   __len11 = __len1 / 2;
   std::advance(__first_cut, __len11);
   __second_cut
     = std::__lower_bound(__middle, __last, *__first_cut,
     __gnu_cxx::__ops::__iter_comp_val(__comp));
   __len22 = std::distance(__middle, __second_cut);
 }
      else
 {
   __len22 = __len2 / 2;
   std::advance(__second_cut, __len22);
   __first_cut
     = std::__upper_bound(__first, __middle, *__second_cut,
     __gnu_cxx::__ops::__val_comp_iter(__comp));
   __len11 = std::distance(__first, __first_cut);
 }

      std::rotate(__first_cut, __middle, __second_cut);
      _BidirectionalIterator __new_middle = __first_cut;
      std::advance(__new_middle, std::distance(__middle, __second_cut));
      std::__merge_without_buffer(__first, __first_cut, __new_middle,
      __len11, __len22, __comp);
      std::__merge_without_buffer(__new_middle, __second_cut, __last,
      __len1 - __len11, __len2 - __len22, __comp);
    }

  template<typename _BidirectionalIterator, typename _Compare>
    void
    __inplace_merge(_BidirectionalIterator __first,
      _BidirectionalIterator __middle,
      _BidirectionalIterator __last,
      _Compare __comp)
    {
      typedef typename iterator_traits<_BidirectionalIterator>::value_type
   _ValueType;
      typedef typename iterator_traits<_BidirectionalIterator>::difference_type
   _DistanceType;

      if (__first == __middle || __middle == __last)
 return;

      const _DistanceType __len1 = std::distance(__first, __middle);
      const _DistanceType __len2 = std::distance(__middle, __last);

      typedef _Temporary_buffer<_BidirectionalIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__merge_without_buffer
   (__first, __middle, __last, __len1, __len2, __comp);
      else
 std::__merge_adaptive
   (__first, __middle, __last, __len1, __len2, __buf.begin(),
    _DistanceType(__buf.size()), __comp);
    }
# 2569 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_less_iter());
    }
# 2610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline void
    inplace_merge(_BidirectionalIterator __first,
    _BidirectionalIterator __middle,
    _BidirectionalIterator __last,
    _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__inplace_merge(__first, __middle, __last,
      __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }



  template<typename _InputIterator, typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __move_merge(_InputIterator __first1, _InputIterator __last1,
   _InputIterator __first2, _InputIterator __last2,
   _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = std::move(*__first2);
       ++__first2;
     }
   else
     {
       *__result = std::move(*__first1);
       ++__first1;
     }
   ++__result;
 }
      return std::move(__first2, __last2, std::move(__first1, __last1, __result))

                  ;
    }

  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2,
    typename _Distance, typename _Compare>
    void
    __merge_sort_loop(_RandomAccessIterator1 __first,
        _RandomAccessIterator1 __last,
        _RandomAccessIterator2 __result, _Distance __step_size,
        _Compare __comp)
    {
      const _Distance __two_step = 2 * __step_size;

      while (__last - __first >= __two_step)
 {
   __result = std::__move_merge(__first, __first + __step_size,
           __first + __step_size,
           __first + __two_step,
           __result, __comp);
   __first += __two_step;
 }
      __step_size = std::min(_Distance(__last - __first), __step_size);

      std::__move_merge(__first, __first + __step_size,
   __first + __step_size, __last, __result, __comp);
    }

  template<typename _RandomAccessIterator, typename _Distance,
    typename _Compare>
    void
    __chunk_insertion_sort(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Distance __chunk_size, _Compare __comp)
    {
      while (__last - __first >= __chunk_size)
 {
   std::__insertion_sort(__first, __first + __chunk_size, __comp);
   __first += __chunk_size;
 }
      std::__insertion_sort(__first, __last, __comp);
    }

  enum { _S_chunk_size = 7 };

  template<typename _RandomAccessIterator, typename _Pointer, typename _Compare>
    void
    __merge_sort_with_buffer(_RandomAccessIterator __first,
        _RandomAccessIterator __last,
        _Pointer __buffer, _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _Distance;

      const _Distance __len = __last - __first;
      const _Pointer __buffer_last = __buffer + __len;

      _Distance __step_size = _S_chunk_size;
      std::__chunk_insertion_sort(__first, __last, __step_size, __comp);

      while (__step_size < __len)
 {
   std::__merge_sort_loop(__first, __last, __buffer,
     __step_size, __comp);
   __step_size *= 2;
   std::__merge_sort_loop(__buffer, __buffer_last, __first,
     __step_size, __comp);
   __step_size *= 2;
 }
    }

  template<typename _RandomAccessIterator, typename _Pointer,
    typename _Distance, typename _Compare>
    void
    __stable_sort_adaptive(_RandomAccessIterator __first,
      _RandomAccessIterator __last,
      _Pointer __buffer, _Distance __buffer_size,
      _Compare __comp)
    {
      const _Distance __len = (__last - __first + 1) / 2;
      const _RandomAccessIterator __middle = __first + __len;
      if (__len > __buffer_size)
 {
   std::__stable_sort_adaptive(__first, __middle, __buffer,
          __buffer_size, __comp);
   std::__stable_sort_adaptive(__middle, __last, __buffer,
          __buffer_size, __comp);
 }
      else
 {
   std::__merge_sort_with_buffer(__first, __middle, __buffer, __comp);
   std::__merge_sort_with_buffer(__middle, __last, __buffer, __comp);
 }
      std::__merge_adaptive(__first, __middle, __last,
       _Distance(__middle - __first),
       _Distance(__last - __middle),
       __buffer, __buffer_size,
       __comp);
    }


  template<typename _RandomAccessIterator, typename _Compare>
    void
    __inplace_stable_sort(_RandomAccessIterator __first,
     _RandomAccessIterator __last, _Compare __comp)
    {
      if (__last - __first < 15)
 {
   std::__insertion_sort(__first, __last, __comp);
   return;
 }
      _RandomAccessIterator __middle = __first + (__last - __first) / 2;
      std::__inplace_stable_sort(__first, __middle, __comp);
      std::__inplace_stable_sort(__middle, __last, __comp);
      std::__merge_without_buffer(__first, __middle, __last,
      __middle - __first,
      __last - __middle,
      __comp);
    }
# 2782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    bool
    __includes(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first2, __first1))
   return false;
 else if (__comp(__first1, __first2))
   ++__first1;
 else
   {
     ++__first1;
     ++__first2;
   }

      return __first2 == __last2;
    }
# 2821 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 2865 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _Compare>
    inline bool
    includes(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _InputIterator2 __last2,
      _Compare __comp)
    {

     
     
     


     


      ;
      ;
      ;
      ;

      return std::__includes(__first1, __last1, __first2, __last2,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 2900 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __next_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__i, __ii))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(__i, --__j))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 2949 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 2981 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    next_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__next_permutation
 (__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _BidirectionalIterator, typename _Compare>
    bool
    __prev_permutation(_BidirectionalIterator __first,
         _BidirectionalIterator __last, _Compare __comp)
    {
      if (__first == __last)
 return false;
      _BidirectionalIterator __i = __first;
      ++__i;
      if (__i == __last)
 return false;
      __i = __last;
      --__i;

      for(;;)
 {
   _BidirectionalIterator __ii = __i;
   --__i;
   if (__comp(__ii, __i))
     {
       _BidirectionalIterator __j = __last;
       while (!__comp(--__j, __i))
  {}
       std::iter_swap(__i, __j);
       std::__reverse(__ii, __last,
        std::__iterator_category(__first));
       return true;
     }
   if (__i == __first)
     {
       std::__reverse(__first, __last,
        std::__iterator_category(__first));
       return false;
     }
 }
    }
# 3049 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last)
    {

     

     

      ;
      ;

      return std::__prev_permutation(__first, __last,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 3081 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _BidirectionalIterator, typename _Compare>
    inline bool
    prev_permutation(_BidirectionalIterator __first,
       _BidirectionalIterator __last, _Compare __comp)
    {

     

     


      ;
      ;

      return std::__prev_permutation(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }




  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    _OutputIterator
    __replace_copy_if(_InputIterator __first, _InputIterator __last,
        _OutputIterator __result,
        _Predicate __pred, const _Tp& __new_value)
    {
      for (; __first != __last; ++__first, (void)++__result)
 if (__pred(__first))
   *__result = __new_value;
 else
   *__result = *__first;
      return __result;
    }
# 3131 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator, typename _Tp>
    inline _OutputIterator
    replace_copy(_InputIterator __first, _InputIterator __last,
   _OutputIterator __result,
   const _Tp& __old_value, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
   __gnu_cxx::__ops::__iter_equals_val(__old_value),
           __new_value);
    }
# 3165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _Predicate, typename _Tp>
    inline _OutputIterator
    replace_copy_if(_InputIterator __first, _InputIterator __last,
      _OutputIterator __result,
      _Predicate __pred, const _Tp& __new_value)
    {

     
     

     

      ;

      return std::__replace_copy_if(__first, __last, __result,
    __gnu_cxx::__ops::__pred_iter(__pred),
           __new_value);
    }

  template<typename _InputIterator, typename _Predicate>
    typename iterator_traits<_InputIterator>::difference_type
    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {
      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      for (; __first != __last; ++__first)
 if (__pred(__first))
   ++__n;
      return __n;
    }
# 3204 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last)
    { return std::is_sorted_until(__first, __last) == __last; }
# 3218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline bool
    is_sorted(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    { return std::is_sorted_until(__first, __last, __comp) == __last; }

  template<typename _ForwardIterator, typename _Compare>
    _ForwardIterator
    __is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
        _Compare __comp)
    {
      if (__first == __last)
 return __last;

      _ForwardIterator __next = __first;
      for (++__next; __next != __last; __first = __next, (void)++__next)
 if (__comp(__next, __first))
   return __next;
      return __next;
    }
# 3247 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 3271 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    inline _ForwardIterator
    is_sorted_until(_ForwardIterator __first, _ForwardIterator __last,
      _Compare __comp)
    {

     
     


      ;
      ;

      return std::__is_sorted_until(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 3296 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _Tp>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b)
    {

     

      return __b < __a ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }
# 3317 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<const _Tp&, const _Tp&>
    minmax(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {
      return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a)
         : pair<const _Tp&, const _Tp&>(__a, __b);
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    pair<_ForwardIterator, _ForwardIterator>
    __minmax_element(_ForwardIterator __first, _ForwardIterator __last,
       _Compare __comp)
    {
      _ForwardIterator __next = __first;
      if (__first == __last
   || ++__next == __last)
 return std::make_pair(__first, __first);

      _ForwardIterator __min{}, __max{};
      if (__comp(__next, __first))
 {
   __min = __next;
   __max = __first;
 }
      else
 {
   __min = __first;
   __max = __next;
 }

      __first = __next;
      ++__first;

      while (__first != __last)
 {
   __next = __first;
   if (++__next == __last)
     {
       if (__comp(__first, __min))
  __min = __first;
       else if (!__comp(__first, __max))
  __max = __first;
       break;
     }

   if (__comp(__next, __first))
     {
       if (__comp(__next, __min))
  __min = __next;
       if (!__comp(__first, __max))
  __max = __first;
     }
   else
     {
       if (__comp(__first, __min))
  __min = __first;
       if (!__comp(__next, __max))
  __max = __next;
     }

   __first = __next;
   ++__first;
 }

      return std::make_pair(__min, __max);
    }
# 3397 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 3425 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline pair<_ForwardIterator, _ForwardIterator>
    minmax_element(_ForwardIterator __first, _ForwardIterator __last,
     _Compare __comp)
    {

     
     


      ;
      ;

      return std::__minmax_element(__first, __last,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


  template<typename _Tp>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l)
    { return *std::min_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    min(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::min_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l)
    { return *std::max_element(__l.begin(), __l.end()); }

  template<typename _Tp, typename _Compare>
    constexpr
    inline _Tp
    max(initializer_list<_Tp> __l, _Compare __comp)
    { return *std::max_element(__l.begin(), __l.end(), __comp); }

  template<typename _Tp>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end());
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _Tp, typename _Compare>
    constexpr
    inline pair<_Tp, _Tp>
    minmax(initializer_list<_Tp> __l, _Compare __comp)
    {
      pair<const _Tp*, const _Tp*> __p =
 std::minmax_element(__l.begin(), __l.end(), __comp);
      return std::make_pair(*__p.first, *__p.second);
    }

  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {


      for (; __first1 != __last1; ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__first1 == __last1)
 return true;



      _ForwardIterator2 __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));
      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
     __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches
     = std::__count_if(__first2, __last2,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches ||
       std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3537 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _BinaryPredicate __pred)
    {

     
     
     


      ;

      return std::__is_permutation(__first1, __last1, __first2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }


  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    bool
    __is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
       _ForwardIterator2 __first2, _ForwardIterator2 __last2,
       _BinaryPredicate __pred)
    {
      using _Cat1
 = typename iterator_traits<_ForwardIterator1>::iterator_category;
      using _Cat2
 = typename iterator_traits<_ForwardIterator2>::iterator_category;
      using _It1_is_RA = is_same<_Cat1, random_access_iterator_tag>;
      using _It2_is_RA = is_same<_Cat2, random_access_iterator_tag>;
      constexpr bool __ra_iters = _It1_is_RA() && _It2_is_RA();
      if (__ra_iters)
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 != __d2)
     return false;
 }



      for (; __first1 != __last1 && __first2 != __last2;
   ++__first1, (void)++__first2)
 if (!__pred(__first1, __first2))
   break;

      if (__ra_iters)
 {
   if (__first1 == __last1)
     return true;
 }
      else
 {
   auto __d1 = std::distance(__first1, __last1);
   auto __d2 = std::distance(__first2, __last2);
   if (__d1 == 0 && __d2 == 0)
     return true;
   if (__d1 != __d2)
     return false;
 }

      for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 {
   if (__scan != std::__find_if(__first1, __scan,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan)))
     continue;

   auto __matches = std::__count_if(__first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan));
   if (0 == __matches
       || std::__count_if(__scan, __last1,
   __gnu_cxx::__ops::__iter_comp_iter(__pred, __scan))
       != __matches)
     return false;
 }
      return true;
    }
# 3661 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {
      ;
      ;

      return
 std::__is_permutation(__first1, __last1, __first2, __last2,
         __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3688 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline bool
    is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
     _ForwardIterator2 __first2, _ForwardIterator2 __last2,
     _BinaryPredicate __pred)
    {
      ;
      ;

      return std::__is_permutation(__first1, __last1, __first2, __last2,
       __gnu_cxx::__ops::__iter_comp_iter(__pred));
    }
# 3716 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator,
    typename _UniformRandomNumberGenerator>
    void
    shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
     _UniformRandomNumberGenerator&& __g)
    {

     

      ;

      if (__first == __last)
 return;

      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef typename std::make_unsigned<_DistanceType>::type __ud_type;
      typedef typename std::uniform_int_distribution<__ud_type> __distr_type;
      typedef typename __distr_type::param_type __p_type;
      __distr_type __d;

      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 std::iter_swap(__i, __first + __d(__g, __p_type(0, __i - __first)));
    }







# 3761 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Function>
    _Function
    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
    {

     
      ;
      for (; __first != __last; ++__first)
 __f(*__first);
      return std::move(__f);
    }
# 3782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline _InputIterator
    find(_InputIterator __first, _InputIterator __last,
  const _Tp& __val)
    {

     
     

      ;
      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 3806 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline _InputIterator
    find_if(_InputIterator __first, _InputIterator __last,
     _Predicate __pred)
    {

     
     

      ;

      return std::__find_if(__first, __last,
       __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 3837 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (*__first1 == *__iter)
     return __first1;
      return __last1;
    }
# 3877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _ForwardIterator,
    typename _BinaryPredicate>
    _InputIterator
    find_first_of(_InputIterator __first1, _InputIterator __last1,
    _ForwardIterator __first2, _ForwardIterator __last2,
    _BinaryPredicate __comp)
    {

     
     
     


      ;
      ;

      for (; __first1 != __last1; ++__first1)
 for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
   if (__comp(*__first1, *__iter))
     return __first1;
      return __last1;
    }
# 3909 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;

      return std::__adjacent_find(__first, __last,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 3934 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _BinaryPredicate>
    inline _ForwardIterator
    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
    _BinaryPredicate __binary_pred)
    {

     
     


      ;

      return std::__adjacent_find(__first, __last,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 3959 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Tp>
    inline typename iterator_traits<_InputIterator>::difference_type
    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__iter_equals_val(__value));
    }
# 3982 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _Predicate>
    inline typename iterator_traits<_InputIterator>::difference_type
    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
    {

     
     

      ;

      return std::__count_if(__first, __last,
        __gnu_cxx::__ops::__pred_iter(__pred));
    }
# 4022 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 4061 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2,
    typename _BinaryPredicate>
    inline _ForwardIterator1
    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
    _ForwardIterator2 __first2, _ForwardIterator2 __last2,
    _BinaryPredicate __predicate)
    {

     
     
     


      ;
      ;

      return std::__search(__first1, __last1, __first2, __last2,
      __gnu_cxx::__ops::__iter_comp_iter(__predicate));
    }
# 4096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
        __gnu_cxx::__ops::__iter_equals_val(__val));
    }
# 4129 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Integer, typename _Tp,
    typename _BinaryPredicate>
    inline _ForwardIterator
    search_n(_ForwardIterator __first, _ForwardIterator __last,
      _Integer __count, const _Tp& __val,
      _BinaryPredicate __binary_pred)
    {

     
     

      ;

      return std::__search_n(__first, __last, __count,
  __gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
    }
# 4163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _UnaryOperation>
    _OutputIterator
    transform(_InputIterator __first, _InputIterator __last,
       _OutputIterator __result, _UnaryOperation __unary_op)
    {

     
     


      ;

      for (; __first != __last; ++__first, (void)++__result)
 *__result = __unary_op(*__first);
      return __result;
    }
# 4200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _BinaryOperation>
    _OutputIterator
    transform(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _OutputIterator __result,
       _BinaryOperation __binary_op)
    {

     
     
     


      ;

      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
 *__result = __binary_op(*__first1, *__first2);
      return __result;
    }
# 4233 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Tp>
    void
    replace(_ForwardIterator __first, _ForwardIterator __last,
     const _Tp& __old_value, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (*__first == __old_value)
   *__first = __new_value;
    }
# 4265 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
    void
    replace_if(_ForwardIterator __first, _ForwardIterator __last,
        _Predicate __pred, const _Tp& __new_value)
    {

     

     

     

      ;

      for (; __first != __last; ++__first)
 if (__pred(*__first))
   *__first = __new_value;
    }
# 4297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Generator>
    void
    generate(_ForwardIterator __first, _ForwardIterator __last,
      _Generator __gen)
    {

     
     

      ;

      for (; __first != __last; ++__first)
 *__first = __gen();
    }
# 4328 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _OutputIterator, typename _Size, typename _Generator>
    _OutputIterator
    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
    {

     



      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __gen();
      return __first;
    }
# 4364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result)
    {

     
     

     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
    __gnu_cxx::__ops::__iter_equal_to_iter(),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4404 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator, typename _OutputIterator,
    typename _BinaryPredicate>
    inline _OutputIterator
    unique_copy(_InputIterator __first, _InputIterator __last,
  _OutputIterator __result,
  _BinaryPredicate __binary_pred)
    {

     
     

      ;

      if (__first == __last)
 return __result;
      return std::__unique_copy(__first, __last, __result,
   __gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
    std::__iterator_category(__first),
    std::__iterator_category(__result));
    }
# 4437 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

      ;

      if (__first != __last)
 for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
   {

     _RandomAccessIterator __j = __first
     + std::rand() % ((__i - __first) + 1);
     if (__i != __j)
       std::iter_swap(__i, __j);
   }
    }
# 4472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
    void
    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,

     _RandomNumberGenerator&& __rand)



    {

     

      ;

      if (__first == __last)
 return;
      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
 {
   _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
   if (__i != __j)
     std::iter_swap(__i, __j);
 }
    }
# 4512 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Predicate>
    inline _ForwardIterator
    partition(_ForwardIterator __first, _ForwardIterator __last,
       _Predicate __pred)
    {

     

     

      ;

      return std::__partition(__first, __last, __pred,
         std::__iterator_category(__first));
    }
# 4545 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 4583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    partial_sort(_RandomAccessIterator __first,
   _RandomAccessIterator __middle,
   _RandomAccessIterator __last,
   _Compare __comp)
    {

     

     


      ;
      ;
      ;

      std::__partial_sort(__first, __middle, __last,
     __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4619 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last)
    {

     

     

      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 4658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
  _RandomAccessIterator __last, _Compare __comp)
    {

     

     


      ;
      ;
      ;

      if (__first == __last || __nth == __last)
 return;

      std::__introselect(__first, __nth, __last,
    std::__lg(__last - __first) * 2,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }
# 4695 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
    }
# 4725 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    _OutputIterator
    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 4786 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 4836 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    merge(_InputIterator1 __first1, _InputIterator1 __last1,
   _InputIterator2 __first2, _InputIterator2 __last2,
   _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


      ;
      ;
      ;
      ;

      return std::__merge(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
    _Compare __comp)
    {
      typedef typename iterator_traits<_RandomAccessIterator>::value_type
 _ValueType;
      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
 _DistanceType;

      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
      _TmpBuf __buf(__first, __last);

      if (__buf.begin() == 0)
 std::__inplace_stable_sort(__first, __last, __comp);
      else
 std::__stable_sort_adaptive(__first, __last, __buf.begin(),
        _DistanceType(__buf.size()), __comp);
    }
# 4900 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
    {

     

     

      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_less_iter());
    }
# 4934 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _RandomAccessIterator, typename _Compare>
    inline void
    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
  _Compare __comp)
    {

     

     


      ;
      ;

      std::__stable_sort(__first, __last,
        __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
  _InputIterator2 __first2, _InputIterator2 __last2,
  _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 {
   if (__comp(__first1, __first2))
     {
       *__result = *__first1;
       ++__first1;
     }
   else if (__comp(__first2, __first1))
     {
       *__result = *__first2;
       ++__first2;
     }
   else
     {
       *__result = *__first1;
       ++__first1;
       ++__first2;
     }
   ++__result;
 }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5002 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5051 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_union(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
         _InputIterator2 __first2, _InputIterator2 __last2,
         _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   ++__first1;
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     *__result = *__first1;
     ++__first1;
     ++__first2;
     ++__result;
   }
      return __result;
    }
# 5121 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
         __first2, __last2, __result,
         __gnu_cxx::__ops::__iter_less_iter());
    }
# 5169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_intersection(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
       _InputIterator2 __first2, _InputIterator2 __last2,
       _OutputIterator __result, _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   ++__first2;
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first1, __last1, __result);
    }
# 5241 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_less_iter());
    }
# 5291 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
     _InputIterator2 __first2, _InputIterator2 __last2,
     _OutputIterator __result, _Compare __comp)
    {

     
     
     

     


     


      ;
      ;
      ;
      ;

      return std::__set_difference(__first1, __last1,
       __first2, __last2, __result,
       __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator,
    typename _Compare>
    _OutputIterator
    __set_symmetric_difference(_InputIterator1 __first1,
          _InputIterator1 __last1,
          _InputIterator2 __first2,
          _InputIterator2 __last2,
          _OutputIterator __result,
          _Compare __comp)
    {
      while (__first1 != __last1 && __first2 != __last2)
 if (__comp(__first1, __first2))
   {
     *__result = *__first1;
     ++__first1;
     ++__result;
   }
 else if (__comp(__first2, __first1))
   {
     *__result = *__first2;
     ++__first2;
     ++__result;
   }
 else
   {
     ++__first1;
     ++__first2;
   }
      return std::copy(__first2, __last2,
         std::copy(__first1, __last1, __result));
    }
# 5369 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
     __first2, __last2, __result,
     __gnu_cxx::__ops::__iter_less_iter());
    }
# 5419 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _OutputIterator, typename _Compare>
    inline _OutputIterator
    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _InputIterator2 __last2,
        _OutputIterator __result,
        _Compare __comp)
    {

     
     
     

     

     


     


      ;
      ;
      ;
      ;

      return std::__set_symmetric_difference(__first1, __last1,
    __first2, __last2, __result,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __min_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last)
 return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__first, __result))
   __result = __first;
      return __result;
    }
# 5472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    _ForwardIterator
    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5497 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    min_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__min_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _ForwardIterator, typename _Compare>
    constexpr
    _ForwardIterator
    __max_element(_ForwardIterator __first, _ForwardIterator __last,
    _Compare __comp)
    {
      if (__first == __last) return __first;
      _ForwardIterator __result = __first;
      while (++__first != __last)
 if (__comp(__result, __first))
   __result = __first;
      return __result;
    }
# 5536 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last)
    {

     
     

      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_less_iter());
    }
# 5561 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stl_algo.h" 3
  template<typename _ForwardIterator, typename _Compare>
    constexpr
    inline _ForwardIterator
    max_element(_ForwardIterator __first, _ForwardIterator __last,
  _Compare __comp)
    {

     
     


      ;
      ;

      return std::__max_element(__first, __last,
    __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }


}
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/algorithm" 2 3
# 211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/lib/gcc/x86_64-w64-mingw32/6.2.0/include-fixed/limits.h" 1 3 4
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/climits" 2 3
# 214 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 1 3
# 21 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
extern "C" {
# 45 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
  __attribute__ ((__dllimport__)) void *__attribute__((__cdecl__)) _memccpy(void *_Dst,const void *_Src,int _Val,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memchr(const void *_Buf ,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _memicmp_l(const void *_Buf1,const void *_Buf2,size_t _Size,_locale_t _Locale);
  int __attribute__((__cdecl__)) memcmp(const void *_Buf1,const void *_Buf2,size_t _Size);
  void * __attribute__((__cdecl__)) memcpy(void * __restrict__ _Dst,const void * __restrict__ _Src,size_t _Size) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memcpy_s (void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
  void * __attribute__((__cdecl__)) mempcpy (void *_Dst, const void *_Src, size_t _Size);
  void * __attribute__((__cdecl__)) memset(void *_Dst,int _Val,size_t _Size);

  void * __attribute__((__cdecl__)) memccpy(void *_Dst,const void *_Src,int _Val,size_t _Size) ;
  int __attribute__((__cdecl__)) memicmp(const void *_Buf1,const void *_Buf2,size_t _Size) ;


  char * __attribute__((__cdecl__)) _strset(char *_Str,int _Val) ;
  char * __attribute__((__cdecl__)) _strset_l(char *_Str,int _Val,_locale_t _Locale) ;
  char * __attribute__((__cdecl__)) strcpy(char * __restrict__ _Dest,const char * __restrict__ _Source);
  char * __attribute__((__cdecl__)) strcat(char * __restrict__ _Dest,const char * __restrict__ _Source);
  int __attribute__((__cdecl__)) strcmp(const char *_Str1,const char *_Str2);
  size_t __attribute__((__cdecl__)) strlen(const char *_Str);
  size_t __attribute__((__cdecl__)) strnlen(const char *_Str,size_t _MaxCount);
  void *__attribute__((__cdecl__)) memmove(void *_Dst,const void *_Src,size_t _Size) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdup(const char *_Src);
  char *__attribute__((__cdecl__)) strchr(const char *_Str,int _Val);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcmpi(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricmp_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  int __attribute__((__cdecl__)) strcoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strcoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll(const char *_Str1,const char *_Str2);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _stricoll_l(const char *_Str1,const char *_Str2,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strncoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll (const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicoll_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  size_t __attribute__((__cdecl__)) strcspn(const char *_Str,const char *_Control);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strerror(const char *_ErrMsg) ;
  char *__attribute__((__cdecl__)) strerror(int) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strlwr(char *_String) ;
  char *strlwr_l(char *_String,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strncat(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  int __attribute__((__cdecl__)) strncmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp(const char *_Str1,const char *_Str2,size_t _MaxCount);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _strnicmp_l(const char *_Str1,const char *_Str2,size_t _MaxCount,_locale_t _Locale);
  char *strncpy(char * __restrict__ _Dest,const char * __restrict__ _Source,size_t _Count) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset(char *_Str,int _Val,size_t _MaxCount) ;
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strnset_l(char *str,int c,size_t count,_locale_t _Locale) ;
  char *__attribute__((__cdecl__)) strpbrk(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strrchr(const char *_Str,int _Ch);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strrev(char *_Str);
  size_t __attribute__((__cdecl__)) strspn(const char *_Str,const char *_Control);
  char *__attribute__((__cdecl__)) strstr(const char *_Str,const char *_SubStr);
  char *__attribute__((__cdecl__)) strtok(char * __restrict__ _Str,const char * __restrict__ _Delim) ;
       

  char *strtok_r(char * __restrict__ _Str, const char * __restrict__ _Delim, char ** __restrict__ __last);
       
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strupr(char *_String) ;
  __attribute__ ((__dllimport__)) char *_strupr_l(char *_String,_locale_t _Locale) ;
  size_t __attribute__((__cdecl__)) strxfrm(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strxfrm_l(char * __restrict__ _Dst,const char * __restrict__ _Src,size_t _MaxCount,_locale_t _Locale);


  char *__attribute__((__cdecl__)) strdup(const char *_Src) ;
  int __attribute__((__cdecl__)) strcmpi(const char *_Str1,const char *_Str2) ;
  int __attribute__((__cdecl__)) stricmp(const char *_Str1,const char *_Str2) ;
  char *__attribute__((__cdecl__)) strlwr(char *_Str) ;
  int __attribute__((__cdecl__)) strnicmp(const char *_Str1,const char *_Str,size_t _MaxCount) ;
  int __attribute__((__cdecl__)) strncasecmp (const char *, const char *, size_t);
  int __attribute__((__cdecl__)) strcasecmp (const char *, const char *);







  char *__attribute__((__cdecl__)) strnset(char *_Str,int _Val,size_t _MaxCount) ;
  char *__attribute__((__cdecl__)) strrev(char *_Str) ;
  char *__attribute__((__cdecl__)) strset(char *_Str,int _Val) ;
  char *__attribute__((__cdecl__)) strupr(char *_Str) ;
# 187 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 3
}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 1 3
# 9 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 2 3
# 23 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
extern "C" {


  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strset_s(char *_Dst,size_t _DstSize,int _Value);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strerror_s(char *_Buf,size_t _SizeInBytes,const char *_ErrMsg);
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) strerror_s(char *_Buf,size_t _SizeInBytes,int _ErrNum);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strlwr_s_l(char *_Str,size_t _Size,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strnset_s(char *_Str,size_t _Size,int _Val,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s(char *_Str,size_t _Size);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strupr_s_l(char *_Str,size_t _Size,_locale_t _Locale);

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncat_s(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncat_s_l(char *_Dst,size_t _DstSizeInChars,const char *_Src,size_t _MaxCount,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcpy_s(char *_Dst, rsize_t _SizeInBytes, const char *_Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcpy_s(char (&_Dest)[__size], const char * _Source) { return strcpy_s(_Dest,__size,_Source); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strncpy_s(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strncpy_s(char (&_Dest)[__size], const char * _Source, size_t _MaxCount) { return strncpy_s(_Dest,__size,_Source,_MaxCount); } }
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _strncpy_s_l(char *_Dst, size_t _DstSizeInChars, const char *_Src, size_t _MaxCount, _locale_t _Locale);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) _strncpy_s_l(char (&_Dest)[__size], const char * _Source, size_t _MaxCount, _locale_t _Locale) { return _strncpy_s_l(_Dest,__size,_Source,_MaxCount,_Locale); } };
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) strtok_s(char *_Str,const char *_Delim,char **_Context);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtok_s_l(char *_Str,const char *_Delim,char **_Context,_locale_t _Locale);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) strcat_s(char *_Dst, rsize_t _SizeInBytes, const char * _Src);
  extern "C++" { template <size_t __size> inline errno_t __attribute__((__cdecl__)) strcat_s(char (&_Dest)[__size], const char * _Source) { return strcat_s(_Dest,__size,_Source); } }

  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) memmove_s(void *_dest,size_t _numberOfElements,const void *_src,size_t _count);
# 82 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/sec_api/string_s.h" 3
}
# 191 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/string.h" 2 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 2 3
# 71 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
namespace std
{


  using ::memchr;
  using ::memcmp;
  using ::memcpy;
  using ::memmove;
  using ::memset;
  using ::strcat;
  using ::strcmp;
  using ::strcoll;
  using ::strcpy;
  using ::strcspn;
  using ::strerror;
  using ::strlen;
  using ::strncat;
  using ::strncmp;
  using ::strncpy;
  using ::strspn;
  using ::strtok;
  using ::strxfrm;
  using ::strchr;
  using ::strpbrk;
  using ::strrchr;
  using ::strstr;


  inline void*
  memchr(void* __s, int __c, size_t __n)
  { return __builtin_memchr(__s, __c, __n); }

  inline char*
  strchr(char* __s, int __n)
  { return __builtin_strchr(__s, __n); }

  inline char*
  strpbrk(char* __s1, const char* __s2)
  { return __builtin_strpbrk(__s1, __s2); }

  inline char*
  strrchr(char* __s, int __n)
  { return __builtin_strrchr(__s, __n); }

  inline char*
  strstr(char* __s1, const char* __s2)
  { return __builtin_strstr(__s1, __s2); }



}
# 216 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 1 3
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
       
# 47 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
namespace std
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }

      static constexpr _Tp*
      _S_ptr(const _Type& __t) noexcept
      { return const_cast<_Tp*>(__t); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }

     static constexpr _Tp*
     _S_ptr(const _Type&) noexcept
     { return nullptr; }
   };
# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(__is_nothrow_swappable<_Tp>::value)
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return _AT_Type::_S_ptr(_M_elems); }

      const_pointer
      data() const noexcept
      { return _AT_Type::_S_ptr(_M_elems); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(std::get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std
{





  template<typename _Tp>
    class tuple_size;


  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;


  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<std::array<_Tp, _Nm>> : true_type
    { };


}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 2 3


namespace std
{







  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(allocator_arg_t, __uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(allocator_arg_t, __uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value
               && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<std::size_t _Idx, typename _Head>
    struct _Tuple_impl<_Idx, _Head>
    : private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      constexpr _Tuple_impl()
      : _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head)
      : _Base(__head) { }

      template<typename _UHead>
        explicit
        constexpr _Tuple_impl(_UHead&& __head)
 : _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_constructible<_Head>::value)
      : _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename _UHead>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _UHead>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Base(__tag, __use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UHead>& __in)
 : _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead>&& __in)
 : _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))
 { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(is_nothrow_move_assignable<_Head>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 return *this;
      }

      template<typename _UHead>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UHead>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UHead>::_M_head(__in);
   return *this;
 }

      template<typename _UHead>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead>&& __in)
        {
   _M_head(*this)
     = std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(__is_nothrow_swappable<_Head>::value)
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
      }
    };

  template<typename... _Elements>
    class tuple;



  template<bool, typename... _Elements>
  struct _TC
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, const _UElements&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return __and_<is_convertible<const _UElements&, _Elements>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return __and_<is_constructible<_Elements, _UElements&&>...>::value;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return __and_<is_convertible<_UElements&&, _Elements>...>::value;
    }

    template<typename _SrcTuple>
    static constexpr bool _NonNestedTuple()
    {
      return __and_<__not_<is_same<tuple<_Elements...>,
                                   typename remove_cv<
                                     typename remove_reference<_SrcTuple>::type
                                   >::type>>,
                     __not_<is_convertible<_SrcTuple, _Elements...>>,
                     __not_<is_constructible<_Elements..., _SrcTuple>>
              >::value;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return __not_<is_same<tuple<_Elements...>,
        typename remove_const<
          typename remove_reference<_UElements...>::type
          >::type>>::value;
    }
  };

  template<typename... _Elements>
  struct _TC<false, _Elements...>
  {
    template<typename... _UElements>
    static constexpr bool _ConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _MoveConstructibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _ImplicitlyMoveConvertibleTuple()
    {
      return false;
    }

    template<typename... _UElements>
    static constexpr bool _NonNestedTuple()
    {
      return true;
    }
    template<typename... _UElements>
    static constexpr bool _NotSameTuple()
    {
      return true;
    }
  };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;



      template<typename _Dummy>
      struct _TC2
      {
        static constexpr bool _DefaultConstructibleTuple()
        {
          return __and_<is_default_constructible<_Elements>...>::value;
        }
        static constexpr bool _ImplicitlyDefaultConstructibleTuple()
        {
          return __and_<__is_implicitly_default_constructible<_Elements>...>
            ::value;
        }
      };

    public:
      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = true>
      constexpr tuple()
      : _Inherited() { }

      template<typename _Dummy = void,
               typename enable_if<_TC2<_Dummy>::
                                    _DefaultConstructibleTuple()
                                  &&
                                  !_TC2<_Dummy>::
                                    _ImplicitlyDefaultConstructibleTuple(),
                                  bool>::type = false>
      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value,
            _Elements...>;

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=true>
        constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>()
                 && (sizeof...(_Elements) >= 1),
               bool>::type=false>
      explicit constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }



      template<typename... _UElements> using _TMC =
                  _TC<(sizeof...(_Elements) == sizeof...(_UElements)),
                      _Elements...>;

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=true>
        constexpr tuple(_UElements&&... __elements)
        : _Inherited(std::forward<_UElements>(__elements)...) { }

      template<typename... _UElements, typename
        enable_if<
    _TC<sizeof...(_UElements) == 1, _Elements...>::template
      _NotSameTuple<_UElements...>()
    && _TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && (sizeof...(_Elements) >= 1),
        bool>::type=false>
        explicit constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;



      template<typename _Dummy> using _TNTC =
        _TC<is_same<_Dummy, void>::value && sizeof...(_Elements) == 1,
            _Elements...>;

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=true>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<const tuple<_UElements...>&>(),
        bool>::type=false>
        explicit constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=true>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }

      template<typename... _UElements, typename _Dummy = void, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>()
                  && _TNTC<_Dummy>::template
                    _NonNestedTuple<tuple<_UElements...>&&>(),
        bool>::type=false>
        explicit constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_Elements...>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_Elements...>(),
               bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _ConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && _TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename
        enable_if<_TMC<_UElements...>::template
                    _MoveConstructibleTuple<_UElements...>()
                  && !_TMC<_UElements...>::template
                    _ImplicitlyMoveConvertibleTuple<_UElements...>(),
        bool>::type=false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<__and_<
                                     __is_implicitly_default_constructible<_U1>,
                                     __is_implicitly_default_constructible<_U2>>
                                   ::value, bool>::type = true>

      constexpr tuple()
      : _Inherited() { }

      template <typename _U1 = _T1,
                typename _U2 = _T2,
                typename enable_if<
                  __and_<
                    is_default_constructible<_U1>,
                    is_default_constructible<_U2>,
                    __not_<
                      __and_<__is_implicitly_default_constructible<_U1>,
                             __is_implicitly_default_constructible<_U2>>>>
                  ::value, bool>::type = false>

      explicit constexpr tuple()
      : _Inherited() { }



      template<typename _Dummy> using _TCC =
        _TC<is_same<_Dummy, void>::value, _T1, _T2>;

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && _TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = true>
        constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }

      template<typename _Dummy = void, typename
               enable_if<_TCC<_Dummy>::template
                           _ConstructibleTuple<_T1, _T2>()
                         && !_TCC<_Dummy>::template
                           _ImplicitlyConvertibleTuple<_T1, _T2>(),
 bool>::type = false>
        explicit constexpr tuple(const _T1& __a1, const _T2& __a2)
        : _Inherited(__a1, __a2) { }



      using _TMC = _TC<true, _T1, _T2>;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && _TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=true>

 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _Dummy = void,
               typename enable_if<
                 _TCC<_Dummy>::template
                   _ConstructibleTuple<_T1, _T2>()
                 && !_TCC<_Dummy>::template
                   _ImplicitlyConvertibleTuple<_T1, _T2>(),
               bool>::type=false>

 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
 explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _ConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && _TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = true>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      template<typename _Alloc, typename _U1, typename _U2, typename
        enable_if<_TMC::template
                    _MoveConstructibleTuple<_U1, _U2>()
                  && !_TMC::template
                    _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),
 bool>::type = false>
        explicit tuple(allocator_arg_t __tag, const _Alloc& __a,
                       pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };






  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr _Head&
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr const _Head&
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr __tuple_element_t<__i, tuple<_Elements...>>&&
    get(tuple<_Elements...>&& __t) noexcept
    {
      typedef __tuple_element_t<__i, tuple<_Elements...>> __element_type;
      return std::forward<__element_type&&>(std::get<__i>(__t));
    }





  template<typename _Head, size_t __i, typename... _Tail>
    constexpr _Head&
    __get_helper2(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<typename _Head, size_t __i, typename... _Tail>
    constexpr const _Head&
    __get_helper2(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&
    get(tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }


  template <typename _Tp, typename... _Types>
    constexpr _Tp&&
    get(tuple<_Types...>&& __t) noexcept
    { return std::forward<_Tp&&>(std::__get_helper2<_Tp>(__t)); }


  template <typename _Tp, typename... _Types>
    constexpr const _Tp&
    get(const tuple<_Types...>& __t) noexcept
    { return std::__get_helper2<_Tp>(__t); }



  template<typename _Tp, typename _Up, size_t __i, size_t __size>
    struct __tuple_compare
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) == std::get<__i>(__u))
   && __tuple_compare<_Tp, _Up, __i + 1, __size>::__eq(__t, __u);
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return bool(std::get<__i>(__t) < std::get<__i>(__u))
   || (!bool(std::get<__i>(__u) < std::get<__i>(__t))
       && __tuple_compare<_Tp, _Up, __i + 1, __size>::__less(__t, __u));
      }
    };

  template<typename _Tp, typename _Up, size_t __size>
    struct __tuple_compare<_Tp, _Up, __size, __size>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__eq(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      static_assert(sizeof...(_TElements) == sizeof...(_UElements),
   "tuple objects can only be compared if they have equal sizes.");
      using __compare = __tuple_compare<tuple<_TElements...>,
     tuple<_UElements...>,
     0, sizeof...(_TElements)>;
      return __compare::__less(__t, __u);
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }



  template<typename... _Elements>
    constexpr tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };

  template<size_t, typename, typename, size_t>
    struct __make_tuple_impl;

  template<size_t _Idx, typename _Tuple, typename... _Tp, size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    : __make_tuple_impl<_Idx + 1,
   tuple<_Tp..., __tuple_element_t<_Idx, _Tuple>>,
   _Tuple, _Nm>
    { };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }




  template<typename... _Elements>
    constexpr tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 2 3




namespace std
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*) noexcept;


  template<typename _Functor, typename = __void_t<>>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<_Functor,
      __void_t<typename _Functor::result_type>>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<_Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };

  template<typename _Tp, typename _Up = typename decay<_Tp>::type>
    struct _Unwrap
    {
      using type = _Tp&&;


      static constexpr _Tp&&
      _S_fwd(_Tp& __t) noexcept { return static_cast<_Tp&&>(__t); }
    };

  template<typename _Tp, typename _Up>
    struct _Unwrap<_Tp, reference_wrapper<_Up>>
    {
      using type = _Up&;


      static _Up&
      _S_fwd(const _Tp& __t) noexcept { __t.get(); }
    };



  template<typename _Tp>
    inline typename _Unwrap<_Tp>::type
    __invfwd(typename remove_reference<_Tp>::type& __t) noexcept
    { return _Unwrap<_Tp>::_S_fwd(__t); }

  template<typename _Res, typename _Fn, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_other, _Fn&& __f, _Args&&... __args)
    noexcept(noexcept(std::forward<_Fn>(__f)(std::forward<_Args>(__args)...)))
    { return std::forward<_Fn>(__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memfun_ref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept(
   (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...)))
    { return (__invfwd<_Tp>(__t).*__f)(std::forward<_Args>(__args)...); }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memfun_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept(
   ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...)))
    {
      return ((*std::forward<_Tp>(__t)).*__f)(std::forward<_Args>(__args)...);
    }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memobj_ref, _MemFun&& __f, _Tp&& __t)
    noexcept(noexcept(__invfwd<_Tp>(__t).*__f))
    { return __invfwd<_Tp>(__t).*__f; }

  template<typename _Res, typename _MemFun, typename _Tp, typename... _Args>
    inline _Res
    __invoke_impl(__invoke_memobj_deref, _MemFun&& __f, _Tp&& __t,
    _Args&&... __args)
    noexcept(noexcept((*std::forward<_Tp>(__t)).*__f))
    { return (*std::forward<_Tp>(__t)).*__f; }


  template<typename _Callable, typename... _Args>
    inline typename result_of<_Callable&&(_Args&&...)>::type
    __invoke(_Callable&& __fn, _Args&&... __args)
    {
      using __result_of = result_of<_Callable&&(_Args&&...)>;
      using __type = typename __result_of::type;
      using __tag = typename __result_of::__invoke_type;
      return std::__invoke_impl<__type>(__tag{}, std::forward<_Callable>(__fn),
     std::forward<_Args>(__args)...);
    }
# 281 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp, typename = __void_t<>> struct __has_argument_type : false_type { }; template<typename _Tp> struct __has_argument_type<_Tp, __void_t<typename _Tp::argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_first_argument_type : false_type { }; template<typename _Tp> struct __has_first_argument_type<_Tp, __void_t<typename _Tp::first_argument_type>> : true_type { };
  template<typename _Tp, typename = __void_t<>> struct __has_second_argument_type : false_type { }; template<typename _Tp> struct __has_second_argument_type<_Tp, __void_t<typename _Tp::second_argument_type>> : true_type { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper&) = default;

      reference_wrapper&
      operator=(const reference_wrapper&) = default;

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return std::__invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }



  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };

  template<typename _Signature>
    struct _Mem_fn_traits;

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Mem_fn_traits_base
    {
      using __result_type = _Res;
      using __maybe_type
 = _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>;
      using __arity = integral_constant<size_t, sizeof...(_ArgTypes)>;
    };
# 578 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) > : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const > : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile > : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile > : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };
template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) &&> : _Mem_fn_traits_base<_Res, _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const &&> : _Mem_fn_traits_base<_Res, const _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) volatile &&> : _Mem_fn_traits_base<_Res, volatile _Class, _ArgTypes...> { using __vararg = true_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = false_type; }; template<typename _Res, typename _Class, typename... _ArgTypes> struct _Mem_fn_traits<_Res (_Class::*)(_ArgTypes... ...) const volatile &&> : _Mem_fn_traits_base<_Res, const volatile _Class, _ArgTypes...> { using __vararg = true_type; };




  template<typename _MemFunPtr,
    bool __is_mem_fn = is_member_function_pointer<_MemFunPtr>::value>
    class _Mem_fn_base
    : public _Mem_fn_traits<_MemFunPtr>::__maybe_type
    {
      using _Traits = _Mem_fn_traits<_MemFunPtr>;

      using _Arity = typename _Traits::__arity;
      using _Varargs = typename _Traits::__vararg;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemFunPtr _M_pmf;

    public:

      using result_type = typename _Traits::__result_type;

      explicit constexpr
      _Mem_fn_base(_MemFunPtr __pmf) noexcept : _M_pmf(__pmf) { }

      template<typename... _Args>
 auto
 operator()(_Args&&... __args) const
 noexcept(noexcept(
       std::__invoke(_M_pmf, std::forward<_Args>(__args)...)))
 -> decltype(std::__invoke(_M_pmf, std::forward<_Args>(__args)...))
 { return std::__invoke(_M_pmf, std::forward<_Args>(__args)...); }
    };


  template<typename _MemObjPtr>
    class _Mem_fn_base<_MemObjPtr, false>
    {
      using _Arity = integral_constant<size_t, 0>;
      using _Varargs = false_type;

      template<typename _Func, typename... _BoundArgs>
 friend struct _Bind_check_arity;

      _MemObjPtr _M_pm;

    public:
      explicit constexpr
      _Mem_fn_base(_MemObjPtr __pm) noexcept : _M_pm(__pm) { }

      template<typename _Tp>
 auto
 operator()(_Tp&& __obj) const
 noexcept(noexcept(std::__invoke(_M_pm, std::forward<_Tp>(__obj))))
 -> decltype(std::__invoke(_M_pm, std::forward<_Tp>(__obj)))
 { return std::__invoke(_M_pm, std::forward<_Tp>(__obj)); }
    };

  template<typename _Res, typename _Class>
    struct _Mem_fn<_Res _Class::*>
    : _Mem_fn_base<_Res _Class::*>
    {
      using _Mem_fn_base<_Res _Class::*>::_Mem_fn_base;
    };
# 654 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }
# 669 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };
# 680 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };

 





  namespace placeholders
  {
 




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
 
  }

 






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };



 template<std::size_t __i, typename _Tuple>
   using _Safe_tuple_element_t
     = typename enable_if<(__i < tuple_size<_Tuple>::value),
     tuple_element<__i, _Tuple>>::type::type;
# 770 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;






  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:




      template<typename _CVRef, typename _Tuple>
 _Tp&
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };







  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(std::get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Tuple>
 _Safe_tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>&&
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   using __type
     = __tuple_element_t<(is_placeholder<_Arg>::value - 1), _Tuple>;
   return std::forward<__type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static constexpr const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static constexpr _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static constexpr type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> __tuple_element_t<_Ind, tuple<_Tp...>> const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor&>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type&>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (std::get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_check_arity { };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args...), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) == sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Ret, typename... _Args, typename... _BoundArgs>
    struct _Bind_check_arity<_Ret (*)(_Args......), _BoundArgs...>
    {
      static_assert(sizeof...(_BoundArgs) >= sizeof...(_Args),
                   "Wrong number of arguments for function");
    };

  template<typename _Tp, typename _Class, typename... _BoundArgs>
    struct _Bind_check_arity<_Tp _Class::*, _BoundArgs...>
    {
      using _Arity = typename _Mem_fn<_Tp _Class::*>::_Arity;
      using _Varargs = typename _Mem_fn<_Tp _Class::*>::_Varargs;
      static_assert(_Varargs::value
      ? sizeof...(_BoundArgs) >= _Arity::value + 1
      : sizeof...(_BoundArgs) == _Arity::value + 1,
      "Wrong number of arguments for pointer-to-member");
    };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename _Tp, typename... _Up>
        explicit
        _Bind_simple(_Tp&& __f, _Up&&... __args)
        : _M_bound(std::forward<_Tp>(__f), std::forward<_Up>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:
      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    : _Bind_check_arity<typename decay<_Func>::type, _BoundArgs...>
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };







  template<typename _Tp>
    struct __is_location_invariant
    : is_trivially_copyable<_Tp>::type
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* __fp)
   { return __fp != nullptr; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* __mp)
   { return __mp != nullptr; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
 }
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::__callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::__callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
 std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_same<_From, _To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      template<typename _Func,
        typename _Res2 = typename result_of<_Func&(_ArgTypes...)>::type>
 struct _Callable : __check_func_return_type<_Res2, _Res> { };



      template<typename _Tp>
 struct _Callable<function, _Tp> : false_type { };

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 1888 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function(const function& __x);
# 1897 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
# 1920 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor,
        typename = _Requires<__not_<is_same<_Functor, function>>, void>,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 1937 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 1955 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 1969 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      function&
      operator=(nullptr_t) noexcept
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = nullptr;
     _M_invoker = nullptr;
   }
 return *this;
      }
# 1997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 2023 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 2051 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 2064 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      _Res operator()(_ArgTypes... __args) const;
# 2077 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      const type_info& target_type() const noexcept;
# 2088 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
      template<typename _Functor> _Functor* target() noexcept;


      template<typename _Functor> const _Functor* target() const noexcept;


    private:
      using _Invoker_type = _Res (*)(const _Any_data&, _ArgTypes&&...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
# 2200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 2218 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 2236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/functional" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}
# 224 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 2
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
 
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
class half;



 namespace detail
 {
# 311 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<bool,typename T,typename> struct conditional { typedef T type; };
  template<typename T,typename F> struct conditional<false,T,F> { typedef F type; };


  template<bool> struct bool_type {};
  typedef bool_type<true> true_type;
  typedef bool_type<false> false_type;


  template<typename> struct is_float : false_type {};
  template<typename T> struct is_float<const T> : is_float<T> {};
  template<typename T> struct is_float<volatile T> : is_float<T> {};
  template<typename T> struct is_float<const volatile T> : is_float<T> {};
  template<> struct is_float<float> : true_type {};
  template<> struct is_float<double> : true_type {};
  template<> struct is_float<long double> : true_type {};




  typedef std::uint_least16_t uint16;


  typedef std::uint_least32_t uint32;


  typedef std::int_fast32_t int17;
# 350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  struct binary_t {};


  constexpr binary_t binary = binary_t();



  struct expr
  {


   explicit constexpr expr(float f) : value_(f) {}



   constexpr operator float() const { return value_; }

  private:

   float value_;
  };





  template<typename T,typename,typename=void,typename=void> struct enable {};
  template<typename T> struct enable<T,half,void,void> { typedef T type; };
  template<typename T> struct enable<T,float,void,void> { typedef T type; };
  template<typename T> struct enable<T,double,void,void> { typedef T type; };
  template<typename T> struct enable<T,long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long long,void,void> { typedef T type; };
  template<typename T> struct enable<T,long,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned long,void,void> { typedef T type; };
  template<typename T> struct enable<T,int,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned int,void,void> { typedef T type; };
  template<typename T> struct enable<T,short,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned short,void,void> { typedef T type; };
  template<typename T> struct enable<T,char,void,void> { typedef T type; };
  template<typename T> struct enable<T,unsigned char,void,void> { typedef T type; };
  template<typename T> struct enable<T,expr,void,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,void> { typedef T type; };
  template<typename T> struct enable<T,half,long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long long,void> { typedef T type; };
  template<typename T> struct enable<T,half,long,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned long,void> { typedef T type; };
  template<typename T> struct enable<T,half,int,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned int,void> { typedef T type; };
  template<typename T> struct enable<T,half,short,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned short,void> { typedef T type; };
  template<typename T> struct enable<T,half,char,void> { typedef T type; };
  template<typename T> struct enable<T,half,unsigned char,void> { typedef T type; };
  template<typename T> struct enable<T,float,half,void> { typedef float type; };
  template<typename T> struct enable<T,half,float,void> { typedef float type; };
  template<typename T> struct enable<T,double,half,void> { typedef double type; };
  template<typename T> struct enable<T,half,double,void> { typedef double type; };
  template<typename T> struct enable<T,half,expr,void> { typedef T type; };
  template<typename T> struct enable<T,expr,half,void> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,void> { typedef T type; };
  template<typename T> struct enable<T,half,half,half> { typedef T type; };
  template<typename T> struct enable<T,half,half,expr> { typedef T type; };
  template<typename T> struct enable<T,half,expr,half> { typedef T type; };
  template<typename T> struct enable<T,half,expr,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,half,half> { typedef T type; };
  template<typename T> struct enable<T,expr,half,expr> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,half> { typedef T type; };
  template<typename T> struct enable<T,expr,expr,expr> { typedef T type; };






  template<typename T,typename U> struct result : enable<expr,T,U> {};
  template<> struct result<half,half> { typedef half type; };
# 434 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T> bool builtin_isinf(T arg)
  {

   return std::isinf(arg);





  }






  template<typename T> bool builtin_isnan(T arg)
  {

   return std::isnan(arg);





  }






  template<typename T> bool builtin_signbit(T arg)
  {

   return std::signbit(arg);



  }
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<std::float_round_style R> uint16 float2half_impl(float value, true_type)
  {

   static_assert(std::numeric_limits<float>::is_iec559, "float to half conversion needs IEEE 754 conformant 'float' type");
   static_assert(sizeof(uint32)==sizeof(float), "float to half conversion needs unsigned integer type of exactly the size of a 'float'");

   static const uint16 base_table[512] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080, 0x0100,
    0x0200, 0x0400, 0x0800, 0x0C00, 0x1000, 0x1400, 0x1800, 0x1C00, 0x2000, 0x2400, 0x2800, 0x2C00, 0x3000, 0x3400, 0x3800, 0x3C00,
    0x4000, 0x4400, 0x4800, 0x4C00, 0x5000, 0x5400, 0x5800, 0x5C00, 0x6000, 0x6400, 0x6800, 0x6C00, 0x7000, 0x7400, 0x7800, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00, 0x7C00,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000,
    0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8000, 0x8001, 0x8002, 0x8004, 0x8008, 0x8010, 0x8020, 0x8040, 0x8080, 0x8100,
    0x8200, 0x8400, 0x8800, 0x8C00, 0x9000, 0x9400, 0x9800, 0x9C00, 0xA000, 0xA400, 0xA800, 0xAC00, 0xB000, 0xB400, 0xB800, 0xBC00,
    0xC000, 0xC400, 0xC800, 0xCC00, 0xD000, 0xD400, 0xD800, 0xDC00, 0xE000, 0xE400, 0xE800, 0xEC00, 0xF000, 0xF400, 0xF800, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00,
    0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00, 0xFC00 };
   static const unsigned char shift_table[512] = {
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
    13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 13 };
   uint32 bits;
   std::memcpy(&bits, &value, sizeof(float));
   uint16 hbits = base_table[bits>>23] + static_cast<uint16>((bits&0x7FFFFF)>>shift_table[bits>>23]);
   if(R == std::round_to_nearest)
    hbits += (((bits&0x7FFFFF)>>(shift_table[bits>>23]-1))|(((bits>>23)&0xFF)==102)) & ((hbits&0x7C00)!=0x7C00)

     & (((((static_cast<uint32>(1)<<(shift_table[bits>>23]-1))-1)&bits)!=0)|hbits)

    ;
   else if(R == std::round_toward_zero)
    hbits -= ((hbits&0x7FFF)==0x7C00) & ~shift_table[bits>>23];
   else if(R == std::round_toward_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=102)&
     ((bits>>23)!=0)))&(hbits<0x7C00)) - ((hbits==0xFC00)&((bits>>23)!=511));
   else if(R == std::round_toward_neg_infinity)
    hbits += ((((bits&0x7FFFFF&((static_cast<uint32>(1)<<(shift_table[bits>>23]))-1))!=0)|(((bits>>23)<=358)&
     ((bits>>23)!=256)))&(hbits<0xFC00)&(hbits>>15)) - ((hbits==0x7C00)&((bits>>23)!=255));
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half_impl(float value, false_type)
  {
   uint16 hbits = builtin_signbit(value) << 15;
   if(value == 0.0f)
    return hbits;
   if(builtin_isnan(value))
    return hbits | 0x7FFF;
   if(builtin_isinf(value))
    return hbits | 0x7C00;
   int exp;
   std::frexp(value, &exp);
   if(exp > 16)
   {
    if(R == std::round_toward_zero)
     return hbits | 0x7BFF;
    else if(R == std::round_toward_infinity)
     return hbits | 0x7C00 - (hbits>>15);
    else if(R == std::round_toward_neg_infinity)
     return hbits | 0x7BFF + (hbits>>15);
    return hbits | 0x7C00;
   }
   if(exp < -13)
    value = std::ldexp(value, 24);
   else
   {
    value = std::ldexp(value, 11-exp);
    hbits |= ((exp+14)<<10);
   }
   int ival = static_cast<int>(value);
   hbits |= static_cast<uint16>(std::abs(ival)&0x3FF);
   if(R == std::round_to_nearest)
   {
    float diff = std::abs(value-static_cast<float>(ival));

     hbits += (diff>0.5f) | ((diff==0.5f)&hbits);



   }
   else if(R == std::round_toward_infinity)
    hbits += value > static_cast<float>(ival);
   else if(R == std::round_toward_neg_infinity)
    hbits += value < static_cast<float>(ival);
   return hbits;
  }




  template<std::float_round_style R> uint16 float2half(float value)
  {
   return float2half_impl<R>(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool S,typename T> uint16 int2half_impl(T value)
  {
   if(S)
    value = -value;
   uint16 bits = S << 15;
   if(value > 65504)
   {
    if(R == std::round_toward_infinity)
     bits |= 0x7C00 - S;
    else if(R == std::round_toward_neg_infinity)
     bits |= 0x7BFF + S;
    else
     bits |= 0x7BFF + (R!=std::round_toward_zero);
   }
   else if(value)
   {
    unsigned int m = value, exp = 25;
    for(; m<0x400; m<<=1,--exp) ;
    for(; m>0x7FF; m>>=1,++exp) ;
    bits |= (exp<<10) | (m&0x3FF);
    if(exp > 25)
    {
     if(R == std::round_to_nearest)
      bits += (value>>(exp-26)) & 1

       & (((((1<<(exp-26))-1)&value)!=0)|bits)

      ;
     else if(R == std::round_toward_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & !S;
     else if(R == std::round_toward_neg_infinity)
      bits += ((value&((1<<(exp-25))-1))!=0) & S;
    }
   }
   return bits;
  }






  template<std::float_round_style R,typename T> uint16 int2half(T value)
  {
   return (value<0) ? int2half_impl<R,true>(value) : int2half_impl<R,false>(value);
  }





  inline float half2float_impl(uint16 value, true_type)
  {

   static_assert(std::numeric_limits<float>::is_iec559, "half to float conversion needs IEEE 754 conformant 'float' type");
   static_assert(sizeof(uint32)==sizeof(float), "half to float conversion needs unsigned integer type of exactly the size of a 'float'");

   static const uint32 mantissa_table[2048] = {
    0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34A00000, 0x34C00000, 0x34E00000, 0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
    0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35A00000, 0x35A80000, 0x35B00000, 0x35B80000, 0x35C00000, 0x35C80000, 0x35D00000, 0x35D80000, 0x35E00000, 0x35E80000, 0x35F00000, 0x35F80000,
    0x36000000, 0x36040000, 0x36080000, 0x360C0000, 0x36100000, 0x36140000, 0x36180000, 0x361C0000, 0x36200000, 0x36240000, 0x36280000, 0x362C0000, 0x36300000, 0x36340000, 0x36380000, 0x363C0000,
    0x36400000, 0x36440000, 0x36480000, 0x364C0000, 0x36500000, 0x36540000, 0x36580000, 0x365C0000, 0x36600000, 0x36640000, 0x36680000, 0x366C0000, 0x36700000, 0x36740000, 0x36780000, 0x367C0000,
    0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368A0000, 0x368C0000, 0x368E0000, 0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369A0000, 0x369C0000, 0x369E0000,
    0x36A00000, 0x36A20000, 0x36A40000, 0x36A60000, 0x36A80000, 0x36AA0000, 0x36AC0000, 0x36AE0000, 0x36B00000, 0x36B20000, 0x36B40000, 0x36B60000, 0x36B80000, 0x36BA0000, 0x36BC0000, 0x36BE0000,
    0x36C00000, 0x36C20000, 0x36C40000, 0x36C60000, 0x36C80000, 0x36CA0000, 0x36CC0000, 0x36CE0000, 0x36D00000, 0x36D20000, 0x36D40000, 0x36D60000, 0x36D80000, 0x36DA0000, 0x36DC0000, 0x36DE0000,
    0x36E00000, 0x36E20000, 0x36E40000, 0x36E60000, 0x36E80000, 0x36EA0000, 0x36EC0000, 0x36EE0000, 0x36F00000, 0x36F20000, 0x36F40000, 0x36F60000, 0x36F80000, 0x36FA0000, 0x36FC0000, 0x36FE0000,
    0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000, 0x37080000, 0x37090000, 0x370A0000, 0x370B0000, 0x370C0000, 0x370D0000, 0x370E0000, 0x370F0000,
    0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000, 0x37180000, 0x37190000, 0x371A0000, 0x371B0000, 0x371C0000, 0x371D0000, 0x371E0000, 0x371F0000,
    0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000, 0x37280000, 0x37290000, 0x372A0000, 0x372B0000, 0x372C0000, 0x372D0000, 0x372E0000, 0x372F0000,
    0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000, 0x37380000, 0x37390000, 0x373A0000, 0x373B0000, 0x373C0000, 0x373D0000, 0x373E0000, 0x373F0000,
    0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000, 0x37480000, 0x37490000, 0x374A0000, 0x374B0000, 0x374C0000, 0x374D0000, 0x374E0000, 0x374F0000,
    0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000, 0x37580000, 0x37590000, 0x375A0000, 0x375B0000, 0x375C0000, 0x375D0000, 0x375E0000, 0x375F0000,
    0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000, 0x37680000, 0x37690000, 0x376A0000, 0x376B0000, 0x376C0000, 0x376D0000, 0x376E0000, 0x376F0000,
    0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000, 0x37780000, 0x37790000, 0x377A0000, 0x377B0000, 0x377C0000, 0x377D0000, 0x377E0000, 0x377F0000,
    0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000, 0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
    0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378A0000, 0x378A8000, 0x378B0000, 0x378B8000, 0x378C0000, 0x378C8000, 0x378D0000, 0x378D8000, 0x378E0000, 0x378E8000, 0x378F0000, 0x378F8000,
    0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000, 0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
    0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379A0000, 0x379A8000, 0x379B0000, 0x379B8000, 0x379C0000, 0x379C8000, 0x379D0000, 0x379D8000, 0x379E0000, 0x379E8000, 0x379F0000, 0x379F8000,
    0x37A00000, 0x37A08000, 0x37A10000, 0x37A18000, 0x37A20000, 0x37A28000, 0x37A30000, 0x37A38000, 0x37A40000, 0x37A48000, 0x37A50000, 0x37A58000, 0x37A60000, 0x37A68000, 0x37A70000, 0x37A78000,
    0x37A80000, 0x37A88000, 0x37A90000, 0x37A98000, 0x37AA0000, 0x37AA8000, 0x37AB0000, 0x37AB8000, 0x37AC0000, 0x37AC8000, 0x37AD0000, 0x37AD8000, 0x37AE0000, 0x37AE8000, 0x37AF0000, 0x37AF8000,
    0x37B00000, 0x37B08000, 0x37B10000, 0x37B18000, 0x37B20000, 0x37B28000, 0x37B30000, 0x37B38000, 0x37B40000, 0x37B48000, 0x37B50000, 0x37B58000, 0x37B60000, 0x37B68000, 0x37B70000, 0x37B78000,
    0x37B80000, 0x37B88000, 0x37B90000, 0x37B98000, 0x37BA0000, 0x37BA8000, 0x37BB0000, 0x37BB8000, 0x37BC0000, 0x37BC8000, 0x37BD0000, 0x37BD8000, 0x37BE0000, 0x37BE8000, 0x37BF0000, 0x37BF8000,
    0x37C00000, 0x37C08000, 0x37C10000, 0x37C18000, 0x37C20000, 0x37C28000, 0x37C30000, 0x37C38000, 0x37C40000, 0x37C48000, 0x37C50000, 0x37C58000, 0x37C60000, 0x37C68000, 0x37C70000, 0x37C78000,
    0x37C80000, 0x37C88000, 0x37C90000, 0x37C98000, 0x37CA0000, 0x37CA8000, 0x37CB0000, 0x37CB8000, 0x37CC0000, 0x37CC8000, 0x37CD0000, 0x37CD8000, 0x37CE0000, 0x37CE8000, 0x37CF0000, 0x37CF8000,
    0x37D00000, 0x37D08000, 0x37D10000, 0x37D18000, 0x37D20000, 0x37D28000, 0x37D30000, 0x37D38000, 0x37D40000, 0x37D48000, 0x37D50000, 0x37D58000, 0x37D60000, 0x37D68000, 0x37D70000, 0x37D78000,
    0x37D80000, 0x37D88000, 0x37D90000, 0x37D98000, 0x37DA0000, 0x37DA8000, 0x37DB0000, 0x37DB8000, 0x37DC0000, 0x37DC8000, 0x37DD0000, 0x37DD8000, 0x37DE0000, 0x37DE8000, 0x37DF0000, 0x37DF8000,
    0x37E00000, 0x37E08000, 0x37E10000, 0x37E18000, 0x37E20000, 0x37E28000, 0x37E30000, 0x37E38000, 0x37E40000, 0x37E48000, 0x37E50000, 0x37E58000, 0x37E60000, 0x37E68000, 0x37E70000, 0x37E78000,
    0x37E80000, 0x37E88000, 0x37E90000, 0x37E98000, 0x37EA0000, 0x37EA8000, 0x37EB0000, 0x37EB8000, 0x37EC0000, 0x37EC8000, 0x37ED0000, 0x37ED8000, 0x37EE0000, 0x37EE8000, 0x37EF0000, 0x37EF8000,
    0x37F00000, 0x37F08000, 0x37F10000, 0x37F18000, 0x37F20000, 0x37F28000, 0x37F30000, 0x37F38000, 0x37F40000, 0x37F48000, 0x37F50000, 0x37F58000, 0x37F60000, 0x37F68000, 0x37F70000, 0x37F78000,
    0x37F80000, 0x37F88000, 0x37F90000, 0x37F98000, 0x37FA0000, 0x37FA8000, 0x37FB0000, 0x37FB8000, 0x37FC0000, 0x37FC8000, 0x37FD0000, 0x37FD8000, 0x37FE0000, 0x37FE8000, 0x37FF0000, 0x37FF8000,
    0x38000000, 0x38004000, 0x38008000, 0x3800C000, 0x38010000, 0x38014000, 0x38018000, 0x3801C000, 0x38020000, 0x38024000, 0x38028000, 0x3802C000, 0x38030000, 0x38034000, 0x38038000, 0x3803C000,
    0x38040000, 0x38044000, 0x38048000, 0x3804C000, 0x38050000, 0x38054000, 0x38058000, 0x3805C000, 0x38060000, 0x38064000, 0x38068000, 0x3806C000, 0x38070000, 0x38074000, 0x38078000, 0x3807C000,
    0x38080000, 0x38084000, 0x38088000, 0x3808C000, 0x38090000, 0x38094000, 0x38098000, 0x3809C000, 0x380A0000, 0x380A4000, 0x380A8000, 0x380AC000, 0x380B0000, 0x380B4000, 0x380B8000, 0x380BC000,
    0x380C0000, 0x380C4000, 0x380C8000, 0x380CC000, 0x380D0000, 0x380D4000, 0x380D8000, 0x380DC000, 0x380E0000, 0x380E4000, 0x380E8000, 0x380EC000, 0x380F0000, 0x380F4000, 0x380F8000, 0x380FC000,
    0x38100000, 0x38104000, 0x38108000, 0x3810C000, 0x38110000, 0x38114000, 0x38118000, 0x3811C000, 0x38120000, 0x38124000, 0x38128000, 0x3812C000, 0x38130000, 0x38134000, 0x38138000, 0x3813C000,
    0x38140000, 0x38144000, 0x38148000, 0x3814C000, 0x38150000, 0x38154000, 0x38158000, 0x3815C000, 0x38160000, 0x38164000, 0x38168000, 0x3816C000, 0x38170000, 0x38174000, 0x38178000, 0x3817C000,
    0x38180000, 0x38184000, 0x38188000, 0x3818C000, 0x38190000, 0x38194000, 0x38198000, 0x3819C000, 0x381A0000, 0x381A4000, 0x381A8000, 0x381AC000, 0x381B0000, 0x381B4000, 0x381B8000, 0x381BC000,
    0x381C0000, 0x381C4000, 0x381C8000, 0x381CC000, 0x381D0000, 0x381D4000, 0x381D8000, 0x381DC000, 0x381E0000, 0x381E4000, 0x381E8000, 0x381EC000, 0x381F0000, 0x381F4000, 0x381F8000, 0x381FC000,
    0x38200000, 0x38204000, 0x38208000, 0x3820C000, 0x38210000, 0x38214000, 0x38218000, 0x3821C000, 0x38220000, 0x38224000, 0x38228000, 0x3822C000, 0x38230000, 0x38234000, 0x38238000, 0x3823C000,
    0x38240000, 0x38244000, 0x38248000, 0x3824C000, 0x38250000, 0x38254000, 0x38258000, 0x3825C000, 0x38260000, 0x38264000, 0x38268000, 0x3826C000, 0x38270000, 0x38274000, 0x38278000, 0x3827C000,
    0x38280000, 0x38284000, 0x38288000, 0x3828C000, 0x38290000, 0x38294000, 0x38298000, 0x3829C000, 0x382A0000, 0x382A4000, 0x382A8000, 0x382AC000, 0x382B0000, 0x382B4000, 0x382B8000, 0x382BC000,
    0x382C0000, 0x382C4000, 0x382C8000, 0x382CC000, 0x382D0000, 0x382D4000, 0x382D8000, 0x382DC000, 0x382E0000, 0x382E4000, 0x382E8000, 0x382EC000, 0x382F0000, 0x382F4000, 0x382F8000, 0x382FC000,
    0x38300000, 0x38304000, 0x38308000, 0x3830C000, 0x38310000, 0x38314000, 0x38318000, 0x3831C000, 0x38320000, 0x38324000, 0x38328000, 0x3832C000, 0x38330000, 0x38334000, 0x38338000, 0x3833C000,
    0x38340000, 0x38344000, 0x38348000, 0x3834C000, 0x38350000, 0x38354000, 0x38358000, 0x3835C000, 0x38360000, 0x38364000, 0x38368000, 0x3836C000, 0x38370000, 0x38374000, 0x38378000, 0x3837C000,
    0x38380000, 0x38384000, 0x38388000, 0x3838C000, 0x38390000, 0x38394000, 0x38398000, 0x3839C000, 0x383A0000, 0x383A4000, 0x383A8000, 0x383AC000, 0x383B0000, 0x383B4000, 0x383B8000, 0x383BC000,
    0x383C0000, 0x383C4000, 0x383C8000, 0x383CC000, 0x383D0000, 0x383D4000, 0x383D8000, 0x383DC000, 0x383E0000, 0x383E4000, 0x383E8000, 0x383EC000, 0x383F0000, 0x383F4000, 0x383F8000, 0x383FC000,
    0x38400000, 0x38404000, 0x38408000, 0x3840C000, 0x38410000, 0x38414000, 0x38418000, 0x3841C000, 0x38420000, 0x38424000, 0x38428000, 0x3842C000, 0x38430000, 0x38434000, 0x38438000, 0x3843C000,
    0x38440000, 0x38444000, 0x38448000, 0x3844C000, 0x38450000, 0x38454000, 0x38458000, 0x3845C000, 0x38460000, 0x38464000, 0x38468000, 0x3846C000, 0x38470000, 0x38474000, 0x38478000, 0x3847C000,
    0x38480000, 0x38484000, 0x38488000, 0x3848C000, 0x38490000, 0x38494000, 0x38498000, 0x3849C000, 0x384A0000, 0x384A4000, 0x384A8000, 0x384AC000, 0x384B0000, 0x384B4000, 0x384B8000, 0x384BC000,
    0x384C0000, 0x384C4000, 0x384C8000, 0x384CC000, 0x384D0000, 0x384D4000, 0x384D8000, 0x384DC000, 0x384E0000, 0x384E4000, 0x384E8000, 0x384EC000, 0x384F0000, 0x384F4000, 0x384F8000, 0x384FC000,
    0x38500000, 0x38504000, 0x38508000, 0x3850C000, 0x38510000, 0x38514000, 0x38518000, 0x3851C000, 0x38520000, 0x38524000, 0x38528000, 0x3852C000, 0x38530000, 0x38534000, 0x38538000, 0x3853C000,
    0x38540000, 0x38544000, 0x38548000, 0x3854C000, 0x38550000, 0x38554000, 0x38558000, 0x3855C000, 0x38560000, 0x38564000, 0x38568000, 0x3856C000, 0x38570000, 0x38574000, 0x38578000, 0x3857C000,
    0x38580000, 0x38584000, 0x38588000, 0x3858C000, 0x38590000, 0x38594000, 0x38598000, 0x3859C000, 0x385A0000, 0x385A4000, 0x385A8000, 0x385AC000, 0x385B0000, 0x385B4000, 0x385B8000, 0x385BC000,
    0x385C0000, 0x385C4000, 0x385C8000, 0x385CC000, 0x385D0000, 0x385D4000, 0x385D8000, 0x385DC000, 0x385E0000, 0x385E4000, 0x385E8000, 0x385EC000, 0x385F0000, 0x385F4000, 0x385F8000, 0x385FC000,
    0x38600000, 0x38604000, 0x38608000, 0x3860C000, 0x38610000, 0x38614000, 0x38618000, 0x3861C000, 0x38620000, 0x38624000, 0x38628000, 0x3862C000, 0x38630000, 0x38634000, 0x38638000, 0x3863C000,
    0x38640000, 0x38644000, 0x38648000, 0x3864C000, 0x38650000, 0x38654000, 0x38658000, 0x3865C000, 0x38660000, 0x38664000, 0x38668000, 0x3866C000, 0x38670000, 0x38674000, 0x38678000, 0x3867C000,
    0x38680000, 0x38684000, 0x38688000, 0x3868C000, 0x38690000, 0x38694000, 0x38698000, 0x3869C000, 0x386A0000, 0x386A4000, 0x386A8000, 0x386AC000, 0x386B0000, 0x386B4000, 0x386B8000, 0x386BC000,
    0x386C0000, 0x386C4000, 0x386C8000, 0x386CC000, 0x386D0000, 0x386D4000, 0x386D8000, 0x386DC000, 0x386E0000, 0x386E4000, 0x386E8000, 0x386EC000, 0x386F0000, 0x386F4000, 0x386F8000, 0x386FC000,
    0x38700000, 0x38704000, 0x38708000, 0x3870C000, 0x38710000, 0x38714000, 0x38718000, 0x3871C000, 0x38720000, 0x38724000, 0x38728000, 0x3872C000, 0x38730000, 0x38734000, 0x38738000, 0x3873C000,
    0x38740000, 0x38744000, 0x38748000, 0x3874C000, 0x38750000, 0x38754000, 0x38758000, 0x3875C000, 0x38760000, 0x38764000, 0x38768000, 0x3876C000, 0x38770000, 0x38774000, 0x38778000, 0x3877C000,
    0x38780000, 0x38784000, 0x38788000, 0x3878C000, 0x38790000, 0x38794000, 0x38798000, 0x3879C000, 0x387A0000, 0x387A4000, 0x387A8000, 0x387AC000, 0x387B0000, 0x387B4000, 0x387B8000, 0x387BC000,
    0x387C0000, 0x387C4000, 0x387C8000, 0x387CC000, 0x387D0000, 0x387D4000, 0x387D8000, 0x387DC000, 0x387E0000, 0x387E4000, 0x387E8000, 0x387EC000, 0x387F0000, 0x387F4000, 0x387F8000, 0x387FC000,
    0x38000000, 0x38002000, 0x38004000, 0x38006000, 0x38008000, 0x3800A000, 0x3800C000, 0x3800E000, 0x38010000, 0x38012000, 0x38014000, 0x38016000, 0x38018000, 0x3801A000, 0x3801C000, 0x3801E000,
    0x38020000, 0x38022000, 0x38024000, 0x38026000, 0x38028000, 0x3802A000, 0x3802C000, 0x3802E000, 0x38030000, 0x38032000, 0x38034000, 0x38036000, 0x38038000, 0x3803A000, 0x3803C000, 0x3803E000,
    0x38040000, 0x38042000, 0x38044000, 0x38046000, 0x38048000, 0x3804A000, 0x3804C000, 0x3804E000, 0x38050000, 0x38052000, 0x38054000, 0x38056000, 0x38058000, 0x3805A000, 0x3805C000, 0x3805E000,
    0x38060000, 0x38062000, 0x38064000, 0x38066000, 0x38068000, 0x3806A000, 0x3806C000, 0x3806E000, 0x38070000, 0x38072000, 0x38074000, 0x38076000, 0x38078000, 0x3807A000, 0x3807C000, 0x3807E000,
    0x38080000, 0x38082000, 0x38084000, 0x38086000, 0x38088000, 0x3808A000, 0x3808C000, 0x3808E000, 0x38090000, 0x38092000, 0x38094000, 0x38096000, 0x38098000, 0x3809A000, 0x3809C000, 0x3809E000,
    0x380A0000, 0x380A2000, 0x380A4000, 0x380A6000, 0x380A8000, 0x380AA000, 0x380AC000, 0x380AE000, 0x380B0000, 0x380B2000, 0x380B4000, 0x380B6000, 0x380B8000, 0x380BA000, 0x380BC000, 0x380BE000,
    0x380C0000, 0x380C2000, 0x380C4000, 0x380C6000, 0x380C8000, 0x380CA000, 0x380CC000, 0x380CE000, 0x380D0000, 0x380D2000, 0x380D4000, 0x380D6000, 0x380D8000, 0x380DA000, 0x380DC000, 0x380DE000,
    0x380E0000, 0x380E2000, 0x380E4000, 0x380E6000, 0x380E8000, 0x380EA000, 0x380EC000, 0x380EE000, 0x380F0000, 0x380F2000, 0x380F4000, 0x380F6000, 0x380F8000, 0x380FA000, 0x380FC000, 0x380FE000,
    0x38100000, 0x38102000, 0x38104000, 0x38106000, 0x38108000, 0x3810A000, 0x3810C000, 0x3810E000, 0x38110000, 0x38112000, 0x38114000, 0x38116000, 0x38118000, 0x3811A000, 0x3811C000, 0x3811E000,
    0x38120000, 0x38122000, 0x38124000, 0x38126000, 0x38128000, 0x3812A000, 0x3812C000, 0x3812E000, 0x38130000, 0x38132000, 0x38134000, 0x38136000, 0x38138000, 0x3813A000, 0x3813C000, 0x3813E000,
    0x38140000, 0x38142000, 0x38144000, 0x38146000, 0x38148000, 0x3814A000, 0x3814C000, 0x3814E000, 0x38150000, 0x38152000, 0x38154000, 0x38156000, 0x38158000, 0x3815A000, 0x3815C000, 0x3815E000,
    0x38160000, 0x38162000, 0x38164000, 0x38166000, 0x38168000, 0x3816A000, 0x3816C000, 0x3816E000, 0x38170000, 0x38172000, 0x38174000, 0x38176000, 0x38178000, 0x3817A000, 0x3817C000, 0x3817E000,
    0x38180000, 0x38182000, 0x38184000, 0x38186000, 0x38188000, 0x3818A000, 0x3818C000, 0x3818E000, 0x38190000, 0x38192000, 0x38194000, 0x38196000, 0x38198000, 0x3819A000, 0x3819C000, 0x3819E000,
    0x381A0000, 0x381A2000, 0x381A4000, 0x381A6000, 0x381A8000, 0x381AA000, 0x381AC000, 0x381AE000, 0x381B0000, 0x381B2000, 0x381B4000, 0x381B6000, 0x381B8000, 0x381BA000, 0x381BC000, 0x381BE000,
    0x381C0000, 0x381C2000, 0x381C4000, 0x381C6000, 0x381C8000, 0x381CA000, 0x381CC000, 0x381CE000, 0x381D0000, 0x381D2000, 0x381D4000, 0x381D6000, 0x381D8000, 0x381DA000, 0x381DC000, 0x381DE000,
    0x381E0000, 0x381E2000, 0x381E4000, 0x381E6000, 0x381E8000, 0x381EA000, 0x381EC000, 0x381EE000, 0x381F0000, 0x381F2000, 0x381F4000, 0x381F6000, 0x381F8000, 0x381FA000, 0x381FC000, 0x381FE000,
    0x38200000, 0x38202000, 0x38204000, 0x38206000, 0x38208000, 0x3820A000, 0x3820C000, 0x3820E000, 0x38210000, 0x38212000, 0x38214000, 0x38216000, 0x38218000, 0x3821A000, 0x3821C000, 0x3821E000,
    0x38220000, 0x38222000, 0x38224000, 0x38226000, 0x38228000, 0x3822A000, 0x3822C000, 0x3822E000, 0x38230000, 0x38232000, 0x38234000, 0x38236000, 0x38238000, 0x3823A000, 0x3823C000, 0x3823E000,
    0x38240000, 0x38242000, 0x38244000, 0x38246000, 0x38248000, 0x3824A000, 0x3824C000, 0x3824E000, 0x38250000, 0x38252000, 0x38254000, 0x38256000, 0x38258000, 0x3825A000, 0x3825C000, 0x3825E000,
    0x38260000, 0x38262000, 0x38264000, 0x38266000, 0x38268000, 0x3826A000, 0x3826C000, 0x3826E000, 0x38270000, 0x38272000, 0x38274000, 0x38276000, 0x38278000, 0x3827A000, 0x3827C000, 0x3827E000,
    0x38280000, 0x38282000, 0x38284000, 0x38286000, 0x38288000, 0x3828A000, 0x3828C000, 0x3828E000, 0x38290000, 0x38292000, 0x38294000, 0x38296000, 0x38298000, 0x3829A000, 0x3829C000, 0x3829E000,
    0x382A0000, 0x382A2000, 0x382A4000, 0x382A6000, 0x382A8000, 0x382AA000, 0x382AC000, 0x382AE000, 0x382B0000, 0x382B2000, 0x382B4000, 0x382B6000, 0x382B8000, 0x382BA000, 0x382BC000, 0x382BE000,
    0x382C0000, 0x382C2000, 0x382C4000, 0x382C6000, 0x382C8000, 0x382CA000, 0x382CC000, 0x382CE000, 0x382D0000, 0x382D2000, 0x382D4000, 0x382D6000, 0x382D8000, 0x382DA000, 0x382DC000, 0x382DE000,
    0x382E0000, 0x382E2000, 0x382E4000, 0x382E6000, 0x382E8000, 0x382EA000, 0x382EC000, 0x382EE000, 0x382F0000, 0x382F2000, 0x382F4000, 0x382F6000, 0x382F8000, 0x382FA000, 0x382FC000, 0x382FE000,
    0x38300000, 0x38302000, 0x38304000, 0x38306000, 0x38308000, 0x3830A000, 0x3830C000, 0x3830E000, 0x38310000, 0x38312000, 0x38314000, 0x38316000, 0x38318000, 0x3831A000, 0x3831C000, 0x3831E000,
    0x38320000, 0x38322000, 0x38324000, 0x38326000, 0x38328000, 0x3832A000, 0x3832C000, 0x3832E000, 0x38330000, 0x38332000, 0x38334000, 0x38336000, 0x38338000, 0x3833A000, 0x3833C000, 0x3833E000,
    0x38340000, 0x38342000, 0x38344000, 0x38346000, 0x38348000, 0x3834A000, 0x3834C000, 0x3834E000, 0x38350000, 0x38352000, 0x38354000, 0x38356000, 0x38358000, 0x3835A000, 0x3835C000, 0x3835E000,
    0x38360000, 0x38362000, 0x38364000, 0x38366000, 0x38368000, 0x3836A000, 0x3836C000, 0x3836E000, 0x38370000, 0x38372000, 0x38374000, 0x38376000, 0x38378000, 0x3837A000, 0x3837C000, 0x3837E000,
    0x38380000, 0x38382000, 0x38384000, 0x38386000, 0x38388000, 0x3838A000, 0x3838C000, 0x3838E000, 0x38390000, 0x38392000, 0x38394000, 0x38396000, 0x38398000, 0x3839A000, 0x3839C000, 0x3839E000,
    0x383A0000, 0x383A2000, 0x383A4000, 0x383A6000, 0x383A8000, 0x383AA000, 0x383AC000, 0x383AE000, 0x383B0000, 0x383B2000, 0x383B4000, 0x383B6000, 0x383B8000, 0x383BA000, 0x383BC000, 0x383BE000,
    0x383C0000, 0x383C2000, 0x383C4000, 0x383C6000, 0x383C8000, 0x383CA000, 0x383CC000, 0x383CE000, 0x383D0000, 0x383D2000, 0x383D4000, 0x383D6000, 0x383D8000, 0x383DA000, 0x383DC000, 0x383DE000,
    0x383E0000, 0x383E2000, 0x383E4000, 0x383E6000, 0x383E8000, 0x383EA000, 0x383EC000, 0x383EE000, 0x383F0000, 0x383F2000, 0x383F4000, 0x383F6000, 0x383F8000, 0x383FA000, 0x383FC000, 0x383FE000,
    0x38400000, 0x38402000, 0x38404000, 0x38406000, 0x38408000, 0x3840A000, 0x3840C000, 0x3840E000, 0x38410000, 0x38412000, 0x38414000, 0x38416000, 0x38418000, 0x3841A000, 0x3841C000, 0x3841E000,
    0x38420000, 0x38422000, 0x38424000, 0x38426000, 0x38428000, 0x3842A000, 0x3842C000, 0x3842E000, 0x38430000, 0x38432000, 0x38434000, 0x38436000, 0x38438000, 0x3843A000, 0x3843C000, 0x3843E000,
    0x38440000, 0x38442000, 0x38444000, 0x38446000, 0x38448000, 0x3844A000, 0x3844C000, 0x3844E000, 0x38450000, 0x38452000, 0x38454000, 0x38456000, 0x38458000, 0x3845A000, 0x3845C000, 0x3845E000,
    0x38460000, 0x38462000, 0x38464000, 0x38466000, 0x38468000, 0x3846A000, 0x3846C000, 0x3846E000, 0x38470000, 0x38472000, 0x38474000, 0x38476000, 0x38478000, 0x3847A000, 0x3847C000, 0x3847E000,
    0x38480000, 0x38482000, 0x38484000, 0x38486000, 0x38488000, 0x3848A000, 0x3848C000, 0x3848E000, 0x38490000, 0x38492000, 0x38494000, 0x38496000, 0x38498000, 0x3849A000, 0x3849C000, 0x3849E000,
    0x384A0000, 0x384A2000, 0x384A4000, 0x384A6000, 0x384A8000, 0x384AA000, 0x384AC000, 0x384AE000, 0x384B0000, 0x384B2000, 0x384B4000, 0x384B6000, 0x384B8000, 0x384BA000, 0x384BC000, 0x384BE000,
    0x384C0000, 0x384C2000, 0x384C4000, 0x384C6000, 0x384C8000, 0x384CA000, 0x384CC000, 0x384CE000, 0x384D0000, 0x384D2000, 0x384D4000, 0x384D6000, 0x384D8000, 0x384DA000, 0x384DC000, 0x384DE000,
    0x384E0000, 0x384E2000, 0x384E4000, 0x384E6000, 0x384E8000, 0x384EA000, 0x384EC000, 0x384EE000, 0x384F0000, 0x384F2000, 0x384F4000, 0x384F6000, 0x384F8000, 0x384FA000, 0x384FC000, 0x384FE000,
    0x38500000, 0x38502000, 0x38504000, 0x38506000, 0x38508000, 0x3850A000, 0x3850C000, 0x3850E000, 0x38510000, 0x38512000, 0x38514000, 0x38516000, 0x38518000, 0x3851A000, 0x3851C000, 0x3851E000,
    0x38520000, 0x38522000, 0x38524000, 0x38526000, 0x38528000, 0x3852A000, 0x3852C000, 0x3852E000, 0x38530000, 0x38532000, 0x38534000, 0x38536000, 0x38538000, 0x3853A000, 0x3853C000, 0x3853E000,
    0x38540000, 0x38542000, 0x38544000, 0x38546000, 0x38548000, 0x3854A000, 0x3854C000, 0x3854E000, 0x38550000, 0x38552000, 0x38554000, 0x38556000, 0x38558000, 0x3855A000, 0x3855C000, 0x3855E000,
    0x38560000, 0x38562000, 0x38564000, 0x38566000, 0x38568000, 0x3856A000, 0x3856C000, 0x3856E000, 0x38570000, 0x38572000, 0x38574000, 0x38576000, 0x38578000, 0x3857A000, 0x3857C000, 0x3857E000,
    0x38580000, 0x38582000, 0x38584000, 0x38586000, 0x38588000, 0x3858A000, 0x3858C000, 0x3858E000, 0x38590000, 0x38592000, 0x38594000, 0x38596000, 0x38598000, 0x3859A000, 0x3859C000, 0x3859E000,
    0x385A0000, 0x385A2000, 0x385A4000, 0x385A6000, 0x385A8000, 0x385AA000, 0x385AC000, 0x385AE000, 0x385B0000, 0x385B2000, 0x385B4000, 0x385B6000, 0x385B8000, 0x385BA000, 0x385BC000, 0x385BE000,
    0x385C0000, 0x385C2000, 0x385C4000, 0x385C6000, 0x385C8000, 0x385CA000, 0x385CC000, 0x385CE000, 0x385D0000, 0x385D2000, 0x385D4000, 0x385D6000, 0x385D8000, 0x385DA000, 0x385DC000, 0x385DE000,
    0x385E0000, 0x385E2000, 0x385E4000, 0x385E6000, 0x385E8000, 0x385EA000, 0x385EC000, 0x385EE000, 0x385F0000, 0x385F2000, 0x385F4000, 0x385F6000, 0x385F8000, 0x385FA000, 0x385FC000, 0x385FE000,
    0x38600000, 0x38602000, 0x38604000, 0x38606000, 0x38608000, 0x3860A000, 0x3860C000, 0x3860E000, 0x38610000, 0x38612000, 0x38614000, 0x38616000, 0x38618000, 0x3861A000, 0x3861C000, 0x3861E000,
    0x38620000, 0x38622000, 0x38624000, 0x38626000, 0x38628000, 0x3862A000, 0x3862C000, 0x3862E000, 0x38630000, 0x38632000, 0x38634000, 0x38636000, 0x38638000, 0x3863A000, 0x3863C000, 0x3863E000,
    0x38640000, 0x38642000, 0x38644000, 0x38646000, 0x38648000, 0x3864A000, 0x3864C000, 0x3864E000, 0x38650000, 0x38652000, 0x38654000, 0x38656000, 0x38658000, 0x3865A000, 0x3865C000, 0x3865E000,
    0x38660000, 0x38662000, 0x38664000, 0x38666000, 0x38668000, 0x3866A000, 0x3866C000, 0x3866E000, 0x38670000, 0x38672000, 0x38674000, 0x38676000, 0x38678000, 0x3867A000, 0x3867C000, 0x3867E000,
    0x38680000, 0x38682000, 0x38684000, 0x38686000, 0x38688000, 0x3868A000, 0x3868C000, 0x3868E000, 0x38690000, 0x38692000, 0x38694000, 0x38696000, 0x38698000, 0x3869A000, 0x3869C000, 0x3869E000,
    0x386A0000, 0x386A2000, 0x386A4000, 0x386A6000, 0x386A8000, 0x386AA000, 0x386AC000, 0x386AE000, 0x386B0000, 0x386B2000, 0x386B4000, 0x386B6000, 0x386B8000, 0x386BA000, 0x386BC000, 0x386BE000,
    0x386C0000, 0x386C2000, 0x386C4000, 0x386C6000, 0x386C8000, 0x386CA000, 0x386CC000, 0x386CE000, 0x386D0000, 0x386D2000, 0x386D4000, 0x386D6000, 0x386D8000, 0x386DA000, 0x386DC000, 0x386DE000,
    0x386E0000, 0x386E2000, 0x386E4000, 0x386E6000, 0x386E8000, 0x386EA000, 0x386EC000, 0x386EE000, 0x386F0000, 0x386F2000, 0x386F4000, 0x386F6000, 0x386F8000, 0x386FA000, 0x386FC000, 0x386FE000,
    0x38700000, 0x38702000, 0x38704000, 0x38706000, 0x38708000, 0x3870A000, 0x3870C000, 0x3870E000, 0x38710000, 0x38712000, 0x38714000, 0x38716000, 0x38718000, 0x3871A000, 0x3871C000, 0x3871E000,
    0x38720000, 0x38722000, 0x38724000, 0x38726000, 0x38728000, 0x3872A000, 0x3872C000, 0x3872E000, 0x38730000, 0x38732000, 0x38734000, 0x38736000, 0x38738000, 0x3873A000, 0x3873C000, 0x3873E000,
    0x38740000, 0x38742000, 0x38744000, 0x38746000, 0x38748000, 0x3874A000, 0x3874C000, 0x3874E000, 0x38750000, 0x38752000, 0x38754000, 0x38756000, 0x38758000, 0x3875A000, 0x3875C000, 0x3875E000,
    0x38760000, 0x38762000, 0x38764000, 0x38766000, 0x38768000, 0x3876A000, 0x3876C000, 0x3876E000, 0x38770000, 0x38772000, 0x38774000, 0x38776000, 0x38778000, 0x3877A000, 0x3877C000, 0x3877E000,
    0x38780000, 0x38782000, 0x38784000, 0x38786000, 0x38788000, 0x3878A000, 0x3878C000, 0x3878E000, 0x38790000, 0x38792000, 0x38794000, 0x38796000, 0x38798000, 0x3879A000, 0x3879C000, 0x3879E000,
    0x387A0000, 0x387A2000, 0x387A4000, 0x387A6000, 0x387A8000, 0x387AA000, 0x387AC000, 0x387AE000, 0x387B0000, 0x387B2000, 0x387B4000, 0x387B6000, 0x387B8000, 0x387BA000, 0x387BC000, 0x387BE000,
    0x387C0000, 0x387C2000, 0x387C4000, 0x387C6000, 0x387C8000, 0x387CA000, 0x387CC000, 0x387CE000, 0x387D0000, 0x387D2000, 0x387D4000, 0x387D6000, 0x387D8000, 0x387DA000, 0x387DC000, 0x387DE000,
    0x387E0000, 0x387E2000, 0x387E4000, 0x387E6000, 0x387E8000, 0x387EA000, 0x387EC000, 0x387EE000, 0x387F0000, 0x387F2000, 0x387F4000, 0x387F6000, 0x387F8000, 0x387FA000, 0x387FC000, 0x387FE000 };
   static const uint32 exponent_table[64] = {
    0x00000000, 0x00800000, 0x01000000, 0x01800000, 0x02000000, 0x02800000, 0x03000000, 0x03800000, 0x04000000, 0x04800000, 0x05000000, 0x05800000, 0x06000000, 0x06800000, 0x07000000, 0x07800000,
    0x08000000, 0x08800000, 0x09000000, 0x09800000, 0x0A000000, 0x0A800000, 0x0B000000, 0x0B800000, 0x0C000000, 0x0C800000, 0x0D000000, 0x0D800000, 0x0E000000, 0x0E800000, 0x0F000000, 0x47800000,
    0x80000000, 0x80800000, 0x81000000, 0x81800000, 0x82000000, 0x82800000, 0x83000000, 0x83800000, 0x84000000, 0x84800000, 0x85000000, 0x85800000, 0x86000000, 0x86800000, 0x87000000, 0x87800000,
    0x88000000, 0x88800000, 0x89000000, 0x89800000, 0x8A000000, 0x8A800000, 0x8B000000, 0x8B800000, 0x8C000000, 0x8C800000, 0x8D000000, 0x8D800000, 0x8E000000, 0x8E800000, 0x8F000000, 0xC7800000 };
   static const unsigned short offset_table[64] = {
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024,
       0, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 1024 };
   uint32 bits = mantissa_table[offset_table[value>>10]+(value&0x3FF)] + exponent_table[value>>10];


   float out;
   std::memcpy(&out, &bits, sizeof(float));
   return out;
  }




  inline float half2float_impl(uint16 value, false_type)
  {
   float out;
   int abs = value & 0x7FFF;
   if(abs > 0x7C00)
    out = std::numeric_limits<float>::has_quiet_NaN ? std::numeric_limits<float>::quiet_NaN() : 0.0f;
   else if(abs == 0x7C00)
    out = std::numeric_limits<float>::has_infinity ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::max();
   else if(abs > 0x3FF)
    out = std::ldexp(static_cast<float>((value&0x3FF)|0x400), (abs>>10)-25);
   else
    out = std::ldexp(static_cast<float>(abs), -24);
   return (value&0x8000) ? -out : out;
  }




  inline float half2float(uint16 value)
  {
   return half2float_impl(value, bool_type<std::numeric_limits<float>::is_iec559&&sizeof(uint32)==sizeof(float)>());
  }







  template<std::float_round_style R,bool E,typename T> T half2int_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   if(e >= 0x7C00)
    return (value&0x8000) ? std::numeric_limits<T>::min() : std::numeric_limits<T>::max();
   if(e < 0x3800)
   {
    if(R == std::round_toward_infinity)
     return T(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     return -T(value>0x8000);
    return T();
   }
   int17 m = (value&0x3FF) | 0x400;
   e >>= 10;
   if(e < 25)
   {
    if(R == std::round_indeterminate || R == std::round_toward_zero)
     m >>= 25 - e;
    else
    {
     if(R == std::round_to_nearest)
      m += (1<<(24-e)) - (~(m>>(25-e))&E);
     else if(R == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(25-e))-1U);
     else if(R == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(25-e))-1U);
     m >>= 25 - e;
    }
   }
   else
    m <<= e - 25;


   return static_cast<T>((value&0x8000) ? -m : m);
  }






  template<std::float_round_style R,typename T> T half2int(uint16 value) { return half2int_impl<R,1,T>(value); }





  template<typename T> T half2int_up(uint16 value) { return half2int_impl<std::round_to_nearest,0,T>(value); }






  template<std::float_round_style R,bool E> uint16 round_half_impl(uint16 value)
  {
   unsigned int e = value & 0x7FFF;
   uint16 result = value;
   if(e < 0x3C00)
   {
    result &= 0x8000;
    if(R == std::round_to_nearest)
     result |= 0x3C00U & -(e>=(0x3800+E));
    else if(R == std::round_toward_infinity)
     result |= 0x3C00U & -(~(value>>15)&(e!=0));
    else if(R == std::round_toward_neg_infinity)
     result |= 0x3C00U & -(value>0x8000);
   }
   else if(e < 0x6400)
   {
    e = 25 - (e>>10);
    unsigned int mask = (1<<e) - 1;
    if(R == std::round_to_nearest)
     result += (1<<(e-1)) - (~(result>>e)&E);
    else if(R == std::round_toward_infinity)
     result += mask & ((value>>15)-1);
    else if(R == std::round_toward_neg_infinity)
     result += mask & -(value>>15);
    result &= ~mask;
   }
   return result;
  }





  template<std::float_round_style R> uint16 round_half(uint16 value) { return round_half_impl<R,1>(value); }




  inline uint16 round_half_up(uint16 value) { return round_half_impl<std::round_to_nearest,0>(value); }


  struct functions;
  template<typename> struct unary_specialized;
  template<typename,typename> struct binary_specialized;
  template<typename,typename,std::float_round_style> struct half_caster;
 }
# 979 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
 class half
 {
  friend struct detail::functions;
  friend struct detail::unary_specialized<half>;
  friend struct detail::binary_specialized<half,half>;
  template<typename,typename,std::float_round_style> friend struct detail::half_caster;
  friend struct std::numeric_limits<half>;

  friend struct std::hash<half>;


 public:



  constexpr half() : data_() {}




  half(detail::expr rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }



  half(float rhs) : data_(detail::float2half<round_style>(rhs)) {

            xip_fpo_half_set_flt(rhs);

        }


  template<int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
  half(const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& rhs) {
   std::cout << "WARNING: explicit method ap_fixed::to_half() should be used to convert ap_fixed to half." << std::endl;
   *this = rhs.to_half();
  }



  operator float() const {



            return xip_fpo_half_get_flt();

        }





  half& operator=(detail::expr rhs) { return *this = static_cast<float>(rhs); }





  template<typename T> typename detail::enable<half&,T>::type operator+=(T rhs) { return *this = *this + rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator-=(T rhs) { return *this = *this - rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator*=(T rhs) { return *this = *this * rhs; }





  template<typename T> typename detail::enable<half&,T>::type operator/=(T rhs) { return *this = *this / rhs; }
# 1097 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  half& operator++() { return *this += 1.0f; }



  half& operator--() { return *this -= 1.0f; }



  half operator++(int) { half out(*this); ++*this; return out; }



  half operator--(int) { half out(*this); --*this; return out; }



        detail::uint16 get_bits() { return data_; }



        void set_bits(detail::uint16 bits) { data_ = bits; }





        xip_fpo_exc_t xip_fpo_get_data(xip_fpo_ptr op) const {
            int exc = 0;
            op->_xip_fpo_sign = ((data_ & 0x8000) ? -1 : 1);
            op->_xip_fpo_exp = ((data_ & 0x7C00) >> 10) - 14;
            *(op->_xip_fpo_d) = ((mp_limb_t)(data_ & 0x3FF) + (mp_limb_t)(0x400)) << (8*sizeof(*(op->_xip_fpo_d)) - 11);
            if ((data_ & 0x7C00) == 0) {
                exc |= 0x1;
                xip_fpo_set_zero(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) == 0x7C00) {
                exc |= 0x2;
                xip_fpo_set_inf(op, op->_xip_fpo_sign);
            } else if ((data_ & 0x7FFF) > 0x7C00) {
                exc |= 0x4;
                xip_fpo_set_nan(op);
            }
            return exc;
        }


        float xip_fpo_half_get_flt() const {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_exc_t exc = xip_fpo_get_data(op);
            float res;
            if (exc & 0x1) {
                res = (op->_xip_fpo_sign > 0 ? 0.0f : -0.0f);
            } else if (exc & 0x2) {
                res = (op->_xip_fpo_sign > 0 ? std::numeric_limits<float>::infinity() : -std::numeric_limits<float>::infinity());
            } else if (exc & 0x4) {
                res = std::numeric_limits<float>::quiet_NaN();
            } else {
                res = xip_fpo_get_flt(op);
            }
            xip_fpo_clear(op);
            return res;
        }



        void xip_fpo_set_data(xip_fpo_ptr op) {
            mpfr_t fr;
            (fr)->_mpfr_prec = (op)->_xip_fpo_mant_prec; (fr)->_mpfr_sign = (op)->_xip_fpo_sign; (fr)->_mpfr_exp = (op)->_xip_fpo_exp; (fr)->_mpfr_d = (op)->_xip_fpo_d;;
            data_ = 0;
            data_ |= (op->_xip_fpo_sign == 1 ? 0 : 1) << 15;
            if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+1)))) {
                data_ &= 0x8000;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+3)))) {
                data_ |= 0x7C00;
            } else if (((fr)->_mpfr_exp == ((mpfr_exp_t)((~((~(mpfr_ulong)0)>>1))+2)))) {
                data_ |= 0x7E00;
            } else {
                data_ |= (op->_xip_fpo_exp + 14) << 10;
                data_ |= (*(op->_xip_fpo_d) << 1) >> (8*sizeof(*(op->_xip_fpo_d)) - 10);
            }
        }


        void xip_fpo_half_set_flt(float rhs) {
            xip_fpo_t op;
            xip_fpo_init2(op, 5, 11);
            xip_fpo_set_flt(op, rhs);
            xip_fpo_set_data(op);
            xip_fpo_clear(op);
        }


        private:

  static const std::float_round_style round_style = (std::float_round_style)(1);



  constexpr half(detail::binary_t, detail::uint16 bits) : data_(bits) {}


  detail::uint16 data_;
 };



    template<typename F>
    half math_function_1arg(F f, half x) {
        half res;
        xip_fpo_t rop, xop;
        xip_fpo_inits2(5, 11, rop, xop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        f(rop, xop);
        res.xip_fpo_set_data(rop);
        xip_fpo_clears(rop, xop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    half binary_operator(F f, half x, half y) {
        half res;
        xip_fpo_t op, xop, yop;
        xip_fpo_inits2(5, 11, op, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(op, xop, yop);
        res.xip_fpo_set_data(op);
        xip_fpo_clears(op, xop, yop, (xip_fpo_ptr)0);
        return res;
    }

    template<typename F>
    bool binary_operator_compare(F f, half x, half y) {
        int res;
        xip_fpo_t xop, yop;
        xip_fpo_inits2(5, 11, xop, yop, (xip_fpo_ptr)0);
        x.xip_fpo_get_data(xop);
        y.xip_fpo_get_data(yop);
        f(&res, xop, yop);
        xip_fpo_clears(xop, yop, (xip_fpo_ptr)0);
        return res;
    }
# 1248 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
 namespace literal
 {





  inline half operator "" _h(long double value) { return half(static_cast<float>(value)); }
 }



 namespace detail
 {

  struct functions
  {
# 1273 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half plus(T1 x, T2 y) { return binary_operator(xip_fpo_add, x, y); }
   static float plus(float x, half y) { return xil_fpo_add_flt(x,y); }
   static float plus(half x, float y) { return xil_fpo_add_flt(x,y); }
   static double plus(double x, half y) { return xil_fpo_add_d(x,y); }
   static double plus(half x, double y) { return xil_fpo_add_d(x,y); }
# 1289 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half minus(T1 x, T2 y) { return binary_operator(xip_fpo_sub, x, y); }
   static float minus(float x, half y) { return xil_fpo_sub_flt(x,y); }
   static float minus(half x, float y) { return xil_fpo_sub_flt(x,y); }
   static double minus(double x, half y) { return xil_fpo_sub_d(x,y); }
   static double minus(half x, double y) { return xil_fpo_sub_d(x,y); }
# 1305 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half multiplies(T1 x, T2 y) { return binary_operator(xip_fpo_mul, x, y); }
   static float multiplies(float x, half y) { return xil_fpo_mul_flt(x,y); }
   static float multiplies(half x, float y) { return xil_fpo_mul_flt(x,y); }
   static double multiplies(double x, half y) { return xil_fpo_mul_d(x,y); }
   static double multiplies(half x, double y) { return xil_fpo_mul_d(x,y); }
# 1321 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static half divides(T1 x, T2 y) { return binary_operator(xip_fpo_div, x, y); }
   static float divides(float x, half y) { return xil_fpo_div_flt(x,y); }
   static float divides(half x, float y) { return xil_fpo_div_flt(x,y); }
   static double divides(double x, half y) { return xil_fpo_div_d(x,y); }
   static double divides(half x, double y) { return xil_fpo_div_d(x,y); }






   template<typename charT,typename traits> static std::basic_ostream<charT,traits>& write(std::basic_ostream<charT,traits> &out, float arg) { return out << arg; }





   template<typename charT,typename traits> static std::basic_istream<charT,traits>& read(std::basic_istream<charT,traits> &in, half &arg)
   {
    float f;
    if(in >> f)
     arg = f;
    return in;
   }





   static expr fmod(float x, float y) { return expr(std::fmod(x, y)); }





   static expr remainder(float x, float y)
   {

    return expr(std::remainder(x, y));
# 1381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }






   static expr remquo(float x, float y, int *quo)
   {

    return expr(std::remquo(x, y, quo));
# 1428 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }





   static expr fdim(float x, float y)
   {

    return expr(std::fdim(x, y));



   }

                        static expr maxmag(float x, float y)
                        {
    if (fabs(y)>fabs(x)) return expr(y);
    else return expr(x);
                        }

                        static expr minmag(float x, float y)
                        {
    if (fabs(y)<fabs(x)) return expr(y);
    else return expr(x);
                        }






   static expr fma(float x, float y, float z)
   {



    return expr(x*y+z);

   }



   static half nanh(const char*) { return half(binary, 0x7FFF); }




   static expr exp(float arg) { return expr(std::exp(arg)); }




   static expr expm1(float arg)
   {

    return expr(std::expm1(arg));



   }




   static expr exp2(float arg)
   {

    return expr(std::exp2(arg));



   }




   static expr log(float arg) { return expr(std::log(arg)); }




   static expr log10(float arg) { return expr(std::log10(arg)); }




   static expr log1p(float arg)
   {

    return expr(std::log1p(arg));



   }




   static expr log2(float arg)
   {

    return expr(std::log2(arg));



   }

                        static expr logb(float arg)
                        {

                                return expr(std::logb(arg));



                        }




   static expr sqrt(float arg) { return expr(std::sqrt(arg)); }




   static expr cbrt(float arg)
   {

    return expr(std::cbrt(arg));






   }





   static expr hypot(float x, float y)
   {

    return expr(std::hypot(x, y));




   }





   static expr pow(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr powr(float base, float exp) { return expr(std::pow(base, exp)); }
                        static expr pown(float base, int exp) { return expr(std::pow(base, exp)); }
   static expr rootn(float base, int exp) { return expr(std::pow(base, float(float(1)/float(exp)))); }




   static expr sin(float arg) { return expr(std::sin(arg)); }




   static expr cos(float arg) { return expr(std::cos(arg)); }




   static expr tan(float arg) { return expr(std::tan(arg)); }




   static expr asin(float arg) { return expr(std::asin(arg)); }




   static expr acos(float arg) { return expr(std::acos(arg)); }




   static expr atan(float arg) { return expr(std::atan(arg)); }





   static expr atan2(float x, float y) { return expr(std::atan2(x, y)); }




   static expr sinh(float arg) { return expr(std::sinh(arg)); }




   static expr cosh(float arg) { return expr(std::cosh(arg)); }




   static expr tanh(float arg) { return expr(std::tanh(arg)); }




   static expr asinh(float arg)
   {

    return expr(std::asinh(arg));



   }




   static expr acosh(float arg)
   {

    return expr(std::acosh(arg));



   }




   static expr atanh(float arg)
   {

    return expr(std::atanh(arg));



   }




   static expr erf(float arg)
   {

    return expr(std::erf(arg));



   }




   static expr erfc(float arg)
   {

    return expr(std::erfc(arg));



   }




   static expr lgamma(float arg)
   {

    return expr(std::lgamma(arg));
# 1721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }




   static expr tgamma(float arg)
   {

    return expr(std::tgamma(arg));
# 1748 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
   }




   static half floor(half arg) { return half(binary, round_half<std::round_toward_neg_infinity>(arg.data_)); }




   static half ceil(half arg) { return half(binary, round_half<std::round_toward_infinity>(arg.data_)); }




   static half trunc(half arg) { return half(binary, round_half<std::round_toward_zero>(arg.data_)); }




   static half round(half arg) { return half(binary, round_half_up(arg.data_)); }




   static long lround(half arg) { return detail::half2int_up<long>(arg.data_); }




   static half rint(half arg) { return half(binary, round_half<half::round_style>(arg.data_)); }




   static long lrint(half arg) { return detail::half2int<half::round_style,long>(arg.data_); }





   static long long llround(half arg) { return detail::half2int_up<long long>(arg.data_); }




   static long long llrint(half arg) { return detail::half2int<half::round_style,long long>(arg.data_); }






   static half frexp(half arg, int *exp)
   {
    unsigned int m = arg.data_ & 0x7FFF;
    if(m >= 0x7C00 || !m)
     return *exp = 0, arg;
    int e = m >> 10;
    if(!e)
     for(m<<=1; m<0x400; m<<=1,--e) ;
    return *exp = e-14, half(binary, static_cast<uint16>((arg.data_&0x8000)|0x3800|(m&0x3FF)));
   }





   static half modf(half arg, half *iptr)
   {
    unsigned int e = arg.data_ & 0x7C00;
    if(e > 0x6000)
     return *iptr = arg, (e==0x7C00&&(arg.data_&0x3FF)) ? arg : half(binary, arg.data_&0x8000);
    if(e < 0x3C00)
     return iptr->data_ = arg.data_ & 0x8000, arg;
    e >>= 10;
    unsigned int mask = (1<<(25-e)) - 1, m = arg.data_ & mask;
    iptr->data_ = arg.data_ & ~mask;
    if(!m)
     return half(binary, arg.data_&0x8000);
    for(; m<0x400; m<<=1,--e) ;
    return half(binary, static_cast<uint16>((arg.data_&0x8000)|(e<<10)|(m&0x3FF)));
   }





   static half scalbln(half arg, long exp)
   {
    long e = arg.data_ & 0x7C00;
    if(e == 0x7C00)
     return arg;
    unsigned int m = arg.data_ & 0x3FF;
    if(e >>= 10)
     m |= 0x400;
    else
    {
     if(!m)
      return arg;
     for(m<<=1; m<0x400; m<<=1,--e) ;
    }
    e += exp;
    uint16 value = arg.data_ & 0x8000;
    if(e > 30)
    {
     if(half::round_style == std::round_toward_zero)
      value |= 0x7BFF;
     else if(half::round_style == std::round_toward_infinity)
      value |= 0x7C00 - (value>>15);
     else if(half::round_style == std::round_toward_neg_infinity)
      value |= 0x7BFF + (value>>15);
     else
      value |= 0x7C00;
    }
    else if(e > 0)
     value |= (e<<10) | (m&0x3FF);
    else if(e > -11)
    {
     if(half::round_style == std::round_to_nearest)
     {
      m += 1 << -e;

      m -= (m>>(1-e)) & 1;

     }
     else if(half::round_style == std::round_toward_infinity)
      m += ((value>>15)-1) & ((1<<(1-e))-1U);
     else if(half::round_style == std::round_toward_neg_infinity)
      m += -(value>>15) & ((1<<(1-e))-1U);
     value |= m >> (1-e);
    }
    else if(half::round_style == std::round_toward_infinity)
     value |= ((value>>15)-1) & 1;
    else if(half::round_style == std::round_toward_neg_infinity)
     value |= value >> 15;
    return half(binary, value);
   }




   static int ilogb(half arg)
   {
    int exp = arg.data_ & 0x7FFF;
    if(!exp)
     return 
# 1894 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           ((int)0x80000000)
# 1894 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                    ;
    if(exp < 0x7C00)
    {
     if(!(exp>>=10))
      for(unsigned int m=(arg.data_&0x3FF); m<0x200; m<<=1,--exp) ;
     return exp - 15;
    }
    if(exp > 0x7C00)
     return 
# 1902 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           ((int)0x80000000)
# 1902 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                      ;
    return 0x7fffffff;
   }




   static half nextafter(half from, half to)
   {
    uint16 fabs = from.data_ & 0x7FFF, tabs = to.data_ & 0x7FFF;
    if(fabs > 0x7C00)
     return from;
    if(tabs > 0x7C00 || from.data_ == to.data_ || !(fabs|tabs))
     return to;
    if(!fabs)
     return half(binary, (to.data_&0x8000)+1);
    bool lt = (signbit(from) ? (static_cast<int17>(0x8000)-from.data_) : static_cast<int17>(from.data_)) <
     (signbit(to) ? (static_cast<int17>(0x8000)-to.data_) : static_cast<int17>(to.data_));
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lt))<<1)-1);
   }





   static half nexttoward(half from, long double to)
   {
    if(isnan(from))
     return from;
    long double lfrom = static_cast<long double>(from);
    if(builtin_isnan(to) || lfrom == to)
     return half(static_cast<float>(to));
    if(!(from.data_&0x7FFF))
     return half(binary, (static_cast<detail::uint16>(builtin_signbit(to))<<15)+1);
    return half(binary, from.data_+(((from.data_>>15)^static_cast<uint16>(lfrom<to))<<1)-1);
   }





   static half copysign(half x, half y) { return half(binary, x.data_^((x.data_^y.data_)&0x8000)); }





   static int fpclassify(half arg)
   {
    unsigned int abs = arg.data_ & 0x7FFF;
    if(abs > 0x7C00)
     return 
# 1953 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           0x0100
# 1953 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                 ;
    if(abs == 0x7C00)
     return 
# 1955 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           (0x0100 | 0x0400)
# 1955 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                      ;
    if(abs > 0x3FF)
     return 
# 1957 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
           0x0400
# 1957 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                    ;
    return abs ? 
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
                (0x0400 | 0x4000) 
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                             : 
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h" 3
                               0x4000
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
                                      ;
   }





   static bool isfinite(half arg) { return (arg.data_&0x7C00) != 0x7C00; }





   static bool isinf(half arg) { return (arg.data_&0x7FFF) == 0x7C00; }





   static bool isnan(half arg) { return (arg.data_&0x7FFF) > 0x7C00; }





   static bool isnormal(half arg) { return ((arg.data_&0x7C00)!=0) & ((arg.data_&0x7C00)!=0x7C00); }





   static bool signbit(half arg) { return (arg.data_&0x8000) != 0; }
# 1999 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_equal, x, y); }
   static bool isequal(float x, half y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(half x, float y) { return xil_fpo_equal_flt(x,y); }
   static bool isequal(double x, half y) { return xil_fpo_equal_d(x,y); }
   static bool isequal(half x, double y) { return xil_fpo_equal_d(x,y); }
# 2015 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isnotequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_notequal, x, y); }
   static bool isnotequal(float x, half y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(half x, float y) { return xil_fpo_notequal_flt(x,y); }
   static bool isnotequal(double x, half y) { return xil_fpo_notequal_d(x,y); }
   static bool isnotequal(half x, double y) { return xil_fpo_notequal_d(x,y); }
# 2032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreater(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greater, x, y); }
   static bool isgreater(float x, half y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(half x, float y) { return xil_fpo_greater_flt(x,y); }
   static bool isgreater(double x, half y) { return xil_fpo_greater_d(x,y); }
   static bool isgreater(half x, double y) { return xil_fpo_greater_d(x,y); }
# 2049 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isgreaterequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_greaterequal, x, y); }
   static bool isgreaterequal(float x, half y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(half x, float y) { return xil_fpo_greaterequal_flt(x,y); }
   static bool isgreaterequal(double x, half y) { return xil_fpo_greaterequal_d(x,y); }
   static bool isgreaterequal(half x, double y) { return xil_fpo_greaterequal_d(x,y); }
# 2066 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool isless(T1 x, T2 y) { return binary_operator_compare(xip_fpo_less, x, y); }
   static bool isless(float x, half y) { return xil_fpo_less_flt(x,y); }
   static bool isless(half x, float y) { return xil_fpo_less_flt(x,y); }
   static bool isless(double x, half y) { return xil_fpo_less_d(x,y); }
   static bool isless(half x, double y) { return xil_fpo_less_d(x,y); }
# 2083 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
            template<typename T1, typename T2>
   static bool islessequal(T1 x, T2 y) { return binary_operator_compare(xip_fpo_lessequal, x, y); }
   static bool islessequal(float x, half y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(half x, float y) { return xil_fpo_lessequal_flt(x,y); }
   static bool islessequal(double x, half y) { return xil_fpo_lessequal_d(x,y); }
   static bool islessequal(half x, double y) { return xil_fpo_lessequal_d(x,y); }







   static bool islessgreater(half x, half y)
   {
    if(isnan(x) || isnan(y))
     return false;



                return isless(x, y) || isgreater(x, y);
   }






   static bool isunordered(half x, half y) { return isnan(x) || isnan(y); }

  private:
   static double erf(double arg)
   {
    if(builtin_isinf(arg))
     return (arg<0.0) ? -1.0 : 1.0;
    double x2 = static_cast<double>(arg) * static_cast<double>(arg), ax2 = 0.147 * x2;
    double value = std::sqrt(1.0-std::exp(-x2*(1.2732395447351626861510701069801+ax2)/(1.0+ax2)));
    return builtin_signbit(arg) ? -value : value;
   }

   static double lgamma(double arg)
   {
    double v = 1.0;
    for(; arg<8.0; ++arg) v *= arg;
    double w = 1.0 / (arg * arg);
    return (((((((-0.02955065359477124183006535947712*w+0.00641025641025641025641025641026)*w+
     -0.00191752691752691752691752691753)*w+8.4175084175084175084175084175084e-4)*w+
     -5.952380952380952380952380952381e-4)*w+7.9365079365079365079365079365079e-4)*w+
     -0.00277777777777777777777777777778)*w+0.08333333333333333333333333333333)/arg +
     0.91893853320467274178032973640562 - std::log(v) - arg + (arg-0.5) * std::log(arg);
   }
  };



  template<typename T> struct unary_specialized
  {



   static constexpr half negate(half arg) { return half(binary, arg.data_^0x8000); }




   static half fabs(half arg) { return half(binary, arg.data_&0x7FFF); }
  };
  template<> struct unary_specialized<expr>
  {
   static constexpr expr negate(float arg) { return expr(-arg); }
   static expr fabs(float arg) { return expr(std::fabs(arg)); }
  };




  template<typename T,typename U> struct binary_specialized
  {




   static expr fmin(float x, float y)
   {

    return expr(std::fmin(x, y));







   }





   static expr fmax(float x, float y)
   {

    return expr(std::fmax(x, y));







   }
  };
  template<> struct binary_specialized<half,half>
  {
   static half fmin(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) >
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
   static half fmax(half x, half y)
   {
    if(functions::isnan(x))
     return y;
    if(functions::isnan(y))
     return x;
    return ((functions::signbit(x) ? (static_cast<int17>(0x8000)-x.data_) : static_cast<int17>(x.data_)) <
      (functions::signbit(y) ? (static_cast<int17>(0x8000)-y.data_) : static_cast<int17>(y.data_))) ? y : x;
   }
  };







  template<typename T,typename U,std::float_round_style R=(std::float_round_style)(1)> struct half_caster {};
  template<typename U,std::float_round_style R> struct half_caster<half,U,R>
  {




   typedef half type;
   static half cast(U arg) { return cast_impl(arg, is_float<U>()); };

  private:
   static half cast_impl(U arg, true_type) { return half(binary, float2half<R>(static_cast<float>(arg))); }
   static half cast_impl(U arg, false_type) { return half(binary, int2half<R>(arg)); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,half,R>
  {




   typedef T type;
   template<typename U> static T cast(U arg) { return cast_impl(arg, is_float<T>()); }

  private:
   static T cast_impl(float arg, true_type) { return static_cast<T>(arg); }
   static T cast_impl(half arg, false_type) { return half2int<R,T>(arg.data_); }
  };
  template<typename T,std::float_round_style R> struct half_caster<T,expr,R> : public half_caster<T,half,R> {};
  template<std::float_round_style R> struct half_caster<half,half,R>
  {
   typedef half type;
   static half cast(half arg) { return arg; }
  };
  template<std::float_round_style R> struct half_caster<half,expr,R> : public half_caster<half,half,R> {};
# 2269 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<bool,T,U>::type operator==(T x, U y) { return functions::isequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator!=(T x, U y) { return functions::isnotequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<(T x, U y) { return functions::isless(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>(T x, U y) { return functions::isgreater(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator<=(T x, U y) { return functions::islessequal(x, y); }






  template<typename T,typename U> typename enable<bool,T,U>::type operator>=(T x, U y) { return functions::isgreaterequal(x, y); }
# 2317 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator+(T x, U y) { return functions::plus(x, y); }
# 2327 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator-(T x, U y) { return functions::minus(x, y); }
# 2337 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator*(T x, U y) { return functions::multiplies(x, y); }
# 2347 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename enable<half,T,U>::type operator/(T x, U y) { return functions::divides(x, y); }





  template<typename T> constexpr typename enable<T,T>::type operator+(T arg) { return arg; }




  template<typename T> constexpr typename enable<T,T>::type operator-(T arg) { return unary_specialized<T>::negate(arg); }
# 2368 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename charT,typename traits> typename enable<std::basic_ostream<charT,traits>&,T>::type
   operator<<(std::basic_ostream<charT,traits> &out, T arg) { return functions::write(out, arg); }





  template<typename charT,typename traits> std::basic_istream<charT,traits>&
   operator>>(std::basic_istream<charT,traits> &in, half &arg) { return functions::read(in, arg); }
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half abs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr abs(expr arg) { return unary_specialized<expr>::fabs(arg); }





  inline half fabs(half arg) { return unary_specialized<half>::fabs(arg); }
  inline expr fabs(expr arg) { return unary_specialized<expr>::fabs(arg); }






  inline expr fmod(half x, half y) { return functions::fmod(x, y); }
  inline expr fmod(half x, expr y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, half y) { return functions::fmod(x, y); }
  inline expr fmod(expr x, expr y) { return functions::fmod(x, y); }






  inline expr remainder(half x, half y) { return functions::remainder(x, y); }
  inline expr remainder(half x, expr y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, half y) { return functions::remainder(x, y); }
  inline expr remainder(expr x, expr y) { return functions::remainder(x, y); }







  inline expr remquo(half x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(half x, expr y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, half y, int *quo) { return functions::remquo(x, y, quo); }
  inline expr remquo(expr x, expr y, int *quo) { return functions::remquo(x, y, quo); }







  inline expr fma(half x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(half x, expr y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, half y, expr z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, half z) { return functions::fma(x, y, z); }
  inline expr fma(expr x, expr y, expr z) { return functions::fma(x, y, z); }

                inline expr mad(half x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(half x, expr y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, half y, expr z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, half z) { return functions::fma(x, y, z); }
                inline expr mad(expr x, expr y, expr z) { return functions::fma(x, y, z); }






  inline half fmax(half x, half y) { return binary_specialized<half,half>::fmax(x, y); }
  inline expr fmax(half x, expr y) { return binary_specialized<half,expr>::fmax(x, y); }
  inline expr fmax(expr x, half y) { return binary_specialized<expr,half>::fmax(x, y); }
  inline expr fmax(expr x, expr y) { return binary_specialized<expr,expr>::fmax(x, y); }






  inline half fmin(half x, half y) { return binary_specialized<half,half>::fmin(x, y); }
  inline expr fmin(half x, expr y) { return binary_specialized<half,expr>::fmin(x, y); }
  inline expr fmin(expr x, half y) { return binary_specialized<expr,half>::fmin(x, y); }
  inline expr fmin(expr x, expr y) { return binary_specialized<expr,expr>::fmin(x, y); }






  inline expr fdim(half x, half y) { return functions::fdim(x, y); }
  inline expr fdim(half x, expr y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, half y) { return functions::fdim(x, y); }
  inline expr fdim(expr x, expr y) { return functions::fdim(x, y); }

                inline expr maxmag(half x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(half x, expr y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, half y) { return functions::maxmag(x, y); }
                inline expr maxmag(expr x, expr y) { return functions::maxmag(x, y); }

                inline expr minmag(half x, half y) { return functions::minmag(x, y); }
                inline expr minmag(half x, expr y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, half y) { return functions::minmag(x, y); }
                inline expr minmag(expr x, expr y) { return functions::minmag(x, y); }




  inline half nanh(const char *arg) { return functions::nanh(arg); }
# 2504 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr exp(half arg) { return functions::exp(arg); }
  inline expr exp(expr arg) { return functions::exp(arg); }





  inline expr expm1(half arg) { return functions::expm1(arg); }
  inline expr expm1(expr arg) { return functions::expm1(arg); }





  inline expr exp2(half arg) { return functions::exp2(arg); }
  inline expr exp2(expr arg) { return functions::exp2(arg); }





  inline expr log(half arg) { return functions::log(arg); }
  inline expr log(expr arg) { return functions::log(arg); }





  inline expr log10(half arg) { return functions::log10(arg); }
  inline expr log10(expr arg) { return functions::log10(arg); }





  inline expr log1p(half arg) { return functions::log1p(arg); }
  inline expr log1p(expr arg) { return functions::log1p(arg); }





  inline expr log2(half arg) { return functions::log2(arg); }
  inline expr log2(expr arg) { return functions::log2(arg); }
# 2560 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half sqrt(half arg) { return math_function_1arg(xip_fpo_sqrt, arg); }

  inline expr sqrt(expr arg) { return functions::sqrt(arg); }





  inline expr cbrt(half arg) { return functions::cbrt(arg); }
  inline expr cbrt(expr arg) { return functions::cbrt(arg); }






  inline expr hypot(half x, half y) { return functions::hypot(x, y); }
  inline expr hypot(half x, expr y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, half y) { return functions::hypot(x, y); }
  inline expr hypot(expr x, expr y) { return functions::hypot(x, y); }






  inline expr pow(half base, half exp) { return functions::pow(base, exp); }
  inline expr pow(half base, expr exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, half exp) { return functions::pow(base, exp); }
  inline expr pow(expr base, expr exp) { return functions::pow(base, exp); }
                inline expr powr(half base, half exp) { return functions::powr(base, exp); }
                inline expr powr(half base, expr exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, half exp) { return functions::powr(base, exp); }
                inline expr powr(expr base, expr exp) { return functions::powr(base, exp); }
                inline expr pown(half base, int exp) { return functions::pown(base, exp); }
                inline expr pown(expr base, int exp) { return functions::pown(base, exp); }
# 2605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr sin(half arg) { return functions::sin(arg); }
  inline expr sin(expr arg) { return functions::sin(arg); }





  inline expr cos(half arg) { return functions::cos(arg); }
  inline expr cos(expr arg) { return functions::cos(arg); }





  inline expr tan(half arg) { return functions::tan(arg); }
  inline expr tan(expr arg) { return functions::tan(arg); }





  inline expr asin(half arg) { return functions::asin(arg); }
  inline expr asin(expr arg) { return functions::asin(arg); }





  inline expr acos(half arg) { return functions::acos(arg); }
  inline expr acos(expr arg) { return functions::acos(arg); }





  inline expr atan(half arg) { return functions::atan(arg); }
  inline expr atan(expr arg) { return functions::atan(arg); }






  inline expr atan2(half x, half y) { return functions::atan2(x, y); }
  inline expr atan2(half x, expr y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, half y) { return functions::atan2(x, y); }
  inline expr atan2(expr x, expr y) { return functions::atan2(x, y); }
# 2661 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr sinh(half arg) { return functions::sinh(arg); }
  inline expr sinh(expr arg) { return functions::sinh(arg); }





  inline expr cosh(half arg) { return functions::cosh(arg); }
  inline expr cosh(expr arg) { return functions::cosh(arg); }





  inline expr tanh(half arg) { return functions::tanh(arg); }
  inline expr tanh(expr arg) { return functions::tanh(arg); }





  inline expr asinh(half arg) { return functions::asinh(arg); }
  inline expr asinh(expr arg) { return functions::asinh(arg); }





  inline expr acosh(half arg) { return functions::acosh(arg); }
  inline expr acosh(expr arg) { return functions::acosh(arg); }





  inline expr atanh(half arg) { return functions::atanh(arg); }
  inline expr atanh(expr arg) { return functions::atanh(arg); }
# 2707 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline expr erf(half arg) { return functions::erf(arg); }
  inline expr erf(expr arg) { return functions::erf(arg); }





  inline expr erfc(half arg) { return functions::erfc(arg); }
  inline expr erfc(expr arg) { return functions::erfc(arg); }





                inline expr lgamma_r(half arg, int *signgamp) { return functions::lgamma(arg); }
                inline expr lgamma_r(expr arg, int *signgamp) { return functions::lgamma(arg); }
  inline expr lgamma(half arg) { return functions::lgamma(arg); }
  inline expr lgamma(expr arg) { return functions::lgamma(arg); }





  inline expr tgamma(half arg) { return functions::tgamma(arg); }
  inline expr tgamma(expr arg) { return functions::tgamma(arg); }
# 2741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half ceil(half arg) { return functions::ceil(arg); }
  inline half ceil(expr arg) { return functions::ceil(arg); }





  inline half floor(half arg) { return functions::floor(arg); }
  inline half floor(expr arg) { return functions::floor(arg); }





  inline half trunc(half arg) { return functions::trunc(arg); }
  inline half trunc(expr arg) { return functions::trunc(arg); }





  inline half round(half arg) { return functions::round(arg); }
  inline half round(expr arg) { return functions::round(arg); }





  inline long lround(half arg) { return functions::lround(arg); }
  inline long lround(expr arg) { return functions::lround(arg); }





  inline half nearbyint(half arg) { return functions::rint(arg); }
  inline half nearbyint(expr arg) { return functions::rint(arg); }





  inline half rint(half arg) { return functions::rint(arg); }
  inline half rint(expr arg) { return functions::rint(arg); }





  inline long lrint(half arg) { return functions::lrint(arg); }
  inline long lrint(expr arg) { return functions::lrint(arg); }





  inline long long llround(half arg) { return functions::llround(arg); }
  inline long long llround(expr arg) { return functions::llround(arg); }





  inline long long llrint(half arg) { return functions::llrint(arg); }
  inline long long llrint(expr arg) { return functions::llrint(arg); }
# 2817 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline half frexp(half arg, int *exp) { return functions::frexp(arg, exp); }
  inline half frexp(expr arg, int *exp) { return functions::frexp(arg, exp); }






  inline half ldexp(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half ldexp(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half modf(half arg, half *iptr) { return functions::modf(arg, iptr); }
  inline half modf(expr arg, half *iptr) { return functions::modf(arg, iptr); }






  inline half scalbn(half arg, int exp) { return functions::scalbln(arg, exp); }
  inline half scalbn(expr arg, int exp) { return functions::scalbln(arg, exp); }






  inline half scalbln(half arg, long exp) { return functions::scalbln(arg, exp); }
  inline half scalbln(expr arg, long exp) { return functions::scalbln(arg, exp); }
# 2859 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline int ilogb(half arg) { return functions::ilogb(arg); }
  inline int ilogb(expr arg) { return functions::ilogb(arg); }





  inline half logb(half arg) { return functions::logb(arg); }
  inline half logb(expr arg) { return functions::logb(arg); }






  inline half nextafter(half from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(half from, expr to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, half to) { return functions::nextafter(from, to); }
  inline half nextafter(expr from, expr to) { return functions::nextafter(from, to); }






  inline half nexttoward(half from, long double to) { return functions::nexttoward(from, to); }
  inline half nexttoward(expr from, long double to) { return functions::nexttoward(from, to); }






  inline half copysign(half x, half y) { return functions::copysign(x, y); }
  inline half copysign(half x, expr y) { return functions::copysign(x, y); }
  inline half copysign(expr x, half y) { return functions::copysign(x, y); }
  inline half copysign(expr x, expr y) { return functions::copysign(x, y); }
# 2910 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline int fpclassify(half arg) { return functions::fpclassify(arg); }
  inline int fpclassify(expr arg) { return functions::fpclassify(arg); }






  inline bool isfinite(half arg) { return functions::isfinite(arg); }
  inline bool isfinite(expr arg) { return functions::isfinite(arg); }






  inline bool isinf(half arg) { return functions::isinf(arg); }
  inline bool isinf(expr arg) { return functions::isinf(arg); }






  inline bool isnan(half arg) { return functions::isnan(arg); }
  inline bool isnan(expr arg) { return functions::isnan(arg); }






  inline bool isnormal(half arg) { return functions::isnormal(arg); }
  inline bool isnormal(expr arg) { return functions::isnormal(arg); }






  inline bool signbit(half arg) { return functions::signbit(arg); }
  inline bool signbit(expr arg) { return functions::signbit(arg); }
# 2963 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  inline bool isgreater(half x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(half x, expr y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, half y) { return functions::isgreater(x, y); }
  inline bool isgreater(expr x, expr y) { return functions::isgreater(x, y); }







  inline bool isgreaterequal(half x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(half x, expr y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, half y) { return functions::isgreaterequal(x, y); }
  inline bool isgreaterequal(expr x, expr y) { return functions::isgreaterequal(x, y); }







  inline bool isless(half x, half y) { return functions::isless(x, y); }
  inline bool isless(half x, expr y) { return functions::isless(x, y); }
  inline bool isless(expr x, half y) { return functions::isless(x, y); }
  inline bool isless(expr x, expr y) { return functions::isless(x, y); }







  inline bool islessequal(half x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(half x, expr y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, half y) { return functions::islessequal(x, y); }
  inline bool islessequal(expr x, expr y) { return functions::islessequal(x, y); }







  inline bool islessgreater(half x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(half x, expr y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, half y) { return functions::islessgreater(x, y); }
  inline bool islessgreater(expr x, expr y) { return functions::islessgreater(x, y); }







  inline bool isunordered(half x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(half x, expr y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, half y) { return functions::isunordered(x, y); }
  inline bool isunordered(expr x, expr y) { return functions::isunordered(x, y); }
# 3040 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,typename U> typename half_caster<T,U>::type half_cast(U arg) { return half_caster<T,U>::cast(arg); }
# 3057 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  template<typename T,std::float_round_style R,typename U> typename half_caster<T,U,R>::type half_cast(U arg)
   { return half_caster<T,U,R>::cast(arg); }

 }

 using detail::operator==;
 using detail::operator!=;
 using detail::operator<;
 using detail::operator>;
 using detail::operator<=;
 using detail::operator>=;
 using detail::operator+;
 using detail::operator-;
 using detail::operator*;
 using detail::operator/;
 using detail::operator<<;
 using detail::operator>>;
# 3135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
  using detail::fpclassify;
  using detail::isfinite;
  using detail::isinf;
  using detail::isnan;
  using detail::isnormal;
  using detail::signbit;
  using detail::isgreater;
  using detail::isgreaterequal;
  using detail::isless;
  using detail::islessequal;
  using detail::islessgreater;
  using detail::isunordered;

 using detail::half_cast;


namespace std
{



 template<> struct numeric_limits<half> : public numeric_limits<float>
 {
 public:

  static constexpr bool is_signed = true;


  static constexpr bool is_exact = false;


  static constexpr bool is_modulo = false;


  static constexpr bool is_iec559 = true;


  static constexpr bool has_infinity = true;


  static constexpr bool has_quiet_NaN = true;


  static constexpr float_denorm_style has_denorm = denorm_present;





  static constexpr float_round_style round_style = (std::numeric_limits<float>::round_style==
   half::round_style) ? half::round_style : round_indeterminate;


  static constexpr int digits = 11;


  static constexpr int digits10 = 3;


  static constexpr int max_digits10 = 5;


  static constexpr int radix = 2;


  static constexpr int min_exponent = -13;


  static constexpr int min_exponent10 = -4;


  static constexpr int max_exponent = 16;


  static constexpr int max_exponent10 = 4;


  static constexpr half min() noexcept { return half(detail::binary, 0x0400); }


  static constexpr half lowest() noexcept { return half(detail::binary, 0xFBFF); }


  static constexpr half max() noexcept { return half(detail::binary, 0x7BFF); }


  static constexpr half epsilon() noexcept { return half(detail::binary, 0x1400); }


  static constexpr half round_error() noexcept
   { return half(detail::binary, (round_style==std::round_to_nearest) ? 0x3800 : 0x3C00); }


  static constexpr half infinity() noexcept { return half(detail::binary, 0x7C00); }


  static constexpr half quiet_NaN() noexcept { return half(detail::binary, 0x7FFF); }


  static constexpr half signaling_NaN() noexcept { return half(detail::binary, 0x7DFF); }


  static constexpr half denorm_min() noexcept { return half(detail::binary, 0x0001); }
 };




 template<> struct hash<half>
 {

  typedef half argument_type;


  typedef size_t result_type;




  result_type operator()(argument_type arg) const
   { return hash<detail::uint16>()(static_cast<unsigned int>(arg.data_)&-(arg.data_!=0x8000)); }
 };

}
# 3274 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/hls_half.h"
extern half half_nan(const char *tagp);





extern half half_atan(half t);
extern half half_atan2(half y, half x);
extern half half_copysign(half x, half y);

extern half half_fabs(half x);

extern half half_abs(half x);
extern half half_fma(half x, half y, half z);
extern half half_mad(half x, half y, half z);
extern half half_frexp (half x, int* exp);
extern half half_ldexp (half x, int exp);
extern half half_fmax(half x, half y);

extern half half_fmin(half x, half y);

extern half half_asin(half t_in);
extern half half_acos(half t_in);
extern half half_sin(half t_in);
extern half half_cos(half t_in);
extern void half_sincos(half x, half *sin, half *cos);
extern half half_sinh(half t_in);
extern half half_cosh(half t_in);
extern half half_sinpi(half t_in);
extern half half_cospi(half t_in);
extern half half_recip(half x);
extern half half_sqrt(half x);
extern half half_rsqrt(half x);
extern half half_cbrt(half x);
extern half half_hypot(half x, half y);
extern half half_log(half x);
extern half half_log10(half x);
extern half half_log2(half x);
extern half half_logb(half x);
extern half half_log1p(half x);
extern int half_ilogb(half x);
extern half half_exp(half x);
extern half half_exp10(half x);
extern half half_exp2(half x);
extern half half_expm1(half x);
extern half half_pow(half x, half y);
extern half half_powr(half x, half y);
extern half half_pown(half x, int y);
extern half half_rootn(half x, int y);
extern half half_floor(half x);

extern half half_ceil(half x);

extern half half_trunc(half x);

extern half half_round(half x);

extern half half_nearbyint(half x);
extern half half_rint(half x);
extern long int half_lrint(half x);
extern long long int half_llrint(half x);
extern long int half_lround(half x);
extern long long int half_llround(half x);
extern half half_modf(half x, half *intpart);

extern half half_fract(half x, half *intpart);
extern half half_nextafter(half x, half y);
extern half half_fmod(half x, half y);
extern half half_remainder(half x, half y);
extern half half_remquo(half x, half y, int* quo);
extern half half_divide(half x, half y);
# 91 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 101 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
namespace AESL_std {
template <class DataType>
DataType inline min(DataType a, DataType b) {
  return (a >= b) ? b : a;
}

template <class DataType>
DataType inline max(DataType a, DataType b) {
  return (a >= b) ? a : b;
}
}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 3
       
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/assert.h" 1 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cassert" 2 3
# 117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 118 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstring" 3
# 119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3






# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 3
       
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 3




# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
       
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 1 3
# 24 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
#pragma pack(push,_CRT_PACKING)



# 27 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
extern "C" {
# 60 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
  typedef long clock_t;
# 112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
  extern __attribute__ ((__dllimport__)) int _daylight;
  extern __attribute__ ((__dllimport__)) long _dstbias;
  extern __attribute__ ((__dllimport__)) long _timezone;
  extern __attribute__ ((__dllimport__)) char * _tzname[2];

  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_daylight(int *_Daylight);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_dstbias(long *_Daylight_savings_bias);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_timezone(long *_Timezone);
  __attribute__ ((__dllimport__)) errno_t __attribute__((__cdecl__)) _get_tzname(size_t *_ReturnValue,char *_Buffer,size_t _SizeInBytes,int _Index);
  char *__attribute__((__cdecl__)) asctime(const struct tm *_Tm) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) asctime_s (char *_Buf,size_t _SizeInWords,const struct tm *_Tm);
  char *__attribute__((__cdecl__)) _ctime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime32_s (char *_Buf,size_t _SizeInBytes,const __time32_t *_Time);
  clock_t __attribute__((__cdecl__)) clock(void);
  double __attribute__((__cdecl__)) _difftime32(__time32_t _Time1,__time32_t _Time2);
  struct tm *__attribute__((__cdecl__)) _gmtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime32_s (struct tm *_Tm,const __time32_t *_Time);
  struct tm *__attribute__((__cdecl__)) _localtime32(const __time32_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime32_s (struct tm *_Tm,const __time32_t *_Time);
  size_t __attribute__((__cdecl__)) strftime(char * __restrict__ _Buf,size_t _SizeInBytes,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm);
  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _strftime_l(char * __restrict__ _Buf,size_t _Max_size,const char * __restrict__ _Format,const struct tm * __restrict__ _Tm,_locale_t _Locale);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strdate(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strdate_s (char *_Buf,size_t _SizeInBytes);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _strtime(char *_Buffer) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _strtime_s (char *_Buf ,size_t _SizeInBytes);
  __time32_t __attribute__((__cdecl__)) _time32(__time32_t *_Time);
  __time32_t __attribute__((__cdecl__)) _mktime32(struct tm *_Tm);
  __time32_t __attribute__((__cdecl__)) _mkgmtime32(struct tm *_Tm);


  void __attribute__((__cdecl__)) tzset(void) ;


  __attribute__ ((__dllimport__)) void __attribute__((__cdecl__)) _tzset(void);


  double __attribute__((__cdecl__)) _difftime64(__time64_t _Time1,__time64_t _Time2);
  __attribute__ ((__dllimport__)) char *__attribute__((__cdecl__)) _ctime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _ctime64_s (char *_Buf,size_t _SizeInBytes,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _gmtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _gmtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) struct tm *__attribute__((__cdecl__)) _localtime64(const __time64_t *_Time) ;
  __attribute__((dllimport)) errno_t __attribute__((__cdecl__)) _localtime64_s (struct tm *_Tm,const __time64_t *_Time);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mktime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _mkgmtime64(struct tm *_Tm);
  __attribute__ ((__dllimport__)) __time64_t __attribute__((__cdecl__)) _time64(__time64_t *_Time);
  unsigned __attribute__((__cdecl__)) _getsystime(struct tm *_Tm);
  unsigned __attribute__((__cdecl__)) _setsystime(struct tm *_Tm,unsigned _MilliSec);
# 203 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
double __attribute__((__cdecl__)) difftime(time_t _Time1,time_t _Time2);
char *__attribute__((__cdecl__)) ctime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) gmtime(const time_t *_Time) ;
struct tm *__attribute__((__cdecl__)) localtime(const time_t *_Time) ;

time_t __attribute__((__cdecl__)) mktime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) _mkgmtime(struct tm *_Tm);
time_t __attribute__((__cdecl__)) time(time_t *_Time);
# 240 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) localtime_s(struct tm *_Tm,const time_t *_Time) { return _localtime64_s(_Tm,_Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) gmtime_s(struct tm *_Tm, const time_t *_Time) { return _gmtime64_s(_Tm, _Time); }
inline __attribute__((__always_inline__)) errno_t __attribute__((__cdecl__)) ctime_s(char *_Buf,size_t _SizeInBytes,const time_t *_Time) { return _ctime64_s(_Buf,_SizeInBytes,_Time); }






  __attribute__ ((__dllimport__)) extern int daylight;
  __attribute__ ((__dllimport__)) extern long timezone;
  __attribute__ ((__dllimport__)) extern char *tzname[2];
  void __attribute__((__cdecl__)) tzset(void) ;


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_timeval.h" 1 3
# 10 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/_timeval.h" 3
struct timeval
{
 long tv_sec;
 long tv_usec;
};
# 256 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 2 3



struct timezone {
  int tz_minuteswest;
  int tz_dsttime;
};

  extern int __attribute__((__cdecl__)) mingw_gettimeofday (struct timeval *p, struct timezone *z);



}


#pragma pack(pop)






inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) localtime_r(const time_t *_Time, struct tm *_Tm) {
  return localtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) struct tm *__attribute__((__cdecl__)) gmtime_r(const time_t *_Time, struct tm *_Tm) {
  return gmtime_s(_Tm, _Time) ? __null : _Tm;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) ctime_r(const time_t *_Time, char *_Str) {
  return ctime_s(_Str, 0x7fffffff, _Time) ? __null : _Str;
}
inline __attribute__((__always_inline__)) char *__attribute__((__cdecl__)) asctime_r(const struct tm *_Tm, char * _Str) {
  return asctime_s(_Str, 0x7fffffff, _Tm) ? __null : _Str;
}
# 301 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_time.h" 1 3
# 74 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/pthread_time.h" 3
extern "C" {



       





int __attribute__((__cdecl__)) nanosleep(const struct timespec *request, struct timespec *remain);

int __attribute__((__cdecl__)) clock_nanosleep(clockid_t clock_id, int flags, const struct timespec *request, struct timespec *remain);
int __attribute__((__cdecl__)) clock_getres(clockid_t clock_id, struct timespec *res);
int __attribute__((__cdecl__)) clock_gettime(clockid_t clock_id, struct timespec *tp);
int __attribute__((__cdecl__)) clock_settime(clockid_t clock_id, const struct timespec *tp);

       


}
# 302 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/time.h" 2 3
# 43 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 2 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

namespace std
{

# 52 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  class time_base
  {
  public:
    enum dateorder { no_order, dmy, mdy, ymd, ydm };
  };

  template<typename _CharT>
    struct __timepunct_cache : public locale::facet
    {

      static const _CharT* _S_timezones[14];

      const _CharT* _M_date_format;
      const _CharT* _M_date_era_format;
      const _CharT* _M_time_format;
      const _CharT* _M_time_era_format;
      const _CharT* _M_date_time_format;
      const _CharT* _M_date_time_era_format;
      const _CharT* _M_am;
      const _CharT* _M_pm;
      const _CharT* _M_am_pm_format;


      const _CharT* _M_day1;
      const _CharT* _M_day2;
      const _CharT* _M_day3;
      const _CharT* _M_day4;
      const _CharT* _M_day5;
      const _CharT* _M_day6;
      const _CharT* _M_day7;


      const _CharT* _M_aday1;
      const _CharT* _M_aday2;
      const _CharT* _M_aday3;
      const _CharT* _M_aday4;
      const _CharT* _M_aday5;
      const _CharT* _M_aday6;
      const _CharT* _M_aday7;


      const _CharT* _M_month01;
      const _CharT* _M_month02;
      const _CharT* _M_month03;
      const _CharT* _M_month04;
      const _CharT* _M_month05;
      const _CharT* _M_month06;
      const _CharT* _M_month07;
      const _CharT* _M_month08;
      const _CharT* _M_month09;
      const _CharT* _M_month10;
      const _CharT* _M_month11;
      const _CharT* _M_month12;


      const _CharT* _M_amonth01;
      const _CharT* _M_amonth02;
      const _CharT* _M_amonth03;
      const _CharT* _M_amonth04;
      const _CharT* _M_amonth05;
      const _CharT* _M_amonth06;
      const _CharT* _M_amonth07;
      const _CharT* _M_amonth08;
      const _CharT* _M_amonth09;
      const _CharT* _M_amonth10;
      const _CharT* _M_amonth11;
      const _CharT* _M_amonth12;

      bool _M_allocated;

      __timepunct_cache(size_t __refs = 0) : facet(__refs),
      _M_date_format(0), _M_date_era_format(0), _M_time_format(0),
      _M_time_era_format(0), _M_date_time_format(0),
      _M_date_time_era_format(0), _M_am(0), _M_pm(0),
      _M_am_pm_format(0), _M_day1(0), _M_day2(0), _M_day3(0),
      _M_day4(0), _M_day5(0), _M_day6(0), _M_day7(0),
      _M_aday1(0), _M_aday2(0), _M_aday3(0), _M_aday4(0),
      _M_aday5(0), _M_aday6(0), _M_aday7(0), _M_month01(0),
      _M_month02(0), _M_month03(0), _M_month04(0), _M_month05(0),
      _M_month06(0), _M_month07(0), _M_month08(0), _M_month09(0),
      _M_month10(0), _M_month11(0), _M_month12(0), _M_amonth01(0),
      _M_amonth02(0), _M_amonth03(0), _M_amonth04(0),
      _M_amonth05(0), _M_amonth06(0), _M_amonth07(0),
      _M_amonth08(0), _M_amonth09(0), _M_amonth10(0),
      _M_amonth11(0), _M_amonth12(0), _M_allocated(false)
      { }

      ~__timepunct_cache();

    private:
      __timepunct_cache&
      operator=(const __timepunct_cache&);

      explicit
      __timepunct_cache(const __timepunct_cache&);
    };

  template<typename _CharT>
    __timepunct_cache<_CharT>::~__timepunct_cache()
    {
      if (_M_allocated)
 {

 }
    }


  template<>
    const char*
    __timepunct_cache<char>::_S_timezones[14];


  template<>
    const wchar_t*
    __timepunct_cache<wchar_t>::_S_timezones[14];



  template<typename _CharT>
    const _CharT* __timepunct_cache<_CharT>::_S_timezones[14];

  template<typename _CharT>
    class __timepunct : public locale::facet
    {
    public:

      typedef _CharT __char_type;
      typedef __timepunct_cache<_CharT> __cache_type;

    protected:
      __cache_type* _M_data;
      __c_locale _M_c_locale_timepunct;
      const char* _M_name_timepunct;

    public:

      static locale::id id;

      explicit
      __timepunct(size_t __refs = 0);

      explicit
      __timepunct(__cache_type* __cache, size_t __refs = 0);
# 206 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      __timepunct(__c_locale __cloc, const char* __s, size_t __refs = 0);



      void
      _M_put(_CharT* __s, size_t __maxlen, const _CharT* __format,
      const tm* __tm) const throw ();

      void
      _M_date_formats(const _CharT** __date) const
      {

 __date[0] = _M_data->_M_date_format;
 __date[1] = _M_data->_M_date_era_format;
      }

      void
      _M_time_formats(const _CharT** __time) const
      {

 __time[0] = _M_data->_M_time_format;
 __time[1] = _M_data->_M_time_era_format;
      }

      void
      _M_date_time_formats(const _CharT** __dt) const
      {

 __dt[0] = _M_data->_M_date_time_format;
 __dt[1] = _M_data->_M_date_time_era_format;
      }

      void
      _M_am_pm_format(const _CharT* __ampm) const
      { __ampm = _M_data->_M_am_pm_format; }

      void
      _M_am_pm(const _CharT** __ampm) const
      {
 __ampm[0] = _M_data->_M_am;
 __ampm[1] = _M_data->_M_pm;
      }

      void
      _M_days(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_day1;
 __days[1] = _M_data->_M_day2;
 __days[2] = _M_data->_M_day3;
 __days[3] = _M_data->_M_day4;
 __days[4] = _M_data->_M_day5;
 __days[5] = _M_data->_M_day6;
 __days[6] = _M_data->_M_day7;
      }

      void
      _M_days_abbreviated(const _CharT** __days) const
      {
 __days[0] = _M_data->_M_aday1;
 __days[1] = _M_data->_M_aday2;
 __days[2] = _M_data->_M_aday3;
 __days[3] = _M_data->_M_aday4;
 __days[4] = _M_data->_M_aday5;
 __days[5] = _M_data->_M_aday6;
 __days[6] = _M_data->_M_aday7;
      }

      void
      _M_months(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_month01;
 __months[1] = _M_data->_M_month02;
 __months[2] = _M_data->_M_month03;
 __months[3] = _M_data->_M_month04;
 __months[4] = _M_data->_M_month05;
 __months[5] = _M_data->_M_month06;
 __months[6] = _M_data->_M_month07;
 __months[7] = _M_data->_M_month08;
 __months[8] = _M_data->_M_month09;
 __months[9] = _M_data->_M_month10;
 __months[10] = _M_data->_M_month11;
 __months[11] = _M_data->_M_month12;
      }

      void
      _M_months_abbreviated(const _CharT** __months) const
      {
 __months[0] = _M_data->_M_amonth01;
 __months[1] = _M_data->_M_amonth02;
 __months[2] = _M_data->_M_amonth03;
 __months[3] = _M_data->_M_amonth04;
 __months[4] = _M_data->_M_amonth05;
 __months[5] = _M_data->_M_amonth06;
 __months[6] = _M_data->_M_amonth07;
 __months[7] = _M_data->_M_amonth08;
 __months[8] = _M_data->_M_amonth09;
 __months[9] = _M_data->_M_amonth10;
 __months[10] = _M_data->_M_amonth11;
 __months[11] = _M_data->_M_amonth12;
      }

    protected:
      virtual
      ~__timepunct();


      void
      _M_initialize_timepunct(__c_locale __cloc = 0);
    };

  template<typename _CharT>
    locale::id __timepunct<_CharT>::id;


  template<>
    void
    __timepunct<char>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<char>::_M_put(char*, size_t, const char*, const tm*) const throw ();


  template<>
    void
    __timepunct<wchar_t>::_M_initialize_timepunct(__c_locale __cloc);

  template<>
    void
    __timepunct<wchar_t>::_M_put(wchar_t*, size_t, const wchar_t*,
     const tm*) const throw ();



}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/time_members.h" 1 3
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/time_members.h" 3
namespace std
{


  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(size_t __refs)
    : facet(__refs), _M_data(0)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__cache_type* __cache, size_t __refs)
    : facet(__refs), _M_data(__cache)
    {
      _M_name_timepunct = _S_get_c_name();
      _M_initialize_timepunct();
    }

  template<typename _CharT>
    __timepunct<_CharT>::__timepunct(__c_locale __cloc, const char* __s,
         size_t __refs)
    : facet(__refs), _M_data(0)
    {
      if (__builtin_strcmp(__s, _S_get_c_name()) != 0)
 {
   const size_t __len = __builtin_strlen(__s) + 1;
   char* __tmp = new char[__len];
   __builtin_memcpy(__tmp, __s, __len);
   _M_name_timepunct = __tmp;
 }
      else
 _M_name_timepunct = _S_get_c_name();

      try
 { _M_initialize_timepunct(__cloc); }
      catch(...)
 {
   if (_M_name_timepunct != _S_get_c_name())
     delete [] _M_name_timepunct;
   throw;
 }
    }

  template<typename _CharT>
    __timepunct<_CharT>::~__timepunct()
    {
      if (_M_name_timepunct != _S_get_c_name())
 delete [] _M_name_timepunct;
      delete _M_data;
      _S_destroy_c_locale(_M_c_locale_timepunct);
    }


}
# 345 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

namespace std
{


namespace __cxx11 {
# 365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class time_get : public locale::facet, public time_base
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;



      static locale::id id;
# 386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_get(size_t __refs = 0)
      : facet (__refs) { }
# 403 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      dateorder
      date_order() const
      { return this->do_date_order(); }
# 427 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_time(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_time(__beg, __end, __io, __err, __tm); }
# 452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_date(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_date(__beg, __end, __io, __err, __tm); }
# 480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_weekday(__beg, __end, __io, __err, __tm); }
# 509 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_monthname(iter_type __beg, iter_type __end, ios_base& __io,
      ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_monthname(__beg, __end, __io, __err, __tm); }
# 535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get_year(iter_type __beg, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm) const
      { return this->do_get_year(__beg, __end, __io, __err, __tm); }
# 556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      inline
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, char __format,
                    char __modifier = 0) const
      {
        return this->do_get(__s, __end, __io, __err, __tm, __format,
                            __modifier);
      }
# 583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type get(iter_type __s, iter_type __end, ios_base& __io,
                    ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
                    const char_type* __fmtend) const;


    protected:

      virtual
      ~time_get() { }
# 603 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual dateorder
      do_date_order() const;
# 621 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 640 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 659 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_weekday(iter_type __beg, iter_type __end, ios_base&,
       ios_base::iostate& __err, tm* __tm) const;
# 678 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_monthname(iter_type __beg, iter_type __end, ios_base&,
         ios_base::iostate& __err, tm* __tm) const;
# 697 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
    ios_base::iostate& __err, tm* __tm) const;
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual

      iter_type
      do_get(iter_type __s, iter_type __end, ios_base& __f,
             ios_base::iostate& __err, tm* __tm,
             char __format, char __modifier) const;



      iter_type
      _M_extract_num(iter_type __beg, iter_type __end, int& __member,
       int __min, int __max, size_t __len,
       ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_name(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
          const _CharT** __names, size_t __indexlen,
          ios_base& __io, ios_base::iostate& __err) const;


      iter_type
      _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
       ios_base::iostate& __err, tm* __tm,
       const _CharT* __format) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id time_get<_CharT, _InIter>::id;


  template<typename _CharT, typename _InIter>
    class time_get_byname : public time_get<_CharT, _InIter>
    {
    public:

      typedef _CharT char_type;
      typedef _InIter iter_type;

      explicit
      time_get_byname(const char*, size_t __refs = 0)
      : time_get<_CharT, _InIter>(__refs) { }


      explicit
      time_get_byname(const string& __s, size_t __refs = 0)
      : time_get_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_get_byname() { }
    };

}
# 794 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class time_put : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _OutIter iter_type;



      static locale::id id;
# 815 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      time_put(size_t __refs = 0)
      : facet(__refs) { }
# 834 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
   const _CharT* __beg, const _CharT* __end) const;
# 854 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, ios_base& __io, char_type __fill,
   const tm* __tm, char __format, char __mod = 0) const
      { return this->do_put(__s, __io, __fill, __tm, __format, __mod); }

    protected:

      virtual
      ~time_put()
      { }
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
      char __format, char __mod) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id time_put<_CharT, _OutIter>::id;


  template<typename _CharT, typename _OutIter>
    class time_put_byname : public time_put<_CharT, _OutIter>
    {
    public:

      typedef _CharT char_type;
      typedef _OutIter iter_type;

      explicit
      time_put_byname(const char*, size_t __refs = 0)
      : time_put<_CharT, _OutIter>(__refs)
      { };


      explicit
      time_put_byname(const string& __s, size_t __refs = 0)
      : time_put_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~time_put_byname() { }
    };
# 926 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  class money_base
  {
  public:
    enum part { none, space, symbol, sign, value };
    struct pattern { char field[4]; };

    static const pattern _S_default_pattern;

    enum
    {
      _S_minus,
      _S_zero,
      _S_end = 11
    };



    static const char* _S_atoms;



    __attribute__ ((__const__)) static pattern
    _S_construct_pattern(char __precedes, char __space, char __posn) throw ();
  };

  template<typename _CharT, bool _Intl>
    struct __moneypunct_cache : public locale::facet
    {
      const char* _M_grouping;
      size_t _M_grouping_size;
      bool _M_use_grouping;
      _CharT _M_decimal_point;
      _CharT _M_thousands_sep;
      const _CharT* _M_curr_symbol;
      size_t _M_curr_symbol_size;
      const _CharT* _M_positive_sign;
      size_t _M_positive_sign_size;
      const _CharT* _M_negative_sign;
      size_t _M_negative_sign_size;
      int _M_frac_digits;
      money_base::pattern _M_pos_format;
      money_base::pattern _M_neg_format;




      _CharT _M_atoms[money_base::_S_end];

      bool _M_allocated;

      __moneypunct_cache(size_t __refs = 0) : facet(__refs),
      _M_grouping(0), _M_grouping_size(0), _M_use_grouping(false),
      _M_decimal_point(_CharT()), _M_thousands_sep(_CharT()),
      _M_curr_symbol(0), _M_curr_symbol_size(0),
      _M_positive_sign(0), _M_positive_sign_size(0),
      _M_negative_sign(0), _M_negative_sign_size(0),
      _M_frac_digits(0),
      _M_pos_format(money_base::pattern()),
      _M_neg_format(money_base::pattern()), _M_allocated(false)
      { }

      ~__moneypunct_cache();

      void
      _M_cache(const locale& __loc);

    private:
      __moneypunct_cache&
      operator=(const __moneypunct_cache&);

      explicit
      __moneypunct_cache(const __moneypunct_cache&);
    };

  template<typename _CharT, bool _Intl>
    __moneypunct_cache<_CharT, _Intl>::~__moneypunct_cache()
    {
      if (_M_allocated)
 {
   delete [] _M_grouping;
   delete [] _M_curr_symbol;
   delete [] _M_positive_sign;
   delete [] _M_negative_sign;
 }
    }

namespace __cxx11 {
# 1021 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, bool _Intl>
    class moneypunct : public locale::facet, public money_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

    private:
      __cache_type* _M_data;

    public:


      static const bool intl = _Intl;

      static locale::id id;
# 1050 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(); }
# 1063 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__cache_type* __cache, size_t __refs = 0)
      : facet(__refs), _M_data(__cache)
      { _M_initialize_moneypunct(); }
# 1078 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      moneypunct(__c_locale __cloc, const char* __s, size_t __refs = 0)
      : facet(__refs), _M_data(0)
      { _M_initialize_moneypunct(__cloc, __s); }
# 1092 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      char_type
      decimal_point() const
      { return this->do_decimal_point(); }
# 1105 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      char_type
      thousands_sep() const
      { return this->do_thousands_sep(); }
# 1135 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string
      grouping() const
      { return this->do_grouping(); }
# 1148 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      curr_symbol() const
      { return this->do_curr_symbol(); }
# 1165 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      positive_sign() const
      { return this->do_positive_sign(); }
# 1182 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      negative_sign() const
      { return this->do_negative_sign(); }
# 1198 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      int
      frac_digits() const
      { return this->do_frac_digits(); }
# 1234 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      pattern
      pos_format() const
      { return this->do_pos_format(); }

      pattern
      neg_format() const
      { return this->do_neg_format(); }


    protected:

      virtual
      ~moneypunct();
# 1256 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_decimal_point() const
      { return _M_data->_M_decimal_point; }
# 1268 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual char_type
      do_thousands_sep() const
      { return _M_data->_M_thousands_sep; }
# 1281 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string
      do_grouping() const
      { return _M_data->_M_grouping; }
# 1294 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_curr_symbol() const
      { return _M_data->_M_curr_symbol; }
# 1307 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_positive_sign() const
      { return _M_data->_M_positive_sign; }
# 1320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_negative_sign() const
      { return _M_data->_M_negative_sign; }
# 1334 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual int
      do_frac_digits() const
      { return _M_data->_M_frac_digits; }
# 1348 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_pos_format() const
      { return _M_data->_M_pos_format; }
# 1362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual pattern
      do_neg_format() const
      { return _M_data->_M_neg_format; }


       void
       _M_initialize_moneypunct(__c_locale __cloc = 0,
    const char* __name = 0);
    };

  template<typename _CharT, bool _Intl>
    locale::id moneypunct<_CharT, _Intl>::id;

  template<typename _CharT, bool _Intl>
    const bool moneypunct<_CharT, _Intl>::intl;

  template<>
    moneypunct<char, true>::~moneypunct();

  template<>
    moneypunct<char, false>::~moneypunct();

  template<>
    void
    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale, const char*);

  template<>
    void
    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale, const char*);


  template<>
    moneypunct<wchar_t, true>::~moneypunct();

  template<>
    moneypunct<wchar_t, false>::~moneypunct();

  template<>
    void
    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale,
       const char*);

  template<>
    void
    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale,
        const char*);



  template<typename _CharT, bool _Intl>
    class moneypunct_byname : public moneypunct<_CharT, _Intl>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      static const bool intl = _Intl;

      explicit
      moneypunct_byname(const char* __s, size_t __refs = 0)
      : moneypunct<_CharT, _Intl>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     __c_locale __tmp;
     this->_S_create_c_locale(__tmp, __s);
     this->_M_initialize_moneypunct(__tmp);
     this->_S_destroy_c_locale(__tmp);
   }
      }


      explicit
      moneypunct_byname(const string& __s, size_t __refs = 0)
      : moneypunct_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~moneypunct_byname() { }
    };

  template<typename _CharT, bool _Intl>
    const bool moneypunct_byname<_CharT, _Intl>::intl;

}

namespace __cxx11 {
# 1465 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _InIter>
    class money_get : public locale::facet
    {
    public:



      typedef _CharT char_type;
      typedef _InIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1487 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_get(size_t __refs = 0) : facet(__refs) { }
# 1517 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, long double& __units) const
      { return this->do_get(__s, __end, __intl, __io, __err, __units); }
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
   ios_base::iostate& __err, string_type& __digits) const
      { return this->do_get(__s, __end, __intl, __io, __err, __digits); }

    protected:

      virtual
      ~money_get() { }
# 1572 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, long double& __units) const;
# 1584 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_get(iter_type __s, iter_type __end, bool __intl, ios_base& __io,
      ios_base::iostate& __err, string_type& __digits) const;
# 1596 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_extract(iter_type __s, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, string& __digits) const;
    };

  template<typename _CharT, typename _InIter>
    locale::id money_get<_CharT, _InIter>::id;
# 1618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT, typename _OutIter>
    class money_put : public locale::facet
    {
    public:


      typedef _CharT char_type;
      typedef _OutIter iter_type;
      typedef basic_string<_CharT> string_type;



      static locale::id id;
# 1639 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      money_put(size_t __refs = 0) : facet(__refs) { }
# 1659 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, long double __units) const
      { return this->do_put(__s, __intl, __io, __fill, __units); }
# 1682 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      iter_type
      put(iter_type __s, bool __intl, ios_base& __io,
   char_type __fill, const string_type& __digits) const
      { return this->do_put(__s, __intl, __io, __fill, __digits); }

    protected:

      virtual
      ~money_put() { }
# 1717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      long double __units) const;
# 1741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual iter_type
      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
      const string_type& __digits) const;
# 1753 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      template<bool _Intl>
        iter_type
        _M_insert(iter_type __s, ios_base& __io, char_type __fill,
    const string_type& __digits) const;
    };

  template<typename _CharT, typename _OutIter>
    locale::id money_put<_CharT, _OutIter>::id;

}





  struct messages_base
  {
    typedef int catalog;
  };

namespace __cxx11 {
# 1796 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
  template<typename _CharT>
    class messages : public locale::facet, public messages_base
    {
    public:



      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;


    protected:


      __c_locale _M_c_locale_messages;
      const char* _M_name_messages;

    public:

      static locale::id id;
# 1824 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(size_t __refs = 0);
# 1838 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      explicit
      messages(__c_locale __cloc, const char* __s, size_t __refs = 0);
# 1851 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>& __s, const locale& __loc) const
      { return this->do_open(__s, __loc); }
# 1869 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      catalog
      open(const basic_string<char>&, const locale&, const char*) const;
# 1887 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      string_type
      get(catalog __c, int __set, int __msgid, const string_type& __s) const
      { return this->do_get(__c, __set, __msgid, __s); }
# 1898 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      void
      close(catalog __c) const
      { return this->do_close(__c); }

    protected:

      virtual
      ~messages();
# 1918 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual catalog
      do_open(const basic_string<char>&, const locale&) const;
# 1937 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 3
      virtual string_type
      do_get(catalog, int, int, const string_type& __dfault) const;






      virtual void
      do_close(catalog) const;


      char*
      _M_convert_to_char(const string_type& __msg) const
      {

 return reinterpret_cast<char*>(const_cast<_CharT*>(__msg.c_str()));
      }


      string_type
      _M_convert_from_char(char*) const
      {

 return string_type();
      }
     };

  template<typename _CharT>
    locale::id messages<_CharT>::id;


  template<>
    string
    messages<char>::do_get(catalog, int, int, const string&) const;


  template<>
    wstring
    messages<wchar_t>::do_get(catalog, int, int, const wstring&) const;



   template<typename _CharT>
    class messages_byname : public messages<_CharT>
    {
    public:
      typedef _CharT char_type;
      typedef basic_string<_CharT> string_type;

      explicit
      messages_byname(const char* __s, size_t __refs = 0);


      explicit
      messages_byname(const string& __s, size_t __refs = 0)
      : messages_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~messages_byname()
      { }
    };

}


}


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/messages_members.h" 1 3
# 36 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/x86_64-w64-mingw32/bits/messages_members.h" 3
namespace std
{



  template<typename _CharT>
     messages<_CharT>::messages(size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
     messages<_CharT>::messages(__c_locale, const char*, size_t __refs)
     : facet(__refs)
     { _M_c_locale_messages = _S_get_c_locale(); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::open(const basic_string<char>& __s, const locale& __loc,
      const char*) const
    { return this->do_open(__s, __loc); }


  template<typename _CharT>
    messages<_CharT>::~messages()
    { _S_destroy_c_locale(_M_c_locale_messages); }

  template<typename _CharT>
    typename messages<_CharT>::catalog
    messages<_CharT>::do_open(const basic_string<char>&, const locale&) const
    { return 0; }

  template<typename _CharT>
    typename messages<_CharT>::string_type
    messages<_CharT>::do_get(catalog, int, int,
        const string_type& __dfault) const
    { return __dfault; }

  template<typename _CharT>
    void
    messages<_CharT>::do_close(catalog) const
    { }


   template<typename _CharT>
     messages_byname<_CharT>::messages_byname(const char* __s, size_t __refs)
     : messages<_CharT>(__refs)
     {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_messages);
     this->_S_create_c_locale(this->_M_c_locale_messages, __s);
   }
     }


}
# 2009 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3


# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3

namespace std
{



  class codecvt_base
  {
  public:
    enum result
    {
      ok,
      partial,
      error,
      noconv
    };
  };
# 67 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
  template<typename _InternT, typename _ExternT, typename _StateT>
    class __codecvt_abstract_base
    : public locale::facet, public codecvt_base
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;
# 115 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      out(state_type& __state, const intern_type* __from,
   const intern_type* __from_end, const intern_type*& __from_next,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const
      {
 return this->do_out(__state, __from, __from_end, __from_next,
       __to, __to_end, __to_next);
      }
# 154 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      unshift(state_type& __state, extern_type* __to, extern_type* __to_end,
       extern_type*& __to_next) const
      { return this->do_unshift(__state, __to,__to_end,__to_next); }
# 195 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      result
      in(state_type& __state, const extern_type* __from,
  const extern_type* __from_end, const extern_type*& __from_next,
  intern_type* __to, intern_type* __to_end,
  intern_type*& __to_next) const
      {
 return this->do_in(__state, __from, __from_end, __from_next,
      __to, __to_end, __to_next);
      }

      int
      encoding() const throw()
      { return this->do_encoding(); }

      bool
      always_noconv() const throw()
      { return this->do_always_noconv(); }

      int
      length(state_type& __state, const extern_type* __from,
      const extern_type* __end, size_t __max) const
      { return this->do_length(__state, __from, __end, __max); }

      int
      max_length() const throw()
      { return this->do_max_length(); }

    protected:
      explicit
      __codecvt_abstract_base(size_t __refs = 0) : locale::facet(__refs) { }

      virtual
      ~__codecvt_abstract_base() { }
# 236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const = 0;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const = 0;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const = 0;

      virtual int
      do_encoding() const throw() = 0;

      virtual bool
      do_always_noconv() const throw() = 0;

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const = 0;

      virtual int
      do_max_length() const throw() = 0;
    };
# 273 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
   template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt
    : public __codecvt_abstract_base<_InternT, _ExternT, _StateT>
    {
    public:

      typedef codecvt_base::result result;
      typedef _InternT intern_type;
      typedef _ExternT extern_type;
      typedef _StateT state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<_InternT, _ExternT, _StateT> (__refs),
 _M_c_locale_codecvt(0)
      { }

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt() { }

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };

  template<typename _InternT, typename _ExternT, typename _StateT>
    locale::id codecvt<_InternT, _ExternT, _StateT>::id;


  template<>
    class codecvt<char, char, mbstate_t>
    : public __codecvt_abstract_base<char, char, mbstate_t>
    {
      friend class messages<char>;

    public:

      typedef char intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state, extern_type* __to,
   extern_type* __to_end, extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state, const extern_type* __from,
     const extern_type* __from_end, const extern_type*& __from_next,
     intern_type* __to, intern_type* __to_end,
     intern_type*& __to_next) const;

      virtual int
      do_encoding() const throw();

      virtual bool
      do_always_noconv() const throw();

      virtual int
      do_length(state_type&, const extern_type* __from,
  const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
  };






  template<>
    class codecvt<wchar_t, char, mbstate_t>
    : public __codecvt_abstract_base<wchar_t, char, mbstate_t>
    {
      friend class messages<wchar_t>;

    public:

      typedef wchar_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    protected:
      __c_locale _M_c_locale_codecvt;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0);

      explicit
      codecvt(__c_locale __cloc, size_t __refs = 0);

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };
# 467 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 3
  template<>
    class codecvt<char16_t, char, mbstate_t>
    : public __codecvt_abstract_base<char16_t, char, mbstate_t>
    {
    public:

      typedef char16_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char16_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<>
    class codecvt<char32_t, char, mbstate_t>
    : public __codecvt_abstract_base<char32_t, char, mbstate_t>
    {
    public:

      typedef char32_t intern_type;
      typedef char extern_type;
      typedef mbstate_t state_type;

    public:
      static locale::id id;

      explicit
      codecvt(size_t __refs = 0)
      : __codecvt_abstract_base<char32_t, char, mbstate_t>(__refs) { }

    protected:
      virtual
      ~codecvt();

      virtual result
      do_out(state_type& __state, const intern_type* __from,
      const intern_type* __from_end, const intern_type*& __from_next,
      extern_type* __to, extern_type* __to_end,
      extern_type*& __to_next) const;

      virtual result
      do_unshift(state_type& __state,
   extern_type* __to, extern_type* __to_end,
   extern_type*& __to_next) const;

      virtual result
      do_in(state_type& __state,
      const extern_type* __from, const extern_type* __from_end,
      const extern_type*& __from_next,
      intern_type* __to, intern_type* __to_end,
      intern_type*& __to_next) const;

      virtual
      int do_encoding() const throw();

      virtual
      bool do_always_noconv() const throw();

      virtual
      int do_length(state_type&, const extern_type* __from,
      const extern_type* __end, size_t __max) const;

      virtual int
      do_max_length() const throw();
    };





  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname : public codecvt<_InternT, _ExternT, _StateT>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<_InternT, _ExternT, _StateT>(__refs)
      {
 if (__builtin_strcmp(__s, "C") != 0
     && __builtin_strcmp(__s, "POSIX") != 0)
   {
     this->_S_destroy_c_locale(this->_M_c_locale_codecvt);
     this->_S_create_c_locale(this->_M_c_locale_codecvt, __s);
   }
      }


      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }


    protected:
      virtual
      ~codecvt_byname() { }
    };


  template<>
    class codecvt_byname<char16_t, char, mbstate_t>
    : public codecvt<char16_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char16_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };

  template<>
    class codecvt_byname<char32_t, char, mbstate_t>
    : public codecvt<char32_t, char, mbstate_t>
    {
    public:
      explicit
      codecvt_byname(const char* __s, size_t __refs = 0)
      : codecvt<char32_t, char, mbstate_t>(__refs) { }

      explicit
      codecvt_byname(const string& __s, size_t __refs = 0)
      : codecvt_byname(__s.c_str(), __refs) { }

    protected:
      virtual
      ~codecvt_byname() { }
    };





  extern template class codecvt_byname<char, char, mbstate_t>;

  extern template
    const codecvt<char, char, mbstate_t>&
    use_facet<codecvt<char, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<char, char, mbstate_t> >(const locale&);


  extern template class codecvt_byname<wchar_t, char, mbstate_t>;

  extern template
    const codecvt<wchar_t, char, mbstate_t>&
    use_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);

  extern template
    bool
    has_facet<codecvt<wchar_t, char, mbstate_t> >(const locale&);



  extern template class codecvt_byname<char16_t, char, mbstate_t>;
  extern template class codecvt_byname<char32_t, char, mbstate_t>;





}
# 2012 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3

namespace std
{


  template<typename _CharT, bool _Intl>
    struct __use_cache<__moneypunct_cache<_CharT, _Intl> >
    {
      const __moneypunct_cache<_CharT, _Intl>*
      operator() (const locale& __loc) const
      {
 const size_t __i = moneypunct<_CharT, _Intl>::id._M_id();
 const locale::facet** __caches = __loc._M_impl->_M_caches;
 if (!__caches[__i])
   {
     __moneypunct_cache<_CharT, _Intl>* __tmp = 0;
     try
       {
  __tmp = new __moneypunct_cache<_CharT, _Intl>;
  __tmp->_M_cache(__loc);
       }
     catch(...)
       {
  delete __tmp;
  throw;
       }
     __loc._M_impl->_M_install_cache(__tmp, __i);
   }
 return static_cast<
   const __moneypunct_cache<_CharT, _Intl>*>(__caches[__i]);
      }
    };

  template<typename _CharT, bool _Intl>
    void
    __moneypunct_cache<_CharT, _Intl>::_M_cache(const locale& __loc)
    {
      const moneypunct<_CharT, _Intl>& __mp =
 use_facet<moneypunct<_CharT, _Intl> >(__loc);

      _M_decimal_point = __mp.decimal_point();
      _M_thousands_sep = __mp.thousands_sep();
      _M_frac_digits = __mp.frac_digits();

      char* __grouping = 0;
      _CharT* __curr_symbol = 0;
      _CharT* __positive_sign = 0;
      _CharT* __negative_sign = 0;
      try
 {
   const string& __g = __mp.grouping();
   _M_grouping_size = __g.size();
   __grouping = new char[_M_grouping_size];
   __g.copy(__grouping, _M_grouping_size);
   _M_use_grouping = (_M_grouping_size
        && static_cast<signed char>(__grouping[0]) > 0
        && (__grouping[0]
     != __gnu_cxx::__numeric_traits<char>::__max));

   const basic_string<_CharT>& __cs = __mp.curr_symbol();
   _M_curr_symbol_size = __cs.size();
   __curr_symbol = new _CharT[_M_curr_symbol_size];
   __cs.copy(__curr_symbol, _M_curr_symbol_size);

   const basic_string<_CharT>& __ps = __mp.positive_sign();
   _M_positive_sign_size = __ps.size();
   __positive_sign = new _CharT[_M_positive_sign_size];
   __ps.copy(__positive_sign, _M_positive_sign_size);

   const basic_string<_CharT>& __ns = __mp.negative_sign();
   _M_negative_sign_size = __ns.size();
   __negative_sign = new _CharT[_M_negative_sign_size];
   __ns.copy(__negative_sign, _M_negative_sign_size);

   _M_pos_format = __mp.pos_format();
   _M_neg_format = __mp.neg_format();

   const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc);
   __ct.widen(money_base::_S_atoms,
       money_base::_S_atoms + money_base::_S_end, _M_atoms);

   _M_grouping = __grouping;
   _M_curr_symbol = __curr_symbol;
   _M_positive_sign = __positive_sign;
   _M_negative_sign = __negative_sign;
   _M_allocated = true;
 }
      catch(...)
 {
   delete [] __grouping;
   delete [] __curr_symbol;
   delete [] __positive_sign;
   delete [] __negative_sign;
   throw;
 }
    }

namespace __cxx11 {

  template<typename _CharT, typename _InIter>
    template<bool _Intl>
      _InIter
      money_get<_CharT, _InIter>::
      _M_extract(iter_type __beg, iter_type __end, ios_base& __io,
   ios_base::iostate& __err, string& __units) const
      {
 typedef char_traits<_CharT> __traits_type;
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;


 bool __negative = false;

 size_type __sign_size = 0;

 const bool __mandatory_sign = (__lc->_M_positive_sign_size
           && __lc->_M_negative_sign_size);

 string __grouping_tmp;
 if (__lc->_M_use_grouping)
   __grouping_tmp.reserve(32);

 int __last_pos = 0;

 int __n = 0;

 bool __testvalid = true;

 bool __testdecfound = false;


 string __res;
 __res.reserve(32);

 const char_type* __lit_zero = __lit + money_base::_S_zero;
 const money_base::pattern __p = __lc->_M_neg_format;
 for (int __i = 0; __i < 4 && __testvalid; ++__i)
   {
     const part __which = static_cast<part>(__p.field[__i]);
     switch (__which)
       {
       case money_base::symbol:




  if (__io.flags() & ios_base::showbase || __sign_size > 1
      || __i == 0
      || (__i == 1 && (__mandatory_sign
         || (static_cast<part>(__p.field[0])
      == money_base::sign)
         || (static_cast<part>(__p.field[2])
      == money_base::space)))
      || (__i == 2 && ((static_cast<part>(__p.field[3])
          == money_base::value)
         || (__mandatory_sign
      && (static_cast<part>(__p.field[3])
          == money_base::sign)))))
    {
      const size_type __len = __lc->_M_curr_symbol_size;
      size_type __j = 0;
      for (; __beg != __end && __j < __len
      && *__beg == __lc->_M_curr_symbol[__j];
    ++__beg, (void)++__j);
      if (__j != __len
   && (__j || __io.flags() & ios_base::showbase))
        __testvalid = false;
    }
  break;
       case money_base::sign:

  if (__lc->_M_positive_sign_size && __beg != __end
      && *__beg == __lc->_M_positive_sign[0])
    {
      __sign_size = __lc->_M_positive_sign_size;
      ++__beg;
    }
  else if (__lc->_M_negative_sign_size && __beg != __end
    && *__beg == __lc->_M_negative_sign[0])
    {
      __negative = true;
      __sign_size = __lc->_M_negative_sign_size;
      ++__beg;
    }
  else if (__lc->_M_positive_sign_size
    && !__lc->_M_negative_sign_size)


    __negative = true;
  else if (__mandatory_sign)
    __testvalid = false;
  break;
       case money_base::value:


  for (; __beg != __end; ++__beg)
    {
      const char_type __c = *__beg;
      const char_type* __q = __traits_type::find(__lit_zero,
              10, __c);
      if (__q != 0)
        {
   __res += money_base::_S_atoms[__q - __lit];
   ++__n;
        }
      else if (__c == __lc->_M_decimal_point
        && !__testdecfound)
        {
   if (__lc->_M_frac_digits <= 0)
     break;

   __last_pos = __n;
   __n = 0;
   __testdecfound = true;
        }
      else if (__lc->_M_use_grouping
        && __c == __lc->_M_thousands_sep
        && !__testdecfound)
        {
   if (__n)
     {

       __grouping_tmp += static_cast<char>(__n);
       __n = 0;
     }
   else
     {
       __testvalid = false;
       break;
     }
        }
      else
        break;
    }
  if (__res.empty())
    __testvalid = false;
  break;
       case money_base::space:

  if (__beg != __end && __ctype.is(ctype_base::space, *__beg))
    ++__beg;
  else
    __testvalid = false;
       case money_base::none:

  if (__i != 3)
    for (; __beg != __end
    && __ctype.is(ctype_base::space, *__beg); ++__beg);
  break;
       }
   }


 if (__sign_size > 1 && __testvalid)
   {
     const char_type* __sign = __negative ? __lc->_M_negative_sign
                                          : __lc->_M_positive_sign;
     size_type __i = 1;
     for (; __beg != __end && __i < __sign_size
     && *__beg == __sign[__i]; ++__beg, (void)++__i);

     if (__i != __sign_size)
       __testvalid = false;
   }

 if (__testvalid)
   {

     if (__res.size() > 1)
       {
  const size_type __first = __res.find_first_not_of('0');
  const bool __only_zeros = __first == string::npos;
  if (__first)
    __res.erase(0, __only_zeros ? __res.size() - 1 : __first);
       }


     if (__negative && __res[0] != '0')
       __res.insert(__res.begin(), '-');


     if (__grouping_tmp.size())
       {

  __grouping_tmp += static_cast<char>(__testdecfound ? __last_pos
                         : __n);
  if (!std::__verify_grouping(__lc->_M_grouping,
         __lc->_M_grouping_size,
         __grouping_tmp))
    __err |= ios_base::failbit;
       }


     if (__testdecfound && __n != __lc->_M_frac_digits)
       __testvalid = false;
   }


 if (!__testvalid)
   __err |= ios_base::failbit;
 else
   __units.swap(__res);


 if (__beg == __end)
   __err |= ios_base::eofbit;
 return __beg;
      }
# 367 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, long double& __units) const
    {
      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      std::__convert_to_v(__str.c_str(), __units, __err, _S_get_c_locale());
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    money_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, bool __intl, ios_base& __io,
    ios_base::iostate& __err, string_type& __digits) const
    {
      typedef typename string::size_type size_type;

      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      string __str;
      __beg = __intl ? _M_extract<true>(__beg, __end, __io, __err, __str)
              : _M_extract<false>(__beg, __end, __io, __err, __str);
      const size_type __len = __str.size();
      if (__len)
 {
   __digits.resize(__len);
   __ctype.widen(__str.data(), __str.data() + __len, &__digits[0]);
 }
      return __beg;
    }

  template<typename _CharT, typename _OutIter>
    template<bool _Intl>
      _OutIter
      money_put<_CharT, _OutIter>::
      _M_insert(iter_type __s, ios_base& __io, char_type __fill,
  const string_type& __digits) const
      {
 typedef typename string_type::size_type size_type;
 typedef money_base::part part;
 typedef __moneypunct_cache<_CharT, _Intl> __cache_type;

 const locale& __loc = __io._M_getloc();
 const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

 __use_cache<__cache_type> __uc;
 const __cache_type* __lc = __uc(__loc);
 const char_type* __lit = __lc->_M_atoms;



 const char_type* __beg = __digits.data();

 money_base::pattern __p;
 const char_type* __sign;
 size_type __sign_size;
 if (!(*__beg == __lit[money_base::_S_minus]))
   {
     __p = __lc->_M_pos_format;
     __sign = __lc->_M_positive_sign;
     __sign_size = __lc->_M_positive_sign_size;
   }
 else
   {
     __p = __lc->_M_neg_format;
     __sign = __lc->_M_negative_sign;
     __sign_size = __lc->_M_negative_sign_size;
     if (__digits.size())
       ++__beg;
   }


 size_type __len = __ctype.scan_not(ctype_base::digit, __beg,
        __beg + __digits.size()) - __beg;
 if (__len)
   {



     string_type __value;
     __value.reserve(2 * __len);



     long __paddec = __len - __lc->_M_frac_digits;
     if (__paddec > 0)
         {
  if (__lc->_M_frac_digits < 0)
    __paddec = __len;
    if (__lc->_M_grouping_size)
      {
      __value.assign(2 * __paddec, char_type());
       _CharT* __vend =
        std::__add_grouping(&__value[0], __lc->_M_thousands_sep,
       __lc->_M_grouping,
       __lc->_M_grouping_size,
       __beg, __beg + __paddec);
      __value.erase(__vend - &__value[0]);
      }
    else
    __value.assign(__beg, __paddec);
       }


     if (__lc->_M_frac_digits > 0)
       {
  __value += __lc->_M_decimal_point;
  if (__paddec >= 0)
    __value.append(__beg + __paddec, __lc->_M_frac_digits);
  else
    {

      __value.append(-__paddec, __lit[money_base::_S_zero]);
      __value.append(__beg, __len);
    }
         }


     const ios_base::fmtflags __f = __io.flags()
                                    & ios_base::adjustfield;
     __len = __value.size() + __sign_size;
     __len += ((__io.flags() & ios_base::showbase)
        ? __lc->_M_curr_symbol_size : 0);

     string_type __res;
     __res.reserve(2 * __len);

     const size_type __width = static_cast<size_type>(__io.width());
     const bool __testipad = (__f == ios_base::internal
         && __len < __width);

     for (int __i = 0; __i < 4; ++__i)
       {
  const part __which = static_cast<part>(__p.field[__i]);
  switch (__which)
    {
    case money_base::symbol:
      if (__io.flags() & ios_base::showbase)
        __res.append(__lc->_M_curr_symbol,
       __lc->_M_curr_symbol_size);
      break;
    case money_base::sign:



      if (__sign_size)
        __res += __sign[0];
      break;
    case money_base::value:
      __res += __value;
      break;
    case money_base::space:



      if (__testipad)
        __res.append(__width - __len, __fill);
      else
        __res += __fill;
      break;
    case money_base::none:
      if (__testipad)
        __res.append(__width - __len, __fill);
      break;
    }
       }


     if (__sign_size > 1)
       __res.append(__sign + 1, __sign_size - 1);


     __len = __res.size();
     if (__width > __len)
       {
  if (__f == ios_base::left)

    __res.append(__width - __len, __fill);
  else

    __res.insert(0, __width - __len, __fill);
  __len = __width;
       }


     __s = std::__write(__s, __res.data(), __len);
   }
 __io.width(0);
 return __s;
      }
# 573 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    long double __units) const
    {
      const locale __loc = __io.getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __cs_size = 64;
      char* __cs = static_cast<char*>(__builtin_alloca(__cs_size));


      int __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);

      if (__len >= __cs_size)
 {
   __cs_size = __len + 1;
   __cs = static_cast<char*>(__builtin_alloca(__cs_size));
   __len = std::__convert_from_v(_S_get_c_locale(), __cs, __cs_size,
     "%.*Lf", 0, __units);
 }
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.tcc" 3
      string_type __digits(__len, char_type());
      __ctype.widen(__cs, __cs + __len, &__digits[0]);
      return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits);
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    money_put<_CharT, _OutIter>::
    do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,
    const string_type& __digits) const
    { return __intl ? _M_insert<true>(__s, __io, __fill, __digits)
             : _M_insert<false>(__s, __io, __fill, __digits); }

}




  template<typename _CharT, typename _InIter>
    time_base::dateorder
    time_get<_CharT, _InIter>::do_date_order() const
    { return time_base::no_order; }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_via_format(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm,
     const _CharT* __format) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const size_t __len = char_traits<_CharT>::length(__format);

      ios_base::iostate __tmperr = ios_base::goodbit;
      size_t __i = 0;
      for (; __beg != __end && __i < __len && !__tmperr; ++__i)
 {
   if (__ctype.narrow(__format[__i], 0) == '%')
     {

       char __c = __ctype.narrow(__format[++__i], 0);
       int __mem = 0;
       if (__c == 'E' || __c == 'O')
  __c = __ctype.narrow(__format[++__i], 0);
       switch (__c)
  {
    const char* __cs;
    _CharT __wcs[10];
  case 'a':

    const char_type* __days1[7];
    __tp._M_days_abbreviated(__days1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days1,
       7, __io, __tmperr);
    break;
  case 'A':

    const char_type* __days2[7];
    __tp._M_days(__days2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_wday, __days2,
       7, __io, __tmperr);
    break;
  case 'h':
  case 'b':

    const char_type* __months1[12];
    __tp._M_months_abbreviated(__months1);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months1, 12, __io, __tmperr);
    break;
  case 'B':

    const char_type* __months2[12];
    __tp._M_months(__months2);
    __beg = _M_extract_name(__beg, __end, __tm->tm_mon,
       __months2, 12, __io, __tmperr);
    break;
  case 'c':

    const char_type* __dt[2];
    __tp._M_date_time_formats(__dt);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dt[0]);
    break;
  case 'd':

    __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 1, 31, 2,
      __io, __tmperr);
    break;
  case 'e':


    if (__ctype.is(ctype_base::space, *__beg))
      __beg = _M_extract_num(++__beg, __end, __tm->tm_mday, 1, 9,
        1, __io, __tmperr);
    else
      __beg = _M_extract_num(__beg, __end, __tm->tm_mday, 10, 31,
        2, __io, __tmperr);
    break;
  case 'D':

    __cs = "%m/%d/%y";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'H':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 0, 23, 2,
      __io, __tmperr);
    break;
  case 'I':

    __beg = _M_extract_num(__beg, __end, __tm->tm_hour, 1, 12, 2,
      __io, __tmperr);
    break;
  case 'm':

    __beg = _M_extract_num(__beg, __end, __mem, 1, 12, 2,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_mon = __mem - 1;
    break;
  case 'M':

    __beg = _M_extract_num(__beg, __end, __tm->tm_min, 0, 59, 2,
      __io, __tmperr);
    break;
  case 'n':
    if (__ctype.narrow(*__beg, 0) == '\n')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'R':

    __cs = "%H:%M";
    __ctype.widen(__cs, __cs + 6, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'S':



    __beg = _M_extract_num(__beg, __end, __tm->tm_sec, 0, 60, 2,



      __io, __tmperr);
    break;
  case 't':
    if (__ctype.narrow(*__beg, 0) == '\t')
      ++__beg;
    else
      __tmperr |= ios_base::failbit;
    break;
  case 'T':

    __cs = "%H:%M:%S";
    __ctype.widen(__cs, __cs + 9, __wcs);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __wcs);
    break;
  case 'x':

    const char_type* __dates[2];
    __tp._M_date_formats(__dates);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __dates[0]);
    break;
  case 'X':

    const char_type* __times[2];
    __tp._M_time_formats(__times);
    __beg = _M_extract_via_format(__beg, __end, __io, __tmperr,
      __tm, __times[0]);
    break;
  case 'y':
  case 'C':

  case 'Y':




    __beg = _M_extract_num(__beg, __end, __mem, 0, 9999, 4,
      __io, __tmperr);
    if (!__tmperr)
      __tm->tm_year = __mem < 0 ? __mem + 100 : __mem - 1900;
    break;
  case 'Z':

    if (__ctype.is(ctype_base::upper, *__beg))
      {
        int __tmp;
        __beg = _M_extract_name(__beg, __end, __tmp,
           __timepunct_cache<_CharT>::_S_timezones,
           14, __io, __tmperr);


        if (__beg != __end && !__tmperr && __tmp == 0
     && (*__beg == __ctype.widen('-')
         || *__beg == __ctype.widen('+')))
   {
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 23, 2,
       __io, __tmperr);
     __beg = _M_extract_num(__beg, __end, __tmp, 0, 59, 2,
       __io, __tmperr);
   }
      }
    else
      __tmperr |= ios_base::failbit;
    break;
  default:

    __tmperr |= ios_base::failbit;
  }
     }
   else
     {

       if (__format[__i] == *__beg)
  ++__beg;
       else
  __tmperr |= ios_base::failbit;
     }
 }

      if (__tmperr || __i != __len)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_num(iter_type __beg, iter_type __end, int& __member,
     int __min, int __max, size_t __len,
     ios_base& __io, ios_base::iostate& __err) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);


      int __mult = __len == 2 ? 10 : (__len == 4 ? 1000 : 1);

      ++__min;
      size_t __i = 0;
      int __value = 0;
      for (; __beg != __end && __i < __len; ++__beg, (void)++__i)
 {
   const char __c = __ctype.narrow(*__beg, '*');
   if (__c >= '0' && __c <= '9')
     {
       __value = __value * 10 + (__c - '0');
       const int __valuec = __value * __mult;
       if (__valuec > __max || __valuec + __mult < __min)
  break;
       __mult /= 10;
     }
   else
     break;
 }
      if (__i == __len)
 __member = __value;

      else if (__len == 4 && __i == 2)
 __member = __value - 100;
      else
 __err |= ios_base::failbit;

      return __beg;
    }



  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_name(iter_type __beg, iter_type __end, int& __member,
      const _CharT** __names, size_t __indexlen,
      ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t __pos = 0;
      bool __testvalid = true;
      const char_type* __name;





      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i1 = 0; __i1 < __indexlen; ++__i1)
     if (__c == __names[__i1][0]
  || __c == __ctype.toupper(__names[__i1][0]))
       __matches[__nmatches++] = __i1;
 }

      while (__nmatches > 1)
 {

   size_t __minlen = __traits_type::length(__names[__matches[0]]);
   for (size_t __i2 = 1; __i2 < __nmatches; ++__i2)
     __minlen = std::min(__minlen,
         __traits_type::length(__names[__matches[__i2]]));
   ++__beg;
   ++__pos;
   if (__pos < __minlen && __beg != __end)
     for (size_t __i3 = 0; __i3 < __nmatches;)
       {
  __name = __names[__matches[__i3]];
  if (!(__name[__pos] == *__beg))
    __matches[__i3] = __matches[--__nmatches];
  else
    ++__i3;
       }
   else
     break;
 }

      if (__nmatches == 1)
 {

   ++__beg;
   ++__pos;
   __name = __names[__matches[0]];
   const size_t __len = __traits_type::length(__name);
   while (__pos < __len && __beg != __end && __name[__pos] == *__beg)
     ++__beg, (void)++__pos;

   if (__len == __pos)
     __member = __matches[0];
   else
     __testvalid = false;
 }
      else
 __testvalid = false;
      if (!__testvalid)
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    _M_extract_wday_or_month(iter_type __beg, iter_type __end, int& __member,
        const _CharT** __names, size_t __indexlen,
        ios_base& __io, ios_base::iostate& __err) const
    {
      typedef char_traits<_CharT> __traits_type;
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);

      int* __matches = static_cast<int*>(__builtin_alloca(2 * sizeof(int)
         * __indexlen));
      size_t __nmatches = 0;
      size_t* __matches_lengths = 0;
      size_t __pos = 0;

      if (__beg != __end)
 {
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < 2 * __indexlen; ++__i)
     if (__c == __names[__i][0]
  || __c == __ctype.toupper(__names[__i][0]))
       __matches[__nmatches++] = __i;
 }

      if (__nmatches)
 {
   ++__beg;
   ++__pos;

   __matches_lengths
     = static_cast<size_t*>(__builtin_alloca(sizeof(size_t)
          * __nmatches));
   for (size_t __i = 0; __i < __nmatches; ++__i)
     __matches_lengths[__i]
       = __traits_type::length(__names[__matches[__i]]);
 }

      for (; __beg != __end; ++__beg, (void)++__pos)
 {
   size_t __nskipped = 0;
   const char_type __c = *__beg;
   for (size_t __i = 0; __i < __nmatches;)
     {
       const char_type* __name = __names[__matches[__i]];
       if (__pos >= __matches_lengths[__i])
  ++__nskipped, ++__i;
       else if (!(__name[__pos] == __c))
  {
    --__nmatches;
    __matches[__i] = __matches[__nmatches];
    __matches_lengths[__i] = __matches_lengths[__nmatches];
  }
       else
  ++__i;
     }
   if (__nskipped == __nmatches)
     break;
 }

      if ((__nmatches == 1 && __matches_lengths[0] == __pos)
   || (__nmatches == 2 && (__matches_lengths[0] == __pos
      || __matches_lengths[1] == __pos)))
 __member = (__matches[0] >= __indexlen
      ? __matches[0] - __indexlen : __matches[0]);
      else
 __err |= ios_base::failbit;

      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_time(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __times[2];
      __tp._M_time_formats(__times);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __times[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_date(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const char_type* __dates[2];
      __tp._M_date_formats(__dates);
      __beg = _M_extract_via_format(__beg, __end, __io, __err,
        __tm, __dates[0]);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_weekday(iter_type __beg, iter_type __end, ios_base& __io,
     ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __days[14];
      __tp._M_days_abbreviated(__days);
      __tp._M_days(__days + 7);
      int __tmpwday;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpwday, __days, 7,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_wday = __tmpwday;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
     }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_monthname(iter_type __beg, iter_type __end,
                     ios_base& __io, ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const __timepunct<_CharT>& __tp = use_facet<__timepunct<_CharT> >(__loc);
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      const char_type* __months[24];
      __tp._M_months_abbreviated(__months);
      __tp._M_months(__months + 12);
      int __tmpmon;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_wday_or_month(__beg, __end, __tmpmon, __months, 12,
           __io, __tmperr);
      if (!__tmperr)
 __tm->tm_mon = __tmpmon;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }

  template<typename _CharT, typename _InIter>
    _InIter
    time_get<_CharT, _InIter>::
    do_get_year(iter_type __beg, iter_type __end, ios_base& __io,
  ios_base::iostate& __err, tm* __tm) const
    {
      const locale& __loc = __io._M_getloc();
      const ctype<_CharT>& __ctype = use_facet<ctype<_CharT> >(__loc);
      int __tmpyear;
      ios_base::iostate __tmperr = ios_base::goodbit;

      __beg = _M_extract_num(__beg, __end, __tmpyear, 0, 9999, 4,
        __io, __tmperr);
      if (!__tmperr)
 __tm->tm_year = __tmpyear < 0 ? __tmpyear + 100 : __tmpyear - 1900;
      else
 __err |= ios_base::failbit;

      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }


  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    get(iter_type __s, iter_type __end, ios_base& __io,
        ios_base::iostate& __err, tm* __tm, const char_type* __fmt,
        const char_type* __fmtend) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;
      while (__fmt != __fmtend &&
             __err == ios_base::goodbit)
        {
          if (__s == __end)
            {
              __err = ios_base::eofbit | ios_base::failbit;
              break;
            }
          else if (__ctype.narrow(*__fmt, 0) == '%')
            {
              char __format;
              char __mod = 0;
              if (++__fmt == __fmtend)
                {
                  __err = ios_base::failbit;
                  break;
                }
              const char __c = __ctype.narrow(*__fmt, 0);
              if (__c != 'E' && __c != 'O')
                __format = __c;
              else if (++__fmt != __fmtend)
                {
                  __mod = __c;
                  __format = __ctype.narrow(*__fmt, 0);
                }
              else
                {
                  __err = ios_base::failbit;
                  break;
                }
              __s = this->do_get(__s, __end, __io, __err, __tm, __format,
     __mod);
              ++__fmt;
            }
          else if (__ctype.is(ctype_base::space, *__fmt))
            {
              ++__fmt;
              while (__fmt != __fmtend &&
                     __ctype.is(ctype_base::space, *__fmt))
                ++__fmt;

              while (__s != __end &&
                     __ctype.is(ctype_base::space, *__s))
                ++__s;
            }

          else if (__ctype.tolower(*__s) == __ctype.tolower(*__fmt) ||
                   __ctype.toupper(*__s) == __ctype.toupper(*__fmt))
            {
              ++__s;
              ++__fmt;
            }
          else
            {
              __err = ios_base::failbit;
              break;
            }
        }
      return __s;
    }

  template<typename _CharT, typename _InIter>
    inline
    _InIter
    time_get<_CharT, _InIter>::
    do_get(iter_type __beg, iter_type __end, ios_base& __io,
           ios_base::iostate& __err, tm* __tm,
           char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __err = ios_base::goodbit;

      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
        {
          __fmt[1] = __format;
          __fmt[2] = char_type();
        }
      else
        {
          __fmt[1] = __mod;
          __fmt[2] = __format;
          __fmt[3] = char_type();
        }

      __beg = _M_extract_via_format(__beg, __end, __io, __err, __tm, __fmt);
      if (__beg == __end)
 __err |= ios_base::eofbit;
      return __beg;
    }



  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    put(iter_type __s, ios_base& __io, char_type __fill, const tm* __tm,
 const _CharT* __beg, const _CharT* __end) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      for (; __beg != __end; ++__beg)
 if (__ctype.narrow(*__beg, 0) != '%')
   {
     *__s = *__beg;
     ++__s;
   }
 else if (++__beg != __end)
   {
     char __format;
     char __mod = 0;
     const char __c = __ctype.narrow(*__beg, 0);
     if (__c != 'E' && __c != 'O')
       __format = __c;
     else if (++__beg != __end)
       {
  __mod = __c;
  __format = __ctype.narrow(*__beg, 0);
       }
     else
       break;
     __s = this->do_put(__s, __io, __fill, __tm, __format, __mod);
   }
 else
   break;
      return __s;
    }

  template<typename _CharT, typename _OutIter>
    _OutIter
    time_put<_CharT, _OutIter>::
    do_put(iter_type __s, ios_base& __io, char_type, const tm* __tm,
    char __format, char __mod) const
    {
      const locale& __loc = __io._M_getloc();
      ctype<_CharT> const& __ctype = use_facet<ctype<_CharT> >(__loc);
      __timepunct<_CharT> const& __tp = use_facet<__timepunct<_CharT> >(__loc);



      const size_t __maxlen = 128;
      char_type __res[__maxlen];






      char_type __fmt[4];
      __fmt[0] = __ctype.widen('%');
      if (!__mod)
 {
   __fmt[1] = __format;
   __fmt[2] = char_type();
 }
      else
 {
   __fmt[1] = __mod;
   __fmt[2] = __format;
   __fmt[3] = char_type();
 }

      __tp._M_put(__res, __maxlen, __fmt, __tm);


      return std::__write(__s, __res, char_traits<char_type>::length(__res));
    }





  extern template class moneypunct<char, false>;
  extern template class moneypunct<char, true>;
  extern template class moneypunct_byname<char, false>;
  extern template class moneypunct_byname<char, true>;
  extern template class __cxx11:: money_get<char>;
  extern template class __cxx11:: money_put<char>;
  extern template class __timepunct<char>;
  extern template class time_put<char>;
  extern template class time_put_byname<char>;
  extern template class time_get<char>;
  extern template class time_get_byname<char>;
  extern template class messages<char>;
  extern template class messages_byname<char>;

  extern template
    const moneypunct<char, true>&
    use_facet<moneypunct<char, true> >(const locale&);

  extern template
    const moneypunct<char, false>&
    use_facet<moneypunct<char, false> >(const locale&);

  extern template
    const money_put<char>&
    use_facet<money_put<char> >(const locale&);

  extern template
    const money_get<char>&
    use_facet<money_get<char> >(const locale&);

  extern template
    const __timepunct<char>&
    use_facet<__timepunct<char> >(const locale&);

  extern template
    const time_put<char>&
    use_facet<time_put<char> >(const locale&);

  extern template
    const time_get<char>&
    use_facet<time_get<char> >(const locale&);

  extern template
    const messages<char>&
    use_facet<messages<char> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<char> >(const locale&);

  extern template
    bool
    has_facet<money_put<char> >(const locale&);

  extern template
    bool
    has_facet<money_get<char> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<char> >(const locale&);

  extern template
    bool
    has_facet<time_put<char> >(const locale&);

  extern template
    bool
    has_facet<time_get<char> >(const locale&);

  extern template
    bool
    has_facet<messages<char> >(const locale&);


  extern template class moneypunct<wchar_t, false>;
  extern template class moneypunct<wchar_t, true>;
  extern template class moneypunct_byname<wchar_t, false>;
  extern template class moneypunct_byname<wchar_t, true>;
  extern template class __cxx11:: money_get<wchar_t>;
  extern template class __cxx11:: money_put<wchar_t>;
  extern template class __timepunct<wchar_t>;
  extern template class time_put<wchar_t>;
  extern template class time_put_byname<wchar_t>;
  extern template class time_get<wchar_t>;
  extern template class time_get_byname<wchar_t>;
  extern template class messages<wchar_t>;
  extern template class messages_byname<wchar_t>;

  extern template
    const moneypunct<wchar_t, true>&
    use_facet<moneypunct<wchar_t, true> >(const locale&);

  extern template
    const moneypunct<wchar_t, false>&
    use_facet<moneypunct<wchar_t, false> >(const locale&);

  extern template
    const money_put<wchar_t>&
    use_facet<money_put<wchar_t> >(const locale&);

  extern template
    const money_get<wchar_t>&
    use_facet<money_get<wchar_t> >(const locale&);

  extern template
    const __timepunct<wchar_t>&
    use_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    const time_put<wchar_t>&
    use_facet<time_put<wchar_t> >(const locale&);

  extern template
    const time_get<wchar_t>&
    use_facet<time_get<wchar_t> >(const locale&);

  extern template
    const messages<wchar_t>&
    use_facet<messages<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<moneypunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<money_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<__timepunct<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_put<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<time_get<wchar_t> >(const locale&);

  extern template
    bool
    has_facet<messages<wchar_t> >(const locale&);




}
# 2014 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_facets_nonio.h" 2 3
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 1 3
# 38 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/stringfwd.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/allocator.h" 1 3
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/codecvt.h" 1 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
namespace std
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    public:

      constexpr default_delete() noexcept = default;
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      template<typename _Up>
      typename enable_if<is_convertible<_Up(*)[], _Tp(*)[]>::value>::type
 operator()(_Up* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      template<typename _Up, typename _Ep>
 using __safe_conversion_up = __and_<
         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
                __not_<is_array<_Up>>,
                __or_<__and_<is_reference<deleter_type>,
                             is_same<deleter_type, _Ep>>,
                      __and_<__not_<is_reference<deleter_type>>,
                             is_convertible<_Ep, deleter_type>>
                >
              >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
# 182 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
               __safe_conversion_up<_Up, _Ep>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 248 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 263 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
        typename enable_if< __and_<
          __safe_conversion_up<_Up, _Ep>,
          is_assignable<deleter_type&, _Ep&&>
          >::value,
          unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;


    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;



      template<typename _Up, typename _Ep,
               typename _Up_up = unique_ptr<_Up, _Ep>,
        typename _Up_element_type = typename _Up_up::element_type>
 using __safe_conversion_up = __and_<
          is_array<_Up>,
          is_same<pointer, element_type*>,
          is_same<typename _Up_up::pointer, _Up_element_type*>,
          is_convertible<_Up_element_type(*)[], element_type(*)[]>,
          __or_<__and_<is_reference<deleter_type>, is_same<deleter_type, _Ep>>,
                __and_<__not_<is_reference<deleter_type>>,
                       is_convertible<_Ep, deleter_type>>>
        >;


      template<typename _Up>
        using __safe_conversion_raw = __and_<
          __or_<__or_<is_same<_Up, pointer>,
                      is_same<_Up, nullptr_t>>,
                __and_<is_pointer<_Up>,
                       is_same<pointer, element_type*>,
                       is_convertible<
                         typename remove_pointer<_Up>::type(*)[],
                         element_type(*)[]>
                >
          >
        >;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
# 444 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      explicit
      unique_ptr(_Up __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }
# 461 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p,
                 typename conditional<is_reference<deleter_type>::value,
                 deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up,
               typename = typename enable_if<
                 __safe_conversion_raw<_Up>::value, bool>::type>
      unique_ptr(_Up __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion_up<_Up, _Ep>>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 516 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 531 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__and_<__safe_conversion_up<_Up, _Ep>,
                         is_assignable<deleter_type&, _Ep&&>
                  >::value,
                  unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      template <typename _Up,
                typename = _Require<
                  __or_<is_same<_Up, pointer>,
                        __and_<is_same<pointer, element_type*>,
                               is_pointer<_Up>,
                               is_convertible<
                                 typename remove_pointer<_Up>::type(*)[],
                                 element_type(*)[]
                               >
                        >
                  >
               >>
      void
      reset(_Up __p) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }

      void reset(nullptr_t = nullptr) noexcept
      {
        reset(pointer());
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };





  template<typename _Tp>
    struct _MakeUniq
    { typedef unique_ptr<_Tp> __single_object; };

  template<typename _Tp>
    struct _MakeUniq<_Tp[]>
    { typedef unique_ptr<_Tp[]> __array; };

  template<typename _Tp, size_t _Bound>
    struct _MakeUniq<_Tp[_Bound]>
    { struct __invalid_type { }; };


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__single_object
    make_unique(_Args&&... __args)
    { return unique_ptr<_Tp>(new _Tp(std::forward<_Args>(__args)...)); }


  template<typename _Tp>
    inline typename _MakeUniq<_Tp>::__array
    make_unique(size_t __num)
    { return unique_ptr<_Tp>(new remove_extent_t<_Tp>[__num]()); }


  template<typename _Tp, typename... _Args>
    inline typename _MakeUniq<_Tp>::__invalid_type
    make_unique(_Args&&...) = delete;





}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 2 3

namespace std
{







  template<typename _OutStr, typename _InChar, typename _Codecvt,
    typename _State, typename _Fn>
    bool
    __do_str_codecvt(const _InChar* __first, const _InChar* __last,
       _OutStr& __outstr, const _Codecvt& __cvt, _State& __state,
       size_t& __count, _Fn __fn)
    {
      if (__first == __last)
 {
   __outstr.clear();
   __count = 0;
   return true;
 }

      size_t __outchars = 0;
      auto __next = __first;
      const auto __maxlen = __cvt.max_length() + 1;

      codecvt_base::result __result;
      do
 {
   __outstr.resize(__outstr.size() + (__last - __next) * __maxlen);
   auto __outnext = &__outstr.front() + __outchars;
   auto const __outlast = &__outstr.back() + 1;
   __result = (__cvt.*__fn)(__state, __next, __last, __next,
     __outnext, __outlast, __outnext);
   __outchars = __outnext - &__outstr.front();
 }
      while (__result == codecvt_base::partial && __next != __last
      && (__outstr.size() - __outchars) < __maxlen);

      if (__result == codecvt_base::error)
 return false;

      if (__result == codecvt_base::noconv)
 {
   __outstr.assign(__first, __last);
   __count = __last - __first;
 }
      else
 {
   __outstr.resize(__outchars);
   __count = __next - __first;
 }

      return true;
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt,
       _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const char*, const char*, const char*&,
   _CharT*, _CharT*, _CharT*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::in;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_in(const char* __first, const char* __last,
       basic_string<_CharT, _Traits, _Alloc>& __outstr,
       const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_in(__first, __last, __outstr, __cvt, __state, __n);
    }


  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt,
        _State& __state, size_t& __count)
    {
      using _Codecvt = codecvt<_CharT, char, _State>;
      using _ConvFn
 = codecvt_base::result
   (_Codecvt::*)(_State&, const _CharT*, const _CharT*, const _CharT*&,
   char*, char*, char*&) const;
      _ConvFn __fn = &codecvt<_CharT, char, _State>::out;
      return __do_str_codecvt(__first, __last, __outstr, __cvt, __state,
         __count, __fn);
    }

  template<typename _CharT, typename _Traits, typename _Alloc, typename _State>
    inline bool
    __str_codecvt_out(const _CharT* __first, const _CharT* __last,
        basic_string<char, _Traits, _Alloc>& __outstr,
        const codecvt<_CharT, char, _State>& __cvt)
    {
      _State __state = {};
      size_t __n;
      return __str_codecvt_out(__first, __last, __outstr, __cvt, __state, __n);
    }



namespace __cxx11 {


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Wide_alloc = allocator<_Elem>,
    typename _Byte_alloc = allocator<char>>
    class wstring_convert
    {
    public:
      typedef basic_string<char, char_traits<char>, _Byte_alloc> byte_string;
      typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;
      typedef typename _Codecvt::state_type state_type;
      typedef typename wide_string::traits_type::int_type int_type;







      explicit
      wstring_convert(_Codecvt* __pcvt = new _Codecvt()) : _M_cvt(__pcvt)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }
# 195 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
      wstring_convert(_Codecvt* __pcvt, state_type __state)
      : _M_cvt(__pcvt), _M_state(__state), _M_with_cvtstate(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }






      explicit
      wstring_convert(const byte_string& __byte_err,
        const wide_string& __wide_err = wide_string())
      : _M_cvt(new _Codecvt),
 _M_byte_err_string(__byte_err), _M_wide_err_string(__wide_err),
 _M_with_strings(true)
      {
 if (!_M_cvt)
   __throw_logic_error("wstring_convert");
      }

      ~wstring_convert() = default;



      wstring_convert(const wstring_convert&) = delete;
      wstring_convert& operator=(const wstring_convert&) = delete;


      wide_string
      from_bytes(char __byte)
      {
 char __bytes[2] = { __byte };
 return from_bytes(__bytes, __bytes+1);
      }

      wide_string
      from_bytes(const char* __ptr)
      { return from_bytes(__ptr, __ptr+char_traits<char>::length(__ptr)); }

      wide_string
      from_bytes(const byte_string& __str)
      {
 auto __ptr = __str.data();
 return from_bytes(__ptr, __ptr + __str.size());
      }

      wide_string
      from_bytes(const char* __first, const char* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 wide_string __out{ _M_wide_err_string.get_allocator() };
 if (__str_codecvt_in(__first, __last, __out, *_M_cvt, _M_state,
        _M_count))
   return __out;
 if (_M_with_strings)
   return _M_wide_err_string;
 __throw_range_error("wstring_convert::from_bytes");
      }



      byte_string
      to_bytes(_Elem __wchar)
      {
 _Elem __wchars[2] = { __wchar };
 return to_bytes(__wchars, __wchars+1);
      }

      byte_string
      to_bytes(const _Elem* __ptr)
      {
 return to_bytes(__ptr, __ptr+wide_string::traits_type::length(__ptr));
      }

      byte_string
      to_bytes(const wide_string& __wstr)
      {
 auto __ptr = __wstr.data();
 return to_bytes(__ptr, __ptr + __wstr.size());
      }

      byte_string
      to_bytes(const _Elem* __first, const _Elem* __last)
      {
 if (!_M_with_cvtstate)
   _M_state = state_type();
 byte_string __out{ _M_byte_err_string.get_allocator() };
 if (__str_codecvt_out(__first, __last, __out, *_M_cvt, _M_state,
         _M_count))
   return __out;
 if (_M_with_strings)
   return _M_byte_err_string;
 __throw_range_error("wstring_convert::to_bytes");
      }





      size_t converted() const noexcept { return _M_count; }


      state_type state() const { return _M_state; }

    private:
      unique_ptr<_Codecvt> _M_cvt;
      byte_string _M_byte_err_string;
      wide_string _M_wide_err_string;
      state_type _M_state = state_type();
      size_t _M_count = 0;
      bool _M_with_cvtstate = false;
      bool _M_with_strings = false;
    };

}


  template<typename _Codecvt, typename _Elem = wchar_t,
    typename _Tr = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Tr>
    {
      typedef basic_streambuf<_Elem, _Tr> _Wide_streambuf;

    public:
      typedef typename _Codecvt::state_type state_type;
# 333 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/locale_conv.h" 3
      explicit
      wbuffer_convert(streambuf* __bytebuf = 0, _Codecvt* __pcvt = new _Codecvt,
        state_type __state = state_type())
      : _M_buf(__bytebuf), _M_cvt(__pcvt), _M_state(__state)
      {
 if (!_M_cvt)
   __throw_logic_error("wbuffer_convert");

 _M_always_noconv = _M_cvt->always_noconv();

 if (_M_buf)
   {
     this->setp(_M_put_area, _M_put_area + _S_buffer_length);
     this->setg(_M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length,
         _M_get_area + _S_putback_length);
   }
      }

      ~wbuffer_convert() = default;



      wbuffer_convert(const wbuffer_convert&) = delete;
      wbuffer_convert& operator=(const wbuffer_convert&) = delete;

      streambuf* rdbuf() const noexcept { return _M_buf; }

      streambuf*
      rdbuf(streambuf *__bytebuf) noexcept
      {
 auto __prev = _M_buf;
 _M_buf = __bytebuf;
 return __prev;
      }


      state_type state() const noexcept { return _M_state; }

    protected:
      int
      sync()
      { return _M_buf && _M_conv_put() && _M_buf->pubsync() ? 0 : -1; }

      typename _Wide_streambuf::int_type
      overflow(typename _Wide_streambuf::int_type __out)
      {
 if (!_M_buf || !_M_conv_put())
   return _Tr::eof();
 else if (!_Tr::eq_int_type(__out, _Tr::eof()))
   return this->sputc(__out);
 return _Tr::not_eof(__out);
      }

      typename _Wide_streambuf::int_type
      underflow()
      {
 if (!_M_buf)
   return _Tr::eof();

 if (this->gptr() < this->egptr() || (_M_buf && _M_conv_get()))
   return _Tr::to_int_type(*this->gptr());
 else
   return _Tr::eof();
      }

      streamsize
      xsputn(const typename _Wide_streambuf::char_type* __s, streamsize __n)
      {
 if (!_M_buf || __n == 0)
   return 0;
 streamsize __done = 0;
 do
 {
   auto __nn = std::min<streamsize>(this->epptr() - this->pptr(),
        __n - __done);
   _Tr::copy(this->pptr(), __s + __done, __nn);
   this->pbump(__nn);
   __done += __nn;
 } while (__done < __n && _M_conv_put());
 return __done;
      }

    private:

      bool
      _M_conv_get()
      {
 const streamsize __pb1 = this->gptr() - this->eback();
 const streamsize __pb2 = _S_putback_length;
 const streamsize __npb = std::min(__pb1, __pb2);

 _Tr::move(_M_get_area + _S_putback_length - __npb,
    this->gptr() - __npb, __npb);

 streamsize __nbytes = sizeof(_M_get_buf) - _M_unconv;
 __nbytes = std::min(__nbytes, _M_buf->in_avail());
 if (__nbytes < 1)
   __nbytes == 1;
 __nbytes = _M_buf->sgetn(_M_get_buf + _M_unconv, __nbytes);
 if (__nbytes < 1)
   return false;
 __nbytes += _M_unconv;



 _Elem* __outbuf = _M_get_area + _S_putback_length;
 _Elem* __outnext = __outbuf;
 const char* __bnext = _M_get_buf;

 codecvt_base::result __result;
 if (_M_always_noconv)
   __result = codecvt_base::noconv;
 else
   {
     _Elem* __outend = _M_get_area + _S_buffer_length;

     __result = _M_cvt->in(_M_state,
      __bnext, __bnext + __nbytes, __bnext,
      __outbuf, __outend, __outnext);
   }

 if (__result == codecvt_base::noconv)
   {

     auto __get_buf = reinterpret_cast<const _Elem*>(_M_get_buf);
     _Tr::copy(__outbuf, __get_buf, __nbytes);
     _M_unconv = 0;
     return true;
   }

 if ((_M_unconv = _M_get_buf + __nbytes - __bnext))
   char_traits<char>::move(_M_get_buf, __bnext, _M_unconv);

 this->setg(__outbuf, __outbuf, __outnext);

 return __result != codecvt_base::error;
      }


      bool
      _M_put(...)
      { return false; }

      bool
      _M_put(const char* __p, streamsize __n)
      {
 if (_M_buf->sputn(__p, __n) < __n)
   return false;
      }


      bool
      _M_conv_put()
      {
 _Elem* const __first = this->pbase();
 const _Elem* const __last = this->pptr();
 const streamsize __pending = __last - __first;

 if (_M_always_noconv)
   return _M_put(__first, __pending);

 char __outbuf[2 * _S_buffer_length];

 const _Elem* __next = __first;
 const _Elem* __start;
 do
   {
     __start = __next;
     char* __outnext = __outbuf;
     char* const __outlast = __outbuf + sizeof(__outbuf);
     auto __result = _M_cvt->out(_M_state, __next, __last, __next,
     __outnext, __outlast, __outnext);
     if (__result == codecvt_base::error)
       return false;
     else if (__result == codecvt_base::noconv)
       return _M_put(__next, __pending);

     if (!_M_put(__outbuf, __outnext - __outbuf))
       return false;
   }
 while (__next != __last && __next != __start);

 if (__next != __last)
   _Tr::move(__first, __next, __last - __next);

 this->pbump(__first - __next);
 return __next != __first;
      }

      streambuf* _M_buf;
      unique_ptr<_Codecvt> _M_cvt;
      state_type _M_state;

      static const streamsize _S_buffer_length = 32;
      static const streamsize _S_putback_length = 3;
      _Elem _M_put_area[_S_buffer_length];
      _Elem _M_get_area[_S_buffer_length];
      streamsize _M_unconv = 0;
      char _M_get_buf[_S_buffer_length-_S_putback_length];
      bool _M_always_noconv;
    };






}
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/locale" 2 3
# 44 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 2 3

# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 1 3
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 3
       
# 34 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/bits/quoted_string.h" 3






namespace std
{
  namespace __detail {
 




    template<typename _String, typename _CharT>
      struct _Quoted_string
      {
 static_assert(is_reference<_String>::value
     || is_pointer<_String>::value,
        "String type must be pointer or reference");

 _Quoted_string(_String __str, _CharT __del, _CharT __esc)
 : _M_string(__str), _M_delim{__del}, _M_escape{__esc}
 { }

 _Quoted_string&
 operator=(_Quoted_string&) = delete;

 _String _M_string;
 _CharT _M_delim;
 _CharT _M_escape;
      };







    template<typename _CharT, typename _Traits>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<const _CharT*, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (const _CharT* __c = __str._M_string; *__c; ++__c)
   {
     if (*__c == __str._M_delim || *__c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << *__c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }







    template<typename _CharT, typename _Traits, typename _String>
      std::basic_ostream<_CharT, _Traits>&
      operator<<(std::basic_ostream<_CharT, _Traits>& __os,
   const _Quoted_string<_String, _CharT>& __str)
      {
 std::basic_ostringstream<_CharT, _Traits> __ostr;
 __ostr << __str._M_delim;
 for (auto& __c : __str._M_string)
   {
     if (__c == __str._M_delim || __c == __str._M_escape)
       __ostr << __str._M_escape;
     __ostr << __c;
   }
 __ostr << __str._M_delim;

 return __os << __ostr.str();
      }





    template<typename _CharT, typename _Traits, typename _Alloc>
      std::basic_istream<_CharT, _Traits>&
      operator>>(std::basic_istream<_CharT, _Traits>& __is,
   const _Quoted_string<basic_string<_CharT, _Traits, _Alloc>&,
          _CharT>& __str)
      {
 _CharT __c;
 __is >> __c;
 if (!__is.good())
   return __is;
 if (__c != __str._M_delim)
   {
     __is.unget();
     __is >> __str._M_string;
     return __is;
   }
 __str._M_string.clear();
 std::ios_base::fmtflags __flags
   = __is.flags(__is.flags() & ~std::ios_base::skipws);
 do
   {
     __is >> __c;
     if (!__is.good())
       break;
     if (__c == __str._M_escape)
       {
  __is >> __c;
  if (!__is.good())
    break;
       }
     else if (__c == __str._M_delim)
       break;
     __str._M_string += __c;
   }
 while (true);
 __is.setf(__flags);

 return __is;
      }

 
  }
}
# 46 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 2 3



namespace std
{





  struct _Resetiosflags { ios_base::fmtflags _M_mask; };
# 65 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Resetiosflags
  resetiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Resetiosflags __f)
    {
      __is.setf(ios_base::fmtflags(0), __f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Resetiosflags __f)
    {
      __os.setf(ios_base::fmtflags(0), __f._M_mask);
      return __os;
    }


  struct _Setiosflags { ios_base::fmtflags _M_mask; };
# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setiosflags
  setiosflags(ios_base::fmtflags __mask)
  { return { __mask }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setiosflags __f)
    {
      __is.setf(__f._M_mask);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setiosflags __f)
    {
      __os.setf(__f._M_mask);
      return __os;
    }


  struct _Setbase { int _M_base; };
# 126 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setbase
  setbase(int __base)
  { return { __base }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setbase __f)
    {
      __is.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setbase __f)
    {
      __os.setf(__f._M_base == 8 ? ios_base::oct :
  __f._M_base == 10 ? ios_base::dec :
  __f._M_base == 16 ? ios_base::hex :
  ios_base::fmtflags(0), ios_base::basefield);
      return __os;
    }


  template<typename _CharT>
    struct _Setfill { _CharT _M_c; };
# 163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Setfill<_CharT>
    setfill(_CharT __c)
    { return { __c }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setfill<_CharT> __f)
    {
      __is.fill(__f._M_c);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setfill<_CharT> __f)
    {
      __os.fill(__f._M_c);
      return __os;
    }


  struct _Setprecision { int _M_n; };
# 194 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setprecision
  setprecision(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setprecision __f)
    {
      __is.precision(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setprecision __f)
    {
      __os.precision(__f._M_n);
      return __os;
    }


  struct _Setw { int _M_n; };
# 224 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  inline _Setw
  setw(int __n)
  { return { __n }; }

  template<typename _CharT, typename _Traits>
    inline basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Setw __f)
    {
      __is.width(__f._M_n);
      return __is;
    }

  template<typename _CharT, typename _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Setw __f)
    {
      __os.width(__f._M_n);
      return __os;
    }



  template<typename _MoneyT>
    struct _Get_money { _MoneyT& _M_mon; bool _M_intl; };
# 257 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Get_money<_MoneyT>
    get_money(_MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_money<_MoneyT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef istreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_get<_CharT, _Iter> _MoneyGet;

       const _MoneyGet& __mg = use_facet<_MoneyGet>(__is.getloc());
       __mg.get(_Iter(__is.rdbuf()), _Iter(), __f._M_intl,
         __is, __err, __f._M_mon);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __is._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __is._M_setstate(ios_base::badbit); }
   if (__err)
     __is.setstate(__err);
 }
      return __is;
    }


  template<typename _MoneyT>
    struct _Put_money { const _MoneyT& _M_mon; bool _M_intl; };
# 304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _MoneyT>
    inline _Put_money<_MoneyT>
    put_money(const _MoneyT& __mon, bool __intl = false)
    { return { __mon, __intl }; }

  template<typename _CharT, typename _Traits, typename _MoneyT>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_money<_MoneyT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
 {
   ios_base::iostate __err = ios_base::goodbit;
   try
     {
       typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
       typedef money_put<_CharT, _Iter> _MoneyPut;

       const _MoneyPut& __mp = use_facet<_MoneyPut>(__os.getloc());
       if (__mp.put(_Iter(__os.rdbuf()), __f._M_intl, __os,
      __os.fill(), __f._M_mon).failed())
  __err |= ios_base::badbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __os._M_setstate(ios_base::badbit);
       throw;
     }
   catch(...)
     { __os._M_setstate(ios_base::badbit); }
   if (__err)
     __os.setstate(__err);
 }
      return __os;
    }

  template<typename _CharT>
    struct _Put_time
    {
      const std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Put_time<_CharT>
    put_time(const std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os, _Put_time<_CharT> __f)
    {
      typename basic_ostream<_CharT, _Traits>::sentry __cerb(__os);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef ostreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_put<_CharT, _Iter> _TimePut;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimePut& __mp = use_facet<_TimePut>(__os.getloc());
              if (__mp.put(_Iter(__os.rdbuf()), __os, __os.fill(),
                           __f._M_tmb, __f._M_fmt, __fmt_end).failed())
                __err |= ios_base::badbit;
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __os._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __os._M_setstate(ios_base::badbit); }
          if (__err)
            __os.setstate(__err);
        }
      return __os;
    }

  template<typename _CharT>
    struct _Get_time
    {
      std::tm* _M_tmb;
      const _CharT* _M_fmt;
    };
# 411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline _Get_time<_CharT>
    get_time(std::tm* __tmb, const _CharT* __fmt)
    { return { __tmb, __fmt }; }

  template<typename _CharT, typename _Traits>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is, _Get_time<_CharT> __f)
    {
      typename basic_istream<_CharT, _Traits>::sentry __cerb(__is, false);
      if (__cerb)
        {
          ios_base::iostate __err = ios_base::goodbit;
          try
            {
              typedef istreambuf_iterator<_CharT, _Traits> _Iter;
              typedef time_get<_CharT, _Iter> _TimeGet;

              const _CharT* const __fmt_end = __f._M_fmt +
                _Traits::length(__f._M_fmt);

              const _TimeGet& __mg = use_facet<_TimeGet>(__is.getloc());
              __mg.get(_Iter(__is.rdbuf()), _Iter(), __is,
                       __err, __f._M_tmb, __f._M_fmt, __fmt_end);
            }
          catch(__cxxabiv1::__forced_unwind&)
            {
              __is._M_setstate(ios_base::badbit);
              throw;
            }
          catch(...)
            { __is._M_setstate(ios_base::badbit); }
          if (__err)
            __is.setstate(__err);
        }
      return __is;
    }
# 459 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  template<typename _CharT>
    inline auto
    quoted(const _CharT* __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<const _CharT*, _CharT>(__string, __delim,
            __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(const basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   const basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline auto
    quoted(basic_string<_CharT, _Traits, _Alloc>& __string,
    _CharT __delim = _CharT('"'), _CharT __escape = _CharT('\\'))
    {
      return __detail::_Quoted_string<
   basic_string<_CharT, _Traits, _Alloc>&, _CharT>(
    __string, __delim, __escape);
    }
# 496 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/iomanip" 3
  extern template ostream& operator<<(ostream&, _Setfill<char>);
  extern template ostream& operator<<(ostream&, _Setiosflags);
  extern template ostream& operator<<(ostream&, _Resetiosflags);
  extern template ostream& operator<<(ostream&, _Setbase);
  extern template ostream& operator<<(ostream&, _Setprecision);
  extern template ostream& operator<<(ostream&, _Setw);
  extern template istream& operator>>(istream&, _Setfill<char>);
  extern template istream& operator>>(istream&, _Setiosflags);
  extern template istream& operator>>(istream&, _Resetiosflags);
  extern template istream& operator>>(istream&, _Setbase);
  extern template istream& operator>>(istream&, _Setprecision);
  extern template istream& operator>>(istream&, _Setw);


  extern template wostream& operator<<(wostream&, _Setfill<wchar_t>);
  extern template wostream& operator<<(wostream&, _Setiosflags);
  extern template wostream& operator<<(wostream&, _Resetiosflags);
  extern template wostream& operator<<(wostream&, _Setbase);
  extern template wostream& operator<<(wostream&, _Setprecision);
  extern template wostream& operator<<(wostream&, _Setw);
  extern template wistream& operator>>(wistream&, _Setfill<wchar_t>);
  extern template wistream& operator>>(wistream&, _Setiosflags);
  extern template wistream& operator>>(wistream&, _Resetiosflags);
  extern template wistream& operator>>(wistream&, _Setbase);
  extern template wistream& operator>>(wistream&, _Setprecision);
  extern template wistream& operator>>(wistream&, _Setw);




}
# 120 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 2





# 124 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
namespace ap_private_ops {

static inline uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


static inline uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}

template <int _AP_W>
inline bool isNegative(const ap_private<_AP_W, false>& a) {
  return false;
}

template <int _AP_W>
inline bool isNegative(const ap_private<_AP_W, true>& a) {
  enum {
    APINT_BITS_PER_WORD = 64,
    _AP_N = (_AP_W + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD
  };
  static const uint64_t sign_mask = 1ULL << ((_AP_W - 1) % APINT_BITS_PER_WORD);
  return (sign_mask & a.get_pVal(_AP_N - 1)) != 0;
}





static inline unsigned CountLeadingZeros_32(uint32_t Value) {
  unsigned Count;



  if (Value == 0) return 32;

  Count = __builtin_clz(Value);
# 175 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  return Count;
}





static inline unsigned CountLeadingZeros_64(uint64_t Value) {
  unsigned Count;



  if (!Value) return 64;

  Count = __builtin_clzll(Value);
# 219 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  return Count;
}





static inline unsigned CountTrailingZeros_64(uint64_t Value) {

  return (Value != 0) ? __builtin_ctzll(Value) : 64;
# 237 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
}



static inline unsigned CountPopulation_64(uint64_t Value) {

  return __builtin_popcountll(Value);






}

static inline uint32_t countLeadingOnes_64(uint64_t __V, uint32_t skip) {
  uint32_t Count = 0;
  if (skip) (__V) <<= (skip);
  while (__V && (__V & (1ULL << 63))) {
    Count++;
    (__V) <<= 1;
  }
  return Count;
}

static inline std::string oct2Bin(char oct) {
  switch (oct) {
    case '\0': {
      return "";
    }
    case '.': {
      return ".";
    }
    case '0': {
      return "000";
    }
    case '1': {
      return "001";
    }
    case '2': {
      return "010";
    }
    case '3': {
      return "011";
    }
    case '4': {
      return "100";
    }
    case '5': {
      return "101";
    }
    case '6': {
      return "110";
    }
    case '7': {
      return "111";
    }
  }
  
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 0 && "Invalid character in digit string"
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "0 && \"Invalid character in digit string\""
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",295),0))
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                 ;
  return "";
}

static inline std::string hex2Bin(char hex) {
  switch (hex) {
    case '\0': {
      return "";
    }
    case '.': {
      return ".";
    }
    case '0': {
      return "0000";
    }
    case '1': {
      return "0001";
    }
    case '2': {
      return "0010";
    }
    case '3': {
      return "0011";
    }
    case '4': {
      return "0100";
    }
    case '5': {
      return "0101";
    }
    case '6': {
      return "0110";
    }
    case '7': {
      return "0111";
    }
    case '8': {
      return "1000";
    }
    case '9': {
      return "1001";
    }
    case 'A':
    case 'a': {
      return "1010";
    }
    case 'B':
    case 'b': {
      return "1011";
    }
    case 'C':
    case 'c': {
      return "1100";
    }
    case 'D':
    case 'd': {
      return "1101";
    }
    case 'E':
    case 'e': {
      return "1110";
    }
    case 'F':
    case 'f': {
      return "1111";
    }
  }
  
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 0 && "Invalid character in digit string"
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "0 && \"Invalid character in digit string\""
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",362),0))
# 362 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                 ;
  return "";
}

static inline uint32_t decode_digit(char cdigit, int radix) {
  uint32_t digit = 0;
  if (radix == 16) {




    if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F'))) 
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                          (void) ((!!(
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                          0 && "Invalid hex digit in string"
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                          )) || (_assert(
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                          "0 && \"Invalid hex digit in string\""
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                          ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",373),0))
# 373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                    ;
    if (((cdigit) >= '0' && (cdigit) <= '9'))
      digit = cdigit - '0';
    else if (cdigit >= 'a')
      digit = cdigit - 'a' + 10;
    else if (cdigit >= 'A')
      digit = cdigit - 'A' + 10;
    else
      
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     0 && "huh? we shouldn't get here"
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "0 && \"huh? we shouldn't get here\""
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",381),0))
# 381 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                              ;
  } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
    digit = cdigit - '0';
  } else {
    
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0 && "Invalid character in digit string"
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0 && \"Invalid character in digit string\""
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",385),0))
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
  }


  return digit;
}


static inline std::string parseString(const std::string& input, unsigned char& radix) {
  size_t len = input.length();
  if (len == 0) {
    if (radix == 0) radix = 10;
    return input;
  }

  size_t startPos = 0;

  while (input[startPos] == ' ' && startPos < len) startPos++;
  while (input[len - 1] == ' ' && startPos < len) len--;

  std::string val = input.substr(startPos, len - startPos);

  len = val.length();
  startPos = 0;



  if (len < 2) {
    if (radix == 0) radix = 10;
    return val;
  }

  bool isNegative = false;
  std::string ans;


  if (val[0] == '-') {
    ans = "-";
    ++startPos;
    isNegative = true;
  } else if (val[0] == '+')
    ++startPos;

  if (len - startPos < 2) {
    if (radix == 0) radix = 10;
    return val;
  }

  if (val.substr(startPos, 2) == "0x" || val.substr(startPos, 2) == "0X") {

    radix = 16;
    startPos += 2;
  } else if (val.substr(startPos, 2) == "0b" ||
             val.substr(startPos, 2) == "0B") {

    radix = 2;
    startPos += 2;
  } else if (val.substr(startPos, 2) == "0o" ||
             val.substr(startPos, 2) == "0O") {

    radix = 8;
    startPos += 2;
  } else if (radix == 0) {
    radix = 10;
  }

  int exp = 0;
  if (radix == 10) {


    size_t expPos = val.find('e');
    bool has_exponent = true;
    if (expPos == std::string::npos) expPos = val.find('E');
    if (expPos == std::string::npos) {

      expPos = len;
      has_exponent = false;
    }


    ans += val.substr(startPos, expPos - startPos);
    if (has_exponent) {

      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));
      iss >> exp;
    }
  } else {

    size_t expPos = val.find('p');
    bool has_exponent = true;
    if (expPos == std::string::npos) expPos = val.find('P');
    if (expPos == std::string::npos) {

      expPos = len;
      has_exponent = false;
    }



    
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   startPos <= expPos
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "startPos <= expPos"
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",484),0))
# 484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                             ;

    for (size_t i = startPos; i < expPos; ++i) {
      if (radix == 16) {
        ans += hex2Bin(val[i]);
      } else if (radix == 8) {
        ans += oct2Bin(val[i]);
      } else {
        ans += val[i];
      }
    }

    radix = 2;
    if (has_exponent) {

      std::istringstream iss(val.substr(expPos + 1, len - expPos - 1));
      iss >> exp;
    }
  }
  if (exp == 0) return ans;

  size_t decPos = ans.find('.');
  if (decPos == std::string::npos) decPos = ans.length();
  if ((int)decPos + exp >= (int)ans.length()) {
    int i = decPos;
    for (; i < (int)ans.length() - 1; ++i) ans[i] = ans[i + 1];
    for (; i < (int)ans.length(); ++i) ans[i] = '0';
    for (; i < (int)decPos + exp; ++i) ans += '0';
    return ans;
  } else if ((int)decPos + exp < (int)isNegative) {
    std::string dupAns = "0.";
    if (ans[0] == '-') dupAns = "-0.";
    for (int i = 0; i < isNegative - (int)decPos - exp; ++i) dupAns += '0';
    for (size_t i = isNegative; i < ans.length(); ++i)
      if (ans[i] != '.') dupAns += ans[i];
    return dupAns;
  }

  if (exp > 0)
    for (size_t i = decPos; i < decPos + exp; ++i) ans[i] = ans[i + 1];
  else {
    if (decPos == ans.length()) ans += ' ';
    for (int i = decPos; i > (int)decPos + exp; --i) ans[i] = ans[i - 1];
  }
  ans[decPos + exp] = '.';
  return ans;
}







static inline bool sub_1(uint64_t x[], uint32_t len, uint64_t y) {
  for (uint32_t i = 0; i < len; ++i) {
    uint64_t __X = x[i];
    x[i] -= y;
    if (y > __X)
      y = 1;
    else {
      y = 0;
      break;
    }
  }
  return (y != 0);
}





static inline bool add_1(uint64_t dest[], uint64_t x[], uint32_t len,
                         uint64_t y) {
  for (uint32_t i = 0; i < len; ++i) {
    dest[i] = y + x[i];
    if (dest[i] < y)
      y = 1;
    else {
      y = 0;
      break;
    }
  }
  return (y != 0);
}





static inline bool add(uint64_t* dest, const uint64_t* x, const uint64_t* y,
                       uint32_t destlen, uint32_t xlen, uint32_t ylen,
                       bool xsigned, bool ysigned) {
  bool carry = false;
  uint32_t len = AESL_std::min(xlen, ylen);
  uint32_t i;
  for (i = 0; i < len && i < destlen; ++i) {
    uint64_t limit =
        AESL_std::min(x[i], y[i]);
    dest[i] = x[i] + y[i] + carry;
    carry = dest[i] < limit || (carry && dest[i] == limit);
  }
  if (xlen > ylen) {
    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;
    for (i = ylen; i < xlen && i < destlen; i++) {
      uint64_t limit = AESL_std::min(x[i], yext);
      dest[i] = x[i] + yext + carry;
      carry = (dest[i] < limit) || (carry && dest[i] == limit);
    }
  } else if (ylen > xlen) {
    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;
    for (i = xlen; i < ylen && i < destlen; i++) {
      uint64_t limit = AESL_std::min(xext, y[i]);
      dest[i] = xext + y[i] + carry;
      carry = (dest[i] < limit) || (carry && dest[i] == limit);
    }
  }
  return carry;
}



static inline bool sub(uint64_t* dest, const uint64_t* x, const uint64_t* y,
                       uint32_t destlen, uint32_t xlen, uint32_t ylen,
                       bool xsigned, bool ysigned) {
  bool borrow = false;
  uint32_t i;
  uint32_t len = AESL_std::min(xlen, ylen);
  for (i = 0; i < len && i < destlen; ++i) {
    uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
    borrow = y[i] > x_tmp || (borrow && x[i] == 0);
    dest[i] = x_tmp - y[i];
  }
  if (xlen > ylen) {
    const uint64_t yext = ysigned && int64_t(y[ylen - 1]) < 0 ? -1 : 0;
    for (i = ylen; i < xlen && i < destlen; i++) {
      uint64_t x_tmp = borrow ? x[i] - 1 : x[i];
      borrow = yext > x_tmp || (borrow && x[i] == 0);
      dest[i] = x_tmp - yext;
    }
  } else if (ylen > xlen) {
    const uint64_t xext = xsigned && int64_t(x[xlen - 1]) < 0 ? -1 : 0;
    for (i = xlen; i < ylen && i < destlen; i++) {
      uint64_t x_tmp = borrow ? xext - 1 : xext;
      borrow = y[i] > x_tmp || (borrow && xext == 0);
      dest[i] = x_tmp - y[i];
    }
  }
  return borrow;
}
# 643 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
static inline uint64_t mul_1(uint64_t dest[], const uint64_t x[], uint32_t len,
                             uint64_t y) {

  uint64_t ly = y & 0xffffffffULL, hy = (y) >> 32;
  uint64_t carry = 0;
  static const uint64_t two_power_32 = 1ULL << 32;

  for (uint32_t i = 0; i < len; ++i) {

    uint64_t lx = x[i] & 0xffffffffULL;
    uint64_t hx = (x[i]) >> 32;




    uint8_t hasCarry = 0;
    dest[i] = carry + lx * ly;

    hasCarry = (dest[i] < carry) ? 1 : 0;
    carry = hx * ly + ((dest[i]) >> 32) + (hasCarry ? two_power_32 : 0);


    hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);

    carry += (lx * hy) & 0xffffffffULL;
    dest[i] = ((carry) << 32) | (dest[i] & 0xffffffffULL);
    carry = (((!carry && hasCarry != 2) || hasCarry == 1) ? two_power_32 : 0) +
            ((carry) >> 32) + ((lx * hy) >> 32) + hx * hy;
  }
  return carry;
}







static inline void mul(uint64_t dest[], const uint64_t x[], uint32_t xlen,
                       const uint64_t y[], uint32_t ylen, uint32_t destlen) {
  
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 xlen > 0
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "xlen > 0"
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",683),0))
# 683 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                 ;
  
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 ylen > 0
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "ylen > 0"
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",684),0))
# 684 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                 ;
  
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 destlen >= xlen + ylen
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "destlen >= xlen + ylen"
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",685),0))
# 685 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                               ;
  if (xlen < destlen) dest[xlen] = mul_1(dest, x, xlen, y[0]);
  for (uint32_t i = 1; i < ylen; ++i) {
    uint64_t ly = y[i] & 0xffffffffULL, hy = (y[i]) >> 32;
    uint64_t carry = 0, lx = 0, hx = 0;
    for (uint32_t j = 0; j < xlen; ++j) {
      lx = x[j] & 0xffffffffULL;
      hx = (x[j]) >> 32;




      uint8_t hasCarry = 0;
      uint64_t resul = carry + lx * ly;
      hasCarry = (resul < carry) ? 1 : 0;
      carry = (hasCarry ? (1ULL << 32) : 0) + hx * ly + ((resul) >> 32);
      hasCarry = (!carry && hasCarry) ? 1 : (!carry ? 2 : 0);
      carry += (lx * hy) & 0xffffffffULL;
      resul = ((carry) << 32) | (resul & 0xffffffffULL);
      if (i + j < destlen) dest[i + j] += resul;
      carry =
          (((!carry && hasCarry != 2) || hasCarry == 1) ? (1ULL << 32) : 0) +
          ((carry) >> 32) + (dest[i + j] < resul ? 1 : 0) + ((lx * hy) >> 32) +
          hx * hy;
    }
    if (i + xlen < destlen) dest[i + xlen] = carry;
  }
}





static inline void KnuthDiv(uint32_t* u, uint32_t* v, uint32_t* q, uint32_t* r,
                            uint32_t m, uint32_t n) {
  
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 u && "Must provide dividend"
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "u && \"Must provide dividend\""
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",720),0))
# 720 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
  
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 v && "Must provide divisor"
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "v && \"Must provide divisor\""
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",721),0))
# 721 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                    ;
  
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 q && "Must provide quotient"
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "q && \"Must provide quotient\""
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",722),0))
# 722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
  
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 u != v && u != q && v != q && "Must us different memory"
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "u != v && u != q && v != q && \"Must us different memory\""
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",723),0))
# 723 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
  
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 n > 1 && "n must be > 1"
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "n > 1 && \"n must be > 1\""
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",724),0))
# 724 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                 ;



  uint64_t b = uint64_t(1) << 32;
# 746 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  uint32_t shift = CountLeadingZeros_32(v[n - 1]);
  uint32_t v_carry = 0;
  uint32_t u_carry = 0;
  if (shift) {
    for (uint32_t i = 0; i < m + n; ++i) {
      uint32_t u_tmp = (u[i]) >> (32 - shift);
      u[i] = ((u[i]) << (shift)) | u_carry;
      u_carry = u_tmp;
    }
    for (uint32_t i = 0; i < n; ++i) {
      uint32_t v_tmp = (v[i]) >> (32 - shift);
      v[i] = ((v[i]) << (shift)) | v_carry;
      v_carry = v_tmp;
    }
  }
  u[m + n] = u_carry;
# 771 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  int j = m;
  do {
# 782 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
    uint64_t dividend = ((uint64_t(u[j + n]) << 32) + u[j + n - 1]);

    uint64_t qp = dividend / v[n - 1];
    uint64_t rp = dividend % v[n - 1];
    if (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2]) {
      qp--;
      rp += v[n - 1];
      if (rp < b && (qp == b || qp * v[n - 2] > b * rp + u[j + n - 2])) qp--;
    }






    bool isNeg = false;
    for (uint32_t i = 0; i < n; ++i) {
      uint64_t u_tmp = uint64_t(u[j + i]) | ((uint64_t(u[j + i + 1])) << 32);
      uint64_t subtrahend = uint64_t(qp) * uint64_t(v[i]);
      bool borrow = subtrahend > u_tmp;




      uint64_t result = u_tmp - subtrahend;
      uint32_t k = j + i;
      u[k++] = (uint32_t)(result & (b - 1));
      u[k++] = (uint32_t)((result) >> 32);
      while (borrow && k <= m + n) {
        borrow = u[k] == 0;
        u[k]--;
        k++;
      }
      isNeg |= borrow;


    }
# 827 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
    if (isNeg) {
      bool carry = true;
      for (uint32_t i = 0; i <= m + n; ++i) {
        u[i] = ~u[i] + carry;
        carry = carry && u[i] == 0;
      }
    }






    q[j] = (uint32_t)qp;
    if (isNeg) {



      q[j]--;



      bool carry = false;
      for (uint32_t i = 0; i < n; i++) {
        uint32_t limit = AESL_std::min(u[j + i], v[i]);
        u[j + i] += v[i] + carry;
        carry = u[j + i] < limit || (carry && u[j + i] == limit);
      }
      u[j + n] += carry;
    }





  } while (--j >= 0);
# 871 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  if (r) {



    if (shift) {
      uint32_t carry = 0;

      for (int i = n - 1; i >= 0; i--) {
        r[i] = ((u[i]) >> (shift)) | carry;
        carry = (u[i]) << (32 - shift);

      }
    } else {
      for (int i = n - 1; i >= 0; i--) {
        r[i] = u[i];

      }
    }

  }

}

template <int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            const ap_private<_AP_W, _AP_S>& RHS, uint32_t rhsWords,
            ap_private<_AP_W, _AP_S>* Quotient,
            ap_private<_AP_W, _AP_S>* Remainder) {
  
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 lhsWords >= rhsWords && "Fractional result"
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "lhsWords >= rhsWords && \"Fractional result\""
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",899),0))
# 899 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
  enum { APINT_BITS_PER_WORD = 64 };







  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);
  uint32_t n = rhsWords * 2;
  uint32_t m = (lhsWords * 2) - n;



  uint32_t SPACE[128];
  uint32_t* __U = 0;
  uint32_t* __V = 0;
  uint32_t* __Q = 0;
  uint32_t* __R = 0;
  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {
    __U = &SPACE[0];
    __V = &SPACE[m + n + 1];
    __Q = &SPACE[(m + n + 1) + n];
    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];
  } else {
    __U = new uint32_t[m + n + 1];
    __V = new uint32_t[n];
    __Q = new uint32_t[m + n];
    if (Remainder) __R = new uint32_t[n];
  }


  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));
  for (unsigned i = 0; i < lhsWords; ++i) {
    uint64_t tmp = LHS.get_pVal(i);
    __U[i * 2] = (uint32_t)(tmp & mask);
    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }
  __U[m + n] = 0;


  memset(__V, 0, (n) * sizeof(uint32_t));
  for (unsigned i = 0; i < rhsWords; ++i) {
    uint64_t tmp = RHS.get_pVal(i);
    __V[i * 2] = (uint32_t)(tmp & mask);
    __V[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }


  memset(__Q, 0, (m + n) * sizeof(uint32_t));
  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));





  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {
    n--;
    m++;
  }
  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;







  
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 n != 0 && "Divide by zero?"
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "n != 0 && \"Divide by zero?\""
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",968),0))
# 968 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                    ;
  if (n == 1) {
    uint32_t divisor = __V[0];
    uint32_t remainder = 0;
    for (int i = m + n - 1; i >= 0; i--) {
      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
      if (partial_dividend == 0) {
        __Q[i] = 0;
        remainder = 0;
      } else if (partial_dividend < divisor) {
        __Q[i] = 0;
        remainder = (uint32_t)partial_dividend;
      } else if (partial_dividend == divisor) {
        __Q[i] = 1;
        remainder = 0;
      } else {
        __Q[i] = (uint32_t)(partial_dividend / divisor);
        remainder = (uint32_t)(partial_dividend - (__Q[i] * divisor));
      }
    }
    if (__R) __R[0] = remainder;
  } else {


    KnuthDiv(__U, __V, __Q, __R, m, n);
  }


  if (Quotient) {

    if (Quotient->BitWidth != LHS.BitWidth) {
      if (Quotient->isSingleWord()) Quotient->set_VAL(0);
    } else
      Quotient->clear();



    if (lhsWords == 1) {
      uint64_t tmp =
          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
      Quotient->set_VAL(tmp);
    } else {
      
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Quotient->isSingleWord() && "Quotient ap_private not large enough"
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Quotient->isSingleWord() && \"Quotient ap_private not large enough\""
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                   1011
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                    
# 1011 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
      for (unsigned i = 0; i < lhsWords; ++i)
        Quotient->set_pVal(
            i, uint64_t(__Q[i * 2]) |
                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Quotient->clearUnusedBits();
  }


  if (Remainder) {

    if (Remainder->BitWidth != RHS.BitWidth) {
      if (Remainder->isSingleWord()) Remainder->set_VAL(0);
    } else
      Remainder->clear();



    if (rhsWords == 1) {
      uint64_t tmp =
          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
      Remainder->set_VAL(tmp);
    } else {
      
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Remainder->isSingleWord() && "Remainder ap_private not large enough"
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Remainder->isSingleWord() && \"Remainder ap_private not large enough\""
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                    "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                    1036
# 1035 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                     
# 1036 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
      for (unsigned i = 0; i < rhsWords; ++i)
        Remainder->set_pVal(
            i, uint64_t(__R[i * 2]) |
                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Remainder->clearUnusedBits();
  }


  if (__U != &SPACE[0]) {
    delete[] __U;
    delete[] __V;
    delete[] __Q;
    delete[] __R;
  }
}

template <int _AP_W, bool _AP_S>
void divide(const ap_private<_AP_W, _AP_S>& LHS, uint32_t lhsWords,
            uint64_t RHS, ap_private<_AP_W, _AP_S>* Quotient,
            ap_private<_AP_W, _AP_S>* Remainder) {
  uint32_t rhsWords = 1;
  
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 lhsWords >= rhsWords && "Fractional result"
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "lhsWords >= rhsWords && \"Fractional result\""
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1059),0))
# 1059 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
  enum { APINT_BITS_PER_WORD = 64 };







  uint64_t mask = ~0ull >> (sizeof(uint32_t) * 8);
  uint32_t n = 2;
  uint32_t m = (lhsWords * 2) - n;



  uint32_t SPACE[128];
  uint32_t* __U = 0;
  uint32_t* __V = 0;
  uint32_t* __Q = 0;
  uint32_t* __R = 0;
  if ((Remainder ? 4 : 3) * n + 2 * m + 1 <= 128) {
    __U = &SPACE[0];
    __V = &SPACE[m + n + 1];
    __Q = &SPACE[(m + n + 1) + n];
    if (Remainder) __R = &SPACE[(m + n + 1) + n + (m + n)];
  } else {
    __U = new uint32_t[m + n + 1];
    __V = new uint32_t[n];
    __Q = new uint32_t[m + n];
    if (Remainder) __R = new uint32_t[n];
  }


  memset(__U, 0, (m + n + 1) * sizeof(uint32_t));
  for (unsigned i = 0; i < lhsWords; ++i) {
    uint64_t tmp = LHS.get_pVal(i);
    __U[i * 2] = tmp & mask;
    __U[i * 2 + 1] = (tmp) >> (sizeof(uint32_t) * 8);
  }
  __U[m + n] = 0;


  memset(__V, 0, (n) * sizeof(uint32_t));
  __V[0] = RHS & mask;
  __V[1] = (RHS) >> (sizeof(uint32_t) * 8);


  memset(__Q, 0, (m + n) * sizeof(uint32_t));
  if (Remainder) memset(__R, 0, n * sizeof(uint32_t));





  for (unsigned i = n; i > 0 && __V[i - 1] == 0; i--) {
    n--;
    m++;
  }
  for (unsigned i = m + n; i > 0 && __U[i - 1] == 0; i--) m--;







  
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 n != 0 && "Divide by zero?"
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "n != 0 && \"Divide by zero?\""
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1125),0))
# 1125 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                    ;
  if (n == 1) {
    uint32_t divisor = __V[0];
    uint32_t remainder = 0;
    for (int i = m + n - 1; i >= 0; i--) {
      uint64_t partial_dividend = (uint64_t(remainder)) << 32 | __U[i];
      if (partial_dividend == 0) {
        __Q[i] = 0;
        remainder = 0;
      } else if (partial_dividend < divisor) {
        __Q[i] = 0;
        remainder = partial_dividend;
      } else if (partial_dividend == divisor) {
        __Q[i] = 1;
        remainder = 0;
      } else {
        __Q[i] = partial_dividend / divisor;
        remainder = partial_dividend - (__Q[i] * divisor);
      }
    }
    if (__R) __R[0] = remainder;
  } else {


    KnuthDiv(__U, __V, __Q, __R, m, n);
  }


  if (Quotient) {

    if (Quotient->BitWidth != LHS.BitWidth) {
      if (Quotient->isSingleWord()) Quotient->set_VAL(0);
    } else
      Quotient->clear();



    if (lhsWords == 1) {
      uint64_t tmp =
          uint64_t(__Q[0]) | ((uint64_t(__Q[1])) << (APINT_BITS_PER_WORD / 2));
      Quotient->set_VAL(tmp);
    } else {
      
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Quotient->isSingleWord() && "Quotient ap_private not large enough"
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Quotient->isSingleWord() && \"Quotient ap_private not large enough\""
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                   1168
# 1167 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                    
# 1168 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
      for (unsigned i = 0; i < lhsWords; ++i)
        Quotient->set_pVal(
            i, uint64_t(__Q[i * 2]) |
                   ((uint64_t(__Q[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Quotient->clearUnusedBits();
  }


  if (Remainder) {

    if (Remainder->BitWidth != 64 ) {
      if (Remainder->isSingleWord()) Remainder->set_VAL(0);
    } else
      Remainder->clear();



    if (rhsWords == 1) {
      uint64_t tmp =
          uint64_t(__R[0]) | ((uint64_t(__R[1])) << (APINT_BITS_PER_WORD / 2));
      Remainder->set_VAL(tmp);
    } else {
      
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     !Remainder->isSingleWord() && "Remainder ap_private not large enough"
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "!Remainder->isSingleWord() && \"Remainder ap_private not large enough\""
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,
                                                    "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ,
                                                    1193
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
      ),0))
                                                     
# 1193 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
      for (unsigned i = 0; i < rhsWords; ++i)
        Remainder->set_pVal(
            i, uint64_t(__R[i * 2]) |
                   ((uint64_t(__R[i * 2 + 1])) << (APINT_BITS_PER_WORD / 2)));
    }
    Remainder->clearUnusedBits();
  }


  if (__U != &SPACE[0]) {
    delete[] __U;
    delete[] __V;
    delete[] __Q;
    delete[] __R;
  }
}


template <int _AP_W, bool _AP_S, bool _AP_C>
inline ap_private<_AP_W, _AP_S, _AP_C> lshr(
    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
  return LHS.lshr(shiftAmt);
}



template <int _AP_W, bool _AP_S, bool _AP_C>
inline ap_private<_AP_W, _AP_S, _AP_C> shl(
    const ap_private<_AP_W, _AP_S, _AP_C>& LHS, uint32_t shiftAmt) {
  return LHS.shl(shiftAmt);
}

}





enum {
  MIN_INT_BITS = 1,

  MAX_INT_BITS = (1 << 23) - 1

};
# 1280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
typedef unsigned long long ap_ulong;
typedef signed long long ap_slong;

template <int _AP_N8, bool _AP_S>
struct valtype;

template <int _AP_N8>
struct valtype<_AP_N8, false> {
  typedef uint64_t Type;
};

template <int _AP_N8>
struct valtype<_AP_N8, true> {
  typedef int64_t Type;
};

template <>
struct valtype<1, false> {
  typedef unsigned char Type;
};
template <>
struct valtype<2, false> {
  typedef unsigned short Type;
};
template <>
struct valtype<3, false> {
  typedef unsigned int Type;
};
template <>
struct valtype<4, false> {
  typedef unsigned int Type;
};
template <>
struct valtype<1, true> {
  typedef signed char Type;
};
template <>
struct valtype<2, true> {
  typedef short Type;
};
template <>
struct valtype<3, true> {
  typedef int Type;
};
template <>
struct valtype<4, true> {
  typedef int Type;
};

template <bool enable>
struct ap_private_enable_if {};
template <>
struct ap_private_enable_if<true> {
  static const bool isValid = true;
};


template <int _AP_W, bool _AP_S>
class ap_private<_AP_W, _AP_S, true> {

  const static bool valid = ap_private_enable_if<_AP_W <= 64>::isValid;




 public:
  typedef typename valtype<(_AP_W + 7) / 8, _AP_S>::Type ValType;
  typedef ap_private<_AP_W, _AP_S> Type;
  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };
    typedef ap_private<mult_w, mult_s> mult;
    typedef ap_private<plus_w, plus_s> plus;
    typedef ap_private<minus_w, minus_s> minus;
    typedef ap_private<logic_w, logic_s> logic;
    typedef ap_private<div_w, div_s> div;
    typedef ap_private<mod_w, mod_s> mod;
    typedef ap_private<_AP_W, _AP_S> arg1;
    typedef bool reduce;
  };
  enum { APINT_BITS_PER_WORD = sizeof(uint64_t) * 8 };
  enum {
    excess_bits = (_AP_W % APINT_BITS_PER_WORD)
                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)
                      : 0
  };
  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));
  static const uint64_t not_mask = ~mask;
  static const uint64_t sign_bit_mask = 1ULL << (APINT_BITS_PER_WORD - 1);
  template <int _AP_W1>
  struct sign_ext_mask {
    static const uint64_t mask = ~0ULL << _AP_W1;
  };
  static const int width = _AP_W;

  enum {
    BitWidth = _AP_W,
    _AP_N = 1,
  };
  ValType VAL;





  void check_canary() {}
  void set_canary() {}


  inline ValType& get_VAL(void) { return VAL; }
  inline ValType get_VAL(void) const { return VAL; }
  inline ValType get_VAL(void) const volatile { return VAL; }
  inline void set_VAL(uint64_t value) { VAL = (ValType)value; }
  inline ValType& get_pVal(int i) { return VAL; }
  inline ValType get_pVal(int i) const { return VAL; }
  inline const uint64_t* get_pVal() const {
    
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0 && "invalid usage"
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0 && \"invalid usage\""
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1411),0))
# 1411 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                               ;
    return 0;
  }
  inline ValType get_pVal(int i) const volatile { return VAL; }
  inline uint64_t* get_pVal() const volatile {
    
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0 && "invalid usage"
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0 && \"invalid usage\""
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1416),0))
# 1416 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                               ;
    return 0;
  }
  inline void set_pVal(int i, uint64_t value) { VAL = (ValType)value; }

  inline uint32_t getBitWidth() const { return BitWidth; }

  template <int _AP_W1, bool _AP_S1>
  ap_private<_AP_W, _AP_S>& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  ap_private<_AP_W, _AP_S>& operator=(
      const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  void operator=(const ap_private& RHS) volatile {

    VAL = RHS.get_VAL();
    clearUnusedBits();
  }

  ap_private& operator=(const ap_private& RHS) {

    VAL = RHS.get_VAL();
    clearUnusedBits();
    return *this;
  }

  void operator=(const volatile ap_private& RHS) volatile {

    VAL = RHS.get_VAL();
    clearUnusedBits();
  }

  ap_private& operator=(const volatile ap_private& RHS) {

    VAL = RHS.get_VAL();
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    *this = ap_private<_AP_W2, false>(op2);
    return *this;
  }
# 1479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
inline ap_private& operator=(const bool v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const signed char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned char v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const short v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned short v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const int v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned int v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const long v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const unsigned long v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const ap_slong v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const ap_ulong v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const half v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }

inline ap_private& operator=(const float v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }
inline ap_private& operator=(const double v) { set_canary(); this->VAL = (ValType)v; clearUnusedBits(); check_canary(); return *this; }



  inline ap_private& operator=(const char* s) {
    ap_private tmp(s);
    operator=(tmp);
    return *this;
  }

 private:
  explicit inline ap_private(uint64_t* val) : VAL(val[0]) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  inline bool isSingleWord() const { return true; }

 public:
  inline void fromString(const char* strStart, uint32_t slen, uint8_t radix) {
    bool isNeg = strStart[0] == '-';
    if (isNeg) {
      strStart++;
      slen--;
    }

    if (strStart[0] == '0' && (strStart[1] == 'b' || strStart[1] == 'B')) {

      do { if ((radix != 2)) { fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 2, radix); fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'o' || strStart[1] == 'O')) {

      do { if ((radix != 8)) { fprintf(
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 8, radix); fprintf(
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1528 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'x' || strStart[1] == 'X')) {

      do { if ((radix != 16)) { fprintf(
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 16, radix); fprintf(
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1533 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (strStart[0] == '0' && (strStart[1] == 'd' || strStart[1] == 'D')) {

      do { if ((radix != 10)) { fprintf(
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", strStart, 10, radix); fprintf(
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 1538 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      strStart += 2;
      slen -=2;
    } else if (radix == 0) {

    }


    
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                             "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                             1547
# 1546 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                              
# 1547 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   strStart && "String is null?"
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "strStart && \"String is null?\""
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1548),0))
# 1548 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                        ;


    uint64_t tmpVAL = VAL = 0;

    switch (radix) {
      case 2:


        for (; *strStart; ++strStart) {
          
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         (*strStart == '0' || *strStart == '1') && ("Wrong binary number")
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "(*strStart == '0' || *strStart == '1') && (\"Wrong binary number\")"
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,
                                        "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
          ,
                                        1559
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
          ),0))
                                         
# 1559 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                        ;
          tmpVAL <<= 1;
          tmpVAL |= (*strStart - '0');
        }
        break;
      case 8:






        sscanf(strStart, "%llo", &tmpVAL);


        break;
      case 10:






        sscanf(strStart, "%llu", &tmpVAL);


        break;
      case 16:






        sscanf(strStart, "%llx", &tmpVAL);


        break;
      default:
        
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       (void) ((!!(
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       true && "Unknown radix"
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       )) || (_assert(
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       "true && \"Unknown radix\""
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1598),0))
# 1598 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                      ;

    }
    VAL = isNeg ? (ValType)(-tmpVAL) : (ValType)(tmpVAL);

    clearUnusedBits();
  }

 private:
  inline ap_private(const std::string& val, uint8_t radix = 2) : VAL(0) {
    
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   !val.empty() && "String empty?"
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "!val.empty() && \"String empty?\""
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",1608),0))
# 1608 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                          ;
    set_canary();
    fromString(val.c_str(), val.size(), radix);
    check_canary();
  }

  inline ap_private(const char strStart[], uint32_t slen, uint8_t radix)
      : VAL(0) {
    set_canary();
    fromString(strStart, slen, radix);
    check_canary();
  }

  inline ap_private(uint32_t numWords, const uint64_t bigVal[])
      : VAL(bigVal[0]) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

 public:
  inline ap_private() {
    set_canary();
    clearUnusedBits();
    check_canary();
  }







  inline ap_private(bool v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(signed char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned char v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned short v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned int v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned long v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(ap_slong v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(ap_ulong v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(half v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(float v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }
  inline ap_private(double v) : VAL((ValType)v) { set_canary(); clearUnusedBits(); check_canary(); }


  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)
      : VAL((ValType)that.get_VAL()) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1, bool _AP_OPT>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, _AP_OPT>& that)
      : VAL((ValType)that.get_VAL()) {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  explicit inline ap_private(const char* val) {
    set_canary();
    unsigned char radix = 10;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');

    if (pos != std::string::npos) str = str.substr(pos);

    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
    operator=(ap_private_val);
    check_canary();
  }

  inline ap_private(const char* val, signed char rd) {
    set_canary();
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');

    if (pos != std::string::npos) str = str.substr(pos);

    ap_private<_AP_W, _AP_S> ap_private_val(str, radix);
    operator=(ap_private_val);
    check_canary();
  }

  inline ~ap_private() { check_canary(); }

  inline bool isNegative() const {
    static const uint64_t sign_mask = 1ULL << (_AP_W - 1);
    return _AP_S && (sign_mask & VAL);
  }

  inline bool isPositive() const { return !isNegative(); }

  inline bool isStrictlyPositive() const { return !isNegative() && VAL != 0; }

  inline bool isAllOnesValue() const { return (mask & VAL) == mask; }

  inline bool operator==(const ap_private<_AP_W, _AP_S>& RHS) const {
    return VAL == RHS.get_VAL();
  }
  inline bool operator==(const ap_private<_AP_W, !_AP_S>& RHS) const {
    return (uint64_t)VAL == (uint64_t)RHS.get_VAL();
  }

  inline bool operator==(uint64_t Val) const { return ((uint64_t)VAL == Val); }
  inline bool operator!=(uint64_t Val) const { return ((uint64_t)VAL != Val); }
  inline bool operator!=(const ap_private<_AP_W, _AP_S>& RHS) const {
    return VAL != RHS.get_VAL();
  }
  inline bool operator!=(const ap_private<_AP_W, !_AP_S>& RHS) const {
    return (uint64_t)VAL != (uint64_t)RHS.get_VAL();
  }


  const ap_private operator++(int) {
    ap_private orig(*this);
    VAL++;
    clearUnusedBits();
    return orig;
  }


  const ap_private operator++() {
    ++VAL;
    clearUnusedBits();
    return *this;
  }


  const ap_private operator--(int) {
    ap_private orig(*this);
    --VAL;
    clearUnusedBits();
    return orig;
  }


  const ap_private operator--() {
    --VAL;
    clearUnusedBits();
    return *this;
  }


  inline ap_private<_AP_W + !_AP_S, true> operator~() const {
    ap_private<_AP_W + !_AP_S, true> Result(*this);
    Result.flip();
    return Result;
  }


  inline typename RType<1, false>::minus operator-() const {
    return ap_private<1, false>(0) - (*this);
  }


  inline bool operator!() const { return !VAL; }

  inline std::string toString(uint8_t radix, bool wantSigned) const;
  inline std::string toStringUnsigned(uint8_t radix = 10) const {
    return toString(radix, false);
  }
  inline std::string toStringSigned(uint8_t radix = 10) const {
    return toString(radix, true);
  }
  inline void clear() { VAL = 0; }
  inline ap_private& clear(uint32_t bitPosition) {
    VAL &= ~(1ULL << (bitPosition));
    clearUnusedBits();
    return *this;
  }

  inline ap_private ashr(uint32_t shiftAmt) const {
    if (_AP_S)
      return ap_private((shiftAmt == BitWidth) ? 0
                                               : ((int64_t)VAL) >> (shiftAmt));
    else
      return ap_private((shiftAmt == BitWidth) ? 0
                                               : ((uint64_t)VAL) >> (shiftAmt));
  }

  inline ap_private lshr(uint32_t shiftAmt) const {
    return ap_private((shiftAmt == BitWidth)
                          ? ap_private(0)
                          : ap_private((VAL & mask) >> (shiftAmt)));
  }

  inline ap_private shl(uint32_t shiftAmt) const




  {
    if (shiftAmt > BitWidth) {
      if (!isNegative())
        return ap_private(0);
      else
        return ap_private(-1);
    }
    if (shiftAmt == BitWidth)
      return ap_private(0);
    else
      return ap_private((VAL) << (shiftAmt));


  }

  inline int64_t getSExtValue() const { return VAL; }


  inline uint64_t getZExtValue() const { return VAL & mask; }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ref.get();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ((uint64_t)(bool)ref);
    check_canary();
  }
# 1867 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline void write(const ap_private<_AP_W, _AP_S>& op2) volatile {
    *this = (op2);
  }



  inline operator ValType() const { return get_VAL(); }

  inline int to_uchar() const { return (unsigned char)get_VAL(); }

  inline int to_char() const { return (signed char)get_VAL(); }

  inline int to_ushort() const { return (unsigned short)get_VAL(); }

  inline int to_short() const { return (short)get_VAL(); }

  inline int to_int() const {

    return (int)get_VAL();
  }

  inline unsigned to_uint() const { return (unsigned)get_VAL(); }

  inline long to_long() const { return (long)get_VAL(); }

  inline unsigned long to_ulong() const { return (unsigned long)get_VAL(); }

  inline ap_slong to_int64() const { return (ap_slong)get_VAL(); }

  inline ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }

  inline double to_double() const {
    if (isNegative())
      return roundToDouble(true);
    else
      return roundToDouble(false);
  }

  inline unsigned length() const { return _AP_W; }

  inline bool isMinValue() const { return VAL == 0; }
  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator&=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) & RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator|=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) | RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator^=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) ^ RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) * RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) + RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    VAL = (ValType)(((uint64_t)VAL) - RHS.get_VAL());
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator&(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) &
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret & RHS;
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator^(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) ^
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret ^ RHS;
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::logic operator|(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::logic_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::logic Ret(((uint64_t)VAL) |
                                                RHS.get_VAL());
      return Ret;
    } else {
      typename RType<_AP_W1, _AP_S1>::logic Ret = *this;
      return Ret | RHS;
    }
  }

  inline ap_private And(const ap_private& RHS) const {
    return ap_private(VAL & RHS.get_VAL());
  }

  inline ap_private Or(const ap_private& RHS) const {
    return ap_private(VAL | RHS.get_VAL());
  }

  inline ap_private Xor(const ap_private& RHS) const {
    return ap_private(VAL ^ RHS.get_VAL());
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::mult operator*(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::mult_w <= 64) {
      typename RType<_AP_W1, _AP_S1>::mult Result(((uint64_t)VAL) *
                                                  RHS.get_VAL());
      return Result;
    } else {
      typename RType<_AP_W1, _AP_S1>::mult Result(*this);
      Result *= RHS;
      return Result;
    }
  }

  inline ap_private Mul(const ap_private& RHS) const {
    return ap_private(VAL * RHS.get_VAL());
  }

  inline ap_private Add(const ap_private& RHS) const {
    return ap_private(VAL + RHS.get_VAL());
  }

  inline ap_private Sub(const ap_private& RHS) const {
    return ap_private(VAL - RHS.get_VAL());
  }

  inline ap_private& operator&=(uint64_t RHS) {
    VAL &= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator|=(uint64_t RHS) {
    VAL |= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator^=(uint64_t RHS) {
    VAL ^= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator*=(uint64_t RHS) {
    VAL *= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator+=(uint64_t RHS) {
    VAL += (ValType)RHS;
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator-=(uint64_t RHS) {
    VAL -= (ValType)RHS;
    clearUnusedBits();
    return *this;
  }

  inline bool isMinSignedValue() const {
    static const uint64_t min_mask = ~(~0ULL << (_AP_W - 1));
    return BitWidth == 1 ? VAL == 1
                         : (ap_private_ops::isNegative<_AP_W>(*this) &&
                            ((min_mask & VAL) == 0));
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::plus operator+(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::plus_w <= 64)
      return typename RType<_AP_W1, _AP_S1>::plus(
          RType<_AP_W1, _AP_S1>::plus_s
              ? int64_t(((uint64_t)VAL) + RHS.get_VAL())
              : uint64_t(((uint64_t)VAL) + RHS.get_VAL()));
    typename RType<_AP_W1, _AP_S1>::plus Result = RHS;
    Result += VAL;
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::minus operator-(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (RType<_AP_W1, _AP_S1>::minus_w <= 64)
      return typename RType<_AP_W1, _AP_S1>::minus(
          int64_t(((uint64_t)VAL) - RHS.get_VAL()));
    typename RType<_AP_W1, _AP_S1>::minus Result = *this;
    Result -= RHS;
    return Result;
  }

  inline uint32_t countPopulation() const {
    return ap_private_ops::CountPopulation_64(VAL);
  }
  inline uint32_t countLeadingZeros() const {
    int remainder = BitWidth % 64;
    int excessBits = (64 - remainder) % 64;
    uint32_t Count = ap_private_ops::CountLeadingZeros_64(VAL);
    if (Count) Count -= excessBits;
    return AESL_std::min(Count, (uint32_t)_AP_W);
  }


  inline ap_private<_AP_W, _AP_S> getHiBits(uint32_t numBits) const {
    ap_private<_AP_W, _AP_S> ret(*this);
    ret = (ret) >> (BitWidth - numBits);
    return ret;
  }


  inline ap_private<_AP_W, _AP_S> getLoBits(uint32_t numBits) const {
    ap_private<_AP_W, _AP_S> ret(((uint64_t)VAL) << (BitWidth - numBits));
    ret = (ret) >> (BitWidth - numBits);
    return ret;


  }

  inline ap_private<_AP_W, _AP_S>& set(uint32_t bitPosition) {
    VAL |= (1ULL << (bitPosition));
    clearUnusedBits();
    return *this;
  }

  inline void set() {
    VAL = (ValType)~0ULL;
    clearUnusedBits();
  }

  template <int _AP_W3>
  inline void set(const ap_private<_AP_W3, false>& val) {
    operator=(ap_private<_AP_W3, _AP_S>(val));
  }

  inline void set(const ap_private& val) { operator=(val); }

  inline void clearUnusedBits(void) volatile




  {
    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };
    VAL = (ValType)(
        _AP_S
            ? ((((int64_t)VAL) << (excess_bits)) >> (excess_bits))
            : (excess_bits ? (((uint64_t)VAL) << (excess_bits)) >> (excess_bits)
                           : (uint64_t)VAL));
  }

  inline void clearUnusedBitsToZero(void) {
    enum { excess_bits = (_AP_W % 64) ? 64 - _AP_W % 64 : 0 };
    static uint64_t mask = ~0ULL >> (excess_bits);
    VAL &= mask;
  }

  inline ap_private udiv(const ap_private& RHS) const {
    return ap_private((uint64_t)VAL / RHS.get_VAL());
  }



  inline ap_private sdiv(const ap_private& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return ((uint64_t)(0 - (*this))) / (uint64_t)(0 - RHS);
      else
        return 0 - ((uint64_t)(0 - (*this)) / (uint64_t)(RHS));
    else if (RHS.isNegative())
      return 0 - (this->udiv((ap_private)(0 - RHS)));
    return this->udiv(RHS);
  }

  template <bool _AP_S2>
  inline ap_private urem(const ap_private<_AP_W, _AP_S2>& RHS) const {
    
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   RHS.get_VAL() != 0 && "Divide by 0"
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "RHS.get_VAL() != 0 && \"Divide by 0\""
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2173),0))
# 2173 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                              ;
    return ap_private(((uint64_t)VAL) % ((uint64_t)RHS.get_VAL()));
  }



  template <bool _AP_S2>
  inline ap_private srem(const ap_private<_AP_W, _AP_S2>& RHS) const {
    if (isNegative()) {
      ap_private lhs = 0 - (*this);
      if (RHS.isNegative()) {
        ap_private rhs = 0 - RHS;
        return 0 - (lhs.urem(rhs));
      } else
        return 0 - (lhs.urem(RHS));
    } else if (RHS.isNegative()) {
      ap_private rhs = 0 - RHS;
      return this->urem(rhs);
    }
    return this->urem(RHS);
  }

  template <int _AP_W1, bool _AP_S1>
  inline bool eq(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return (*this) == RHS;
  }

  template <int _AP_W1, bool _AP_S1>
  inline bool ne(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ult(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    if (_AP_W1 <= 64) {
      uint64_t lhsZext = ((uint64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);
      uint64_t rhsZext =
          ((uint64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);
      return lhsZext < rhsZext;
    } else
      return RHS.uge(*this);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool slt(const ap_private<_AP_W1, _AP_S1>& RHS) const




  {
    if (_AP_W1 <= 64) {
      int64_t lhsSext = ((int64_t(VAL)) << (64 - _AP_W)) >> (64 - _AP_W);
      int64_t rhsSext =
          ((int64_t(RHS.get_VAL())) << (64 - _AP_W1)) >> (64 - _AP_W1);
      return lhsSext < rhsSext;
    } else
      return RHS.sge(*this);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ule(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sle(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool ugt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sgt(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool uge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !ult(RHS);
  }





  template <int _AP_W1, bool _AP_S1>
  inline bool sge(const ap_private<_AP_W1, _AP_S1>& RHS) const {
    return !slt(RHS);
  }

  inline ap_private abs() const {
    if (isNegative()) return -(*this);
    return *this;
  }

  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> ret(*this);
    return ret;
  }

  inline static uint32_t getBitsNeeded(const char* str, uint32_t slen,
                                       uint8_t radix) {
    return _AP_W;
  }

  inline uint32_t getActiveBits() const {
    uint32_t bits = _AP_W - countLeadingZeros();
    return bits ? bits : 1;
  }

  inline double roundToDouble(bool isSigned = false) const {
    return isSigned ? double((int64_t)VAL) : double((uint64_t)VAL);
  }



  inline ap_private& reverse() {
    for (int i = 0; i < _AP_W / 2; ++i) {
      bool tmp = operator[](i);
      if (operator[](_AP_W - 1 - i))
        set(i);
      else
        clear(i);
      if (tmp)
        set(_AP_W - 1 - i);
      else
        clear(_AP_W - 1 - i);
    }
    clearUnusedBits();
    return *this;
  }


  inline bool iszero() const { return isMinValue(); }

  inline bool to_bool() const { return !iszero(); }


  inline bool sign() const {
    if (isNegative()) return true;
    return false;
  }


  inline void invert(int i) {
    
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2349),0))
# 2349 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2350),0))
# 2350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    flip(i);
  }


  inline bool test(int i) const {
    
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2356),0))
# 2356 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2357),0))
# 2357 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return operator[](i);
  }



  inline void lrotate(int n) {
    
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2364),0))
# 2364 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2365),0))
# 2365 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(shl(n) | lshr(_AP_W - n));
  }



  inline void rrotate(int n) {
    
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2372),0))
# 2372 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2373),0))
# 2373 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(lshr(n) | shl(_AP_W - n));
  }


  inline void set(int i, bool v) {
    
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2379),0))
# 2379 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2380),0))
# 2380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline void set_bit(int i, bool v) {
    
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2386),0))
# 2386 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2387),0))
# 2387 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline bool get_bit(int i) const {
    
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2393),0))
# 2393 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2394),0))
# 2394 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return (((1ULL << i) & VAL) != 0);
  }


  inline ap_private& flip() {
    VAL = (ValType)((~0ULL ^ VAL) & mask);
    clearUnusedBits();
    return *this;
  }


  inline ap_private& flip(uint32_t bitPosition) {
    
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   bitPosition < BitWidth && "Out of the bit-width range!"
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "bitPosition < BitWidth && \"Out of the bit-width range!\""
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2407),0))
# 2407 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    set_bit(bitPosition, !get_bit(bitPosition));
    return *this;
  }


  inline void b_not() { flip(); }
# 2432 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::div operator/(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    return typename RType<_AP_W2, _AP_S2>::div(
        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::mod operator%(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    typename RType<_AP_W2, _AP_S2>::mod res =
        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)
                                                  : lhs.urem(rhs));
    return res;
  }
# 2472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator /=( const ap_private<_AP_W2, _AP_S2>& op) { *this = operator /(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private<_AP_W, _AP_S>& operator %=( const ap_private<_AP_W2, _AP_S2>& op) { *this = operator %(op); return *this; }
# 2490 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator<<(const char op) const { if (op >= _AP_W) return ap_private(0); if (CHAR_IS_SIGNED && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }



  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this << sh;
    } else {
      int sh = op2.to_int();
      return *this << sh;
    }
  }
# 2534 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator>>(const char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((CHAR_IS_SIGNED) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }



  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this >> sh;
    } else {
      int sh = op2.to_int();
      return *this >> sh;
    }
  }
# 2590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >>(op); clearUnusedBits(); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >>(op); clearUnusedBits(); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator >>(op); clearUnusedBits(); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator <<(op); clearUnusedBits(); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator <<(op); clearUnusedBits(); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator <<(op); clearUnusedBits(); return *this; }




  template <int _AP_W1, bool _AP_S1>
  inline bool operator==(const ap_private<_AP_W1, _AP_S1>& op) const {
    enum { _AP_MAX_W = ((((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) > (32) ? (((_AP_W) > (_AP_W1) ? (_AP_W) : (_AP_W1))) : (32)) };
    ap_private<_AP_MAX_W, false> lhs(*this);
    ap_private<_AP_MAX_W, false> rhs(op);
    if (_AP_MAX_W <= 64) {
      return (uint64_t)lhs.get_VAL() == (uint64_t)rhs.get_VAL();
    } else
      return lhs == rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this == op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);


    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);
    else if (_AP_W < 32 && _AP_W2 < 32)

      return lhs.sgt(rhs);
    else


        if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ugt(rhs);
      else
        return lhs.sgt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ugt(rhs);
    else
      return lhs.sgt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this > op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);
    else if (_AP_W < 32 && _AP_W2 < 32)
      return lhs.slt(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ult(rhs);
      else
        return lhs.slt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ult(rhs);
    else
      return lhs.slt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this < op);
  }




  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_bit_ref<_AP_W, _AP_S> operator[](int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }

  inline _private_bit_ref<_AP_W, _AP_S> bit(int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> bit(
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }
# 2915 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline bool and_reduce() const { return (VAL & mask) == mask; }

  inline bool nand_reduce() const { return (VAL & mask) != mask; }

  inline bool or_reduce() const { return (bool)VAL; }

  inline bool nor_reduce() const { return VAL == 0; }

  inline bool xor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? true : false;
  }

  inline bool xnor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? false : true;
  }

  inline std::string to_string(uint8_t radix = 2, bool sign = false) const {
    return toString(radix, radix == 10 ? _AP_S : sign);
  }
};

template <int _AP_W, bool _AP_S>
std::string ap_private<_AP_W, _AP_S, true>::toString(uint8_t radix,
                                                     bool wantSigned) const {
  
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,
                                           "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ,
                                           2942
# 2941 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ),0))
                                            
# 2942 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                           ;
  static const char* digits[] = {"0", "1", "2", "3", "4", "5", "6", "7",
                                 "8", "9", "a", "b", "c", "d", "e", "f"};
  std::string result;
  if (radix != 10) {





    if (*this == (uint64_t)(0)) {


      switch (radix) {
        case 2:
          result = "0b0";
          break;
        case 8:
          result = "0o0";
          break;
        case 16:
          result = "0x0";
          break;
        default:
          
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "invalid radix" && 0
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2966),0))
# 2966 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
      }
    } else {
      ap_private<_AP_W, false, true> tmp(*this);
      size_t insert_at = 0;
      bool leading_zero = true;
      if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        result = "-";
        insert_at = 1;
        leading_zero = false;
      }
      switch (radix) {
        case 2:
          result += "0b";
          break;
        case 8:
          result += "0o";
          break;
        case 16:
          result += "0x";
          break;
        default:
          
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "invalid radix" && 0
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",2993),0))
# 2993 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
      }
      insert_at += 2;


      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
      uint64_t mask = radix - 1;
      ap_private<_AP_W, false, true> zero(0);
      unsigned bits = 0;
      bool msb = false;
      while (tmp.ne(zero)) {
        unsigned digit = (unsigned)(tmp.get_VAL() & mask);
        result.insert(insert_at, digits[digit]);
        tmp = tmp.lshr(shift);
        bits++;
        msb = (digit >> (shift - 1)) == 1;
      }
      bits *= shift;
      if (bits < _AP_W && leading_zero && msb)
        result.insert(insert_at, digits[0]);
    }
    return result;
  }

  ap_private<_AP_W, false, true> tmp(*this);
  ap_private<6, false, true> divisor(radix);
  ap_private<_AP_W, _AP_S, true> zero(0);
  size_t insert_at = 0;
  if (wantSigned && isNegative()) {



    tmp.flip();
    tmp++;
    result = "-";
    insert_at = 1;
  }
  if (tmp == ap_private<_AP_W, false, true>(0ULL))
    result = "0";
  else
    while (tmp.ne(zero)) {
      ap_private<_AP_W, false, true> APdigit = tmp % divisor;
      ap_private<_AP_W, false, true> tmp2 = tmp / divisor;
      uint32_t digit = (uint32_t)(APdigit.getZExtValue());
      
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     digit < radix && "divide failed"
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "digit < radix && \"divide failed\""
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3037),0))
# 3037 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
      result.insert(insert_at, digits[digit]);
      tmp = tmp2;
    }
  return result;

}


template <int _AP_W, bool _AP_S>
class ap_private<_AP_W, _AP_S, false> {

  const static bool valid = ap_private_enable_if<(_AP_W > 64)>::isValid;




 public:
  enum { BitWidth = _AP_W, _AP_N = (_AP_W + 63) / 64 };
  static const int width = _AP_W;

 private:
# 3069 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(uint32_t numWords, const uint64_t bigVal[]) {
    set_canary();
    
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   bigVal && "Null pointer detected!"
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "bigVal && \"Null pointer detected!\""
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3071),0))
# 3071 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    {

      memset(pVal, 0, _AP_N * sizeof(uint64_t));


      uint32_t words = AESL_std::min<uint32_t>(numWords, _AP_N);

      memcpy(pVal, bigVal, words * APINT_WORD_SIZE);
      if (words >= _AP_W) clearUnusedBits();

    }
    check_canary();
  }
# 3094 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(const std::string& val, uint8_t radix = 2) {
    set_canary();
    
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   !val.empty() && "The input string is empty."
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "!val.empty() && \"The input string is empty.\""
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3096),0))
# 3096 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                       ;
    const char* c_str = val.c_str();
    fromString(c_str, val.size(), radix);
    check_canary();
  }
# 3112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(const char strStart[], uint32_t slen, uint8_t radix) {
    set_canary();
    fromString(strStart, slen, radix);
    check_canary();
  }

  inline void report() {
    do { if ((_AP_W > ((1024 + 1023) / 1024) * 1024)) { fprintf(
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "ERROR: " "ap_%sint<%d>: Bitwidth exceeds the " "default max value %d. Please use macro " "AP_INT_MAX_W to set a larger max value.", _AP_S ? "" : "u", _AP_W, ((1024 + 1023) / 1024) * 1024); fprintf(
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 3119 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); abort(); } } while (0)



                                                                     ;
  }





  uint64_t pVal[_AP_N];





  inline void check_canary() {}
  inline void set_canary() {}


 public:
  typedef typename valtype<8, _AP_S>::Type ValType;
  typedef ap_private<_AP_W, _AP_S> Type;

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  friend struct ap_fixed_base;


  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };
    typedef ap_private<mult_w, mult_s> mult;
    typedef ap_private<plus_w, plus_s> plus;
    typedef ap_private<minus_w, minus_s> minus;
    typedef ap_private<logic_w, logic_s> logic;
    typedef ap_private<div_w, div_s> div;
    typedef ap_private<mod_w, mod_s> mod;
    typedef ap_private<_AP_W, _AP_S> arg1;
    typedef bool reduce;
  };

  inline uint64_t& get_VAL(void) { return pVal[0]; }
  inline uint64_t get_VAL(void) const { return pVal[0]; }
  inline uint64_t get_VAL(void) const volatile { return pVal[0]; }
  inline void set_VAL(uint64_t value) { pVal[0] = value; }
  inline uint64_t& get_pVal(int index) { return pVal[index]; }
  inline uint64_t* get_pVal() { return pVal; }
  inline const uint64_t* get_pVal() const { return pVal; }
  inline uint64_t get_pVal(int index) const { return pVal[index]; }
  inline uint64_t* get_pVal() const volatile { return pVal; }
  inline uint64_t get_pVal(int index) const volatile { return pVal[index]; }
  inline void set_pVal(int i, uint64_t value) { pVal[i] = value; }


  enum {
    APINT_BITS_PER_WORD = sizeof(uint64_t) * 8,
    APINT_WORD_SIZE = sizeof(uint64_t)
  };

  enum {
    excess_bits = (_AP_W % APINT_BITS_PER_WORD)
                      ? APINT_BITS_PER_WORD - (_AP_W % APINT_BITS_PER_WORD)
                      : 0
  };
  static const uint64_t mask = ((uint64_t)~0ULL >> (excess_bits));

 public:

  explicit inline ap_private(const char* val) {
    set_canary();
    unsigned char radix = 10;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');
    if (pos != std::string::npos) str = str.substr(pos);
    ap_private ap_private_val(str, radix);
    operator=(ap_private_val);
    report();
    check_canary();
  }

  inline ap_private(const char* val, unsigned char rd) {
    set_canary();
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(val, radix);
    std::string::size_type pos = str.find('.');
    if (pos != std::string::npos) str = str.substr(pos);
    ap_private ap_private_val(str, radix);
    operator=(ap_private_val);
    report();

    report();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ref.get();
    report();
    check_canary();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private(const _private_bit_ref<_AP_W2, _AP_S2>& ref) {
    set_canary();
    *this = ((uint64_t)(bool)ref);
    report();
    check_canary();
  }
# 3276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(const ap_private& that) {
      set_canary();
      memcpy(pVal, that.get_pVal(), _AP_N * APINT_WORD_SIZE);
      clearUnusedBits();
      check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, false>& that) {
    set_canary();
    operator=(that);
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, false>& that) {
    set_canary();
    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, false>&>(that));
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const ap_private<_AP_W1, _AP_S1, true>& that) {
    set_canary();
    static const uint64_t that_sign_ext_mask =
        (_AP_W1 == APINT_BITS_PER_WORD)
            ? 0
            : ~0ULL >> (_AP_W1 % APINT_BITS_PER_WORD)
                           << (_AP_W1 % APINT_BITS_PER_WORD);
    if (that.isNegative()) {
      pVal[0] = that.get_VAL() | that_sign_ext_mask;
      memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1));
    } else {
      pVal[0] = that.get_VAL();
      memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1));
    }
    clearUnusedBits();
    check_canary();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private(const volatile ap_private<_AP_W1, _AP_S1, true>& that) {
    set_canary();
    operator=(const_cast<const ap_private<_AP_W1, _AP_S1, true>&>(that));
    check_canary();
  }



  inline ~ap_private() { check_canary(); }







  inline ap_private() {
    set_canary();
    clearUnusedBits();
    check_canary();
  }

  inline ap_private(uint64_t* val, uint32_t bits = _AP_W) { 
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                           (void) ((!!(
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           0
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                           )) || (_assert(
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           "0"
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                           ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3339),0))
# 3339 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                    ; }
  inline ap_private(const uint64_t* const val, uint32_t bits) { 
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                               (void) ((!!(
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                               0
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                               )) || (_assert(
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                               "0"
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                                                               ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3340),0))
# 3340 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                        ; }
# 3363 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private(bool val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(char val, bool isSigned = CHAR_IS_SIGNED) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(signed char val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned char val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(short val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned short val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(int val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned int val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(long val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(unsigned long val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(ap_slong val, bool isSigned = true) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(ap_ulong val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(half val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(float val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }
  inline ap_private(double val, bool isSigned = false) { set_canary(); pVal[0] = (ValType)val; if (isSigned && int64_t(pVal[0]) < 0) { memset(pVal + 1, ~0, sizeof(uint64_t) * (_AP_N - 1)); } else { memset(pVal + 1, 0, sizeof(uint64_t) * (_AP_N - 1)); } clearUnusedBits(); check_canary(); }




  inline bool isSingleWord() const { return false; }



  static inline uint32_t whichWord(uint32_t bitPosition) {

    return (bitPosition) >> 6;
  }




  static inline uint32_t whichBit(uint32_t bitPosition) {

    return bitPosition & 0x3f;
  }





  static inline uint64_t maskBit(uint32_t bitPosition) {
    return 1ULL << (whichBit(bitPosition));
  }



  inline uint64_t getWord(uint32_t bitPosition) const {
    return pVal[whichWord(bitPosition)];
  }






  inline void clearUnusedBits(void) volatile




  {
    pVal[_AP_N - 1] =
        _AP_S ? ((((int64_t)pVal[_AP_N - 1]) << (excess_bits)) >> excess_bits)
              : (excess_bits
                     ? ((pVal[_AP_N - 1]) << (excess_bits)) >> (excess_bits)
                     : pVal[_AP_N - 1]);
  }

  inline void clearUnusedBitsToZero(void) { pVal[_AP_N - 1] &= mask; }

  inline void clearUnusedBitsToOne(void) { pVal[_AP_N - 1] |= mask; }



  inline void fromString(const char* str, uint32_t slen, uint8_t radix) {
    enum { numbits = _AP_W };
    bool isNeg = str[0] == '-';
    if (isNeg) {
      str++;
      slen--;
    }

    if (str[0] == '0' && (str[1] == 'b' || str[1] == 'B')) {

      do { if ((radix != 2)) { fprintf(
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 2, radix); fprintf(
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3447 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'o' || str[1] == 'O')) {

      do { if ((radix != 8)) { fprintf(
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 8, radix); fprintf(
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3452 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'x' || str[1] == 'X')) {

      do { if ((radix != 16)) { fprintf(
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 16, radix); fprintf(
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3457 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (str[0] == '0' && (str[1] == 'd' || str[1] == 'D')) {

      do { if ((radix != 10)) { fprintf(
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "WARNING: " "%s seems to have base %d, but %d given.", str, 10, radix); fprintf(
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (&__iob_func()[2])
# 3462 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     , "\n"); } } while (0);
      str += 2;
      slen -=2;
    } else if (radix == 0) {

    }


    
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                             "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                             3471
# 3470 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                              
# 3471 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   str && "String is null?"
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "str && \"String is null?\""
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3472),0))
# 3472 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;


    while (*str == '0' && *(str + 1) != '\0') {
      str++;
      slen--;
    }
    
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (slen <= numbits || radix != 2) && "Insufficient bit width"
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(slen <= numbits || radix != 2) && \"Insufficient bit width\""
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3479),0))
# 3479 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                      ;
    
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   ((slen - 1) * 3 <= numbits || radix != 8) && "Insufficient bit width"
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "((slen - 1) * 3 <= numbits || radix != 8) && \"Insufficient bit width\""
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                   3481
# 3480 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                    
# 3481 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;
    
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   ((slen - 1) * 4 <= numbits || radix != 16) && "Insufficient bit width"
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "((slen - 1) * 4 <= numbits || radix != 16) && \"Insufficient bit width\""
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                   3483
# 3482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                    
# 3483 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;
    
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   (((slen - 1) * 64) / 22 <= numbits || radix != 10) && "Insufficient bit width"
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "(((slen - 1) * 64) / 22 <= numbits || radix != 10) && \"Insufficient bit width\""
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,
                                   "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ,
                                   3485
# 3484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
    ),0))
                                    
# 3485 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                   ;


    memset(pVal, 0, _AP_N * sizeof(uint64_t));


    uint32_t shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);



    uint64_t bigVal[_AP_N];
    memset(bigVal, 0, _AP_N * sizeof(uint64_t));
    ap_private<_AP_W, _AP_S> apdigit(getBitWidth(), bigVal);
    ap_private<_AP_W, _AP_S> apradix(radix);


    for (unsigned i = 0; i < slen; i++) {

      uint32_t digit = 0;
      char cdigit = str[i];
      if (radix == 16) {




        if (!(((cdigit) >= '0' && (cdigit) <= '9') || ((cdigit) >= 'a' && (cdigit) <= 'f') || ((cdigit) >= 'A' && (cdigit) <= 'F'))) 
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                              (void) ((!!(
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                              0 && "Invalid hex digit in string"
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                              )) || (_assert(
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                              "0 && \"Invalid hex digit in string\""
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
                              ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3510),0))
# 3510 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                        ;
        if (((cdigit) >= '0' && (cdigit) <= '9'))
          digit = cdigit - '0';
        else if (cdigit >= 'a')
          digit = cdigit - 'a' + 10;
        else if (cdigit >= 'A')
          digit = cdigit - 'A' + 10;
        else
          
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         0 && "huh? we shouldn't get here"
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "0 && \"huh? we shouldn't get here\""
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3518),0))
# 3518 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                  ;
      } else if (((cdigit) >= '0' && (cdigit) <= '9')) {
        digit = cdigit - '0';
      } else if (cdigit != '\0') {
        
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       (void) ((!!(
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       0 && "Invalid character in digit string"
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       )) || (_assert(
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
       "0 && \"Invalid character in digit string\""
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
       ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3522),0))
# 3522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                       ;
      }



      if (shift)
        *this <<= shift;
      else
        *this *= apradix;


      apdigit.set_VAL(digit);
      *this += apdigit;
    }

    if (isNeg) {
      (*this)--;
      this->flip();
    }
    clearUnusedBits();
  }

  inline ap_private read() volatile { return *this; }

  inline void write(const ap_private& op2) volatile { *this = (op2); }

  inline operator ValType() const { return get_VAL(); }

  inline int to_uchar() const { return (unsigned char)get_VAL(); }

  inline int to_char() const { return (signed char)get_VAL(); }

  inline int to_ushort() const { return (unsigned short)get_VAL(); }

  inline int to_short() const { return (short)get_VAL(); }

  inline int to_int() const { return (int)get_VAL(); }

  inline unsigned to_uint() const { return (unsigned)get_VAL(); }

  inline long to_long() const { return (long)get_VAL(); }

  inline unsigned long to_ulong() const { return (unsigned long)get_VAL(); }

  inline ap_slong to_int64() const { return (ap_slong)get_VAL(); }

  inline ap_ulong to_uint64() const { return (ap_ulong)get_VAL(); }

  inline double to_double() const {
    if (isNegative())
      return roundToDouble(true);
    else
      return roundToDouble(false);
  }

  inline unsigned length() const { return _AP_W; }



  inline ap_private& reverse() {
    for (int i = 0; i < _AP_W / 2; ++i) {
      bool tmp = operator[](i);
      if (operator[](_AP_W - 1 - i))
        set(i);
      else
        clear(i);
      if (tmp)
        set(_AP_W - 1 - i);
      else
        clear(_AP_W - 1 - i);
    }
    clearUnusedBits();
    return *this;
  }


  inline bool iszero() const { return isMinValue(); }

  inline bool to_bool() const { return !iszero(); }


  inline bool sign() const {
    if (isNegative()) return true;
    return false;
  }


  inline void invert(int i) {
    
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3610),0))
# 3610 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3611),0))
# 3611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    flip(i);
  }


  inline bool test(int i) const {
    
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3617),0))
# 3617 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3618),0))
# 3618 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return operator[](i);
  }


  inline void set(int i, bool v) {
    
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3624),0))
# 3624 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3625),0))
# 3625 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline void set_bit(int i, bool v) {
    
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to write bit with negative index"
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to write bit with negative index\""
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3631),0))
# 3631 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to write bit beyond MSB"
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to write bit beyond MSB\""
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3632),0))
# 3632 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                            ;
    v ? set(i) : clear(i);
  }


  inline ap_private& set(uint32_t bitPosition) {
    pVal[whichWord(bitPosition)] |= maskBit(bitPosition);
    clearUnusedBits();
    return *this;
  }

  inline void set() {
    for (int i = 0; i < _AP_N; ++i) pVal[i] = ~0ULL;
    clearUnusedBits();
  }


  inline bool get(int i) const {
    
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3650),0))
# 3650 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3651),0))
# 3651 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
  }


  inline bool get_bit(int i) const {
    
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i >= 0 && "Attempting to read bit with negative index"
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i >= 0 && \"Attempting to read bit with negative index\""
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3657),0))
# 3657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                 ;
    
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   i < _AP_W && "Attempting to read bit beyond MSB"
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "i < _AP_W && \"Attempting to read bit beyond MSB\""
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3658),0))
# 3658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    return ((maskBit(i) & (pVal[whichWord(i)])) != 0);
  }



  inline void lrotate(int n) {
    
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3665),0))
# 3665 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3666),0))
# 3666 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(shl(n) | lshr(_AP_W - n));
  }



  inline void rrotate(int n) {
    
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n >= 0 && "Attempting to shift negative index"
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n >= 0 && \"Attempting to shift negative index\""
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3673),0))
# 3673 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                         ;
    
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   n < _AP_W && "Shift value larger than bit width"
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "n < _AP_W && \"Shift value larger than bit width\""
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3674),0))
# 3674 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                           ;
    operator=(lshr(n) | shl(_AP_W - n));
  }



  inline ap_private& clear(uint32_t bitPosition) {
    pVal[whichWord(bitPosition)] &= ~maskBit(bitPosition);
    clearUnusedBits();
    return *this;
  }


  inline void clear() { memset(pVal, 0, _AP_N * APINT_WORD_SIZE); }


  ap_private& flip() {
    for (int i = 0; i < _AP_N; ++i) pVal[i] ^= ~0ULL;
    clearUnusedBits();
    return *this;
  }


  inline ap_private& flip(uint32_t bitPosition) {
    
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   bitPosition < BitWidth && "Out of the bit-width range!"
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "bitPosition < BitWidth && \"Out of the bit-width range!\""
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",3698),0))
# 3698 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;
    set_bit(bitPosition, !get_bit(bitPosition));
    return *this;
  }


  inline void b_not() { flip(); }

  inline ap_private getLoBits(uint32_t numBits) const {
    return ap_private_ops::lshr(ap_private_ops::shl(*this, _AP_W - numBits),
                                _AP_W - numBits);
  }

  inline ap_private getHiBits(uint32_t numBits) const {
    return ap_private_ops::lshr(*this, _AP_W - numBits);
  }
# 3757 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator &=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
# 3757 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (&__iob_func()[2])
# 3757 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "&=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] &= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] &= ext; } clearUnusedBits(); return *this; };
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator |=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
# 3758 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (&__iob_func()[2])
# 3758 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "|=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] |= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] |= ext; } clearUnusedBits(); return *this; };
  template <int _AP_W1, bool _AP_S1> inline ap_private& operator ^=(const ap_private<_AP_W1, _AP_S1>& RHS) { const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t numWords = AESL_std::min((int)_AP_N, _AP_N1); uint32_t i; if (_AP_W != _AP_W1) fprintf(
# 3759 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (&__iob_func()[2])
# 3759 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 , "Warning! Bitsize mismach for ap_[u]int " "^=" " ap_[u]int.\n"); for (i = 0; i < numWords; ++i) pVal[i] ^= RHS.get_pVal(i); if (_AP_N1 < _AP_N) { uint64_t ext = RHS.isNegative() ? ~0ULL : 0; for (; i < _AP_N; i++) pVal[i] ^= ext; } clearUnusedBits(); return *this; };





  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator+=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    uint64_t RHSpVal[_AP_N1];
    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);
    ap_private_ops::add(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,
                        _AP_S1);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator-=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    uint64_t RHSpVal[_AP_N1];
    for (int i = 0; i < _AP_N1; ++i) RHSpVal[i] = RHS.get_pVal(i);
    ap_private_ops::sub(pVal, pVal, RHSpVal, _AP_N, _AP_N, _AP_N1, _AP_S,
                        _AP_S1);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator*=(const ap_private<_AP_W1, _AP_S1>& RHS) {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : whichWord(lhsBits - 1) + 1;
    if (!lhsWords) {

      return *this;
    }

    ap_private dupRHS = RHS;

    uint32_t rhsBits = dupRHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : whichWord(rhsBits - 1) + 1;
    if (!rhsWords) {

      clear();
      return *this;
    }


    uint32_t destWords = rhsWords + lhsWords;
    uint64_t* dest = (uint64_t*)malloc(destWords * sizeof(uint64_t));


    ap_private_ops::mul(dest, pVal, lhsWords, dupRHS.get_pVal(), rhsWords,
                        destWords);


    clear();
    uint32_t wordsToCopy = destWords >= _AP_N ? _AP_N : destWords;

    memcpy(pVal, dest, wordsToCopy * APINT_WORD_SIZE);

    uint64_t ext = (isNegative() ^ RHS.isNegative()) ? ~0ULL : 0ULL;
    for (int i = wordsToCopy; i < _AP_N; i++) pVal[i] = ext;
    clearUnusedBits();

    free(dest);
    return *this;
  }
# 3836 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator /=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator /(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator %=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator %(op); return *this; }
# 3876 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator |( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] | RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] | ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) | ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext | ext2); } } Result.clearUnusedBits(); return Result; };
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator &( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] & RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] & ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) & ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext & ext2); } } Result.clearUnusedBits(); return Result; };
  template <int _AP_W1, bool _AP_S1> inline typename RType<_AP_W1, _AP_S1>::logic operator ^( const ap_private<_AP_W1, _AP_S1>& RHS) const { enum { numWords = (RType<_AP_W1, _AP_S1>::logic_w + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD }; typename RType<_AP_W1, _AP_S1>::logic Result; uint32_t i; const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N; uint32_t min_N = std::min((int)_AP_N, _AP_N1); uint32_t max_N = std::max((int)_AP_N, _AP_N1); for (i = 0; i < min_N; ++i) Result.set_pVal(i, pVal[i] ^ RHS.get_pVal(i)); if (numWords > i) { uint64_t ext = ((_AP_N < _AP_N1 && isNegative()) || (_AP_N1 < _AP_N && RHS.isNegative())) ? ~0ULL : 0; if (_AP_N > _AP_N1) for (; i < max_N; i++) Result.set_pVal(i, pVal[i] ^ ext); else for (; i < max_N; i++) Result.set_pVal(i, RHS.get_pVal(i) ^ ext); if (numWords > i) { uint64_t ext2 = ((_AP_N > _AP_N1 && isNegative()) || (_AP_N1 > _AP_N && RHS.isNegative())) ? ~0ULL : 0; Result.set_pVal(i, ext ^ ext2); } } Result.clearUnusedBits(); return Result; };



  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::plus operator+(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::plus Result, lhs(*this), rhs(RHS);
    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::plus_w + 63) / 64;
    ap_private_ops::add(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),
                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
    Result.clearUnusedBits();
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::minus operator-(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::minus Result, lhs(*this), rhs(RHS);
    const int Result_AP_N = (RType<_AP_W1, _AP_S1>::minus_w + 63) / 64;
    ap_private_ops::sub(Result.get_pVal(), lhs.get_pVal(), rhs.get_pVal(),
                        Result_AP_N, Result_AP_N, Result_AP_N, _AP_S, _AP_S1);
    Result.clearUnusedBits();
    return Result;
  }

  template <int _AP_W1, bool _AP_S1>
  inline typename RType<_AP_W1, _AP_S1>::mult operator*(
      const ap_private<_AP_W1, _AP_S1>& RHS) const {
    typename RType<_AP_W1, _AP_S1>::mult temp = *this;
    temp *= RHS;
    return temp;
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::div operator/(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    return typename RType<_AP_W2, _AP_S2>::div(
        (_AP_S || _AP_S2) ? lhs.sdiv(rhs) : lhs.udiv(rhs));
  }

  template <int _AP_W2, bool _AP_S2>
  inline typename RType<_AP_W2, _AP_S2>::mod operator%(
      const ap_private<_AP_W2, _AP_S2>& op) const {
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        lhs = *this;
    ap_private<((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2))),
               (_AP_W > _AP_W2 ? _AP_S
                               : (_AP_W2 > _AP_W ? _AP_S2 : _AP_S || _AP_S2))>
        rhs = op;
    typename RType<_AP_W2, _AP_S2>::mod res =
        typename RType<_AP_W2, _AP_S2>::mod(_AP_S ? lhs.srem(rhs)
                                                  : lhs.urem(rhs));
    return res;
  }
# 3951 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator<<(const int op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }

  inline ap_private operator<<(const signed char op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned char op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const short op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned short op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned int op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const unsigned long long op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const long long op) const { if (op >= _AP_W) return ap_private(0); if (true && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const half op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const float op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }
  inline ap_private operator<<(const double op) const { if (op >= _AP_W) return ap_private(0); if (false && op < 0) return *this >> (0 - op); return shl(op); }


  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator<<(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this << sh;
    } else {
      int sh = op2.to_int();
      return *this << sh;
    }
  }
# 3994 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private operator>>(const char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((CHAR_IS_SIGNED) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const signed char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned char op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned short op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned int op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const unsigned long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const long long op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((true) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const half op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const float op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }
  inline ap_private operator>>(const double op) const { if (op >= _AP_W) { if (isNegative()) return ap_private(-1); else return ap_private(0); } if ((false) && op < 0) return *this << (0 - op); if (_AP_S) return ashr(op); else return lshr(op); }


  template <int _AP_W2, bool _AP_S2>
  inline ap_private operator>>(const ap_private<_AP_W2, _AP_S2>& op2) const {
    if (_AP_S2 == false) {
      uint32_t sh = op2.to_uint();
      return *this >> sh;
    } else {
      int sh = op2.to_int();
      return *this >> sh;
    }
  }
# 4039 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(int op) { *this = operator >>(op); return *this; } inline ap_private& operator >>=(unsigned int op) { *this = operator >>(op); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator >>=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator >>(op); return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(int op) { *this = operator <<(op); return *this; } inline ap_private& operator <<=(unsigned int op) { *this = operator <<(op); return *this; } template <int _AP_W2, bool _AP_S2> inline ap_private& operator <<=(const ap_private<_AP_W2, _AP_S2>& op) { *this = operator <<(op); return *this; }




  inline bool operator==(const ap_private& RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 = RHS.getActiveBits();


    if (n1 != n2) return false;



    if (n1 <= APINT_BITS_PER_WORD) return pVal[0] == RHS.get_pVal(0);


    for (int i = whichWord(n1 - 1); i >= 0; --i)
      if (pVal[i] != RHS.get_pVal(i)) return false;
    return true;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W) > (_AP_W2) ? (_AP_W) : (_AP_W2)),
    };
    ap_private<_AP_MAX_W, false> lhs(*this);
    ap_private<_AP_MAX_W, false> rhs(op);
    return lhs == rhs;
  }

  inline bool operator==(uint64_t Val) const {
    uint32_t n = getActiveBits();
    if (n <= APINT_BITS_PER_WORD)
      return pVal[0] == Val;
    else
      return false;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this == op);
  }

  template <bool _AP_S1>
  inline bool operator!=(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }

  inline bool operator!=(uint64_t Val) const { return !((*this) == Val); }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this > op);
  }

  inline bool operator<(const ap_private& op) const {
    return _AP_S ? slt(op) : ult(op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.slt(rhs) : lhs.ult(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ult(rhs);
      else
        return lhs.slt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ult(rhs);
    else
      return lhs.slt(rhs);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_private<_AP_W2, _AP_S2>& op) const {
    return !(*this < op);
  }

  inline bool operator>(const ap_private& op) const {
    return _AP_S ? sgt(op) : ugt(op);
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_private<_AP_W2, _AP_S2>& op) const {
    enum {
      _AP_MAX_W = ((_AP_W + (_AP_S || _AP_S2)) > (_AP_W2 + (_AP_S || _AP_S2)) ? (_AP_W + (_AP_S || _AP_S2)) : (_AP_W2 + (_AP_S || _AP_S2)))
    };
    ap_private<_AP_MAX_W, _AP_S> lhs(*this);
    ap_private<_AP_MAX_W, _AP_S2> rhs(op);
    if (_AP_S == _AP_S2)
      return _AP_S ? lhs.sgt(rhs) : lhs.ugt(rhs);
    else if (_AP_S)
      if (_AP_W2 >= _AP_W)
        return lhs.ugt(rhs);
      else
        return lhs.sgt(rhs);
    else if (_AP_W >= _AP_W2)
      return lhs.ugt(rhs);
    else
      return lhs.sgt(rhs);
  }



  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>*>(this), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    return _private_range_ref<_AP_W, _AP_S>(
        (const_cast<ap_private<_AP_W, _AP_S>*>(this)), Hi, Lo);
  }

  inline _private_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> range(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> operator()(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> range(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return _private_range_ref<_AP_W, _AP_S>(const_cast<ap_private*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline _private_range_ref<_AP_W, _AP_S> operator()(
      const ap_private<_AP_W2, _AP_S2>& HiIdx,
      const ap_private<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline _private_bit_ref<_AP_W, _AP_S> operator[](int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> operator[](
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> operator[](int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  inline _private_bit_ref<_AP_W, _AP_S> bit(int index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_bit_ref<_AP_W, _AP_S> bit(const ap_private<_AP_W2, _AP_S2>& index) {
    return _private_bit_ref<_AP_W, _AP_S>(*this, index.to_int());
  }

  inline const _private_bit_ref<_AP_W, _AP_S> bit(int index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline const _private_bit_ref<_AP_W, _AP_S> bit(
      const ap_private<_AP_W2, _AP_S2>& index) const {
    return _private_bit_ref<_AP_W, _AP_S>(
        const_cast<ap_private<_AP_W, _AP_S>&>(*this), index.to_int());
  }
# 4409 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> ret(*this);
    return ret;
  }

  template <int _AP_W3>
  inline void set(const ap_private<_AP_W3, false>& val) {
    operator=(ap_private<_AP_W3, _AP_S>(val));
  }







  inline bool isNegative() const {

    enum { shift = (_AP_W - APINT_BITS_PER_WORD * (_AP_N - 1) - 1) };
    static const uint64_t mask = 1ULL << (shift);
    return _AP_S && (pVal[_AP_N - 1] & mask);
  }



  inline bool isPositive() const { return !isNegative(); }




  inline bool isStrictlyPositive() const {
    return isPositive() && (*this) != 0;
  }




  inline bool isAllOnesValue() const { return countPopulation() == _AP_W; }




  inline bool isMaxValue() const { return countPopulation() == _AP_W; }




  inline bool isMaxSignedValue() const {
    return !isNegative() && countPopulation() == _AP_W - 1;
  }




  inline bool isMinValue() const { return countPopulation() == 0; }




  inline bool isMinSignedValue() const {
    return isNegative() && countPopulation() == 1;
  }




  inline const uint64_t* getRawData() const { return &pVal[0]; }
# 4484 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private sqrt() const {

    uint32_t magnitude = getActiveBits();



    if (magnitude <= 5) {
      static const uint8_t results[32] = {
                      0,
                      1, 1,
                      2, 2, 2, 2,
                      3, 3, 3, 3, 3, 3,
                      4, 4, 4, 4, 4, 4, 4, 4,
                      5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                      6};
      return ap_private<_AP_W, _AP_S>( results[get_VAL()]);
    }





    if (magnitude < 52) {






      return ap_private<_AP_W, _AP_S>(
                                      uint64_t(
                                          ::round(::sqrt(double(get_VAL())))));

    }






    uint32_t nbits = BitWidth, i = 4;
    ap_private<_AP_W, _AP_S> testy(16);
    ap_private<_AP_W, _AP_S> x_old( 1);
    ap_private<_AP_W, _AP_S> x_new(0);
    ap_private<_AP_W, _AP_S> two( 2);


    for (;; i += 2, testy = testy.shl(2))
      if (i >= nbits || this->ule(testy)) {
        x_old = x_old.shl(i / 2);
        break;
      }


    for (;;) {
      x_new = (this->udiv(x_old) + x_old).udiv(two);
      if (x_old.ule(x_new)) break;
      x_old = x_new;
    }
# 4551 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
    ap_private<_AP_W, _AP_S> square(x_old * x_old);
    ap_private<_AP_W, _AP_S> nextSquare((x_old + 1) * (x_old + 1));
    if (this->ult(square))
      return x_old;
    else if (this->ule(nextSquare)) {
      ap_private<_AP_W, _AP_S> midpoint((nextSquare - square).udiv(two));
      ap_private<_AP_W, _AP_S> offset(*this - square);
      if (offset.ult(midpoint))
        return x_old;
      else
        return x_old + 1;
    } else
      
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     0 && "Error in ap_private<_AP_W, _AP_S>::sqrt computation"
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "0 && \"Error in ap_private<_AP_W, _AP_S>::sqrt computation\""
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4563),0))
# 4563 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                       ;
    return x_old + 1;
  }






  inline ap_private& operator=(const ap_private& RHS) {
    if (this != &RHS) memcpy(pVal, RHS.get_pVal(), _AP_N * APINT_WORD_SIZE);
    clearUnusedBits();
    return *this;
  }
  inline ap_private& operator=(const volatile ap_private& RHS) {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    clearUnusedBits();
    return *this;
  }
  inline void operator=(const ap_private& RHS) volatile {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    clearUnusedBits();
  }
  inline void operator=(const volatile ap_private& RHS) volatile {
    if (this != &RHS)
      for (int i = 0; i < _AP_N; ++i) pVal[i] = RHS.get_pVal(i);
    clearUnusedBits();
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator=(const ap_private<_AP_W1, _AP_S1>& RHS) {
    if (_AP_S1)
      cpSextOrTrunc(RHS);
    else
      cpZextOrTrunc(RHS);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W1, bool _AP_S1>
  inline ap_private& operator=(const volatile ap_private<_AP_W1, _AP_S1>& RHS) {
    if (_AP_S1)
      cpSextOrTrunc(RHS);
    else
      cpZextOrTrunc(RHS);
    clearUnusedBits();
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_private& operator=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    *this = ap_private<_AP_W2, false>(op2);
    return *this;
  }
# 4658 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private& operator=(const bool rhs) { ap_private<(1), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const char rhs) { ap_private<(8), (CHAR_IS_SIGNED)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const signed char rhs) { ap_private<(8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned char rhs) { ap_private<(8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const short rhs) { ap_private<(sizeof(short) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned short rhs) { ap_private<(sizeof(unsigned short) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const int rhs) { ap_private<(sizeof(int) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned int rhs) { ap_private<(sizeof(unsigned int) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const long rhs) { ap_private<(sizeof(long) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const unsigned long rhs) { ap_private<(sizeof(unsigned long) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const ap_slong rhs) { ap_private<(sizeof(ap_slong) * 8), (true)> tmp = rhs; operator=(tmp); return *this; }
  inline ap_private& operator=(const ap_ulong rhs) { ap_private<(sizeof(ap_ulong) * 8), (false)> tmp = rhs; operator=(tmp); return *this; }




  inline ap_private& operator=(const char* s) {
    ap_private tmp(s);
    operator=(tmp);
    return *this;
  }






  inline const ap_private operator++(int) {
    ap_private API(*this);
    ++(*this);
    return API;
  }



  inline ap_private& operator++() {
    ap_private_ops::add_1(pVal, pVal, _AP_N, 1);
    clearUnusedBits();
    return *this;
  }



  inline const ap_private operator--(int) {
    ap_private API(*this);
    --(*this);
    return API;
  }



  inline ap_private& operator--() {
    ap_private_ops::sub_1(pVal, _AP_N, 1);
    clearUnusedBits();
    return *this;
  }




  inline ap_private<_AP_W + !_AP_S, true> operator~() const {
    ap_private<_AP_W + !_AP_S, true> Result(*this);
    Result.flip();
    return Result;
  }




  inline typename RType<1, false>::minus operator-() const {
    return ap_private<1, false>(0) - (*this);
  }




  inline bool operator!() const {
    for (int i = 0; i < _AP_N; ++i)
      if (pVal[i]) return false;
    return true;
  }

  template <bool _AP_S1>
  inline ap_private<_AP_W, _AP_S || _AP_S1> And(
      const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator&(RHS);
  }
  template <bool _AP_S1>
  inline ap_private Or(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator|(RHS);
  }
  template <bool _AP_S1>
  inline ap_private Xor(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return this->operator^(RHS);
  }

  inline ap_private Mul(const ap_private& RHS) const {
    ap_private Result(*this);
    Result *= RHS;
    return Result;
  }

  inline ap_private Add(const ap_private& RHS) const {
    ap_private Result(0);
    ap_private_ops::add(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,
                        _AP_N, _AP_S, _AP_S);
    Result.clearUnusedBits();
    return Result;
  }

  inline ap_private Sub(const ap_private& RHS) const {
    ap_private Result(0);
    ap_private_ops::sub(Result.get_pVal(), pVal, RHS.get_pVal(), _AP_N, _AP_N,
                        _AP_N, _AP_S, _AP_S);
    Result.clearUnusedBits();
    return Result;
  }



  inline ap_private ashr(uint32_t shiftAmt) const {
    
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   shiftAmt <= BitWidth && "Invalid shift amount, too big"
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "shiftAmt <= BitWidth && \"Invalid shift amount, too big\""
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4779),0))
# 4779 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;

    if (shiftAmt == 0) return ap_private(*this);





    if (shiftAmt == BitWidth) {
      if (isNegative())
        return ap_private(-1);
      else
        return ap_private(0);
    }


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();


    uint32_t wordShift =
        shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;
    uint32_t breakWord = _AP_N - 1 - offset;
    uint32_t bitsInWord = whichBit(BitWidth);
    if (bitsInWord == 0) bitsInWord = APINT_BITS_PER_WORD;


    if (wordShift == 0) {

      for (uint32_t i = 0; i <= breakWord; ++i)
        val[i] = pVal[i + offset];


      if (isNegative())
        if (bitsInWord < APINT_BITS_PER_WORD)
          val[breakWord] |= ~0ULL << (bitsInWord);
    } else {

      for (uint32_t i = 0; i < breakWord; ++i) {


        val[i] = ((pVal[i + offset]) >> (wordShift));
        val[i] |= ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));
      }



      val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);




      if (isNegative()) {
        if (wordShift > bitsInWord) {
          if (breakWord > 0)
            val[breakWord - 1] |=
                ~0ULL << (APINT_BITS_PER_WORD - (wordShift - bitsInWord));
          val[breakWord] |= ~0ULL;
        } else
          val[breakWord] |= (~0ULL << (bitsInWord - wordShift));
      }
    }


    uint64_t fillValue = (isNegative() ? ~0ULL : 0);
    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = fillValue;
    Retval.clearUnusedBits();
    return Retval;
  }



  inline ap_private lshr(uint32_t shiftAmt) const {



    if (shiftAmt == BitWidth) return ap_private(0);




    if (shiftAmt == 0) return ap_private(*this);


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();



    if (shiftAmt < APINT_BITS_PER_WORD) {
      uint64_t carry = 0;
      for (int i = _AP_N - 1; i >= 0; --i) {
        val[i] = ((pVal[i]) >> (shiftAmt)) | carry;
        carry = (pVal[i]) << (APINT_BITS_PER_WORD - shiftAmt);
      }
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


    if (wordShift == 0) {
      for (uint32_t i = 0; i < _AP_N - offset; ++i) val[i] = pVal[i + offset];
      for (uint32_t i = _AP_N - offset; i < _AP_N; i++) val[i] = 0;
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t breakWord = _AP_N - offset - 1;
    for (uint32_t i = 0; i < breakWord; ++i)
      val[i] = ((pVal[i + offset]) >> (wordShift)) |
               ((pVal[i + offset + 1]) << (APINT_BITS_PER_WORD - wordShift));

    val[breakWord] = (pVal[breakWord + offset]) >> (wordShift);


    for (int i = breakWord + 1; i < _AP_N; ++i) val[i] = 0;
    Retval.clearUnusedBits();
    return Retval;
  }



  inline ap_private shl(uint32_t shiftAmt) const {
    
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   shiftAmt <= BitWidth && "Invalid shift amount, too big"
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "shiftAmt <= BitWidth && \"Invalid shift amount, too big\""
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4908),0))
# 4908 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                  ;



    if (shiftAmt == BitWidth) return ap_private(0);





    if (shiftAmt == 0) return ap_private(*this);


    ap_private Retval(0);
    uint64_t* val = Retval.get_pVal();

    if (shiftAmt < APINT_BITS_PER_WORD) {
      uint64_t carry = 0;
      for (int i = 0; i < _AP_N; i++) {
        val[i] = ((pVal[i]) << (shiftAmt)) | carry;
        carry = (pVal[i]) >> (APINT_BITS_PER_WORD - shiftAmt);
      }
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t wordShift = shiftAmt % APINT_BITS_PER_WORD;
    uint32_t offset = shiftAmt / APINT_BITS_PER_WORD;


    if (wordShift == 0) {
      for (uint32_t i = 0; i < offset; i++) val[i] = 0;
      for (int i = offset; i < _AP_N; i++) val[i] = pVal[i - offset];
      Retval.clearUnusedBits();
      return Retval;
    }


    uint32_t i = _AP_N - 1;
    for (; i > offset; --i)
      val[i] = (pVal[i - offset]) << (wordShift) |
               (pVal[i - offset - 1]) >> (APINT_BITS_PER_WORD - wordShift);
    val[offset] = (pVal[0]) << (wordShift);
    for (i = 0; i < offset; ++i) val[i] = 0;
    Retval.clearUnusedBits();
    return Retval;
  }

  inline ap_private rotl(uint32_t rotateAmt) const {
    if (rotateAmt == 0) return ap_private(*this);

    ap_private hi(*this);
    ap_private lo(*this);
    hi.shl(rotateAmt);
    lo.lshr(BitWidth - rotateAmt);
    return hi | lo;
  }

  inline ap_private rotr(uint32_t rotateAmt) const {
    if (rotateAmt == 0) return ap_private(*this);

    ap_private hi(*this);
    ap_private lo(*this);
    lo.lshr(rotateAmt);
    hi.shl(BitWidth - rotateAmt);
    return hi | lo;
  }






  inline ap_private udiv(const ap_private& RHS) const {

    uint32_t rhsBits = RHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
    
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   rhsWords && "Divided by zero???"
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "rhsWords && \"Divided by zero???\""
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",4986),0))
# 4986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                           ;
    uint32_t lhsBits = this->getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


    if (!lhsWords)

      return ap_private(0);
    else if (lhsWords < rhsWords || this->ult(RHS)) {

      return ap_private(0);
    } else if (*this == RHS) {

      return ap_private(1);
    } else if (lhsWords == 1 && rhsWords == 1) {

      return ap_private(this->pVal[0] / RHS.get_pVal(0));
    }


    ap_private Quotient(0);
    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, &Quotient,
                           (ap_private*)0);
    return Quotient;
  }



  inline ap_private sdiv(const ap_private& RHS) const {
    if (isNegative())
      if (RHS.isNegative())
        return (-(*this)).udiv(-RHS);
      else
        return -((-(*this)).udiv(RHS));
    else if (RHS.isNegative())
      return -(this->udiv((ap_private)(-RHS)));
    return this->udiv(RHS);
  }
# 5033 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline ap_private urem(const ap_private& RHS) const {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);


    uint32_t rhsBits = RHS.getActiveBits();
    uint32_t rhsWords = !rhsBits ? 0 : (whichWord(rhsBits - 1) + 1);
    
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   rhsWords && "Performing remainder operation by zero ???"
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "rhsWords && \"Performing remainder operation by zero ???\""
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5041),0))
# 5041 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                   ;


    if (lhsWords == 0) {

      return ap_private(0);
    } else if (lhsWords < rhsWords || this->ult(RHS)) {

      return *this;
    } else if (*this == RHS) {

      return ap_private(0);
    } else if (lhsWords == 1) {

      return ap_private(pVal[0] % RHS.get_pVal(0));
    }


    ap_private Remainder(0);
    ap_private_ops::divide(*this, lhsWords, RHS, rhsWords, (ap_private*)(0),
                           &Remainder);
    return Remainder;
  }

  inline ap_private urem(uint64_t RHS) const {

    uint32_t lhsBits = getActiveBits();
    uint32_t lhsWords = !lhsBits ? 0 : (whichWord(lhsBits - 1) + 1);

    uint32_t rhsWords = 1;

    
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   rhsWords && "Performing remainder operation by zero ???"
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "rhsWords && \"Performing remainder operation by zero ???\""
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5072),0))
# 5072 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                   ;

    if (lhsWords == 0) {

      return ap_private(0);
    } else if (lhsWords < rhsWords || this->ult(RHS)) {

      return *this;
    } else if (*this == RHS) {

      return ap_private(0);
    } else if (lhsWords == 1) {

      return ap_private(pVal[0] % RHS);
    }


    ap_private Remainder(0);
    divide(*this, lhsWords, RHS, (ap_private*)(0), &Remainder);
    return Remainder;
  }



  inline ap_private srem(const ap_private& RHS) const {
    if (isNegative()) {
      ap_private lhs = -(*this);
      if (RHS.isNegative()) {
        ap_private rhs = -RHS;
        return -(lhs.urem(rhs));
      } else
        return -(lhs.urem(RHS));
    } else if (RHS.isNegative()) {
      ap_private rhs = -RHS;
      return this->urem(rhs);
    }
    return this->urem(RHS);
  }



  inline ap_private srem(int64_t RHS) const {
    if (isNegative())
      if (RHS < 0)
        return -((-(*this)).urem(-RHS));
      else
        return -((-(*this)).urem(RHS));
    else if (RHS < 0)
      return this->urem(-RHS);
    return this->urem(RHS);
  }





  template <bool _AP_S1>
  inline bool eq(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return (*this) == RHS;
  }





  template <bool _AP_S1>
  inline bool ne(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !((*this) == RHS);
  }





  template <bool _AP_S1>
  inline bool ult(const ap_private<_AP_W, _AP_S1>& RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 = RHS.getActiveBits();


    if (n1 < n2) return true;


    if (n2 < n1) return false;


    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
      return pVal[0] < RHS.get_pVal(0);


    uint32_t topWord = whichWord(AESL_std::max(n1, n2) - 1);
    for (int i = topWord; i >= 0; --i) {
      if (pVal[i] > RHS.get_pVal(i)) return false;
      if (pVal[i] < RHS.get_pVal(i)) return true;
    }
    return false;
  }

  inline bool ult(uint64_t RHS) const {

    uint32_t n1 = getActiveBits();
    uint32_t n2 =
        64 - ap_private_ops::CountLeadingZeros_64(RHS);


    if (n1 < n2) return true;


    if (n2 < n1) return false;


    if (n1 <= APINT_BITS_PER_WORD && n2 <= APINT_BITS_PER_WORD)
      return pVal[0] < RHS;
    
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   0
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "0"
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5186),0))
# 5186 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
            ;
  }

  template <bool _AP_S1>
  inline bool slt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    ap_private lhs(*this);
    ap_private<_AP_W, _AP_S1> rhs(RHS);
    bool lhsNeg = isNegative();
    bool rhsNeg = rhs.isNegative();
    if (lhsNeg) {

      lhs.flip();
      lhs++;
    }
    if (rhsNeg) {

      rhs.flip();
      rhs++;
    }



    if (lhsNeg)
      if (rhsNeg)
        return lhs.ugt(rhs);
      else
        return true;
    else if (rhsNeg)
      return false;
    else
      return lhs.ult(rhs);
  }





  template <bool _AP_S1>
  inline bool ule(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return ult(RHS) || eq(RHS);
  }





  template <bool _AP_S1>
  inline bool sle(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return slt(RHS) || eq(RHS);
  }





  template <bool _AP_S1>
  inline bool ugt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !ult(RHS) && !eq(RHS);
  }





  template <bool _AP_S1>
  inline bool sgt(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !slt(RHS) && !eq(RHS);
  }





  template <bool _AP_S1>
  inline bool uge(const ap_private<_AP_W, _AP_S>& RHS) const {
    return !ult(RHS);
  }





  template <bool _AP_S1>
  inline bool sge(const ap_private<_AP_W, _AP_S1>& RHS) const {
    return !slt(RHS);
  }


  template <int _AP_W1, bool _AP_S1>
  inline void cpSext(const ap_private<_AP_W1, _AP_S1>& that) {
    
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 < BitWidth && "Invalid ap_private SignExtend request"
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 < BitWidth && \"Invalid ap_private SignExtend request\""
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5276),0))
# 5276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                       ;
    
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 <= MAX_INT_BITS && "Too many bits"
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 <= MAX_INT_BITS && \"Too many bits\""
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5277),0))
# 5277 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;

    if (!that.isNegative()) {
      cpZext(that);
      return;
    }


    enum { wordBits = _AP_W1 % APINT_BITS_PER_WORD };
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;

    if (_AP_N1 == _AP_N) {
      enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };

      static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      pVal[_AP_N - 1] |= mask;
      return;
    }

    enum { newWordBits = _AP_W % APINT_BITS_PER_WORD };

    static const uint64_t mask = wordBits ? (~0ULL << (wordBits)) : 0ULL;
    int i;
    for (i = 0; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);
    pVal[i - 1] |= mask;
    for (; i < _AP_N - 1; i++) pVal[i] = ~0ULL;
    pVal[i] = ~0ULL;
    clearUnusedBits();
    return;
  }


  template <int _AP_W1, bool _AP_S1>
  inline void cpZext(const ap_private<_AP_W1, _AP_S1>& that) {
    
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 < BitWidth && "Invalid ap_private ZeroExtend request"
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 < BitWidth && \"Invalid ap_private ZeroExtend request\""
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5312),0))
# 5312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                       ;
    
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   _AP_W1 <= MAX_INT_BITS && "Too many bits"
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "_AP_W1 <= MAX_INT_BITS && \"Too many bits\""
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5313),0))
# 5313 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                    ;
    const int _AP_N1 = ap_private<_AP_W1, _AP_S1>::_AP_N;
    int i = 0;
    for (; i < _AP_N1; ++i) pVal[i] = that.get_pVal(i);
    for (; i < _AP_N; ++i) pVal[i] = 0;
    clearUnusedBits();
  }

  template <int _AP_W1, bool _AP_S1>
  inline void cpZextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
    if (BitWidth > _AP_W1)
      cpZext(that);
    else {
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      clearUnusedBits();
    }
  }

  template <int _AP_W1, bool _AP_S1>
  inline void cpSextOrTrunc(const ap_private<_AP_W1, _AP_S1>& that) {
    if (BitWidth > _AP_W1)
      cpSext(that);
    else {
      for (int i = 0; i < _AP_N; ++i) pVal[i] = that.get_pVal(i);
      clearUnusedBits();
    }
  }






  inline uint32_t getBitWidth() const { return BitWidth; }




  inline uint32_t getNumWords() const {
    return (BitWidth + APINT_BITS_PER_WORD - 1) / APINT_BITS_PER_WORD;
  }





  inline uint32_t getActiveBits() const {
    uint32_t bits = BitWidth - countLeadingZeros();
    return bits ? bits : 1;
  }






  inline uint64_t getZExtValue() const {
    
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   getActiveBits() <= 64 && "Too many bits for uint64_t"
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "getActiveBits() <= 64 && \"Too many bits for uint64_t\""
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5370),0))
# 5370 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                                ;
    return *pVal;
  }






  inline int64_t getSExtValue() const {
    
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   getActiveBits() <= 64 && "Too many bits for int64_t"
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "getActiveBits() <= 64 && \"Too many bits for int64_t\""
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5380),0))
# 5380 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                               ;
    return int64_t(pVal[0]);
  }




  inline static uint32_t getBitsNeeded(const char* str, uint32_t slen,
                                       uint8_t radix) {
    
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   str != 0 && "Invalid value string"
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "str != 0 && \"Invalid value string\""
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5389),0))
# 5389 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
    
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   slen > 0 && "Invalid string length"
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "slen > 0 && \"Invalid string length\""
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5390),0))
# 5390 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                              ;


    uint32_t isNegative = str[0] == '-';
    if (isNegative) {
      slen--;
      str++;
    }


    if (radix == 2) return slen + isNegative;
    if (radix == 8) return slen * 3 + isNegative;
    if (radix == 16) return slen * 4 + isNegative;


    
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (void) ((!!(
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   radix == 10 && "Invalid radix"
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   )) || (_assert(
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   "radix == 10 && \"Invalid radix\""
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5405),0))
# 5405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                         ;






    return isNegative + slen * 4;
  }







  inline uint32_t countLeadingZeros() const {
    enum {
      msw_bits = (BitWidth % APINT_BITS_PER_WORD)
                     ? (BitWidth % APINT_BITS_PER_WORD)
                     : APINT_BITS_PER_WORD,
      excessBits = APINT_BITS_PER_WORD - msw_bits
    };
    uint32_t Count = ap_private_ops::CountLeadingZeros_64(pVal[_AP_N - 1]);
    if (Count >= excessBits) Count -= excessBits;
    if (!pVal[_AP_N - 1]) {
      for (int i = _AP_N - 1; i; --i) {
        if (!pVal[i - 1])
          Count += APINT_BITS_PER_WORD;
        else {
          Count += ap_private_ops::CountLeadingZeros_64(pVal[i - 1]);
          break;
        }
      }
    }
    return Count;
  }






  inline uint32_t countLeadingOnes() const {
    if (isSingleWord())
      return countLeadingOnes_64(get_VAL(), APINT_BITS_PER_WORD - BitWidth);

    uint32_t highWordBits = BitWidth % APINT_BITS_PER_WORD;
    uint32_t shift =
        (highWordBits == 0 ? 0 : APINT_BITS_PER_WORD - highWordBits);
    int i = _AP_N - 1;
    uint32_t Count = countLeadingOnes_64(get_pVal(i), shift);
    if (Count == highWordBits) {
      for (i--; i >= 0; --i) {
        if (get_pVal(i) == ~0ULL)
          Count += APINT_BITS_PER_WORD;
        else {
          Count += countLeadingOnes_64(get_pVal(i), 0);
          break;
        }
      }
    }
    return Count;
  }
# 5477 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline uint32_t countTrailingZeros() const {
    uint32_t Count = 0;
    uint32_t i = 0;
    for (; i < _AP_N && get_pVal(i) == 0; ++i) Count += APINT_BITS_PER_WORD;
    if (i < _AP_N) Count += ap_private_ops::CountTrailingZeros_64(get_pVal(i));
    return AESL_std::min(Count, BitWidth);
  }






  inline uint32_t countPopulation() const {
    uint32_t Count = 0;
    for (int i = 0; i < _AP_N - 1; ++i)
      Count += ap_private_ops::CountPopulation_64(pVal[i]);
    Count += ap_private_ops::CountPopulation_64(pVal[_AP_N - 1] & mask);
    return Count;
  }







  inline std::string toString(uint8_t radix, bool wantSigned) const;






  inline std::string toStringUnsigned(uint8_t radix = 10) const {
    return toString(radix, false);
  }






  inline std::string toStringSigned(uint8_t radix = 10) const {
    return toString(radix, true);
  }


  inline double roundToDouble(bool isSigned) const {

    if (isSingleWord() || getActiveBits() <= APINT_BITS_PER_WORD) {
      uint64_t val = pVal[0];
      if (isSigned) {
        int64_t sext = ((int64_t(val)) << (64 - BitWidth)) >> (64 - BitWidth);
        return double(sext);
      } else
        return double(val);
    }


    bool isNeg = isSigned ? (*this)[BitWidth - 1] : false;


    ap_private<_AP_W, _AP_S> Tmp(isNeg ? -(*this) : (*this));


    uint32_t n = Tmp.getActiveBits();




    uint64_t exp = n;


    if (exp > 1023) {
      if (!isSigned || !isNeg)
        return std::numeric_limits<double>::infinity();
      else
        return -std::numeric_limits<double>::infinity();
    }
    exp += 1023;



    uint64_t mantissa;
    unsigned hiWord = whichWord(n - 1);
    if (hiWord == 0) {
      mantissa = Tmp.get_pVal(0);
      if (n > 52)
        (mantissa) >>= (n - 52);
    } else {
      
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     hiWord > 0 && "High word is negative?"
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "hiWord > 0 && \"High word is negative?\""
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5568),0))
# 5568 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                                   ;
      uint64_t hibits = (Tmp.get_pVal(hiWord))
                        << (52 - n % APINT_BITS_PER_WORD);
      uint64_t lobits =
          (Tmp.get_pVal(hiWord - 1)) >> (11 + n % APINT_BITS_PER_WORD);
      mantissa = hibits | lobits;
    }


    uint64_t sign = isNeg ? (1ULL << (APINT_BITS_PER_WORD - 1)) : 0;
    union {
      double __D;
      uint64_t __I;
    } __T;
    __T.__I = sign | ((exp) << 52) | mantissa;
    return __T.__D;
  }


  inline double roundToDouble() const { return roundToDouble(false); }


  inline double signedRoundToDouble() const { return roundToDouble(true); }





  inline double bitsToDouble() const {
    union {
      uint64_t __I;
      double __D;
    } __T;
    __T.__I = pVal[0];
    return __T.__D;
  }





  inline float bitsToFloat() const {
    union {
      uint32_t __I;
      float __F;
    } __T;
    __T.__I = uint32_t(pVal[0]);
    return __T.__F;
  }





  inline ap_private& doubleToBits(double __V) {
    union {
      uint64_t __I;
      double __D;
    } __T;
    __T.__D = __V;
    pVal[0] = __T.__I;
    return *this;
  }





  inline ap_private& floatToBits(float __V) {
    union {
      uint32_t __I;
      float __F;
    } __T;
    __T.__F = __V;
    pVal[0] = __T.__I;
  }



  inline bool and_reduce() const { return isMaxValue(); }

  inline bool nand_reduce() const { return isMinValue(); }

  inline bool or_reduce() const { return (bool)countPopulation(); }

  inline bool nor_reduce() const { return countPopulation() == 0; }

  inline bool xor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? true : false;
  }

  inline bool xnor_reduce() const {
    unsigned int i = countPopulation();
    return (i % 2) ? false : true;
  }
  inline std::string to_string(uint8_t radix = 16, bool sign = false) const {
    return toString(radix, radix == 10 ? _AP_S : sign);
  }
};

namespace ap_private_ops {

enum { APINT_BITS_PER_WORD = 64 };
template <int _AP_W, bool _AP_S>
inline bool operator==(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
  return V2 == V1;
}

template <int _AP_W, bool _AP_S>
inline bool operator!=(uint64_t V1, const ap_private<_AP_W, _AP_S>& V2) {
  return V2 != V1;
}

template <int _AP_W, bool _AP_S, int index>
inline bool get(const ap_private<_AP_W, _AP_S>& a) {
  static const uint64_t mask = 1ULL << (index & 0x3f);
  return ((mask & a.get_pVal((index) >> 6)) != 0);
}

template <int _AP_W, bool _AP_S, int msb_index, int lsb_index>
inline void set(ap_private<_AP_W, _AP_S>& a,
                const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
  enum {
    APINT_BITS_PER_WORD = 64,
    lsb_word = lsb_index / APINT_BITS_PER_WORD,
    msb_word = msb_index / APINT_BITS_PER_WORD,
    msb = msb_index % APINT_BITS_PER_WORD,
    lsb = lsb_index % APINT_BITS_PER_WORD
  };
  if (msb_word == lsb_word) {
    const uint64_t mask = ~0ULL >>
                          (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>
                          (APINT_BITS_PER_WORD - msb - 1);

    a.get_pVal(msb_word) |= mask;
  } else {
    const uint64_t lsb_mask = ~0ULL >> (lsb) << (lsb);
    const uint64_t msb_mask = ~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>
                              (APINT_BITS_PER_WORD - msb - 1);

    a.get_pVal(lsb_word) |= lsb_mask;
    for (int i = lsb_word + 1; i < msb_word; i++) {
      a.set_pVal(i, ~0ULL);

    }


    a.get_pVal(msb_word) |= msb_mask;
  }
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int msb_index, int lsb_index>
inline void clear(ap_private<_AP_W, _AP_S>& a,
                  const ap_private<((msb_index) > (1) ? (msb_index) : (1)), true>& mark1 = 0,
                  const ap_private<((lsb_index) > (1) ? (lsb_index) : (1)), true>& mark2 = 0) {
  enum {
    APINT_BITS_PER_WORD = 64,
    lsb_word = lsb_index / APINT_BITS_PER_WORD,
    msb_word = msb_index / APINT_BITS_PER_WORD,
    msb = msb_index % APINT_BITS_PER_WORD,
    lsb = lsb_index % APINT_BITS_PER_WORD
  };
  if (msb_word == lsb_word) {
    const uint64_t mask =
        ~(~0ULL >> (lsb) << (APINT_BITS_PER_WORD - msb + lsb - 1) >>
          (APINT_BITS_PER_WORD - msb - 1));

    a.get_pVal(msb_word) &= mask;
  } else {
    const uint64_t lsb_mask = ~(~0ULL >> (lsb) << (lsb));
    const uint64_t msb_mask = ~(~0ULL << (APINT_BITS_PER_WORD - msb - 1) >>
                                (APINT_BITS_PER_WORD - msb - 1));

    a.get_pVal(lsb_word) &= lsb_mask;
    for (int i = lsb_word + 1; i < msb_word; i++) {

      a.get_pVal(i) = 0;
    }

    a.get_pVal(msb_word) &= msb_mask;
  }
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int index>
inline void set(ap_private<_AP_W, _AP_S>& a,
                const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };
  static const uint64_t mask = 1ULL << (index % APINT_BITS_PER_WORD);

  a.get_pVal(word) |= mask;
  a.clearUnusedBits();
}

template <int _AP_W, bool _AP_S, int index>
inline void clear(ap_private<_AP_W, _AP_S>& a,
                  const ap_private<((index) > (1) ? (index) : (1)), true>& mark = 0) {
  enum { APINT_BITS_PER_WORD = 64, word = index / APINT_BITS_PER_WORD };
  static const uint64_t mask = ~(1ULL << (index % APINT_BITS_PER_WORD));

  a.get_pVal(word) &= mask;
  a.clearUnusedBits();
}

}

template <int _AP_W, bool _AP_S>
inline std::string ap_private<_AP_W, _AP_S, false>::toString(
    uint8_t radix, bool wantSigned) const {
  
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 (void) ((!!(
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 (radix == 10 || radix == 8 || radix == 16 || radix == 2) && "Radix should be 2, 8, 10, or 16!"
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 )) || (_assert(
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
 "(radix == 10 || radix == 8 || radix == 16 || radix == 2) && \"Radix should be 2, 8, 10, or 16!\""
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
 ,
                                           "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ,
                                           5781
# 5780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
  ),0))
                                            
# 5781 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                           ;
  static const char* digits[] = {"0", "1", "2", "3", "4", "5", "6", "7",
                                 "8", "9", "A", "B", "C", "D", "E", "F"};
  std::string result;

  if (radix != 10) {





    if (*this == (uint64_t)(0))
      result = "0";
    else {
      ap_private<_AP_W, false> tmp(*this);
      size_t insert_at = 0;
      bool leading_zero = true;
      if (wantSigned && isNegative()) {



        tmp.flip();
        tmp++;
        tmp.clearUnusedBitsToZero();
        result = "-";
        insert_at = 1;
        leading_zero = false;
      }
      switch (radix) {
        case 2:
          result += "0b";
          break;
        case 8:
          result += "0o";
          break;
        case 16:
          result += "0x";
          break;
        default:
          
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         (void) ((!!(
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "invalid radix" && 0
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         )) || (_assert(
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
         "\"invalid radix\" && 0"
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
         ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5820),0))
# 5820 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                     ;
      }
      insert_at += 2;

      uint32_t shift = (radix == 16 ? 4 : (radix == 8 ? 3 : 1));
      uint64_t mask = radix - 1;
      ap_private<_AP_W, false> zero(0);
      unsigned bits = 0;
      while (tmp.ne(zero)) {
        uint64_t digit = tmp.get_VAL() & mask;
        result.insert(insert_at, digits[digit]);
        tmp = tmp.lshr(shift);
        ++bits;
      }
      bits *= shift;
      if (bits < _AP_W && leading_zero) result.insert(insert_at, digits[0]);
    }
    return result;
  }

  ap_private<_AP_W, false> tmp(*this);
  ap_private<_AP_W, false> divisor(radix);
  ap_private<_AP_W, false> zero(0);
  size_t insert_at = 0;
  if (wantSigned && isNegative()) {



    tmp.flip();
    tmp++;
    tmp.clearUnusedBitsToZero();
    result = "-";
    insert_at = 1;
  }
  if (tmp == ap_private<_AP_W, false>(0))
    result = "0";
  else
    while (tmp.ne(zero)) {
      ap_private<_AP_W, false> APdigit(0);
      ap_private<_AP_W, false> tmp2(0);
      ap_private_ops::divide(tmp, tmp.getNumWords(), divisor,
                             divisor.getNumWords(), &tmp2, &APdigit);
      uint64_t digit = APdigit.getZExtValue();
      
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     (void) ((!!(
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     digit < radix && "divide failed"
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     )) || (_assert(
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
     "digit < radix && \"divide failed\""
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
     ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h",5863),0))
# 5863 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
                                             ;
      result.insert(insert_at, digits[digit]);
      tmp = tmp2;
    }

  return result;
}

template <int _AP_W, bool _AP_S>
std::ostream &operator<<(std::ostream &os, const ap_private<_AP_W, _AP_S> &x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.toString(16, false);
  } else if (ff & std::cout.oct) {
    os << x.toString(8, false);
  } else {
    os << x.toString(10, _AP_S);
  }
  return os;
}
# 6128 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S>
struct _private_range_ref {



  ap_private<_AP_W, _AP_S>& d_bv;
  int l_index;
  int h_index;

 public:

  inline _private_range_ref(const _private_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}


  inline _private_range_ref(ap_private<_AP_W, _AP_S>* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {
    do { if ((h < 0 || l < 0)) { fprintf(
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Higher bound (%d) and lower bound (%d) cannot be " "negative.", h, l); fprintf(
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)


                     ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Higher bound (%d) or lower bound (%d) out of range (%d).", h, l, _AP_W); fprintf(
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6149 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                      ;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator|=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= " "ap_private<>.range()."); fprintf(
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6158 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv |= ref.d_bv;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator|=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() |= _AP_ROOT_TYPE<>."); fprintf(
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6169 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv |= ref.V;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator&=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= " "ap_private<>.range()."); fprintf(
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6179 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv &= ref.d_bv;
    return *this;
  };


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator&=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() &= _AP_ROOT_TYPE<>."); fprintf(
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6190 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv &= ref.V;
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator^=(
      const _private_range_ref<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index) != (ref.h_index - ref.l_index))) { fprintf(
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() ^= " "ap_private<>.range()."); fprintf(
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6200 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)

                                        ;
    this->d_bv ^= ref.d_bv;
    return *this;
  };


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref<_AP_W, _AP_S>& operator^=(
      const ssdm_int_sim<_AP_W2, _AP_S2>& ref) {
    do { if (((h_index - l_index + 1) != _AP_W2)) { fprintf(
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Bitsize mismach for ap_private<>.range() ^= _AP_ROOT_TYPE<>."); fprintf(
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6211 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                               ;
    this->d_bv ^= ref.V;
    return *this;
  }



  inline operator ap_private<_AP_W, false>() const {
    ap_private<_AP_W, false> val(0);
    if (h_index >= l_index) {
      if (_AP_W > 64) {
        val = d_bv;
        ap_private<_AP_W, false> mask(-1);
        mask >>= _AP_W - (h_index - l_index + 1);
        val >>= l_index;
        val &= mask;
      } else {
        const static uint64_t mask = (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));
        val = (d_bv >> l_index) & (mask >> (_AP_W - (h_index - l_index + 1)));
      }
    } else {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    }
    return val;
  }

  inline operator unsigned long long() const { return to_uint64(); }


  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(const ap_private<_AP_W2, _AP_S2>& val) {
    ap_private<_AP_W, false> vval = ap_private<_AP_W, false>(val);
    if (l_index > h_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);
    } else {
      if (_AP_W > 64) {
        ap_private<_AP_W, false> mask(-1);
        if (l_index > 0) {
          mask <<= l_index;
          vval <<= l_index;
        }
        if (h_index < _AP_W - 1) {
          ap_private<_AP_W, false> mask2(-1);
          mask2 >>= _AP_W - h_index - 1;
          mask &= mask2;
          vval &= mask2;
        }
        mask.flip();
        d_bv &= mask;
        d_bv |= vval;
      } else {
        unsigned shift = 64 - _AP_W;
        uint64_t mask = ~0ULL >> (shift);
        if (l_index > 0) {
          vval = mask & vval << l_index;
          mask = mask & mask << l_index;
        }
        if (h_index < _AP_W - 1) {
          uint64_t mask2 = mask;
          mask2 >>= (_AP_W - h_index - 1);
          mask &= mask2;
          vval &= mask2;
        }
        mask = ~mask;
        d_bv &= mask;
        d_bv |= vval;
      }
    }
    return *this;
  }

  inline _private_range_ref& operator=(unsigned long long val) {
    const ap_private<_AP_W, _AP_S> vval = val;
    return operator=(vval);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(
      const _private_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((unsigned long long)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline _private_range_ref& operator=(
      const _private_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_private<_AP_W, false> tmpVal(val);
    return operator=(tmpVal);
  }
# 6312 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(val.to_ap_int_base().V);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(val.operator ap_int_base<_AP_W2, false>().V);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline _private_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((unsigned long long)(bool)val);
  }
# 6405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs == rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs != rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs > rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs >= rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs < rhs;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const _private_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_private<_AP_W, false> lhs = get();
    ap_private<_AP_W2, false> rhs = op2.get();
    return lhs <= rhs;
  }

  template <int _AP_W2>
  inline void set(const ap_private<_AP_W2, false>& val) {
    ap_private<_AP_W, _AP_S> vval = val;
    if (l_index > h_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        (vval)[i] ? d_bv.set(j) : d_bv.clear(j);
    } else {
      if (_AP_W > 64) {
        ap_private<_AP_W, _AP_S> mask(-1);
        if (l_index > 0) {
          ap_private<_AP_W, false> mask1(-1);
          mask1 >>= _AP_W - l_index;
          mask1.flip();
          mask = mask1;

          vval <<= l_index;
        }
        if (h_index < _AP_W - 1) {
          ap_private<_AP_W, false> mask2(-1);
          mask2 <<= h_index + 1;
          mask2.flip();
          mask &= mask2;
          vval &= mask2;
        }
        mask.flip();
        d_bv &= mask;
        d_bv |= vval;
      } else {
        uint64_t mask = ~0ULL >> (64 - _AP_W);
        if (l_index > 0) {
          uint64_t mask1 = mask;
          mask1 = mask & (mask1 >> (_AP_W - l_index));
          vval = mask & (vval << l_index);
          mask = ~mask1 & mask;

        }
        if (h_index < _AP_W - 1) {
          uint64_t mask2 = ~0ULL >> (64 - _AP_W);
          mask2 = mask & (mask2 << (h_index + 1));
          mask &= ~mask2;
          vval &= ~mask2;
        }
        d_bv &= (~mask & (~0ULL >> (64 - _AP_W)));
        d_bv |= vval;
      }
    }
  }

  inline ap_private<_AP_W, false> get() const {
    ap_private<_AP_W, false> val(0);
    if (h_index < l_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    } else {
      val = d_bv;
      val >>= l_index;
      if (h_index < _AP_W - 1) {
        if (_AP_W <= 64) {
          const static uint64_t mask =
              (~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0));
          val &= (mask >> (_AP_W - (h_index - l_index + 1)));
        } else {
          ap_private<_AP_W, false> mask(-1);
          mask >>= _AP_W - (h_index - l_index + 1);
          val &= mask;
        }
      }
    }
    return val;
  }

  inline ap_private<_AP_W, false> get() {
    ap_private<_AP_W, false> val(0);
    if (h_index < l_index) {
      for (int i = 0, j = l_index; j >= 0 && j >= h_index; j--, i++)
        if ((d_bv)[j]) val.set(i);
    } else {
      val = d_bv;
      val >>= l_index;
      if (h_index < _AP_W - 1) {
        if (_AP_W <= 64) {
          static const uint64_t mask = ~0ULL >> (64 > _AP_W ? (64 - _AP_W) : 0);
          return val &= ((mask) >> (_AP_W - (h_index - l_index + 1)));
        } else {
          ap_private<_AP_W, false> mask(-1);
          mask >>= _AP_W - (h_index - l_index + 1);
          val &= mask;
        }
      }
    }
    return val;
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline int to_int() const {
    ap_private<_AP_W, false> val = get();
    return val.to_int();
  }

  inline unsigned int to_uint() const {
    ap_private<_AP_W, false> val = get();
    return val.to_uint();
  }

  inline long to_long() const {
    ap_private<_AP_W, false> val = get();
    return val.to_long();
  }

  inline unsigned long to_ulong() const {
    ap_private<_AP_W, false> val = get();
    return val.to_ulong();
  }

  inline ap_slong to_int64() const {
    ap_private<_AP_W, false> val = get();
    return val.to_int64();
  }

  inline ap_ulong to_uint64() const {
    ap_private<_AP_W, false> val = get();
    return val.to_uint64();
  }

  inline std::string to_string(uint8_t radix = 2) const {
    return get().to_string(radix);
  }

  inline bool and_reduce() {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret &= d_bv[i];
    return ret;
  }

  inline bool or_reduce() {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret |= d_bv[i];
    return ret;
  }

  inline bool xor_reduce() {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) ret ^= d_bv[i];
    return ret;
  }
};





template <int _AP_W, bool _AP_S>
struct _private_bit_ref {



  ap_private<_AP_W, _AP_S>& d_bv;
  int d_index;

 public:

  inline _private_bit_ref(const _private_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}


  inline _private_bit_ref(ap_private<_AP_W, _AP_S>& bv, int index = 0)
      : d_bv(bv), d_index(index) {
    do { if ((d_index < 0)) { fprintf(
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Index of bit vector  (%d) cannot be negative.\n", d_index); fprintf(
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6626 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                        ;
    do { if ((d_index >= _AP_W)) { fprintf(
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "WARNING: " "Index of bit vector (%d) out of range (%d).\n", d_index, _AP_W); fprintf(
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h" 3
   (&__iob_func()[2])
# 6628 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
   , "\n"); } } while (0)
                                                                                ;
  }

  inline operator bool() const { return d_bv.get_bit(d_index); }

  inline bool to_bool() const { return operator bool(); }

  template <typename T>
  inline _private_bit_ref& operator=(const T& val) {
    if (!!val)
      d_bv.set(d_index);
    else
      d_bv.clear(d_index);
    return *this;
  }
# 6730 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const _private_bit_ref<_AP_W2, _AP_S2>& op) const {
    return get() != op.get();
  }

  inline bool get() const { return operator bool(); }
# 6752 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
  inline int length() const { return 1; }






};
# 6780 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(const ap_private<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(const ap_private<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
# 6806 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline float operator *(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline float operator *(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline float operator /(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline float operator /(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline float operator +(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline float operator +(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline float operator -(float i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline float operator -(const ap_private<_AP_W, _AP_S>& op, float i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline double operator *(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline double operator *(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline double operator /(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline double operator /(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline double operator +(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline double operator +(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline double operator -(double i_op, const ap_private<_AP_W, _AP_S>& op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline double operator -(const ap_private<_AP_W, _AP_S>& op, double i_op) { typename ap_private<_AP_W, _AP_S>::ValType op2 = op; return op2 - i_op; }
# 6911 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::mult operator *(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator *(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::plus operator +(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator +(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::minus operator -(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator -(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::div operator /(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator /(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::mod operator %(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator %(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator &(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator &(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator |(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator |(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(bool i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator ^(ap_private<(1), (false)>(i_op)); } template <int _AP_W, bool _AP_S> bool operator >>(bool i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> bool operator <<(bool i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(1), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, bool i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator +=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator -=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator *=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator /=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator %=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator &=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator |=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator ^=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, bool op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, bool op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator >(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator <(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator >=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator <=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator ==(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, bool op2) { return op.operator !=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(1), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::mult operator *(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator *(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::plus operator +(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator +(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::minus operator -(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator -(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::div operator /(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator /(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::mod operator %(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator %(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator &(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator &(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator |(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator |(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, _AP_S>::logic operator ^(char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator ^(ap_private<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, bool _AP_S> char operator >>(char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> char operator <<(char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator +=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator -=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator *=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator /=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator %=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator &=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator |=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator ^=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator >(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator <(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator >=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator <=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator ==(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, char op2) { return op.operator !=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator *(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator +(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator -(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::div operator /(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator /(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator %(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator &(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator |(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(signed char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator ^(ap_private<(8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> signed char operator >>(signed char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> signed char operator <<(signed char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, signed char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator +=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator -=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator *=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator /=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator %=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator &=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator |=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator ^=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, signed char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, signed char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator >(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator <(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator >=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator <=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator ==(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, signed char op2) { return op.operator !=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator *(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator +(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator -(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator /(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator %(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator &(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator |(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned char i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator ^(ap_private<(8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned char operator >>(unsigned char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned char operator <<(unsigned char i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned char i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator +=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator -=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator *=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator /=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator %=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator &=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator |=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator ^=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned char op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator >(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator <(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator >=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator <=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator ==(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned char op2) { return op.operator !=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator *(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator +(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator -(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator /(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator %(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator &(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator |(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator ^(ap_private<(sizeof(short) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> short operator >>(short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> short operator <<(short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(short) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, short i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator +=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator -=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator *=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator /=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator %=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator &=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator |=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator ^=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, short op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, short op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator >(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator <(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator >=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator <=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator ==(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, short op2) { return op.operator !=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator *(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator +(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator -(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator /(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator %(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator &(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator |(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned short i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator ^(ap_private<(sizeof(unsigned short) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned short operator >>(unsigned short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned short operator <<(unsigned short i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned short i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator +=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator -=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator *=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator /=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator %=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator &=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator |=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator ^=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned short op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator >(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator <(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator >=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator <=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator ==(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned short op2) { return op.operator !=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator *(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator +(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator -(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator /(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator %(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator &(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator |(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator ^(ap_private<(sizeof(int) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> int operator >>(int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> int operator <<(int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(int) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, int i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator +=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator -=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator *=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator /=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator %=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator &=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator |=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator ^=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, int op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, int op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator >(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator <(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator >=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator <=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator ==(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, int op2) { return op.operator !=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator *(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator +(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator -(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator /(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator %(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator &(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator |(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned int i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator ^(ap_private<(sizeof(unsigned int) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned int operator >>(unsigned int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned int operator <<(unsigned int i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned int i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator +=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator -=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator *=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator /=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator %=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator &=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator |=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator ^=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned int op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator >(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator <(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator >=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator <=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator ==(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned int op2) { return op.operator !=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator *(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator +(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator -(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator /(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator %(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator &(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator |(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator ^(ap_private<(sizeof(long) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> long operator >>(long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> long operator <<(long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(long) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, long i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator +=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator -=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator *=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator /=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator %=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator &=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator |=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator ^=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, long op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, long op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator >(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator <(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator >=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator <=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator ==(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, long op2) { return op.operator !=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator *(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator +(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator -(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator /(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator %(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator &(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator |(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(unsigned long i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator ^(ap_private<(sizeof(unsigned long) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> unsigned long operator >>(unsigned long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> unsigned long operator <<(unsigned long i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, unsigned long i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator +=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator -=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator *=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator /=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator %=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator &=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator |=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator ^=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, unsigned long op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator >(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator <(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator >=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator <=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator ==(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, unsigned long op2) { return op.operator !=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::mult operator *(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator *(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::plus operator +(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator +(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::minus operator -(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator -(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::div operator /(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::div operator /(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator /(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::mod operator %(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator %(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator &(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator &(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator |(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator |(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, _AP_S>::logic operator ^(ap_slong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator ^(ap_private<(sizeof(ap_slong) * 8), (true)>(i_op)); } template <int _AP_W, bool _AP_S> ap_slong operator >>(ap_slong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> ap_slong operator <<(ap_slong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, ap_slong i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator +=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator -=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator *=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator /=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator %=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator &=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator |=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator ^=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, ap_slong op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator >(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator <(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator >=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator <=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator ==(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, ap_slong op2) { return op.operator !=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator !=(op); }
template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::mult operator *(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator *(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::mult operator *(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator *(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::plus operator +(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator +(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::plus operator +(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator +(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::minus operator -(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator -(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::minus operator -(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator -(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::div operator /(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator /(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::div operator /(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator /(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::mod operator %(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator %(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::mod operator %(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator %(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator &(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator &(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator &(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator &(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator |(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator |(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator |(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator |(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, _AP_S>::logic operator ^(ap_ulong i_op, const ap_private<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op).operator ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator ^(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator ^(ap_private<(sizeof(ap_ulong) * 8), (false)>(i_op)); } template <int _AP_W, bool _AP_S> ap_ulong operator >>(ap_ulong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op >>(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator >>(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator >>(i_op); } template <int _AP_W, bool _AP_S> ap_ulong operator <<(ap_ulong i_op, const ap_private<_AP_W, _AP_S, false>& op) { return i_op <<(op.get_VAL()); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, _AP_S>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator <<(const ap_private<_AP_W, _AP_S>& op, ap_ulong i_op) { return op.operator <<(i_op); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator +=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator +=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator -=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator -=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator *=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator *=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator /=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator /=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator %=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator %=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator &=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator &=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator |=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator |=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator ^=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator ^=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator >>=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { op = op.operator>>(op2); return op; } template <int _AP_W, bool _AP_S> inline ap_private<_AP_W, _AP_S>& operator <<=( ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { op = op.operator<<(op2); return op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator >(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >(op); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator <(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <(op); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator >=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >=(op); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator <=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <=(op); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator ==(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ==(op); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_private<_AP_W, _AP_S>& op, ap_ulong op2) { return op.operator !=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const ap_private<_AP_W, _AP_S, false>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator !=(op); }
# 6977 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator +(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator -(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator *(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator /(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator %(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator &(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator |(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ^(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>(ap_private<_AP_W2, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <<(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<(ap_private<_AP_W2, false>(op2)); }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator +=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator +=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator -=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator -=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator *=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator *=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator /=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator /=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator %=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator %=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator &=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator &=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator |=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator |=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator ^=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator ^=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator >>=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator >>=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator <<=( ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<=(ap_private<_AP_W2, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_range_ref<_AP_W1, _AP_S1>& operator <<=( _private_range_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<_AP_W1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_private<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const _private_range_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_private<_AP_W2, false>()); }
# 7052 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator +=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator +=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator +=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator -=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator -=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator -=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator *=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator *=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator *=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator /=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator /=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator /=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator %=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator %=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator %=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator &=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator &=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator &=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator |=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator |=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator |=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator ^=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator ^=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator ^=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator >>=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator >>=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator >>=(op2); op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_private<_AP_W1, _AP_S1>& operator <<=( ap_private<_AP_W1, _AP_S1>& op1, _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<=(ap_private<1, false>(op2)); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline _private_bit_ref<_AP_W1, _AP_S1>& operator <<=( _private_bit_ref<_AP_W1, _AP_S1>& op1, ap_private<_AP_W2, _AP_S2>& op2) { ap_private<1, false> tmp(op1); tmp.operator <<=(op2); op1 = tmp; return op1; }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator +(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator +(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator -(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator -(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator *(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator *(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator /(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator /(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator %(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator %(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator &(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator &(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator |(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator |(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator ^(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ^(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator >>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >>(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<1, false>(op1).operator <<(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <<(ap_private<1, false>(op2)); }


template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(ap_private<1, false>(op2)); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const _private_bit_ref<_AP_W1, _AP_S1>& op1, const ap_private<_AP_W2, _AP_S2>& op2) { return ap_private<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_private<_AP_W1, _AP_S1>& op1, const _private_bit_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(ap_private<1, false>(op2)); }
# 7117 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, bool op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, short op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, int op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, long op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
template <int _AP_W, bool _AP_S> inline bool operator >(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))> op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))< op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator >=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))>= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 >=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator <=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))<= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 <=(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator ==(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ==( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator ==(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))== op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 ==(bool(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator !=(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator !=( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline bool operator !=(const _private_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (bool(op))!= op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const _private_bit_ref<_AP_W, _AP_S>& op) { return op2 !=(bool(op)); }
# 7163 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, bool op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(1), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(1), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (CHAR_IS_SIGNED)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (CHAR_IS_SIGNED)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, signed char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::div operator /(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(short) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, short op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(short) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(short) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(short) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned short) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned short) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned short) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned short) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::div operator /(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(int) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, int op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(int) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(int) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(int) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned int) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned int) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned int) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned int) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::div operator /(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(long) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, long op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(long) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(long) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(long) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(unsigned long) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(unsigned long) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(unsigned long) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(unsigned long) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_slong) * 8), (true)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(ap_slong) * 8), (true)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_slong) * 8), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_slong) * 8), (true)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator +(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator +( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator -(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator -( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator *(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator *( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::div operator /(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator /(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator /( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator %(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator %( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator &(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator &( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator |(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator |( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator ^(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator ^( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator >>(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator >>( ap_private<_AP_W, false>(op)); } template <int _AP_W, bool _AP_S> inline typename ap_private<_AP_W, false>::template RType<(sizeof(ap_ulong) * 8), (false)>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return (ap_private<_AP_W, false>(op)) . operator <<(ap_private<(sizeof(ap_ulong) * 8), (false)>(op2)); } template <int _AP_W, bool _AP_S> inline typename ap_private<(sizeof(ap_ulong) * 8), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const _private_range_ref<_AP_W, _AP_S>& op) { return ap_private<(sizeof(ap_ulong) * 8), (false)>(op2).operator <<( ap_private<_AP_W, false>(op)); }
# 7188 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/etc/ap_private.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator +( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator -( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator *( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator /( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator %( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator &( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator |( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator ^( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator >>( ap_private<_AP_W2, false>(rhs)); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_private<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const _private_range_ref<_AP_W, _AP_S>& lhs, const _private_range_ref<_AP_W2, _AP_S2>& rhs) { return ap_private<_AP_W, false>(lhs).operator <<( ap_private<_AP_W2, false>(rhs)); }
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h" 2


template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ROOT_op_concat(const _Tp1& Ret, const _Tp2& X, const _Tp3& Y) {
  _Tp1 r = (X).operator,(Y);
  return r;
}

template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1& _AP_ROOT_op_set_bit(_Tp1& Val, const _Tp2& Bit, const _Tp3& Repl) {
  (Val).set_bit((Bit), (Repl));
  return Val;
}



template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
inline _Tp1& _AP_ROOT_op_set_range(_Tp1& Val, const _Tp2& Lo, const _Tp3& Hi,
                                   const _Tp4& Repl) {
  (Val).range((Hi), (Lo)) = Repl;
  return (Val);
}
# 691 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
inline ap_ulong doubleToRawBits(double pf) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline unsigned int floatToRawBits(float pf) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__D = pf;
  return LD.__L;
}

inline unsigned short halfToRawBits(half pf) {
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
  return pf.get_bits();

}


inline double rawBitsToDouble(ap_ulong pi) {
  union {
    ap_ulong __L;
    double __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline float rawBitsToFloat(unsigned long pi) {
  union {
    unsigned int __L;
    float __D;
  } LD;
  LD.__L = pi;
  return LD.__D;
}


inline half rawBitsToHalf(unsigned short pi) {
# 753 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_common.h"
  half __D;
  __D.set_bits(pi);
  return __D;

}
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 1
# 80 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_N, bool _AP_S>
struct retval;


template <int _AP_N>
struct retval<_AP_N, true> {
  typedef ap_slong Type;
};

template <int _AP_N>
struct retval<_AP_N, false> {
  typedef ap_ulong Type;
};


template <>
struct retval<1, true> {
  typedef signed char Type;
};

template <>
struct retval<1, false> {
  typedef unsigned char Type;
};


template <>
struct retval<2, true> {
  typedef short Type;
};

template <>
struct retval<2, false> {
  typedef unsigned short Type;
};


template <>
struct retval<3, true> {
  typedef long Type;
};

template <>
struct retval<3, false> {
  typedef unsigned long Type;
};

template <>
struct retval<4, true> {
  typedef long Type;
};

template <>
struct retval<4, false> {
  typedef unsigned long Type;
};




template <int _AP_W2, bool _AP_S2>
struct _ap_int_factory;
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,true> { typedef ap_int<_AP_W2> type; };
template <int _AP_W2>
struct _ap_int_factory<_AP_W2,false> { typedef ap_uint<_AP_W2> type; };

template <int _AP_W, bool _AP_S>
struct ap_int_base : public ssdm_int_sim<_AP_W, _AP_S> {
 public:
  typedef ssdm_int_sim<_AP_W, _AP_S> Base;







  typedef typename retval<(((_AP_W + 7) / 8) > (8) ? ((_AP_W + 7) / 8) : (8)), _AP_S>::Type RetType;

  static const int width = _AP_W;

  template <int _AP_W2, bool _AP_S2>
  struct RType {
    enum {
      mult_w = _AP_W + _AP_W2,
      mult_s = _AP_S || _AP_S2,
      plus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,
      div_w = _AP_W + _AP_S2,
      div_s = _AP_S || _AP_S2,
      mod_w = ((_AP_W) < (_AP_W2 + (!_AP_S2 && _AP_S)) ? (_AP_W) : (_AP_W2 + (!_AP_S2 && _AP_S))),
      mod_s = _AP_S,
      logic_w = ((_AP_W + (_AP_S2 && !_AP_S)) > (_AP_W2 + (_AP_S && !_AP_S2)) ? (_AP_W + (_AP_S2 && !_AP_S)) : (_AP_W2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };


    typedef ap_int_base<mult_w, mult_s> mult_base;
    typedef ap_int_base<plus_w, plus_s> plus_base;
    typedef ap_int_base<minus_w, minus_s> minus_base;
    typedef ap_int_base<logic_w, logic_s> logic_base;
    typedef ap_int_base<div_w, div_s> div_base;
    typedef ap_int_base<mod_w, mod_s> mod_base;
    typedef ap_int_base<_AP_W, _AP_S> arg1_base;

    typedef typename _ap_int_factory<mult_w, mult_s>::type mult;
    typedef typename _ap_int_factory<plus_w, plus_s>::type plus;
    typedef typename _ap_int_factory<minus_w, minus_s>::type minus;
    typedef typename _ap_int_factory<logic_w, logic_s>::type logic;
    typedef typename _ap_int_factory<div_w, div_s>::type div;
    typedef typename _ap_int_factory<mod_w, mod_s>::type mod;
    typedef typename _ap_int_factory<_AP_W, _AP_S>::type arg1;
    typedef bool reduce;
  };





  inline ap_int_base() {





  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }
# 237 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline ap_int_base(const bool op) { Base::V = op; }
  inline ap_int_base(const char op) { Base::V = op; }
  inline ap_int_base(const signed char op) { Base::V = op; }
  inline ap_int_base(const unsigned char op) { Base::V = op; }
  inline ap_int_base(const short op) { Base::V = op; }
  inline ap_int_base(const unsigned short op) { Base::V = op; }
  inline ap_int_base(const int op) { Base::V = op; }
  inline ap_int_base(const unsigned int op) { Base::V = op; }
  inline ap_int_base(const long op) { Base::V = op; }
  inline ap_int_base(const unsigned long op) { Base::V = op; }
  inline ap_int_base(const ap_slong op) { Base::V = op; }
  inline ap_int_base(const ap_ulong op) { Base::V = op; }




  inline ap_int_base(half op) {
    ap_int_base<_AP_W, _AP_S> t((float)op);
    Base::V = t.V;
  }


  inline ap_int_base(float op) {
    const int BITS = 23 + 8 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = floatToRawBits(op);
    bool is_neg = (reg.V).get_bit((BITS - 1));

    ap_int_base<8 + 1, true> exp = 0;
    exp.V = (reg.V).range((BITS - 2), (23));
    exp = exp - ((1L << (8 - 1L)) - 1L);

    ap_int_base<23 + 2, true> man;
    man.V = (reg.V).range((23 - 1), (0));

    do { if ((exp == ((unsigned char)(((1L << (8 - 1L)) - 1L) + 1)) && man.V != 0)) { fprintf(
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "WARNING: " "assign NaN to ap integer value"); fprintf(
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 272 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); } } while (0)
                                                 ;

    man.V = _AP_ROOT_op_set_bit(man.V, 23, 1);


    if ((reg.V & 0x7ffffffful) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 23 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 23 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  inline ap_int_base(double op) {
    const int BITS = 52 + 11 + 1;
    ap_int_base<BITS, false> reg;
    reg.V = doubleToRawBits(op);
    bool is_neg = (reg.V).get_bit((BITS - 1));

    ap_int_base<11 + 1, true> exp = 0;
    exp.V = (reg.V).range((BITS - 2), (52));
    exp = exp - ((1L << (11 - 1L)) - 1L);

    ap_int_base<52 + 2, true> man;
    man.V = (reg.V).range((52 - 1), (0));

    do { if ((exp == ((unsigned char)(((1L << (11 - 1L)) - 1L) + 1)) && man.V != 0)) { fprintf(
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "WARNING: " "assign NaN to ap integer value"); fprintf(
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); } } while (0)
                                                 ;

    man.V = _AP_ROOT_op_set_bit(man.V, 52, 1);


    if ((reg.V & 0x7fffffffffffffffull) == 0) {
      Base::V = 0;
    } else {
      int sh_amt = 52 - exp.V;
      if (sh_amt == 0) {
        Base::V = man.V;
      } else if (sh_amt > 0) {
        if (sh_amt < 52 + 2) {
          Base::V = man.V >> sh_amt;
        } else {
          if (is_neg)
            Base::V = -1;
          else
            Base::V = 0;
        }
      } else {
        sh_amt = -sh_amt;
        if (sh_amt < _AP_W) {
          Base::V = man.V;
          Base::V <<= sh_amt;
        } else {
          Base::V = 0;
        }
      }
    }
    if (is_neg) *this = -(*this);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_range_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = (ref.get()).V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base(const ap_bit_ref<_AP_W2, _AP_S2>& ref) {
    Base::V = ref.operator bool();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref) {
    const ap_int_base<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>::_AP_WR,
                      false>
        tmp = ref.get();
    Base::V = tmp.V;
  }




  inline ap_int_base(const char* s, signed char rd = 0) {
    if (rd == 0)
      rd = guess_radix(s);
    unsigned int length = strlen(s);
    Base::V.fromString(s, length, rd);
  }
# 405 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = (val.get()).V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    Base::V = val.operator bool();
  }

  inline ap_int_base read() volatile {

    ap_int_base ret;
    ret.V = Base::V;
    return ret;
  }

  inline void write(const ap_int_base<_AP_W, _AP_S>& op2) volatile {

    Base::V = op2.V;
  }


  template <int _AP_W2, bool _AP_S2>
  inline void operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline void operator=(
      const volatile ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline void operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) volatile {
    Base::V = op2.V;
  }

  inline void operator=(const ap_int_base<_AP_W, _AP_S>& op2) volatile {
    Base::V = op2.V;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(
      const volatile ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_int_base<_AP_W2, _AP_S2>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline ap_int_base& operator=(const volatile ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }

  inline ap_int_base& operator=(const ap_int_base<_AP_W, _AP_S>& op2) {
    Base::V = op2.V;
    return *this;
  }
# 482 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline ap_int_base& operator=(bool op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(signed char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned char op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(short op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned short op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(int op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned int op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(long op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(unsigned long op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(ap_slong op) { Base::V = op; return *this; }
  inline ap_int_base& operator=(ap_ulong op) { Base::V = op; return *this; }



  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (bool)op2;
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int_base& operator=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    Base::V = (ap_int_base<_AP_W2, false>(op2)).V;
    return *this;
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base& operator=(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op2) {
    Base::V = op2.get().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = op.to_ap_int_base().V;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = (bool)op;
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int_base& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    Base::V = ((const ap_int_base<_AP_W2, false>)(op)).V;
    return *this;
  }





  inline operator RetType() const { return (RetType)(Base::V); }




  inline bool to_bool() const { return (bool)(Base::V); }
  inline char to_char() const { return (char)(Base::V); }
  inline signed char to_schar() const { return (signed char)(Base::V); }
  inline unsigned char to_uchar() const { return (unsigned char)(Base::V); }
  inline short to_short() const { return (short)(Base::V); }
  inline unsigned short to_ushort() const { return (unsigned short)(Base::V); }
  inline int to_int() const { return (int)(Base::V); }
  inline unsigned to_uint() const { return (unsigned)(Base::V); }
  inline long to_long() const { return (long)(Base::V); }
  inline unsigned long to_ulong() const { return (unsigned long)(Base::V); }
  inline ap_slong to_int64() const { return (ap_slong)(Base::V); }
  inline ap_ulong to_uint64() const { return (ap_ulong)(Base::V); }
  inline float to_float() const { return (float)(Base::V); }
  inline double to_double() const { return (double)(Base::V); }
# 586 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline int length() const volatile { return _AP_W; }


  inline bool iszero() const { return Base::V == 0; }


  inline bool is_zero() const { return Base::V == 0; }


  inline bool sign() const {
    if (_AP_S &&
        (Base::V).get_bit((_AP_W - 1)))
      return true;
    else
      return false;
  }


  inline void clear(int i) {
    
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",605),0))
# 605 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);
  }


  inline void invert(int i) {
    
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",611),0))
# 611 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    bool val = (Base::V).get_bit((i));
    if (val)
      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 0);
    else
      Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);
  }

  inline bool test(int i) const {
    
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",620),0))
# 620 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    return (Base::V).get_bit((i));
  }


  inline ap_int_base& get() { return *this; }


  inline void set(int i) {
    
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",629),0))
# 629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, 1);
  }


  inline void set(int i, bool v) {
    
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (i >= 0 && i < _AP_W) && ("position out of range")
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(i >= 0 && i < _AP_W) && (\"position out of range\")"
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",635),0))
# 635 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                          ;
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);
  }



  inline ap_int_base& lrotate(int n) {
    
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (n >= 0 && n < _AP_W) && ("shift value out of range")
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(n >= 0 && n < _AP_W) && (\"shift value out of range\")"
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",642),0))
# 642 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                             ;






    Base::V.lrotate(n);

    return *this;
  }



  inline ap_int_base& rrotate(int n) {
    
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (n >= 0 && n < _AP_W) && ("shift value out of range")
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(n >= 0 && n < _AP_W) && (\"shift value out of range\")"
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",657),0))
# 657 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                             ;






    Base::V.rrotate(n);

    return *this;
  }



  inline ap_int_base& reverse() {
    Base::V = (Base::V).range((0), (_AP_W - 1));
    return *this;
  }


  inline void set_bit(int i, bool v) {
    Base::V = _AP_ROOT_op_set_bit(Base::V, i, v);
  }


  inline bool get_bit(int i) const {
    return (bool)(Base::V).get_bit((i));
  }


  inline void b_not() { Base::V = ~Base::V; }
# 699 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator *=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V *= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator +=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V += op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator -=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V -= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator /=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V /= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator %=(const ap_int_base<_AP_W2, _AP_S2>& op2) { Base::V %= op2.V; return *this; }
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator &=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "&=" "ap_[u]int."); fprintf(
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 717 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V &= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator |=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "|=" "ap_[u]int."); fprintf(
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 718 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V |= op2.V; return *this; }
  template <int _AP_W2, bool _AP_S2> inline ap_int_base& operator ^=(const ap_int_base<_AP_W2, _AP_S2>& op2) { do { if (((_AP_W != _AP_W2))) { fprintf(
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "WARNING: " "Bitsize mismatch for ap_[u]int" "^=" "ap_[u]int."); fprintf(
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
 (&__iob_func()[2])
# 719 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
 , "\n"); } } while (0); Base::V ^= op2.V; return *this; }





  inline ap_int_base& operator++() {
    operator+=((ap_int_base<1, false>)1);
    return *this;
  }
  inline ap_int_base& operator--() {
    operator-=((ap_int_base<1, false>)1);
    return *this;
  }




  inline const typename RType<_AP_W,_AP_S>::arg1 operator++(int) {
    ap_int_base t = *this;
    operator+=((ap_int_base<1, false>)1);
    return t;
  }
  inline const typename RType<_AP_W,_AP_S>::arg1 operator--(int) {
    ap_int_base t = *this;
    operator-=((ap_int_base<1, false>)1);
    return t;
  }




  inline typename RType<_AP_W,_AP_S>::arg1 operator+() const { return *this; }


  inline typename RType<1, false>::minus operator-() const {
    return ap_int_base<1, false>(0) - *this;
  }




  inline bool operator!() const { return Base::V == 0; }





  inline typename RType<_AP_W,_AP_S>::arg1 operator~() const {
    ap_int_base<_AP_W, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>(sh);
    } else
      return operator<<(sh);
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V << op2.to_uint();
    return r;
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<(sh);
    }
    return operator>>(sh);
  }

  template <int _AP_W2>
  inline typename RType<_AP_W,_AP_S>::arg1 operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    ap_int_base r;
    r.V = Base::V >> op2.to_uint();
    return r;
  }
# 828 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2>
  inline ap_int_base& operator<<=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator>>=(sh);
    } else
      return operator<<=(sh);
  }

  template <int _AP_W2>
  inline ap_int_base& operator<<=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V <<= op2.to_uint();
    return *this;
  }

  template <int _AP_W2>
  inline ap_int_base& operator>>=(const ap_int_base<_AP_W2, true>& op2) {
    bool isNeg = (op2.V).get_bit((_AP_W2 - 1));
    ap_int_base<_AP_W2, false> sh = op2;
    if (isNeg) {
      sh = -op2;
      return operator<<=(sh);
    }
    return operator>>=(sh);
  }

  template <int _AP_W2>
  inline ap_int_base& operator>>=(const ap_int_base<_AP_W2, false>& op2) {
    Base::V >>= op2.to_uint();
    return *this;
  }
# 877 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V == op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return !(Base::V == op2.V);
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V < op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V >= op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V > op2.V;
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_int_base<_AP_W2, _AP_S2>& op2) const {
    return Base::V <= op2.V;
  }




  inline ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) {
    do { if ((Hi >= _AP_W)) { fprintf(
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Hi(%d)out of bound(%d) in range()", Hi, _AP_W); fprintf(
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 906 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    do { if ((Lo >= _AP_W)) { fprintf(
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Lo(%d)out of bound(%d) in range()", Lo, _AP_W); fprintf(
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 907 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    return ap_range_ref<_AP_W, _AP_S>(this, Hi, Lo);
  }


  inline ap_range_ref<_AP_W, _AP_S> range(int Hi, int Lo) const {
    do { if ((Hi >= _AP_W)) { fprintf(
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Hi(%d)out of bound(%d) in range()", Hi, _AP_W); fprintf(
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 913 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    do { if ((Lo >= _AP_W)) { fprintf(
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "ERROR: " "Lo(%d)out of bound(%d) in range()", Lo, _AP_W); fprintf(
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (&__iob_func()[2])
# 914 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   , "\n"); abort(); } } while (0);
    return ap_range_ref<_AP_W, _AP_S>(const_cast<ap_int_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline ap_range_ref<_AP_W, _AP_S> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline ap_range_ref<_AP_W, _AP_S> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline ap_range_ref<_AP_W, _AP_S> operator()(int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline ap_range_ref<_AP_W, _AP_S> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }
# 986 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline ap_bit_ref<_AP_W, _AP_S> operator[](int index) {
    
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",987),0))
# 987 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",988),0))
# 988 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref<_AP_W, _AP_S> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",996),0))
# 996 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",997),0))
# 997 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline bool operator[](int index) const {
    
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1003),0))
# 1003 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1004),0))
# 1004 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }
  template <int _AP_W2, bool _AP_S2>
  inline bool operator[](const ap_int_base<_AP_W2, _AP_S2>& index) const {
    
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1010),0))
# 1010 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index.to_int());
    return br.to_bool();
  }

  inline ap_bit_ref<_AP_W, _AP_S> bit(int index) {
    
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1016),0))
# 1016 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1017),0))
# 1017 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index);
    return bvh;
  }
  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref<_AP_W, _AP_S> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1024),0))
# 1024 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1025),0))
# 1025 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> bvh(this, index.to_int());
    return bvh;
  }

  inline bool bit(int index) const {
    
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index >= 0) && ("Attempting to read bit with negative index")
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index >= 0) && (\"Attempting to read bit with negative index\")"
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1031),0))
# 1031 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                      ;
    
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   (void) ((!!(
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   (index < _AP_W) && ("Attempting to read bit beyond MSB")
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   )) || (_assert(
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
   "(index < _AP_W) && (\"Attempting to read bit beyond MSB\")"
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h" 3
   ,"D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h",1032),0))
# 1032 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
                                                                ;
    ap_bit_ref<_AP_W, _AP_S> br(this, index);
    return br.to_bool();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool bit(const ap_int_base<_AP_W2, _AP_S2>& index) const {
    return bit(index.to_int());
  }
# 1053 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  inline int countLeadingZeros() {
# 1088 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
    return (Base::V).countLeadingZeros();

  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(const ap_int_base<_AP_W2, _AP_S2>& a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  concat(ap_int_base<_AP_W2, _AP_S2>& a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this), a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) const {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_int_base, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_int_base, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       a2);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) const {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        const_cast<ap_int_base<_AP_W, _AP_S>&>(*this),
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_int_base, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        _AP_W, ap_int_base, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this, a2);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator&(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this & a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator|(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this | a2.get();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int_base<((_AP_W2 + _AP_W3) > (_AP_W) ? (_AP_W2 + _AP_W3) : (_AP_W)), _AP_S> operator^(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& a2) {
    return *this ^ a2.get();
  }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    Base::V = val.V;
  }





  inline bool and_reduce() const { return (Base::V).and_reduce(); }
  inline bool nand_reduce() const { return (Base::V).nand_reduce(); }
  inline bool or_reduce() const { return (Base::V).or_reduce(); }
  inline bool nor_reduce() const { return !((Base::V).or_reduce()); }
  inline bool xor_reduce() const { return (Base::V).xor_reduce(); }
  inline bool xnor_reduce() const {
    return !((Base::V).xor_reduce());
  }





  std::string to_string(signed char rd = 2, bool sign = _AP_S) const {


    if (rd == 2) sign = false;
    return (Base::V).to_string(rd, sign);
  }





};




template <int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& os,
                                const ap_int_base<_AP_W, _AP_S>& x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.to_string(16);
  } else if (ff & std::cout.oct) {
    os << x.to_string(8);
  } else {
    os << x.to_string(10);
  }
  return os;
}



template <int _AP_W, bool _AP_S>
inline std::istream& operator>>(std::istream& in,
                                ap_int_base<_AP_W, _AP_S>& op) {
  std::string str;
  in >> str;
  const std::ios_base::fmtflags basefield = in.flags() & std::ios_base::basefield;
  unsigned radix = (basefield == std::ios_base::dec) ? 0 : (
                     (basefield == std::ios_base::oct) ? 8 : (
                       (basefield == std::ios_base::hex) ? 16 : 0));
  op = ap_int_base<_AP_W, _AP_S>(str.c_str(), radix);
  return in;
}
# 1352 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mult_base ret; ret.V = lhs.V * rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::plus_base ret; ret.V = lhs.V + rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::minus_base ret; ret.V = lhs.V - rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V & rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V | rhs.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base lhs(op); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base rhs(op2); typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::logic_base ret; ret.V = lhs.V ^ rhs.V; return ret; }
# 1371 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::div_base ret; ret.V = op.V / op2.V; return ret; }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { typename ap_int_base<_AP_W, _AP_S>::template RType< _AP_W2, _AP_S2>::mod_base ret; ret.V = op.V % op2.V; return ret; }
# 1399 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op + op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator +(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 + i_op; }
template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(PTR_TYPE* i_op, const ap_int_base<_AP_W, _AP_S>& op) { ap_slong op2 = op.to_int64(); return i_op - op2; } template <typename PTR_TYPE, int _AP_W, bool _AP_S> inline PTR_TYPE* operator -(const ap_int_base<_AP_W, _AP_S>& op, PTR_TYPE* i_op) { ap_slong op2 = op.to_int64(); return op2 - i_op; }
# 1427 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline half operator *(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline half operator *(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline half operator /(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline half operator /(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline half operator +(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline half operator +(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline half operator -(half i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline half operator -(const ap_int_base<_AP_W, _AP_S>& op, half i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline float operator *(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline float operator *(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline float operator /(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline float operator /(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline float operator +(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline float operator +(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline float operator -(float i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline float operator -(const ap_int_base<_AP_W, _AP_S>& op, float i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
template <int _AP_W, bool _AP_S> inline double operator *(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op * op2; } template <int _AP_W, bool _AP_S> inline double operator *(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 * i_op; } template <int _AP_W, bool _AP_S> inline double operator /(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op / op2; } template <int _AP_W, bool _AP_S> inline double operator /(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 / i_op; } template <int _AP_W, bool _AP_S> inline double operator +(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op + op2; } template <int _AP_W, bool _AP_S> inline double operator +(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 + i_op; } template <int _AP_W, bool _AP_S> inline double operator -(double i_op, const ap_int_base<_AP_W, _AP_S>& op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return i_op - op2; } template <int _AP_W, bool _AP_S> inline double operator -(const ap_int_base<_AP_W, _AP_S>& op, double i_op) { typename ap_int_base<_AP_W, _AP_S>::RetType op2 = op; return op2 - i_op; }
# 1461 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op * ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op + ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op - ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op / ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op % ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op & ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op | ap_int_base<1, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, bool i_op) { return op ^ ap_int_base<1, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op * ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op + ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op - ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op / ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op % ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op & ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op | ap_int_base<8, CHAR_IS_SIGNED>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, CHAR_IS_SIGNED>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, char i_op) { return op ^ ap_int_base<8, CHAR_IS_SIGNED>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op * ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op + ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op - ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op / ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op % ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op & ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op | ap_int_base<8, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, signed char i_op) { return op ^ ap_int_base<8, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op * ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op + ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op - ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op / ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op % ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op & ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op | ap_int_base<8, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<8, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned char i_op) { return op ^ ap_int_base<8, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op * ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op + ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op - ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op / ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op % ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op & ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op | ap_int_base<_AP_SIZE_short, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, short i_op) { return op ^ ap_int_base<_AP_SIZE_short, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op * ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op + ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op - ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op / ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op % ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op & ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op | ap_int_base<_AP_SIZE_short, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_short, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned short i_op) { return op ^ ap_int_base<_AP_SIZE_short, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op * ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op + ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op - ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op / ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op % ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op & ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op | ap_int_base<_AP_SIZE_int, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, int i_op) { return op ^ ap_int_base<_AP_SIZE_int, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op * ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op + ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op - ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op / ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op % ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op & ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op | ap_int_base<_AP_SIZE_int, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_int, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned int i_op) { return op ^ ap_int_base<_AP_SIZE_int, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op * ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op + ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op - ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op / ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op % ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op & ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op | ap_int_base<_AP_SIZE_long, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, long i_op) { return op ^ ap_int_base<_AP_SIZE_long, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op * ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op + ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op - ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op / ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op % ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op & ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op | ap_int_base<_AP_SIZE_long, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_long, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, unsigned long i_op) { return op ^ ap_int_base<_AP_SIZE_long, false>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, true>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, true>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_slong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, true>(i_op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) *(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mult operator *(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op * ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) +(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::plus operator +(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op + ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) -(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::minus operator -(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op - ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) /(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::div operator /(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op / ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) %(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::mod operator %(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op % ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) &(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator &(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op & ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) |(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator |(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op | ap_int_base<_AP_SIZE_ap_slong, false>(i_op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) ^(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_SIZE_ap_slong, false>::logic operator ^(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong i_op) { return op ^ ap_int_base<_AP_SIZE_ap_slong, false>(i_op); }
# 1500 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, char op2) { ap_int_base<_AP_W, _AP_S> r; if (CHAR_IS_SIGNED) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, short op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, int op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, long op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V << op2) : (op.V >> (-op2)); else r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { ap_int_base<_AP_W, _AP_S> r; if (true) r.V = op2 >= 0 ? (op.V >> op2) : (op.V << (-op2)); else r.V = op.V >> op2; return r; }
# 1524 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, bool op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator<<( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V << op2; return r; } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, _AP_S>::template RType<_AP_W,_AP_S>::arg1 operator>>( const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { ap_int_base<_AP_W, _AP_S> r; r.V = op.V >> op2; return r; }
# 1555 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op += ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op -= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op *= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op /= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op %= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op &= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op |= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op ^= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >>= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <<= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op += ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op -= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op *= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op /= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op %= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op &= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op |= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op ^= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >>= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <<= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op += ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op -= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op *= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op /= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op %= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op &= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op |= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op ^= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >>= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <<= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op += ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op -= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op *= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op /= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op %= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op &= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op |= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op ^= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >>= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <<= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op += ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op -= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op *= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op /= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op %= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op &= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op |= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op ^= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >>= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <<= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op += ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op -= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op *= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op /= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op %= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op &= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op |= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op ^= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >>= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <<= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op += ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op -= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op *= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op /= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op %= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op &= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op |= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op ^= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >>= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <<= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op += ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op -= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op *= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op /= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op %= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op &= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op |= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op ^= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >>= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <<= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op += ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op -= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op *= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op /= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op %= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op &= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op |= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op ^= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >>= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <<= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op += ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op -= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op *= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op /= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op %= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op &= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op |= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op ^= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >>= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <<= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator +=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op += ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator -=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op -= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator *=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op *= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator /=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op /= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator %=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op %= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator &=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op &= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator |=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op |= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator ^=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op ^= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator >>=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >>= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W, _AP_S>& operator <<=( ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <<= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1592 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W, bool _AP_S> inline bool operator >(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(bool i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<1, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, bool op2) { return op != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, CHAR_IS_SIGNED>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, char op2) { return op != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, signed char op2) { return op != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<8, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned char op2) { return op != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, short op2) { return op != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_short, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned short op2) { return op != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, int op2) { return op != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_int, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned int op2) { return op != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, long op2) { return op != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_long, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, unsigned long op2) { return op != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, true>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_slong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) > op; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) < op; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) >= op; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) <= op; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) == op; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong i_op, const ap_int_base<_AP_W, _AP_S>& op) { return ap_int_base<_AP_SIZE_ap_slong, false>(i_op) != op; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op, ap_ulong op2) { return op != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1629 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
  template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() > op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 > op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() < op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 < op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() >= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator >=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 >= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() <= op2 ; } template <int _AP_W, bool _AP_S> inline bool operator <=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 <= op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline bool operator ==(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() == op2 ; } template <int _AP_W, bool _AP_S> inline bool operator ==(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 == op2.to_double() ; }
  template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, double op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline bool operator !=(double op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_int_base<_AP_W, _AP_S>& op1, float op2) { return op1.to_double() != op2 ; } template <int _AP_W, bool _AP_S> inline bool operator !=(float op1, const ap_int_base<_AP_W, _AP_S>& op2) { return op1 != op2.to_double() ; }
# 1659 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) + op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) - op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) * op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) / op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) % op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) & op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) | op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) ^ op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) >> op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<_AP_W2, false>(op2); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1) << op2; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<_AP_W2, false>(op2); }
# 1690 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator +=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator -=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator *=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator /=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator %=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator >>=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<_AP_W2, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator <<=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1722 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator &=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator |=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W2, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_range_ref<_AP_W1, _AP_S1>& operator ^=( ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<_AP_W1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1741 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator ==(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator ==(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator !=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator !=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator >=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator >=(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <(op2.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_range_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<_AP_W1, false>(op1).operator <=(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_range_ref<_AP_W2, _AP_S2>& op2) { return op1.operator <=(op2.operator ap_int_base<_AP_W2, false>()); }
# 1768 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::plus operator +(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 + ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::plus operator +(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) + op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::minus operator -(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 - ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::minus operator -(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) - op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mult operator *(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 * ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mult operator *(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) * op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::div operator /(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 / ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::div operator /(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) / op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::mod operator %(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 % ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::mod operator %(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) % op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator &(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 & ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator &(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) & op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator |(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 | ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator |(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) | op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::logic operator ^(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 ^ ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::logic operator ^(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) ^ op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator >>(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >> ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator >>(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >> op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W1, _AP_S1>::template RType<1, false>::arg1 operator <<(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 << ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline typename ap_int_base<1, false>::template RType<_AP_W2, _AP_S2>::arg1 operator <<(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) << op2; }
# 1799 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator +=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 += ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator +=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp += op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator -=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 -= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator -=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp -= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator *=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 *= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator *=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp *= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator /=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 /= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator /=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp /= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator %=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 %= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator %=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp %= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator >>=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >>= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator >>=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp >>= op2; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator <<=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <<= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator <<=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp <<= op2; op1 = tmp; return op1; }
# 1831 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator &=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V &= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator &=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V &= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator |=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V |= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator |=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V |= op2.V; op1 = tmp; return op1; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W1, _AP_S1>& operator ^=( ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op2); op1.V ^= tmp.V; return op1; } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline ap_bit_ref<_AP_W1, _AP_S1>& operator ^=( ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { ap_int_base<1, false> tmp(op1); tmp.V ^= op2.V; op1 = tmp; return op1; }
# 1850 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 == ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator ==(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) == op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 != ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator !=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) != op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 > ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) > op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 >= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator >=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) >= op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 < ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) < op2; }
template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_int_base<_AP_W1, _AP_S1>& op1, const ap_bit_ref<_AP_W2, _AP_S2>& op2) { return op1 <= ap_int_base<1, false>(op2); } template <int _AP_W1, bool _AP_S1, int _AP_W2, bool _AP_S2> inline bool operator <=(const ap_bit_ref<_AP_W1, _AP_S1>& op1, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op1) <= op2; }
# 1958 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_base.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator ==( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 == op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator ==( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() == op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator !=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 != op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator !=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() != op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 > op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() > op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 >= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator >=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() >= op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 < op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() < op2; }
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <=( const ap_int_base<_AP_W3, _AP_S3>& op1, const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op2) { return op1 <= op2.get(); } template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2, int _AP_W3, bool _AP_S3> inline bool operator <=( const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& op1, const ap_int_base<_AP_W3, _AP_S3>& op2) { return op1.get() <= op2; }
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h" 1
# 73 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W1, typename _AP_T1, int _AP_W2, typename _AP_T2>
struct ap_concat_ref {
  enum {
    _AP_WR = _AP_W1 + _AP_W2,
  };

  _AP_T1& mbv1;
  _AP_T2& mbv2;

  inline ap_concat_ref(const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& ref)
      : mbv1(ref.mbv1), mbv2(ref.mbv2) {}

  inline ap_concat_ref(_AP_T1& bv1, _AP_T2& bv2) : mbv1(bv1), mbv2(bv2) {}

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> Part1;
    Part1.V = (vval.V).range((W_ref1 + W_ref2 - 1), (W_ref2));
    mbv1.set(Part1);
    ap_int_base<_AP_W2, false> Part2;
    Part2.V = (vval.V).range((W_ref2 - 1), (0));
    mbv2.set(Part2);
    return *this;
  }
# 116 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_concat_ref& operator=(bool val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(signed char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned char val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned short val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned int val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(unsigned long val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(ap_slong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(ap_ulong val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(half val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(float val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }
  inline ap_concat_ref& operator=(double val) { ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val); return operator=(tmpVal); }





  inline ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W1, _AP_T1, _AP_W2, _AP_T2>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline ap_concat_ref& operator=(
      const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_bit_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }
  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref& operator=(const ap_range_ref<_AP_W3, _AP_S3>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> tmpVal(val);
    return operator=(tmpVal);
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((const ap_int_base<_AP_W3, false>)(val));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const ap_fixed_base<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&
          val) {
    return operator=(val.to_ap_int_base());
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref& operator=(
      const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>& val) {
    return operator=((ap_ulong)(bool)(val));
  }

  inline operator ap_int_base<_AP_WR, false>() const { return get(); }

  inline operator ap_ulong() const { return get().to_uint64(); }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                       ap_range_ref<_AP_W3, _AP_S3> >
  operator,(const ap_range_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_range_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_range_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(*this, a2);
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(volatile ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const ap_int_base<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3, ap_int_base<_AP_W3, _AP_S3> >
      operator,(const volatile ap_int_base<_AP_W3, _AP_S3> &a2) {

    ap_int_base<_AP_W3, _AP_S3> op(a2);
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3,
                         ap_int_base<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_int_base<_AP_W3, _AP_S3>&>(op));
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >
  operator,(const ap_bit_ref<_AP_W3, _AP_S3> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, 1, ap_bit_ref<_AP_W3, _AP_S3> >(
        *this, const_cast<ap_bit_ref<_AP_W3, _AP_S3>&>(a2));
  }

  template <int _AP_W3, typename _AP_T3, int _AP_W4, typename _AP_T4>
  inline ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                       ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >
  operator,(const ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> &a2) {
    return ap_concat_ref<_AP_WR, ap_concat_ref, _AP_W3 + _AP_W4,
                         ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4> >(
        *this, const_cast<ap_concat_ref<_AP_W3, _AP_T3, _AP_W4, _AP_T4>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline ap_concat_ref<
      _AP_WR, ap_concat_ref, _AP_W3,
      af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
  operator,(
      const af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, _AP_W3,
        af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<
            af_range_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(a2));
  }

  template <int _AP_W3, int _AP_I3, bool _AP_S3, ap_q_mode _AP_Q3,
            ap_o_mode _AP_O3, int _AP_N3>
  inline
      ap_concat_ref<_AP_WR, ap_concat_ref, 1,
                    af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >
      operator,(const af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>
                    &a2) {
    return ap_concat_ref<
        _AP_WR, ap_concat_ref, 1,
        af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3> >(
        *this,
        const_cast<af_bit_ref<_AP_W3, _AP_I3, _AP_S3, _AP_Q3, _AP_O3, _AP_N3>&>(
            a2));
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator&(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() & a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator|(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() | a2;
  }

  template <int _AP_W3, bool _AP_S3>
  inline ap_int_base<((_AP_WR) > (_AP_W3) ? (_AP_WR) : (_AP_W3)), _AP_S3> operator^(
      const ap_int_base<_AP_W3, _AP_S3>& a2) {
    return get() ^ a2;
  }
# 304 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_int_base<_AP_WR, false> get() const {
    ap_int_base<_AP_WR, false> tmpVal(0);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W2, false> v2(mbv2);
    ap_int_base<_AP_W1, false> v1(mbv1);
    tmpVal.V = _AP_ROOT_op_set_range(tmpVal.V, 0, W_ref2 - 1, v2.V);
    tmpVal.V =
        _AP_ROOT_op_set_range(tmpVal.V, W_ref2, W_ref1 + W_ref2 - 1, v1.V);
    return tmpVal;
  }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    ap_int_base<_AP_W1 + _AP_W2, false> vval(val);
    int W_ref1 = mbv1.length();
    int W_ref2 = mbv2.length();
    ap_int_base<_AP_W1, false> tmpVal1;
    tmpVal1.V = (vval.V).range((W_ref1 + W_ref2 - 1), (W_ref2));
    mbv1.set(tmpVal1);
    ap_int_base<_AP_W2, false> tmpVal2;
    tmpVal2.V = (vval.V).range((W_ref2 - 1), (0));
    mbv2.set(tmpVal2);
  }

  inline int length() const { return mbv1.length() + mbv2.length(); }
};




template <int _AP_W, bool _AP_S>
struct ap_range_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:
  inline ap_range_ref(const ap_range_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}

  inline ap_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {}

  inline ap_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {}

  inline operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  inline operator ap_ulong() const { return to_uint64(); }
# 385 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_range_ref& operator=(bool val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(signed char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned char val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned short val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned int val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(unsigned long val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(ap_slong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(ap_ulong val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(half val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(float val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }
  inline ap_range_ref& operator=(double val) { ap_int_base<_AP_W, false> tmp(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V); return *this; }




  inline ap_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }




  inline ap_range_ref& operator=(const ap_range_ref& val) {
    return operator=((const ap_int_base<_AP_W, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    return operator=(val.to_ap_int_base());
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)(val));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)(val));
  }


  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
      operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, a2);
  }

  inline
  ap_concat_ref<_AP_W, ap_range_ref, _AP_W, ap_int_base<_AP_W, _AP_S> >
  operator,(ap_int_base<_AP_W, _AP_S>& a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W,
                         ap_int_base<_AP_W, _AP_S> >(*this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<_AP_W, ap_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      _AP_W, ap_range_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, ap_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &a2) {
    return ap_concat_ref<
        _AP_W, ap_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop == hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop < hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> hop(op2);
    return lop <= hop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<=(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator|=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V |= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator&=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V &= op2.V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= (op2.d_bv).V;
    return *this;
  };

  template <int _AP_W2, bool _AP_S2>
  inline ap_range_ref<_AP_W, _AP_S>& operator^=(
      const ap_int_base<_AP_W2, _AP_S2>& op2) {
    (this->d_bv).V ^= op2.V;
    return *this;
  };

  inline ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  template <int _AP_W2>
  inline void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }

  inline int to_int() const {
    return (int)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned to_uint() const {
    return (unsigned)((d_bv.V).range((h_index), (l_index)));
  }

  inline long to_long() const {
    return (long)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned long to_ulong() const {
    return (unsigned long)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_slong to_int64() const {
    return (ap_slong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_ulong to_uint64() const {
    return (ap_ulong)((d_bv.V).range((h_index), (l_index)));
  }

  inline bool and_reduce() const {
    bool ret = true;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret &= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  inline bool or_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret |= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  inline bool xor_reduce() const {
    bool ret = false;
    bool reverse = l_index > h_index;
    unsigned low = reverse ? h_index : l_index;
    unsigned high = reverse ? l_index : h_index;
    for (unsigned i = low; i != high; ++i) {



      ret ^= (d_bv.V).get_bit((i));
    }
    return ret;
  }

  std::string to_string(signed char radix = 2) const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_string(radix);
  }






};




template <int _AP_W, bool _AP_S>
inline std::ostream& operator<<(std::ostream& os,
                                const ap_range_ref<_AP_W, _AP_S>& x) {
  std::ios_base::fmtflags ff = std::cout.flags();
  if (ff & std::cout.hex) {
    os << x.to_string(16);
  } else if (ff & std::cout.oct) {
    os << x.to_string(8);
  } else {
    os << x.to_string(10);
  }
  return os;
}



template <int _AP_W, bool _AP_S>
inline std::istream& operator>>(std::istream& in,
                                ap_range_ref<_AP_W, _AP_S>& op) {
  std::string str;
  in >> str;
  op = ap_int_base<_AP_W, _AP_S>(str.c_str());
  return in;
}






template <int _AP_W, bool _AP_S>
struct ap_bit_ref {



  typedef ap_int_base<_AP_W, _AP_S> ref_type;
  ref_type& d_bv;
  int d_index;

 public:

  inline ap_bit_ref(const ap_bit_ref<_AP_W, _AP_S>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {}

  inline ap_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline ap_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}

  inline operator bool() const { return (d_bv.V).get_bit((d_index)); }
  inline bool to_bool() const { return (d_bv.V).get_bit((d_index)); }
# 810 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_bit_ref& operator=(bool val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(signed char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned char val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(short val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned short val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(int val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned int val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(long val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(unsigned long val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(ap_slong val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
  inline ap_bit_ref& operator=(ap_ulong val) { d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val); return *this; }
# 832 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
  inline ap_bit_ref& operator=(half val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }
  inline ap_bit_ref& operator=(float val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }
  inline ap_bit_ref& operator=(double val) { bool tmp_val = val; d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index,tmp_val); return *this; }




  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(val.V != 0));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_int_base<_AP_W2, false>)val);
  }



  inline ap_bit_ref& operator=(const ap_bit_ref& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((const ap_int_base<_AP_W2, false>)val);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=((ap_ulong)(bool)val);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=((const ap_int_base<_AP_W2 + _AP_W3, false>)val);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, a2);
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(const volatile ap_int_base<_AP_W2, _AP_S2> &a2) {
    ap_int_base<_AP_W2, _AP_S2> op(a2);
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_int_base<_AP_W2, _AP_S2>&>(op));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(a2));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &a2) {
    return ap_concat_ref<1, ap_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      1, ap_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<
        1, ap_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<
            af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(a2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &a2) {
    return ap_concat_ref<1, ap_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            a2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    return get() != op.get();
  }

  inline bool get() const { return (d_bv.V).get_bit((d_index)); }

  inline bool get() { return (d_bv.V).get_bit((d_index)); }

  template <int _AP_W3>
  inline void set(const ap_int_base<_AP_W3, false>& val) {
    operator=(val);
  }

  inline bool operator~() const {
    bool bit = (d_bv.V).get_bit((d_index));
    return bit ? false : true;
  }

  inline int length() const { return 1; }


  std::string to_string() const { return get() ? "1" : "0"; }




};
# 1030 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator >(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, bool _AP_S> inline bool operator >(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 > bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) > ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, bool _AP_S> inline bool operator <(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 < bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) < ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator >=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, bool _AP_S> inline bool operator >=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 >= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator >=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) >= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator <=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, bool _AP_S> inline bool operator <=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 <= bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator <=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) <= ap_int_base<_AP_SIZE_ap_slong, false>(op2); }






template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<1, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(bool op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, bool op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<1, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, CHAR_IS_SIGNED>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(signed char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, signed char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<8, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned char op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned char op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<8, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned short op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned short op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_short, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned int op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned int op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_int, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(unsigned long op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, unsigned long op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_long, false>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_slong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_slong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, true>(op2); }
template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator ==(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, bool _AP_S> inline bool operator ==(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 == bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator ==( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) == ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); } template <int _AP_W, bool _AP_S> inline bool operator !=(const ap_bit_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, bool _AP_S> inline bool operator !=(ap_ulong op2, const ap_bit_ref<_AP_W, _AP_S>& op) { return op2 != bool(op); } template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline bool operator !=( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1>& op, ap_ulong op2) { return ap_int_base<_AP_W + _AP_W1, false>(op) != ap_int_base<_AP_SIZE_ap_slong, false>(op2); }
# 1089 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::plus operator +(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::minus operator -(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mult operator *(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::div operator /(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::mod operator %(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::plus operator +(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::minus operator -(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mult operator *(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::div operator /(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::mod operator %(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::plus operator +(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::minus operator -(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mult operator *(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::div operator /(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::mod operator %(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::plus operator +(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::minus operator -(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mult operator *(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::div operator /(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::mod operator %(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::plus operator +(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::minus operator -(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mult operator *(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::div operator /(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::mod operator %(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::plus operator +(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::minus operator -(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mult operator *(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::div operator /(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::mod operator %(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::plus operator +(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::minus operator -(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mult operator *(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::div operator /(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::mod operator %(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::plus operator +(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::minus operator -(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mult operator *(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::div operator /(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::mod operator %(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::plus operator +(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::minus operator -(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mult operator *(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::div operator /(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::mod operator %(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::plus operator +(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::minus operator -(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mult operator *(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::div operator /(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::mod operator %(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::plus operator +(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::minus operator -(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mult operator *(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::div operator /(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::mod operator %(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) % ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) + ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::plus operator +(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) + ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) - ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::minus operator -(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) - ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) * ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mult operator *(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) * ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::div operator /(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) / ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::div operator /(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) / ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) % ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::mod operator %(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) % ap_int_base<_AP_W, false>(op); }
# 1112 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator &(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator |(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::logic operator ^(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator >>(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(1), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, bool op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(1), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(1), (false)>::template RType<_AP_W, false>::arg1 operator <<(bool op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(1), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator &(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator |(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::logic operator ^(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator >>(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (CHAR_IS_SIGNED)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (CHAR_IS_SIGNED)>::template RType<_AP_W, false>::arg1 operator <<(char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator &(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator |(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::logic operator ^(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator >>(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (true)>::template RType<_AP_W, false>::arg1 operator <<(signed char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator &(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator |(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(8), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(8), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(8), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned char op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(8), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator &(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator |(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::logic operator ^(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator >>(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (true)>::template RType<_AP_W, false>::arg1 operator <<(short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator &(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator |(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_short), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_short), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned short op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator &(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator |(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::logic operator ^(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator >>(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (true)>::template RType<_AP_W, false>::arg1 operator <<(int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator &(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator |(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_int), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_int), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned int op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator &(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator |(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::logic operator ^(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator >>(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (true)>::template RType<_AP_W, false>::arg1 operator <<(long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator &(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator |(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::logic operator ^(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator >>(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_long), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_long), (false)>::template RType<_AP_W, false>::arg1 operator <<(unsigned long op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator &(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator |(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::logic operator ^(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator >>(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (true)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (true)>::template RType<_AP_W, false>::arg1 operator <<(ap_slong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) << ap_int_base<_AP_W, false>(op); }
template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) & ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator &(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) & ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) | ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator |(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) | ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) ^ ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::logic operator ^(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) ^ ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >> ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator >>(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >> ap_int_base<_AP_W, false>(op); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<_AP_W, false>::template RType<(_AP_SIZE_ap_slong), (false)>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) << ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, bool _AP_S> inline typename ap_int_base<(_AP_SIZE_ap_slong), (false)>::template RType<_AP_W, false>::arg1 operator <<(ap_ulong op2, const ap_range_ref<_AP_W, _AP_S>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) << ap_int_base<_AP_W, false>(op); }
# 1140 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::plus operator +(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())+( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::minus operator -(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())-( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mult operator *(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())*( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::div operator /(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())/( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::mod operator %(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())%( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator &(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())&( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator |(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())|( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::logic operator ^(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())^( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator >>(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())>>( rhs.operator ap_int_base<_AP_W2, false>()); }
template <int _AP_W, bool _AP_S, int _AP_W2, bool _AP_S2> inline typename ap_int_base<_AP_W, false>::template RType<_AP_W2, false>::arg1 operator <<(const ap_range_ref<_AP_W, _AP_S>& lhs, const ap_range_ref<_AP_W2, _AP_S2>& rhs) { return (lhs.operator ap_int_base<_AP_W, false>())<<( rhs.operator ap_int_base<_AP_W2, false>()); }
# 1189 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::plus operator +( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() + rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::minus operator -( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() - rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mult operator *( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() * rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::div operator /( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() / rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::mod operator %( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() % rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator &( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() & rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator |( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() | rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::logic operator ^( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() ^ rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator >>( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() >> rhs.get(); }
template <int _AP_LW1, typename _AP_LT1, int _AP_LW2, typename _AP_LT2, int _AP_RW1, typename _AP_RT1, int _AP_RW2, typename _AP_RT2> inline typename ap_int_base<_AP_LW1 + _AP_LW2, false>::template RType< _AP_RW1 + _AP_RW2, false>::arg1 operator <<( const ap_concat_ref<_AP_LW1, _AP_LT1, _AP_LW2, _AP_LT2>& lhs, const ap_concat_ref<_AP_RW1, _AP_RT1, _AP_RW2, _AP_RT2>& rhs) { return lhs.get() << rhs.get(); }
# 1336 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 1; ret >>= 1; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); ret <<= 1; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<1 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<1 + 1, false> operator,( bool op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, bool op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op2); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 1, false> operator,( bool op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<1 + _AP_W + _AP_W2, false> val(op1); ap_int_base<1 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 1, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + _AP_W, false> val(op2); ap_int_base<1 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 1; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 1, false> operator,( bool op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + _AP_W, false> val(op1); ap_int_base<1 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 1, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, bool op2) { ap_int_base<1 + 1, false> val(op2); val[1] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 1, false> operator,( bool op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<1 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, char op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op2); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> val(op1); ap_int_base<8 + _AP_W + _AP_W2, CHAR_IS_SIGNED> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (CHAR_IS_SIGNED) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, char op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, CHAR_IS_SIGNED> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, signed char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( signed char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, signed char op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op2); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( signed char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, true> val(op1); ap_int_base<8 + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( signed char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, signed char op2) { ap_int_base<8 + 1, true> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( signed char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); if (_AP_S) { ret <<= 8; ret >>= 8; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); ret <<= 8; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<8 + 1, false> operator,( unsigned char op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned char op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op2); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + 8, false> operator,( unsigned char op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<8 + _AP_W + _AP_W2, false> val(op1); ap_int_base<8 + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + _AP_W, false> val(op2); ap_int_base<8 + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= 8; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + 8, false> operator,( unsigned char op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + _AP_W, false> val(op1); ap_int_base<8 + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned char op2) { ap_int_base<8 + 1, false> val(op2); val[8] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + 8, false> operator,( unsigned char op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<8 + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, short op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_short; ret >>= _AP_SIZE_short; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); ret <<= _AP_SIZE_short; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_short + 1, false> operator,( unsigned short op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_short, false> operator,( unsigned short op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_short; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_short, false> operator,( unsigned short op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_short + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned short op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op2); val[_AP_SIZE_short] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_short, false> operator,( unsigned short op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_short + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, int op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_int; ret >>= _AP_SIZE_int; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); ret <<= _AP_SIZE_int; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_int + 1, false> operator,( unsigned int op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_int, false> operator,( unsigned int op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_int; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_int, false> operator,( unsigned int op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_int + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned int op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op2); val[_AP_SIZE_int] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_int, false> operator,( unsigned int op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_int + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, long op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_long; ret >>= _AP_SIZE_long; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); ret <<= _AP_SIZE_long; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_long + 1, false> operator,( unsigned long op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_long, false> operator,( unsigned long op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_long; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_long, false> operator,( unsigned long op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_long + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, unsigned long op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op2); val[_AP_SIZE_long] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_long, false> operator,( unsigned long op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_long + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (true) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_slong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op1); if (true) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, true> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (true) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_slong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_slong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, true> val(op1); val <<= 1; val[0] = op2; return val; }
template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_int_base<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_int_base<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); if (_AP_S) { ret <<= _AP_SIZE_ap_slong; ret >>= _AP_SIZE_ap_slong; } ret |= val << _AP_W; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const ap_range_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); ret <<= _AP_SIZE_ap_slong; if (false) { val <<= _AP_W; val >>= _AP_W; } ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_range_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( const ap_bit_ref<_AP_W, _AP_S> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, bool _AP_S> inline ap_int_base<_AP_SIZE_ap_slong + 1, false> operator,( ap_ulong op1, const ap_bit_ref<_AP_W, _AP_S> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op1); if (false) { val <<= _AP_W + _AP_W2; val >>= _AP_W + _AP_W2; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, typename _AP_T, int _AP_W2, typename _AP_T2> inline ap_int_base<_AP_W + _AP_W2 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const ap_concat_ref<_AP_W, _AP_T, _AP_W2, _AP_T2> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W + _AP_W2, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op2); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op1); if (false) { val <<= _AP_W; val >>= _AP_W; } ret <<= _AP_SIZE_ap_slong; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<_AP_W + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> val(op1); ap_int_base<_AP_SIZE_ap_slong + _AP_W, false> ret(op2); int len = op2.length(); val <<= len; ret |= val; return ret; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op1, ap_ulong op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op2); val[_AP_SIZE_ap_slong] = op1; return val; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_int_base<1 + _AP_SIZE_ap_slong, false> operator,( ap_ulong op1, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> &op2) { ap_int_base<_AP_SIZE_ap_slong + 1, false> val(op1); val <<= 1; val[0] = op2; return val; }
# 1360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_ref.h"
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator <<( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() << int(rhs); }

template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned int rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, unsigned long rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_slong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
template <int _AP_W, typename _AP_T, int _AP_W1, typename _AP_T1> inline ap_uint<_AP_W + _AP_W1> operator >>( const ap_concat_ref<_AP_W, _AP_T, _AP_W1, _AP_T1> lhs, ap_ulong rhs) { return ap_uint<_AP_W + _AP_W1>(lhs).get() >> int(rhs); }
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2




template <int _AP_W>
struct ap_int : ap_int_base<_AP_W, true> {
  typedef ap_int_base<_AP_W, true> Base;

  inline ap_int() : Base() {}
  template <int _AP_W2>
  inline ap_int(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_int(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }
# 95 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_int(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_int(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_int(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_int(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline ap_int(bool val) { Base::V = val; }
  inline ap_int(char val) { Base::V = val; }
  inline ap_int(signed char val) { Base::V = val; }
  inline ap_int(unsigned char val) { Base::V = val; }
  inline ap_int(short val) { Base::V = val; }
  inline ap_int(unsigned short val) { Base::V = val; }
  inline ap_int(int val) { Base::V = val; }
  inline ap_int(unsigned int val) { Base::V = val; }
  inline ap_int(long val) { Base::V = val; }
  inline ap_int(unsigned long val) { Base::V = val; }
  inline ap_int(ap_slong val) { Base::V = val; }
  inline ap_int(ap_ulong val) { Base::V = val; }

  ap_int(double val) : Base(val) {}
  ap_int(float val) : Base(val) {}
  ap_int(half val) : Base(val) {}


  inline ap_int(const char* s) : Base(s) {}

  inline ap_int(const char* s, signed char rd) : Base(s, rd) {}




  inline ap_int& operator=(const ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline ap_int& operator=(const volatile ap_int<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline void operator=(const ap_int<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline void operator=(const volatile ap_int<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};




template <int _AP_W>
struct ap_uint : ap_int_base<_AP_W, false> {
  typedef ap_int_base<_AP_W, false> Base;

  inline ap_uint() : Base() {}
  template <int _AP_W2>
  inline ap_uint(const ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const volatile ap_uint<_AP_W2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2>
  inline ap_uint(const volatile ap_int<_AP_W2>& op) {
    Base::V = op.V;
  }
# 236 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_range_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_bit_ref<_AP_W2, _AP_S2>& ref) : Base(ref) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_uint(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& ref)
      : Base(ref) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(const ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(const ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(
      const volatile ap_fixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, true, _AP_Q2, _AP_O2, _AP_N2>)op) {}

  template <int _AP_W2, int _AP_I2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2,
            int _AP_N2>
  inline ap_uint(
      const volatile ap_ufixed<_AP_W2, _AP_I2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base((ap_fixed_base<_AP_W2, _AP_I2, false, _AP_Q2, _AP_O2, _AP_N2>)op) {
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_uint(const ap_int_base<_AP_W2, _AP_S2>& op) {
    Base::V = op.V;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_uint(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}



  inline ap_uint(bool val) { Base::V = val; }
  inline ap_uint(char val) { Base::V = val; }
  inline ap_uint(signed char val) { Base::V = val; }
  inline ap_uint(unsigned char val) { Base::V = val; }
  inline ap_uint(short val) { Base::V = val; }
  inline ap_uint(unsigned short val) { Base::V = val; }
  inline ap_uint(int val) { Base::V = val; }
  inline ap_uint(unsigned int val) { Base::V = val; }
  inline ap_uint(long val) { Base::V = val; }
  inline ap_uint(unsigned long val) { Base::V = val; }
  inline ap_uint(ap_slong val) { Base::V = val; }
  inline ap_uint(ap_ulong val) { Base::V = val; }

  ap_uint(double val) : Base(val) {}
  ap_uint(float val) : Base(val) {}
  ap_uint(half val) : Base(val) {}


  inline ap_uint(const char* s) : Base(s) {}

  inline ap_uint(const char* s, signed char rd) : Base(s, rd) {}




  inline ap_uint& operator=(const ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline ap_uint& operator=(const volatile ap_uint<_AP_W>& op2) {
    Base::V = op2.V;
    return *this;
  }


  inline void operator=(const ap_uint<_AP_W>& op2) volatile { Base::V = op2.V; }

  inline void operator=(const volatile ap_uint<_AP_W>& op2) volatile {
    Base::V = op2.V;
  }

};
# 359 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h" 1
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h" 2




namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h"
template <int _AP_W>
class complex<ap_int<_AP_W> > {
 public:
  typedef ap_int<_AP_W> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 222 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int_special.h"
template <int _AP_W>
inline bool operator==(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W>
inline bool operator==(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W>
inline bool operator!=(const complex<ap_int<_AP_W> > &__x, const ap_int<_AP_W> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W>
inline bool operator!=(const ap_int<_AP_W> &__x, const complex<ap_int<_AP_W> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 360 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2







# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 1
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 1
# 62 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 1
# 63 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 2
# 78 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
# 41 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 1 3
# 32 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 3
       
# 33 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 3



# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 1 3
# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3

# 84 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3
typedef unsigned short fexcept_t;





typedef struct
{
  unsigned short __control_word;
  unsigned short __unused0;
  unsigned short __status_word;
  unsigned short __unused1;
  unsigned short __tag_word;
  unsigned short __unused2;
  unsigned int __ip_offset;
  unsigned short __ip_selector;
  unsigned short __opcode;
  unsigned int __data_offset;
  unsigned short __data_selector;
  unsigned short __unused3;
  unsigned int __mxcsr;
} fenv_t;
# 124 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/x86_64-w64-mingw32/include/fenv.h" 3
extern "C" {





extern int __attribute__((__cdecl__)) feclearexcept (int);
extern int __attribute__((__cdecl__)) fegetexceptflag (fexcept_t * flagp, int excepts);
extern int __attribute__((__cdecl__)) feraiseexcept (int excepts );
extern int __attribute__((__cdecl__)) fesetexceptflag (const fexcept_t *, int);
extern int __attribute__((__cdecl__)) fetestexcept (int excepts);



extern int __attribute__((__cdecl__)) fegetround (void);
extern int __attribute__((__cdecl__)) fesetround (int mode);



extern int __attribute__((__cdecl__)) fegetenv(fenv_t * envp);
extern int __attribute__((__cdecl__)) fesetenv(const fenv_t * );
extern int __attribute__((__cdecl__)) feupdateenv(const fenv_t *);
extern int __attribute__((__cdecl__)) feholdexcept(fenv_t *);


}
# 37 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 2 3
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/fenv.h" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 42 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 2 3
# 58 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cfenv" 3
namespace std
{

  using ::fenv_t;
  using ::fexcept_t;


  using ::feclearexcept;
  using ::fegetexceptflag;
  using ::feraiseexcept;
  using ::fesetexceptflag;
  using ::fetestexcept;

  using ::fegetround;
  using ::fesetround;

  using ::fegetenv;
  using ::feholdexcept;
  using ::fesetenv;
  using ::feupdateenv;
}
# 79 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 2
# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"

# 99 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <typename _Tp1, typename _Tp2>
inline bool _AP_ctype_op_get_bit(_Tp1& var, const _Tp2& index) {
  return !!(var & (1ull << (index)));
}
template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ctype_op_set_bit(_Tp1& var, const _Tp2& index, const _Tp3& x) {
  var |= (((x) ? 1ull : 0ull) << (index));
  return var;
}
template <typename _Tp1, typename _Tp2, typename _Tp3>
inline _Tp1 _AP_ctype_op_get_range(_Tp1& var, const _Tp2& low,
                                   const _Tp3& high) {
  _Tp1 r = var;
  ap_ulong mask = -1ll;
  mask >>= (sizeof(_Tp1) * 8 - ((high) - (low) + 1));
  r >>= (low);
  r &= mask;
  return r;
}
template <typename _Tp1, typename _Tp2, typename _Tp3, typename _Tp4>
inline _Tp1 _AP_ctype_op_set_range(_Tp1& var, const _Tp2& low, const _Tp3& high,
                                   const _Tp4& x) {
  ap_ulong mask = -1ll;
  mask >>= (_AP_SIZE_ap_slong - ((high) - (low) + 1));
  var &= ~(mask << (low));
  var |= ((mask & x) << (low));
  return var;
}






template <int _AP_W2, int _AP_I2, bool _AP_S2>
struct _ap_fixed_factory;
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, true> {
  typedef ap_fixed<_AP_W2, _AP_I2> type;
};
template <int _AP_W2, int _AP_I2>
struct _ap_fixed_factory<_AP_W2, _AP_I2, false> {
  typedef ap_ufixed<_AP_W2, _AP_I2> type;
};
# 154 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct ap_fixed_base : ssdm_int_sim<_AP_W, _AP_S> {
 public:
  typedef ssdm_int_sim<_AP_W, _AP_S> Base;
  static const int width = _AP_W;
  static const int iwidth = _AP_I;
  static const ap_q_mode qmode = _AP_Q;
  static const ap_o_mode omode = _AP_O;


  template <int _AP_W2, int _AP_I2, bool _AP_S2>
  struct RType {
    enum {
      _AP_F = _AP_W - _AP_I,
      F2 = _AP_W2 - _AP_I2,
      mult_w = _AP_W + _AP_W2,
      mult_i = _AP_I + _AP_I2,
      mult_s = _AP_S || _AP_S2,
      plus_w = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
               1 + ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      plus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      plus_s = _AP_S || _AP_S2,
      minus_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1 +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      minus_i =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) + 1,
      minus_s = true,

      div_w = _AP_S2 + _AP_W + ((F2) > (0) ? (F2) : (0)),



      div_i = _AP_S2 + _AP_I + F2,
      div_s = _AP_S || _AP_S2,
      logic_w =
          ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))) +
          ((_AP_F) > (F2) ? (_AP_F) : (F2)),
      logic_i = ((_AP_I + (_AP_S2 && !_AP_S)) > (_AP_I2 + (_AP_S && !_AP_S2)) ? (_AP_I + (_AP_S2 && !_AP_S)) : (_AP_I2 + (_AP_S && !_AP_S2))),
      logic_s = _AP_S || _AP_S2
    };

    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> lhs;
    typedef ap_fixed_base<_AP_W2, _AP_I2, _AP_S2> rhs;

    typedef ap_fixed_base<mult_w, mult_i, mult_s> mult_base;
    typedef ap_fixed_base<plus_w, plus_i, plus_s> plus_base;
    typedef ap_fixed_base<minus_w, minus_i, minus_s> minus_base;
    typedef ap_fixed_base<logic_w, logic_i, logic_s> logic_base;
    typedef ap_fixed_base<div_w, div_i, div_s> div_base;
    typedef ap_fixed_base<_AP_W, _AP_I, _AP_S> arg1_base;

    typedef typename _ap_fixed_factory<mult_w, mult_i, mult_s>::type mult;
    typedef typename _ap_fixed_factory<plus_w, plus_i, plus_s>::type plus;
    typedef typename _ap_fixed_factory<minus_w, minus_i, minus_s>::type minus;
    typedef typename _ap_fixed_factory<logic_w, logic_i, logic_s>::type logic;
    typedef typename _ap_fixed_factory<div_w, div_i, div_s>::type div;
    typedef typename _ap_fixed_factory<_AP_W, _AP_I, _AP_S>::type arg1;
  };

 private:


  void fromString(const std::string& val, unsigned char radix) {
    do { if ((!(radix == 2 || radix == 8 || radix == 10 || radix == 16))) { fprintf(
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "ERROR: " "ap_fixed_base::fromString(%s, %d)", val.c_str(), radix); fprintf(
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 220 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); abort(); } } while (0)
                                                                      ;

    Base::V = 0;
    int startPos = 0;
    int endPos = val.length();
    int decPos = val.find(".");
    if (decPos == -1) decPos = endPos;


    bool isNegative = false;
    if (val[0] == '-') {
      isNegative = true;
      ++startPos;
    } else if (val[0] == '+')
      ++startPos;
# 244 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    ap_fixed_base<((_AP_I) > (4) ? (_AP_I) : (4)) + 4, ((_AP_I) > (4) ? (_AP_I) : (4)) + 4, false>
        integer_bits = 0;


    unsigned shift = (radix == 16 ? 4 : radix == 8 ? 3 : radix == 2 ? 1 : 0);




    bool sticky_int = false;


    for (int i = startPos; i < decPos; i++) {

      char cdigit = val[i];
      if (cdigit == '\0') continue;
      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);

      sticky_int |= integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 1] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 2] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] |
                    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 4];

      if (shift)
        integer_bits <<= shift;
      else
        integer_bits *= radix;


      integer_bits += digit;


    }
    integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] =
        integer_bits[((_AP_I) > (4) ? (_AP_I) : (4)) + 4 - 3] | sticky_int;

    ap_fixed_base<((_AP_W - _AP_I) > (0) ? (_AP_W - _AP_I) : (0)) + 4 + 4, 4, false> fractional_bits = 0;
    bool sticky = false;


    for (int i = endPos - 1; i >= decPos + 1; i--) {

      char cdigit = val[i];
      if (cdigit == '\0') continue;
      unsigned digit = ap_private_ops::decode_digit(cdigit, radix);

      fractional_bits += digit;

      sticky |= fractional_bits[0] | fractional_bits[1] | fractional_bits[2] |
                fractional_bits[3];

      if (shift)
        fractional_bits >>= shift;
      else
        fractional_bits /= radix;



    }




    fractional_bits[0] = fractional_bits[0] | sticky;

    if (isNegative)
      *this = -(integer_bits + fractional_bits);
    else
      *this = integer_bits + fractional_bits;


  }


  inline void report() {
    if (!_AP_S && _AP_O == AP_WRAP_SM) {
      fprintf(
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
             (&__iob_func()[2])
# 320 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
                   , "ap_ufxied<...> cannot support AP_WRAP_SM.\n");
      exit(1);
    }
    if (_AP_W > ((1024 + 1023) / 1024) * 1024) {
      fprintf(
# 324 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
             (&__iob_func()[2])
# 324 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
                   ,
              "[E] ap_%sfixed<%d, ...>: Bitwidth exceeds the "
              "default max value %d. Please use macro "
              "AP_INT_MAX_W to set a larger max value.\n",
              _AP_S ? "" : "u", _AP_W, ((1024 + 1023) / 1024) * 1024);
      exit(1);
    }
  }






  inline void overflow_adjust(bool underflow, bool overflow, bool lD,
                              bool sign) {
    if (!underflow && !overflow) return;
    if (_AP_O == AP_WRAP) {
      if (_AP_N == 0) return;
      if (_AP_S) {


        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);
        if (_AP_N > 1) {

          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);
        }
      } else {

        ap_int_base<_AP_W, false> mask(-1);
        Base::V =
            _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 1, mask.V);
      }
    } else if (_AP_O == AP_SAT_ZERO) {
      Base::V = 0;
    } else if (_AP_O == AP_WRAP_SM && _AP_S) {
      bool Ro = (Base::V).get_bit((_AP_W - 1));
      if (_AP_N == 0) {
        if (lD != Ro) {
          Base::V = ~Base::V;
          Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, lD);
        }
      } else {
        if (_AP_N == 1 && sign != Ro) {
          Base::V = ~Base::V;
        } else if (_AP_N > 1) {
          bool lNo = (Base::V).get_bit((_AP_W - _AP_N));
          if (lNo == sign) Base::V = ~Base::V;
          ap_int_base<_AP_W, false> mask(-1);
          if (sign) mask.V = 0;
          Base::V =
              _AP_ROOT_op_set_range(Base::V, _AP_W - _AP_N, _AP_W - 2, mask.V);
        }
        Base::V = _AP_ROOT_op_set_bit(Base::V, _AP_W - 1, sign);
      }
    } else {
      if (_AP_S) {
        if (overflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          Base::V = ~Base::V;
        } else if (underflow) {
          Base::V = 1;
          Base::V <<= _AP_W - 1;
          if (_AP_O == AP_SAT_SYM) Base::V |= 1;
        }
      } else {
        if (overflow)
          Base::V = ~(ap_int_base<_AP_W, false>(0).V);
        else if (underflow)
          Base::V = 0;
      }
    }
  }

  inline bool quantization_adjust(bool qb, bool r, bool s) {
    bool carry = (bool)(Base::V).get_bit((_AP_W - 1));
    if (_AP_Q == AP_TRN) return false;
    if (_AP_Q == AP_RND_ZERO)
      qb &= s || r;
    else if (_AP_Q == AP_RND_MIN_INF)
      qb &= r;
    else if (_AP_Q == AP_RND_INF)
      qb &= !s || r;
    else if (_AP_Q == AP_RND_CONV)
      qb &= (Base::V).get_bit((0)) || r;
    else if (_AP_Q == AP_TRN_ZERO)
      qb = s && (qb || r);
    Base::V += qb;
    return carry && (!(bool)(Base::V).get_bit((_AP_W - 1)));
  }


 public:



  inline ap_fixed_base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const volatile ap_int_base<_AP_W2, _AP_S2>& op) {
    ap_fixed_base<_AP_W2, _AP_W2, _AP_S2> tmp;
    tmp.V = op.V;
    operator=(tmp);
    report();
  }



  inline ap_fixed_base(const char* s, signed char rd = 0) {
    unsigned char radix = rd;
    std::string str = ap_private_ops::parseString(s, radix);
    do { if ((radix == 0)) { fprintf(
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "ERROR: " "ap_fixed_base(const char* \"%s\", %d), str=%s, radix = %d", s, rd, str.c_str(), radix); fprintf(
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 464 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); abort(); } } while (0)
                                        ;
    fromString(str, radix);
  }
# 491 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_bit_ref<_AP_W2, _AP_S2>& op) {
    *this = ((bool)op);
    report();
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base(const ap_range_ref<_AP_W2, _AP_S2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_fixed_base(
      const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op) {
    *this = (ap_int_base<_AP_W2 + _AP_W3, false>(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (bool(op));
    report();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    *this = (ap_int_base<_AP_W2, false>(op));
    report();
  }
# 535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  inline ap_fixed_base(const bool x) { ap_fixed_base<(1), (1), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const char x) { ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const signed char x) { ap_fixed_base<(8), (8), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned char x) { ap_fixed_base<(8), (8), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned short x) { ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned int x) { ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const unsigned long x) { ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const ap_slong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)> tmp; tmp.V = x; *this = tmp; }
  inline ap_fixed_base(const ap_ulong x) { ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)> tmp; tmp.V = x; *this = tmp; }







  ap_fixed_base(double d) {
    ap_int_base<64, false> ireg;
    ireg.V = doubleToRawBits(d);
    bool isneg = (ireg.V).get_bit((63));

    ap_int_base<11 + 1, true> exp;
    ap_int_base<11, false> exp_tmp;
    exp_tmp.V =
        (ireg.V).range((52 + 11 - 1), (52));
    exp = exp_tmp - ((1L << (11 - 1L)) - 1L);
    ap_int_base<52 + 2, true> man;
    man.V = (ireg.V).range((52 - 1), (0));

    do { if ((exp == ((1L << (11 - 1L)) - 1L) + 1 && man.V != 0)) { fprintf(
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "assign NaN to fixed point value"); fprintf(
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 567 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                  ;
    man.V = _AP_ROOT_op_set_bit(man.V, 52, 1);
    if (isneg) man = -man;
    if ((ireg.V & 0x7fffffffffffffffLL) == 0) {
      Base::V = 0;
    } else {
      int _AP_W2 = 52 + 2, _AP_I2 = exp.V + 2, _AP_F = _AP_W - _AP_I,
          F2 = _AP_W2 - _AP_I2;
      bool _AP_S2 = true,
           QUAN_INC = F2 > _AP_F &&
                      !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));
      bool carry = false;

      unsigned sh_amt = (F2 > _AP_F) ? F2 - _AP_F : _AP_F - F2;
      if (F2 == _AP_F)
        Base::V = man.V;
      else if (F2 > _AP_F) {
        if (sh_amt < 52 + 2)
          Base::V = man.V >> sh_amt;
        else {
          Base::V = isneg ? -1 : 0;
        }
        if ((_AP_Q != AP_TRN) && !((_AP_Q == AP_TRN_ZERO) && !_AP_S2)) {
          bool qb = (F2 - _AP_F > _AP_W2) ? isneg : (bool)(man.V).get_bit((F2 - _AP_F - 1))
                                                                              ;
          bool r =
              (F2 > _AP_F + 1)
                  ? (man.V).range(((F2 - _AP_F - 2 < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1)), (0))

                                                                        != 0
                  : false;
          carry = quantization_adjust(qb, r, isneg);
        }
      } else {
        Base::V = man.V;
        if (sh_amt < _AP_W)
          Base::V = Base::V << sh_amt;
        else
          Base::V = 0;
      }

      if ((_AP_O != AP_WRAP || _AP_N != 0) &&
          ((!_AP_S && _AP_S2) ||
           _AP_I - _AP_S <
               _AP_I2 - _AP_S2 +
                   (QUAN_INC ||
                    (_AP_S2 && (_AP_O == AP_SAT_SYM))))) {
        bool deleted_zeros = _AP_S2 ? true : !carry, deleted_ones = true;
        bool neg_src = isneg;
        bool lD = false;
        int pos1 = F2 - _AP_F + _AP_W;
        int pos2 = F2 - _AP_F + _AP_W + 1;
        bool newsignbit = (Base::V).get_bit((_AP_W - 1));
        if (pos1 < _AP_W2 && pos1 >= 0)

          lD = (man.V >> pos1) & 1;
        if (pos1 < _AP_W2) {
          bool Range1_all_ones = true;
          bool Range1_all_zeros = true;
          bool Range2_all_ones = true;
          ap_int_base<52 + 2, false> Range2;
          ap_int_base<52 + 2, false> all_ones(-1);

          if (pos2 >= 0 && pos2 < _AP_W2) {


            Range2.V = man.V;
            Range2.V >>= pos2;
            Range2_all_ones = Range2 == (all_ones >> pos2);
          } else if (pos2 < 0)
            Range2_all_ones = false;
          if (pos1 >= 0 && pos2 < _AP_W2) {
            Range1_all_ones = Range2_all_ones && lD;
            Range1_all_zeros = !Range2.V && !lD;
          } else if (pos2 == _AP_W2) {
            Range1_all_ones = lD;
            Range1_all_zeros = !lD;
          } else if (pos1 < 0) {
            Range1_all_zeros = !man.V;
            Range1_all_ones = false;
          }

          deleted_zeros =
              deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
          deleted_ones =
              carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
          neg_src = isneg && !(carry && Range1_all_ones);
        } else
          neg_src = isneg && newsignbit;
        bool neg_trg = _AP_S && newsignbit;
        bool overflow = (neg_trg || !deleted_zeros) && !isneg;
        bool underflow = (!neg_trg || !deleted_ones) && neg_src;
        if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
          underflow |=
              neg_src &&
              (_AP_W > 1 ? (Base::V).range((_AP_W - 2), (0)) == 0
                         : true);
        overflow_adjust(underflow, overflow, lD, neg_src);
      }
    }
    report();
  }


  inline ap_fixed_base(float d) { *this = ap_fixed_base(double(d)); }


  inline ap_fixed_base(half d) { *this = ap_fixed_base(double(d)); }
# 688 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {

    const int _AP_F = _AP_W - _AP_I;
    const int F2 = _AP_W2 - _AP_I2;
    const int QUAN_INC =
          F2 > _AP_F && !(_AP_Q == AP_TRN || (_AP_Q == AP_TRN_ZERO && !_AP_S2));

    if (!op) Base::V = 0;
    bool carry = false;
    bool signbit = (op.V).get_bit((_AP_W2 - 1));
    bool isneg = signbit && _AP_S2;
    if (F2 == _AP_F)
      Base::V = op.V;
    else if (F2 > _AP_F) {
      unsigned int sh_amt = F2 - _AP_F;

      if (sh_amt < _AP_W2) {
        Base::V = op.V >> sh_amt;
      } else {
        Base::V = isneg ? -1 : 0;
      }
      if (_AP_Q != AP_TRN && !(_AP_Q == AP_TRN_ZERO && !_AP_S2)) {
        bool qbit = (op.V).get_bit((F2 - _AP_F - 1));

        bool qb = (F2 - _AP_F > _AP_W2) ? _AP_S2 && signbit : qbit;
        enum { hi = ((F2 - _AP_F - 2) < _AP_W2) ? (F2 - _AP_F - 2) : (_AP_W2 - 1) };

        bool r = (F2 > _AP_F + 1) ? ((op.V).range((hi), (0)) != 0) : false;
        carry = quantization_adjust(qb, r, isneg);
      }
    } else {
      unsigned sh_amt = _AP_F - F2;

      if (sh_amt < _AP_W) {
        if (_AP_W > _AP_W2) {

          Base::V = op.V;
          Base::V <<= sh_amt;
        } else {

          Base::V = op.V << sh_amt;
        }
      } else {
        Base::V = 0;
      }
    }

    if ((_AP_O != AP_WRAP || _AP_N != 0) &&
        ((!_AP_S && _AP_S2) ||
         _AP_I - _AP_S <
             _AP_I2 - _AP_S2 +
                 (QUAN_INC || (_AP_S2 && _AP_O == AP_SAT_SYM)))) {
      bool deleted_zeros = _AP_S2 ? true : !carry;
      bool deleted_ones = true;
      bool neg_src = isneg;
      bool newsignbit = (Base::V).get_bit((_AP_W - 1));
      enum { pos1 = F2 - _AP_F + _AP_W, pos2 = F2 - _AP_F + _AP_W + 1 };
      bool lD = (pos1 < _AP_W2 && pos1 >= 0) ? (op.V).get_bit((pos1))
                                             : false;
      if (pos1 < _AP_W2) {
        bool Range1_all_ones = true;
        bool Range1_all_zeros = true;
        bool Range2_all_ones = true;
        ap_int_base<_AP_W2, false> all_ones(-1);

        if (pos2 < _AP_W2 && pos2 >= 0) {
          ap_int_base<_AP_W2, false> Range2;
          Range2.V = (op.V).range((_AP_W2 - 1), (pos2));
          Range2_all_ones = Range2 == (all_ones >> pos2);
        } else if (pos2 < 0) {
          Range2_all_ones = false;
        }

        if (pos1 >= 0 && pos2 < _AP_W2) {
          ap_int_base<_AP_W2, false> Range1;
          Range1.V = (op.V).range((_AP_W2 - 1), (pos1));
          Range1_all_ones = Range1 == (all_ones >> pos1);
          Range1_all_zeros = !Range1.V;
        } else if (pos2 == _AP_W2) {
          Range1_all_ones = lD;
          Range1_all_zeros = !lD;
        } else if (pos1 < 0) {
          Range1_all_zeros = !op.V;
          Range1_all_ones = false;
        }

        deleted_zeros =
            deleted_zeros && (carry ? Range1_all_ones : Range1_all_zeros);
        deleted_ones =
            carry ? Range2_all_ones && (pos1 < 0 || !lD) : Range1_all_ones;
        neg_src = isneg && !(carry && Range1_all_ones);
      } else
        neg_src = isneg && newsignbit;
      bool neg_trg = _AP_S && newsignbit;
      bool overflow = (neg_trg || !deleted_zeros) && !isneg;
      bool underflow = (!neg_trg || !deleted_ones) && neg_src;
      if ((_AP_O == AP_SAT_SYM) && _AP_S2 && _AP_S)
        underflow |=
            neg_src &&
            (_AP_W > 1 ? (Base::V).range((_AP_W - 2), (0)) == 0
                       : true);

      overflow_adjust(underflow, overflow, lD, neg_src);
    }
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator=(
      const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    operator=(const_cast<const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(op));
    return *this;
  }


  inline ap_fixed_base& setBits(ap_ulong bv) {

    Base::V = bv;
    return *this;
  }


  static inline ap_fixed_base bitsToFixed(ap_ulong bv) {

    ap_fixed_base t;



    t.V.set_bits(bv);

    return t;
  }





  inline ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> to_ap_int_base(
      bool Cnative = true) const {
    ap_int_base<((_AP_I) > (1) ? (_AP_I) : (1)), _AP_S> ret;
    if (_AP_I == 0) {
      ret.V = 0;
    } else if (_AP_I > 0 && _AP_I <= _AP_W) {
      ret.V = (Base::V).range((_AP_W - 1), (_AP_W - _AP_I));
    } else if (_AP_I > _AP_W) {
      ret.V = (Base::V).range((_AP_W - 1), (0));
      ret.V <<= (_AP_I - _AP_W);
    }
# 848 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    if (Cnative && _AP_I < _AP_W) {

      if (_AP_S && (Base::V).get_bit((_AP_W - 1)) && (_AP_I < _AP_W) &&
          ((Base::V).range((_AP_I < 0 ? _AP_W - 1 : _AP_W - _AP_I - 1), (0))
                                                                      != 0))
        ++ret;
    } else {

    }
    return ret;
  };

 public:
  template <int _AP_W2, bool _AP_S2>
  inline operator ap_int_base<_AP_W2, _AP_S2>() const {
    return ap_int_base<_AP_W2, _AP_S2>(to_ap_int_base());
  }


  inline char to_char() const { return to_ap_int_base().to_char(); }

  inline int to_int() const { return to_ap_int_base().to_int(); }

  inline unsigned to_uint() const { return to_ap_int_base().to_uint(); }

  inline ap_slong to_int64() const { return to_ap_int_base().to_int64(); }

  inline ap_ulong to_uint64() const { return to_ap_int_base().to_uint64(); }



  inline double to_double() const {

    do { if ((std::fegetround() != 
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   0x0000
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   )) { fprintf(
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 881 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 52 + 11 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (11 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 52;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    ap_ulong m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (ap_ulong)(tmp.V >> (lsb_index - 1))
                           : (ap_ulong)(tmp.V << (1 - lsb_index));
    } else {
      m = (ap_ulong)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;


    if (_AP_ctype_op_get_bit(m, 52 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);

    m = _AP_ctype_op_set_range(m, 52, 52 + 11 - 1, e);


    return rawBitsToDouble(m);
  }



  inline float to_float() const {

    do { if ((std::fegetround() != 
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   0x0000
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   )) { fprintf(
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 931 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 23 + 8 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (8 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 23;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    unsigned long m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned long)(tmp.V >> (lsb_index - 1))
                           : (unsigned long)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned long)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (_AP_ctype_op_get_bit(m, 23 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);
    m = _AP_ctype_op_set_range(m, 23, 23 + 8 - 1, e);

    return rawBitsToFloat(m);
  }



  inline half to_half() const {

    do { if ((std::fegetround() != 
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   0x0000
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   )) { fprintf(
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Only FE_TONEAREST is supported"); fprintf(
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 978 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                 ;

    enum { BITS = 10 + 5 + 1 };
    if (!Base::V) return 0.0f;
    bool s = _AP_S && (Base::V).get_bit((_AP_W - 1));
    ap_int_base<_AP_W, false> tmp;
    if (s)
      tmp.V = -Base::V;
    else
      tmp.V = Base::V;
    int l = tmp.countLeadingZeros();
    int e = _AP_I - l - 1 + ((1L << (5 - 1L)) - 1L);
    int lsb_index = _AP_W - l - 1 - 10;

    bool a = (lsb_index >=2) ?
        ((tmp.V).range((lsb_index - 2), (0)) != 0) : 0;

    a |= (lsb_index >=0) ? (tmp.V).get_bit((lsb_index)) : 0;

    unsigned short m;

    if (_AP_W > BITS) {
      m = (lsb_index >= 1) ? (unsigned short)(tmp.V >> (lsb_index - 1))
                           : (unsigned short)(tmp.V << (1 - lsb_index));
    } else {
      m = (unsigned short)tmp.V;
      m = (lsb_index >= 1) ? (m >> (lsb_index - 1))
                           : (m << (1 - lsb_index));
    }
    m += a;
    m >>= 1;

    if (_AP_ctype_op_get_bit(m, 10 + 1)) {
      e += 1;
    }

    m = _AP_ctype_op_set_bit(m, BITS - 1, s);
    m = _AP_ctype_op_set_range(m, 10, 10 + 5 - 1, e);

    return rawBitsToHalf(m);
  }


  inline operator long double() const { return (long double)to_double(); }

  inline operator double() const { return to_double(); }

  inline operator float() const { return to_float(); }

  inline operator half() const { return to_half(); }

  inline operator bool() const { return (bool)Base::V != 0; }

  inline operator char() const { return (char)to_int(); }

  inline operator signed char() const { return (signed char)to_int(); }

  inline operator unsigned char() const { return (unsigned char)to_uint(); }

  inline operator short() const { return (short)to_int(); }

  inline operator unsigned short() const { return (unsigned short)to_uint(); }

  inline operator int() const { return to_int(); }

  inline operator unsigned int() const { return to_uint(); }



  inline operator long() const { return (long)to_int64(); }

  inline operator unsigned long() const { return (unsigned long)to_uint64(); }






  inline operator ap_ulong() const { return to_uint64(); }

  inline operator ap_slong() const { return to_int64(); }

  inline int length() const { return _AP_W; };




  inline ap_ulong bits_to_uint64() const {
    return (Base::V).to_uint64();
  }





  inline int countLeadingZeros() {
# 1104 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return Base::V.countLeadingZeros();

  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline typename RType<_AP_W2, _AP_I2, _AP_S2>::mult operator*(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::mult_base r, t;
    r.V = Base::V;
    t.V = op2.V;
    r.V *= op2.V;
    return r;
  }



  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline typename RType<_AP_W2, _AP_I2, _AP_S2>::div operator/(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2)
      const {
    typename RType<_AP_W2, _AP_I2, _AP_S2>::div_base r;

    enum {F2 = _AP_W2-_AP_I2,
              _W1=((_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) > (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)) ? (_AP_W + ((F2) > (0) ? (F2) : (0)) + ((_AP_S2 && !_AP_S) ? 1 : 0)) : (_AP_W2 + ((_AP_S && !_AP_S2) ? 1 : 0)))};
    ap_int_base<_W1,_AP_S||_AP_S2> dividend,divisior;
    ap_int_base<_W1,_AP_S> tmp1;
    ap_int_base<_W1,_AP_S2> tmp2;
    tmp1.V = Base::V;
    tmp1.V <<= ((F2) > (0) ? (F2) : (0));
    tmp2.V = op2.V;
    dividend = tmp1;
    divisior = tmp2;
    r.V = ((_AP_S||_AP_S2) ? dividend.V.sdiv(divisior.V): dividend.V.udiv(divisior.V));
# 1177 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return r;
  }
# 1192 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::plus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V + rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::minus_base ret, lhs(*this), rhs(op2); ret.V = lhs.V - rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V & rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V | rhs.V; return ret; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline typename RType<_AP_W2, _AP_I2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { typename RType<_AP_W2, _AP_I2, _AP_S2>::logic_base ret, lhs(*this), rhs(op2); ret.V = lhs.V ^ rhs.V; return ret; }
# 1210 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator *=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator *(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator /=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator /(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator +=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator +(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator -=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator -(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator &=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator &(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator |=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator |(op2); return *this; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline ap_fixed_base& operator ^=( const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) { *this = operator ^(op2); return *this; }





  inline ap_fixed_base& operator++() {
    operator+=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline ap_fixed_base& operator--() {
    operator-=(ap_fixed_base<_AP_W - _AP_I + 1, 1, false>(1));
    return *this;
  }


  inline const ap_fixed_base operator++(int) {
    ap_fixed_base r(*this);
    operator++();
    return r;
  }


  inline const ap_fixed_base operator--(int) {
    ap_fixed_base r(*this);
    operator--();
    return r;
  }



  inline ap_fixed_base operator+() { return *this; }

  inline ap_fixed_base<_AP_W + 1, _AP_I + 1, true> operator-() const {
    ap_fixed_base<_AP_W + 1, _AP_I + 1, true> r(*this);
    r.V = -r.V;
    return r;
  }

  inline ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> getNeg() {
    ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> r(*this);
    r.V = -r.V;
    return r;
  }



  inline bool operator!() const { return Base::V == 0; }




  inline ap_fixed_base<_AP_W, _AP_I, _AP_S> operator~() const {
    ap_fixed_base<_AP_W, _AP_I, _AP_S> r;
    r.V = ~Base::V;
    return r;
  }




  template <int _AP_SHIFT>
  inline ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> lshift() const {
    ap_fixed_base<_AP_W, _AP_I + _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }

  template <int _AP_SHIFT>
  inline ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> rshift() const {
    ap_fixed_base<_AP_W, _AP_I - _AP_SHIFT, _AP_S> r;
    r.V = Base::V;
    return r;
  }





  inline ap_fixed_base operator<<(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V << sh;
# 1328 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return r;
  }

  inline ap_fixed_base operator>>(unsigned int sh) const {
    ap_fixed_base r;
    r.V = Base::V >> sh;
# 1350 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
    return r;
  }


  inline ap_fixed_base operator<<(int sh) const {
    ap_fixed_base r;
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator>>(ush);
    } else {
      return operator<<(ush);
    }
  }

  inline ap_fixed_base operator>>(int sh) const {
    bool isNeg = sh < 0;
    unsigned int ush = isNeg ? -sh : sh;
    if (isNeg) {
      return operator<<(ush);
    } else {
      return operator>>(ush);
    }
  }


  template <int _AP_W2>
  inline ap_fixed_base operator<<(const ap_int_base<_AP_W2, true>& op2) const {


    int sh = op2.to_int();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline ap_fixed_base operator>>(const ap_int_base<_AP_W2, true>& op2) const {
    int sh = op2.to_int();
    return operator>>(sh);
  }


  template <int _AP_W2>
  inline ap_fixed_base operator<<(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator<<(sh);
  }

  template <int _AP_W2>
  inline ap_fixed_base operator>>(const ap_int_base<_AP_W2, false>& op2) const {
    unsigned int sh = op2.to_uint();
    return operator>>(sh);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base operator<<(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator<<(op2.to_ap_int_base());
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base operator>>(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          op2) {
    return operator>>(op2.to_ap_int_base());
  }





  inline ap_fixed_base& operator<<=(const int sh) {
    *this = operator<<(sh);
    return *this;
  }

  inline ap_fixed_base& operator<<=(const unsigned int sh) {
    *this = operator<<(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base& operator<<=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator<<=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator<<(sh.to_int());
    return *this;
  }


  inline ap_fixed_base& operator>>=(const int sh) {
    *this = operator>>(sh);
    return *this;
  }

  inline ap_fixed_base& operator>>=(const unsigned int sh) {
    *this = operator>>(sh);
    return *this;
  }

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed_base& operator>>=(const ap_int_base<_AP_W2, _AP_S2>& sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed_base& operator>>=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          sh) {
    *this = operator>>(sh.to_int());
    return *this;
  }
# 1494 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator >(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V > op2.V; else if (_AP_F > F2) return Base::V > ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V > op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator <(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V < op2.V; else if (_AP_F > F2) return Base::V < ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V < op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator >=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V >= op2.V; else if (_AP_F > F2) return Base::V >= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V >= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator <=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V <= op2.V; else if (_AP_F > F2) return Base::V <= ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V <= op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator ==(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V == op2.V; else if (_AP_F > F2) return Base::V == ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V == op2.V; return false; }
  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2, ap_o_mode _AP_O2, int _AP_N2> inline bool operator !=(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) const { enum { _AP_F = _AP_W - _AP_I, F2 = _AP_W2 - _AP_I2 }; if (_AP_F == F2) return Base::V != op2.V; else if (_AP_F > F2) return Base::V != ap_fixed_base<((_AP_W2 + _AP_F - F2) > (1) ? (_AP_W2 + _AP_F - F2) : (1)), _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>(op2).V; else return ap_fixed_base<((_AP_W + F2 - _AP_F + 1) > (1) ? (_AP_W + F2 - _AP_F + 1) : (1)), _AP_I + 1, _AP_S, _AP_Q, _AP_O, _AP_N>(*this).V != op2.V; return false; }





  inline bool operator >(double d) const { return to_double() > d; }
  inline bool operator <(double d) const { return to_double() < d; }
  inline bool operator >=(double d) const { return to_double() >= d; }
  inline bool operator <=(double d) const { return to_double() <= d; }
  inline bool operator ==(double d) const { return to_double() == d; }
  inline bool operator !=(double d) const { return to_double() != d; }


  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      unsigned index) {
    do { if ((index >= _AP_W)) { fprintf(
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1515 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator[](
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    do { if ((index < 0)) { fprintf(
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1522 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index >= _AP_W)) { fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1523 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline bool operator[](unsigned index) const {
    do { if ((index >= _AP_W)) { fprintf(
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1529 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index));
  }

  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      unsigned index) {
    do { if ((index >= _AP_W)) { fprintf(
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1535 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, index);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> bit(
      const ap_int_base<_AP_W2, _AP_S2>& index) {
    do { if ((index < 0)) { fprintf(
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1542 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index >= _AP_W)) { fprintf(
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1543 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this,
                                                                index.to_int());
  }

  inline bool bit(unsigned index) const {
    do { if ((index >= _AP_W)) { fprintf(
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1549 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index));
  }

  template <int _AP_W2>
  inline af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> get_bit(
      const ap_int_base<_AP_W2, true>& index) {
    do { if ((index < _AP_I - _AP_W)) { fprintf(
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit with negative index"); fprintf(
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1556 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0)
                                                             ;
    do { if ((index >= _AP_I)) { fprintf(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1558 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        this, index.to_int() + _AP_W - _AP_I);
  }

  inline bool get_bit(int index) const {
    do { if ((index >= _AP_I)) { fprintf(
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1564 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index < _AP_I - _AP_W)) { fprintf(
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1565 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index + _AP_W - _AP_I))
                                                     ;
  }
# 1580 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  template <int _AP_W2>
  inline bool get_bit(const ap_int_base<_AP_W2, true>& index) const {
    do { if ((index >= _AP_I)) { fprintf(
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1582 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    do { if ((index < _AP_I - _AP_W)) { fprintf(
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Attempting to read bit beyond MSB"); fprintf(
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1583 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return (const_cast<ap_fixed_base*>(this)->V).get_bit((index.to_int() + _AP_W - _AP_I))
                                                              ;
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(int Hi,
                                                                      int Lo) {
    do { if (((Hi >= _AP_W) || (Lo >= _AP_W))) { fprintf(
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Out of bounds in range()"); fprintf(
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1590 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(this, Hi, Lo);
  }


  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      int Hi, int Lo) const {
    do { if (((Hi >= _AP_W) || (Lo >= _AP_W))) { fprintf(
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "WARNING: " "Out of bounds in range()"); fprintf(
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h" 3
   (&__iob_func()[2])
# 1597 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
   , "\n"); } } while (0);
    return af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(
        const_cast<ap_fixed_base*>(this), Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() {
    return this->range(_AP_W - 1, 0);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> range() const {
    return this->range(_AP_W - 1, 0);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) {
    return this->range(Hi, Lo);
  }

  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      int Hi, int Lo) const {
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  template <int _AP_W2, bool _AP_S2, int _AP_W3, bool _AP_S3>
  inline af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> operator()(
      const ap_int_base<_AP_W2, _AP_S2>& HiIdx,
      const ap_int_base<_AP_W3, _AP_S3>& LoIdx) const {
    int Hi = HiIdx.to_int();
    int Lo = LoIdx.to_int();
    return this->range(Hi, Lo);
  }

  inline bool is_zero() const { return Base::V == 0; }

  inline bool is_neg() const {
    if (_AP_S && (Base::V).get_bit((_AP_W - 1))) return true;
    return false;
  }

  inline int wl() const { return _AP_W; }

  inline int iwl() const { return _AP_I; }

  inline ap_q_mode q_mode() const { return _AP_Q; }

  inline ap_o_mode o_mode() const { return _AP_O; }

  inline int n_bits() const { return _AP_N; }
# 1680 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
  std::string to_string(unsigned char radix = 2, bool sign = _AP_S) const {


    if (radix == 2) sign = false;

    std::string str;
    str.clear();
    char step = 0;
    bool isNeg = sign && (Base::V < 0);


    ap_fixed_base<_AP_W + 1, _AP_I + 1> tmp(*this);
    if (isNeg) {
      tmp = -tmp;
      str += '-';
    }
    std::string prefix;
    switch (radix) {
      case 2:
        prefix = "0b";
        step = 1;
        break;
      case 8:
        prefix = "0o";
        step = 3;
        break;
      case 16:
        prefix = "0x";
        step = 4;
        break;
      default:
        break;
    }

    if (_AP_I > 0) {




      ap_int_base<((_AP_I + 1) > (1) ? (_AP_I + 1) : (1)), false> int_part;




      int_part.V = (tmp.V).range((_AP_W), (_AP_W - _AP_I))
                                      ;
      str += int_part.to_string(radix, false);
    } else {
      str += prefix;
      str += '0';
    }

    ap_fixed_base<((_AP_W - _AP_I) > (1) ? (_AP_W - _AP_I) : (1)), 0, false> frac_part = tmp;

    if (radix == 10) {
      if (frac_part != 0) {
        str += ".";
        while (frac_part != 0) {
          char digit = (frac_part * radix).to_char();
          str += static_cast<char>(digit + '0');
          frac_part *= radix;
        }
      }
    } else {
      if (frac_part != 0) {
        str += ".";
        for (signed i = _AP_W - _AP_I - 1; i >= 0; i -= step) {
          char digit = frac_part.range(i, ((0) > (i - step + 1) ? (0) : (i - step + 1))).to_char();


          int offset = ((0) < (i - step + 1) ? (0) : (i - step + 1));
          digit <<= -offset;
          str += digit < 10 ? static_cast<char>(digit + '0')
                            : static_cast<char>(digit - 10 + 'a');
        }
        if (radix == 16)
          str += "p0";
      }
    }
    return str;
  }






};

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_not(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) {
  ret.V = ~op.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_and(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V & op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_or(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V | op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void b_xor(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  ret.V = op1.V ^ op2.V;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void neg(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
  ap_fixed_base<_AP_W2 + !_AP_S2, _AP_I2 + !_AP_S2, true, _AP_Q2, _AP_O2,
                _AP_N2>
      t;
  t.V = -op.V;
  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void lshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F2 = _AP_W2 - _AP_I2,
    _AP_I3 = ((_AP_I) > (_AP_I2) ? (_AP_I) : (_AP_I2)),
    _AP_W3 = _AP_I3 + F2,
  };

  ap_fixed_base<_AP_W3, _AP_I3, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  t.V <<= i;

  ret = t;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N, int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
          ap_o_mode _AP_O2, int _AP_N2>
inline void rshift(
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ret,
    const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op,
    int i) {
  enum {
    F = _AP_W - _AP_I,
    F2 = _AP_W2 - _AP_I2,
    F3 = ((F) > (F2) ? (F) : (F2)),
    _AP_W3 = _AP_I2 + F3,
    sh = F - F2,
  };

  ap_fixed_base<_AP_W3, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> t;
  t.V = op.V;
  if (sh >= 0)
    t.V <<= (int) sh;
  t.V >>= i;

  ret = t;
}
# 1869 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
inline std::string scientificFormat(std::string& input) {
  if (input.length() == 0) return input;

  size_t decPosition = input.find('.');
  if (decPosition == std::string::npos) decPosition = input.length();

  size_t firstNonZeroPos = 0;
  for (; input[firstNonZeroPos] > '9' || input[firstNonZeroPos] < '1';
       firstNonZeroPos++)
    ;

  int exp;
  if (firstNonZeroPos > decPosition)
    exp = decPosition - firstNonZeroPos;
  else
    exp = decPosition - firstNonZeroPos - 1;
  std::string expString = "";
  if (exp == 0)
    ;
  else if (exp < 0) {
    expString += "e-";
    exp = -exp;
  } else
    expString += "e+";

  if (exp < 10 && exp > 0) {
    expString += '0';
    expString += (char)('0' + exp);
  } else if (exp != 0) {
    std::string tmp;

    std::ostringstream oss;
    oss << exp;

    tmp = oss.str();
    expString += tmp;
  }

  int lastNonZeroPos = (int)(input.length() - 1);
  for (; lastNonZeroPos >= 0; --lastNonZeroPos)
    if (input[lastNonZeroPos] <= '9' && input[lastNonZeroPos] > '0') break;

  std::string ans = "";
  ans += input[firstNonZeroPos];
  if (firstNonZeroPos != (size_t)lastNonZeroPos) {
    ans += '.';
    for (int i = firstNonZeroPos + 1; i <= lastNonZeroPos; i++)
      if (input[i] != '.') ans += input[i];
  }

  ans += expString;
  return ans;
}

inline std::string reduceToPrecision(std::string& input, int precision) {
  bool isZero = true;
  size_t inputLen = input.length();
  for (size_t i = 0; i < inputLen && isZero; i++)
    if (input[i] != '.' && input[i] != '0') isZero = false;
  if (isZero) return "0";


  int FirstNonZeroPos = 0;
  int LastNonZeroPos = (int)inputLen - 1;
  int truncBitPosition = 0;
  size_t decPosition = input.find('.');
  for (; input[FirstNonZeroPos] < '1' || input[FirstNonZeroPos] > '9';
       FirstNonZeroPos++)
    ;

  for (; input[LastNonZeroPos] < '1' || input[LastNonZeroPos] > '9';
       LastNonZeroPos--)
    ;

  if (decPosition == std::string::npos) decPosition = inputLen;

  if ((int)decPosition > LastNonZeroPos) {
    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) return input;
    truncBitPosition = FirstNonZeroPos + precision;
  } else if ((int)decPosition < FirstNonZeroPos) {
    if (LastNonZeroPos - FirstNonZeroPos + 1 <= precision) {
      if (FirstNonZeroPos - decPosition - 1 < 4) {
        return input;
      } else {
        if (input[0] == '-') {
          std::string tmp = input.substr(1, inputLen - 1);
          return std::string("-") + scientificFormat(tmp);
        } else
          return scientificFormat(input);
      }
    }
    truncBitPosition = FirstNonZeroPos + precision;
  } else {
    if (LastNonZeroPos - FirstNonZeroPos <= precision) return input;
    truncBitPosition = FirstNonZeroPos + precision + 1;
  }



  std::string ans = "";
  std::string dupInput = "0";
  if (input[0] == '-') {
    ans += '-';
    dupInput += input.substr(1, inputLen - 1);
  } else {
    dupInput += input.substr(0, inputLen);
    ++truncBitPosition;
  }


  bool carry = dupInput[truncBitPosition] > '4';
  for (int i = truncBitPosition - 1; i >= 0 && carry; i--) {
    if (dupInput[i] == '.') continue;
    if (dupInput[i] == '9')
      dupInput[i] = '0';
    else {
      ++dupInput[i];
      carry = false;
    }
  }


  if (dupInput[0] == '1')
    FirstNonZeroPos = 0;
  else {
    FirstNonZeroPos = 0;
    while (dupInput[FirstNonZeroPos] < '1' || dupInput[FirstNonZeroPos] > '9')
      ++FirstNonZeroPos;
  }

  unsigned it = FirstNonZeroPos;
  int NValidNumber = 0;
  while (it < dupInput.length()) {
    if (dupInput[it] == '.') {
      ++it;
      continue;
    }
    ++NValidNumber;
    if (NValidNumber > precision) dupInput[it] = '0';
    ++it;
  }


  decPosition = dupInput.find('.');
  if (decPosition == std::string::npos)
    truncBitPosition = (int)dupInput.length();
  else
    for (truncBitPosition = (int)(dupInput.length() - 1); truncBitPosition >= 0;
         --truncBitPosition) {
      if (dupInput[truncBitPosition] == '.') break;
      if (dupInput[truncBitPosition] != '0') {
        truncBitPosition++;
        break;
      }
    }

  if (dupInput[0] == '1')
    dupInput = dupInput.substr(0, truncBitPosition);
  else
    dupInput = dupInput.substr(1, truncBitPosition - 1);

  decPosition = dupInput.find('.');
  if (decPosition != std::string::npos) {
    size_t it = 0;
    for (it = decPosition + 1; dupInput[it] == '0'; it++)
      ;
    if (it - decPosition - 1 < 4) {
      ans += dupInput;
      return ans;
    } else {
      ans += scientificFormat(dupInput);
      return ans;
    }
  } else if ((int)(dupInput.length()) <= precision) {
    ans += dupInput;
    return ans;
  }

  ans += scientificFormat(dupInput);
  return ans;
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline void print(
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  if (_AP_I > 0) {
    ap_int_base<_AP_I, _AP_S> p1;
    p1.V = x.V >> (_AP_W - _AP_I);
    print(p1.V);
  } else {
    printf("0");
  }
  printf(".");
  if (_AP_I < _AP_W) {
    ap_int_base<_AP_W - _AP_I, false> p2;
    p2.V = (x.V).range((_AP_W - _AP_I), (0));
    print(p2.V, false);
  }
}
# 2080 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& out,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {

  unsigned width = out.width();
  unsigned precision = out.precision();
  char fill = out.fill();
  std::string str = x.to_string(10, _AP_S);
  str = reduceToPrecision(str, precision);
  if (width > str.length()) {
    for (unsigned i = 0; i < width - str.length(); ++i)
      out << fill;
  }
  out << str;
  return out;
}





template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::istream& operator>>(
    std::istream& in,
    ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  double d;
  in >> d;
  x = ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>(d);
  return in;
}
# 2213 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::plus operator +( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::minus operator -( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::mult operator *( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::div operator /( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator &( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator |( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::logic operator ^( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (1), (1), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator +=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator -=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator *=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator /=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator &=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator |=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ^=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >>=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <<=(ap_int_base<(1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator >=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator <=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator ==(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool i_op) { return op.operator !=(ap_fixed_base<(1), (1), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(1), (1), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::plus operator +( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::minus operator -( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::mult operator *( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::div operator /( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator &( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator |( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::logic operator ^( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (CHAR_IS_SIGNED)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >>=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <<=(ap_int_base<(8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (CHAR_IS_SIGNED)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::plus operator +( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::minus operator -( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::mult operator *( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::div operator /( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator &( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator |( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::logic operator ^( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >>=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <<=(ap_int_base<(8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::plus operator +( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::minus operator -( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::mult operator *( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::div operator /( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator &( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator |( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::logic operator ^( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (8), (8), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator +=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator -=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator *=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator /=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator &=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator |=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ^=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >>=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <<=(ap_int_base<(8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator >=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator <=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator ==(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char i_op) { return op.operator !=(ap_fixed_base<(8), (8), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(8), (8), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::plus operator +( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::minus operator -( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::mult operator *( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::div operator /( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator &( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator |( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::logic operator ^( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::plus operator +( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::minus operator -( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::mult operator *( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::div operator /( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator &( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator |( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::logic operator ^( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_short), (_AP_SIZE_short), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_short), (_AP_SIZE_short), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::plus operator +( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::minus operator -( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::mult operator *( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::div operator /( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator &( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator |( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::logic operator ^( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::plus operator +( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::minus operator -( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::mult operator *( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::div operator /( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator &( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator |( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::logic operator ^( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_int), (_AP_SIZE_int), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_int), (_AP_SIZE_int), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::plus operator +( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::minus operator -( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::mult operator *( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::div operator /( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator &( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator |( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::logic operator ^( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::plus operator +( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::minus operator -( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::mult operator *( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::div operator /( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator &( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator |( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::logic operator ^( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_long), (_AP_SIZE_long), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_long), (_AP_SIZE_long), (false)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::plus operator +( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::minus operator -( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::mult operator *( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::div operator /( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator &( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator |( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::logic operator ^( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (true)>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::plus operator +( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::minus operator -( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::mult operator *( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::div operator /( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator &( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator |( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::logic operator ^( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator >>( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< (_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>::lhs operator <<( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator +=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator -=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator *=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator /=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator &=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator |=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ^=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator >>=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >>=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator <<=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <<=(ap_int_base<(_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator >=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator >=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator <=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator <=(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator ==(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator ==(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong i_op) { return op.operator !=(ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<(_AP_SIZE_ap_slong), (_AP_SIZE_ap_slong), (false)>(i_op).operator !=(op); }
# 2301 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_base.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::plus operator +( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator +(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::plus operator +( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::minus operator -( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator -(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::minus operator -( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::mult operator *( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator *(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::mult operator *( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::div operator /( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator /(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::div operator /( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator &( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator &(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator &( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator |( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator |(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator |( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>::template RType< _AP_W, _AP_I, _AP_S>::logic operator ^( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ^(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline typename ap_fixed_base<_AP_W, _AP_I, _AP_S>::template RType< _AP_W2, _AP_W2, _AP_S2>::logic operator ^( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator +=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator +=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator +=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator +=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator -=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator -=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator -=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator -=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator *=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator *=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator *=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator *=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator /=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator /=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator /=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator /=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator &=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator &=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator &=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator &=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator |=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator |=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator |=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator |=(op.to_ap_int_base()); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& operator ^=( ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ^=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline ap_int_base<_AP_W2, _AP_S2>& operator ^=( ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return i_op.operator ^=(op.to_ap_int_base()); }



template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator ==(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator ==(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator !=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator !=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator >=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator >=(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& i_op) { return op.operator <=(ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op)); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& i_op, const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_fixed_base<_AP_W2, _AP_W2, _AP_S2>(i_op).operator <=(op); }




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator==(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator==(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator!=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator!=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator>(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator>=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator<=(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator<(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>(op1);
}

template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline bool operator<=(
    double op1,
    const ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op2) {
  return op2.operator>=(op1);
}
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 1
# 70 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_bit_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int d_index;

 public:
  inline af_bit_ref(
      const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), d_index(ref.d_index) {

    do { if ((d_index < 0)) { fprintf(
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Index of bit vector  (%d) cannot be negative.", d_index); fprintf(
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 85 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                        ;
    do { if ((d_index >= _AP_W)) { fprintf(
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Index of bit vector (%d) out of range (%d).", d_index, _AP_W); fprintf(
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 87 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                               ;

  }

  inline af_bit_ref(ref_type* bv, int index = 0) : d_bv(*bv), d_index(index) {}

  inline af_bit_ref(const ref_type* bv, int index = 0)
      : d_bv(*const_cast<ref_type*>(bv)), d_index(index) {}


  inline operator bool() const { return (d_bv.V).get_bit((d_index)); }



  inline af_bit_ref& operator=(bool val) {
    d_bv.V = _AP_ROOT_op_set_bit(d_bv.V, d_index, val);
    return *this;
  }



  inline af_bit_ref& operator=(const af_bit_ref& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_bit_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    return operator=(bool(val));
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_int_base<_AP_W2, _AP_S2>& val) {
    return operator=(val != 0);
  }

  template <int _AP_W2, bool _AP_S2>
  inline af_bit_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_bit_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    return operator=(ap_int_base<_AP_W2, false>(val));
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline af_bit_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    return operator=(ap_int_base<_AP_W2 + _AP_W3, false>(val));
  }




  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
  operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> > operator,(
      const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(*this,
                                                                        op);
  }

  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >(
        *this, op);
  }

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<1, af_bit_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(*this,
                                                                         op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<
      1, af_bit_ref, _AP_W2,
      af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        1, af_bit_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(*this,
                                                                       op);
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                    _AP_Q2, _AP_O2, _AP_N2> >
  operator,(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<1, af_bit_ref, 1, af_bit_ref<_AP_W2, _AP_I2, _AP_S2,
                                                      _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator==(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() == op.get();
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator!=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op) {
    return get() != op.get();
  }


  inline bool operator~() const {
    bool bit = (d_bv.V).get_bit((d_index));
    return bit ? false : true;
  }

  inline bool get() const { return (d_bv.V).get_bit((d_index)); }

  inline int length() const { return 1; }


  std::string to_string() const { return get() ? "1" : "0"; }




};




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& os,
    const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  os << x.to_string();
  return os;
}




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
struct af_range_ref {



  typedef ap_fixed_base<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N> ref_type;
  ref_type& d_bv;
  int l_index;
  int h_index;

 public:

  inline af_range_ref(
      const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& ref)
      : d_bv(ref.d_bv), l_index(ref.l_index), h_index(ref.h_index) {}




  inline af_range_ref(ref_type* bv, int h, int l)
      : d_bv(*bv), l_index(l), h_index(h) {

    do { if ((h < 0 || l < 0)) { fprintf(
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) and lower(%d) bound cannot be negative.", h, l); fprintf(
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 280 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)

                  ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) or lower(%d) bound out of range.", h, l); fprintf(
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 283 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                                                                          ;
    do { if ((h < l)) { fprintf(
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "The bits selected will be returned in reverse order."); fprintf(
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 285 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0);

  }

  inline af_range_ref(const ref_type* bv, int h, int l)
      : d_bv(*const_cast<ref_type*>(bv)), l_index(l), h_index(h) {

    do { if ((h < 0 || l < 0)) { fprintf(
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) and lower(%d) bound cannot be negative.", h, l); fprintf(
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 292 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)

                  ;
    do { if ((h >= _AP_W || l >= _AP_W)) { fprintf(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "Higher bound(%d) or lower(%d) bound out of range.", h, l); fprintf(
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 295 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0)
                                                                          ;
    do { if ((h < l)) { fprintf(
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "WARNING: " "The bits selected will be returned in reverse order."); fprintf(
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h" 3
   (&__iob_func()[2])
# 297 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
   , "\n"); } } while (0);

  }
# 311 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
  inline af_range_ref& operator=(const bool val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const signed char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned char val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned short val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned int val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const unsigned long val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const ap_slong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const ap_ulong val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const half val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const float val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }
  inline af_range_ref& operator=(const double val) { ap_int_base<_AP_W, false> loc(val); d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, loc.V); return *this; }



  inline af_range_ref& operator=(const char* val) {
    const ap_int_base<_AP_W, false> tmp(val);
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, tmp.V);
    return *this;
  }



  template <int _AP_W3, bool _AP_S3>
  inline af_range_ref& operator=(const ap_int_base<_AP_W3, _AP_S3>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
    return *this;
  }


  template <int _AP_W2, bool _AP_S2>
  inline af_range_ref& operator=(const ap_range_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, bool _AP_S2>
  inline af_range_ref& operator=(const ap_bit_ref<_AP_W2, _AP_S2>& val) {
    const ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&
          val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
    return *this;
  }




  inline af_range_ref& operator=(const af_range_ref& val) {
    ap_int_base<_AP_W, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<_AP_W2, false> tmp(val);
    return operator=(tmp);
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline af_range_ref& operator=(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& val) {
    ap_int_base<1, false> tmp((bool)val);
    return operator=(tmp);
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline af_range_ref& operator=(
      const ap_concat_ref<_AP_W2, _AP_T3, _AP_W3, _AP_T3>& val) {
    const ap_int_base<_AP_W2 + _AP_W3, false> tmp(val);
    return operator=(tmp);
  }




  template <int _AP_W2, bool _AP_S2>
  inline bool operator==(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator!=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator<=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, bool _AP_S2>
  inline bool operator>=(const ap_range_ref<_AP_W2, _AP_S2>& op2) {
    return !(operator<(op2));
  }




  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator==(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop == rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator!=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator==(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator<(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop < rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator>(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    ap_int_base<_AP_W, false> lop(*this);
    ap_int_base<_AP_W2, false> rop(op2);
    return lop > rop;
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator<=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator>(op2));
  }

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline bool operator>=(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op2) {
    return !(operator<(op2));
  }





  template <int _AP_W2, int _AP_S2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_int_base<_AP_W2, _AP_S2> >
      operator,(ap_int_base<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_int_base<_AP_W2, _AP_S2> >(*this, op);
  }


  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >
  operator,(const ap_bit_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, 1, ap_bit_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_bit_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, int _AP_S2>
  inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2, ap_range_ref<_AP_W2, _AP_S2> >
  operator,(const ap_range_ref<_AP_W2, _AP_S2> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                         ap_range_ref<_AP_W2, _AP_S2> >(
        *this, const_cast<ap_range_ref<_AP_W2, _AP_S2>&>(op));
  }


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                       ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >
  operator,(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> &op) {
    return ap_concat_ref<_AP_W, af_range_ref, _AP_W2 + _AP_W3,
                         ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3> >(
        *this, const_cast<ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>&>(op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, _AP_W2,
                    af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>
                    &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, _AP_W2,
        af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline
      ap_concat_ref<_AP_W, af_range_ref, 1,
                    af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >
      operator,(
          const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> &op) {
    return ap_concat_ref<
        _AP_W, af_range_ref, 1,
        af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2> >(
        *this,
        const_cast<af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>&>(
            op));
  }


  inline operator ap_ulong() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_uint64();
  }

  inline operator ap_int_base<_AP_W, false>() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  inline ap_int_base<_AP_W, false> to_ap_int_base() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }


  inline char to_char() const {
    return (char)((d_bv.V).range((h_index), (l_index)));
  }

  inline int to_int() const {
    return (int)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned to_uint() const {
    return (unsigned)((d_bv.V).range((h_index), (l_index)));
  }

  inline long to_long() const {
    return (long)((d_bv.V).range((h_index), (l_index)));
  }

  inline unsigned long to_ulong() const {
    return (unsigned long)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_slong to_int64() const {
    return (ap_slong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_ulong to_uint64() const {
    return (ap_ulong)((d_bv.V).range((h_index), (l_index)));
  }

  inline ap_int_base<_AP_W, false> get() const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret;
  }

  template <int _AP_W2>
  inline void set(const ap_int_base<_AP_W2, false>& val) {
    d_bv.V = _AP_ROOT_op_set_range(d_bv.V, l_index, h_index, val.V);
  }

  inline int length() const {
    return h_index >= l_index ? h_index - l_index + 1 : l_index - h_index + 1;
  }


  std::string to_string(signed char rd = 2) const {
    ap_int_base<_AP_W, false> ret;
    ret.V = (d_bv.V).range((h_index), (l_index));
    return ret.to_string(rd);
  }






};




template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O,
          int _AP_N>
inline std::ostream& operator<<(
    std::ostream& os,
    const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& x) {
  os << x.to_string();
  return os;
}
# 696 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(1), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(1), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, bool op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( bool op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (CHAR_IS_SIGNED)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (CHAR_IS_SIGNED)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, signed char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( signed char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(8), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(8), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned char op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned char op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_short), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_short), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned short op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned short op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_int), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_int), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned int op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned int op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_long), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_long), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, unsigned long op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( unsigned long op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (true)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_slong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_slong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) > ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) < ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) >= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator >=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) <= ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator <=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) == ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator ==( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == bool(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return ap_int_base<_AP_W, false>(op) != ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return ap_int_base<(_AP_SIZE_ap_slong), (false)>(op2) != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, ap_ulong op2) { return bool(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N> inline bool operator !=( ap_ulong op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != bool(op); }
# 742 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_ref.h"
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) > op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 > ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) < op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 < ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) >= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator >=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 >= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) <= op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator <=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 <= ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) == op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator ==( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 == ap_int_base<1, false>(op); }
template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S>& op2) { return ap_int_base<_AP_W, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_range_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<_AP_W, false>(op); } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op, const ap_int_base<_AP_W2, _AP_S2>& op2) { return ap_int_base<1, false>(op) != op2; } template <int _AP_W, int _AP_I, bool _AP_S, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N, int _AP_W2, bool _AP_S2> inline bool operator !=( const ap_int_base<_AP_W2, _AP_S2>& op2, const af_bit_ref<_AP_W, _AP_I, _AP_S, _AP_Q, _AP_O, _AP_N>& op) { return op2 != ap_int_base<1, false>(op); }
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 2





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_fixed : ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, true, _AP_Q, _AP_O, _AP_N> Base;


  inline ap_fixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                      _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                               _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 111 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
# 145 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, bool _AP_S2>
  inline ap_fixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}


  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_fixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_fixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}





  inline ap_fixed(bool v) : Base(v) {}
  inline ap_fixed(char v) : Base(v) {}
  inline ap_fixed(signed char v) : Base(v) {}
  inline ap_fixed(unsigned char v) : Base(v) {}
  inline ap_fixed(short v) : Base(v) {}
  inline ap_fixed(unsigned short v) : Base(v) {}
  inline ap_fixed(int v) : Base(v) {}
  inline ap_fixed(unsigned int v) : Base(v) {}
  inline ap_fixed(long v) : Base(v) {}
  inline ap_fixed(unsigned long v) : Base(v) {}
  inline ap_fixed(ap_slong v) : Base(v) {}
  inline ap_fixed(ap_ulong v) : Base(v) {}
  inline ap_fixed(half v) : Base(v) {}
  inline ap_fixed(float v) : Base(v) {}
  inline ap_fixed(double v) : Base(v) {}


  inline ap_fixed(const char* s) : Base(s) {}

  inline ap_fixed(const char* s, signed char rd) : Base(s, rd) {}






  inline ap_fixed& operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline ap_fixed& operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const volatile ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }
};





template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
struct ap_ufixed : ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> {
  typedef ap_fixed_base<_AP_W, _AP_I, false, _AP_Q, _AP_O, _AP_N> Base;


  inline ap_ufixed() : Base() {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(const ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                       _AP_O2, _AP_N2>& op)
      : Base(op) {}


  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(const volatile ap_fixed_base<_AP_W2, _AP_I2, _AP_S2, _AP_Q2,
                                                _AP_O2, _AP_N2>& op)
      : Base(op) {}
# 276 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const volatile ap_int_base<_AP_W2, _AP_S2>& op) : Base(op) {}
# 307 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_bit_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, bool _AP_S2>
  inline ap_ufixed(const ap_range_ref<_AP_W2, _AP_S2>& op) : Base(op) {}

  template <int _AP_W2, typename _AP_T2, int _AP_W3, typename _AP_T3>
  inline ap_ufixed(const ap_concat_ref<_AP_W2, _AP_T2, _AP_W3, _AP_T3>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(
      const af_bit_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}

  template <int _AP_W2, int _AP_I2, bool _AP_S2, ap_q_mode _AP_Q2,
            ap_o_mode _AP_O2, int _AP_N2>
  inline ap_ufixed(
      const af_range_ref<_AP_W2, _AP_I2, _AP_S2, _AP_Q2, _AP_O2, _AP_N2>& op)
      : Base(op) {}




  inline ap_ufixed(bool v) : Base(v) {}
  inline ap_ufixed(char v) : Base(v) {}
  inline ap_ufixed(signed char v) : Base(v) {}
  inline ap_ufixed(unsigned char v) : Base(v) {}
  inline ap_ufixed(short v) : Base(v) {}
  inline ap_ufixed(unsigned short v) : Base(v) {}
  inline ap_ufixed(int v) : Base(v) {}
  inline ap_ufixed(unsigned int v) : Base(v) {}
  inline ap_ufixed(long v) : Base(v) {}
  inline ap_ufixed(unsigned long v) : Base(v) {}
  inline ap_ufixed(ap_slong v) : Base(v) {}
  inline ap_ufixed(ap_ulong v) : Base(v) {}
  inline ap_ufixed(half v) : Base(v) {}
  inline ap_ufixed(float v) : Base(v) {}
  inline ap_ufixed(double v) : Base(v) {}


  inline ap_ufixed(const char* s) : Base(s) {}

  inline ap_ufixed(const char* s, signed char rd) : Base(s, rd) {}


  inline ap_ufixed& operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(
      const ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) volatile {
    Base::V = op.V;
  }

  inline ap_ufixed& operator=(
      const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N>& op) {
    Base::V = op.V;
    return *this;
  }

  inline void operator=(const volatile ap_ufixed<_AP_W, _AP_I, _AP_Q, _AP_O,
                                                 _AP_N>& op) volatile {
    Base::V = op.V;
  }
};
# 398 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h" 1
# 55 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h"
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdio" 3
# 56 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 1 3
# 39 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
       
# 40 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/cstdlib" 3
# 57 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h" 2




namespace std {
template<typename _Tp> class complex;
}







namespace std {
# 89 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
class complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > {
 public:
  typedef ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> _Tp;
  typedef _Tp value_type;




  complex() : _M_real(_Tp()), _M_imag(_Tp()) {}


  complex(const _Tp &__r, const _Tp &__i = _Tp(0))
      : _M_real(__r), _M_imag(__i) {}


  template <typename _Up>
  complex(const complex<_Up> &__z) : _M_real(__z.real()), _M_imag(__z.imag()) {}


  const _Tp& real() const { return _M_real; }
  const _Tp& imag() const { return _M_imag; }







  void real(_Tp __val) { _M_real = __val; }

  void imag(_Tp __val) { _M_imag = __val; }



  complex<_Tp> &operator=(const _Tp __t) {
    _M_real = __t;
    _M_imag = _Tp(0);
    return *this;
  }



  complex<_Tp> &operator+=(const _Tp &__t) {
    _M_real += __t;
    return *this;
  }



  complex<_Tp> &operator-=(const _Tp &__t) {
    _M_real -= __t;
    return *this;
  }



  complex<_Tp> &operator*=(const _Tp &__t) {
    _M_real *= __t;
    _M_imag *= __t;
    return *this;
  }



  complex<_Tp> &operator/=(const _Tp &__t) {
    _M_real /= __t;
    _M_imag /= __t;
    return *this;
  }


  template <typename _Up>
  complex<_Tp> &operator=(const complex<_Up> &__z) {
    _M_real = __z.real();
    _M_imag = __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator+=(const complex<_Up> &__z) {
    _M_real += __z.real();
    _M_imag += __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator-=(const complex<_Up> &__z) {
    _M_real -= __z.real();
    _M_imag -= __z.imag();
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator*=(const complex<_Up> &__z) {
    const _Tp __r = _M_real * __z.real() - _M_imag * __z.imag();
    _M_imag = _M_real * __z.imag() + _M_imag * __z.real();
    _M_real = __r;
    return *this;
  }



  template <typename _Up>
  complex<_Tp> &operator/=(const complex<_Up> &__z) {
    complex<_Tp> cj (__z.real(), -__z.imag());
    complex<_Tp> a = (*this) * cj;
    complex<_Tp> b = cj * __z;
    _M_real = a.real() / b.real();
    _M_imag = a.imag() / b.real();
    return *this;
  }

 private:
  _Tp _M_real;
  _Tp _M_imag;

};
# 221 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed_special.h"
template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() == __y &&
         __x.imag() == 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator==(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x == __y.real() &&
         0 == __y.imag();
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__x,
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__y) {
  return __x.real() != __y ||
         __x.imag() != 0;
}


template <int _AP_W, int _AP_I, ap_q_mode _AP_Q, ap_o_mode _AP_O, int _AP_N>
inline bool operator!=(
    const ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> &__x,
    const complex<ap_fixed<_AP_W, _AP_I, _AP_Q, _AP_O, _AP_N> > &__y) {
  return __x != __y.real() ||
         0 != __y.imag();
}

}
# 399 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_fixed.h" 2
# 368 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/include/ap_int.h" 2
# 5 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h" 2
# 15 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn.h"
typedef std::complex<float> COMPLEXD;


struct axis_data {
 COMPLEXD data;
 ap_uint<1> last;
};

const COMPLEXD LS_gold[52] = {
 -0.5484816+0.3837994i,-0.3623023+1.075885i,-0.7660071+0.6852779i,
 0.0140981+0.6291122i,1.606364+0.8892474i,1.678347+0.05568536i,0.163479-1.465672i,
 0.329441-0.8346519i,-1.457966-1.253829i,-0.7650381+0.3915202i,-0.4770873+1.216696i,
 0.2704967+1.656089i,1.11718+1.513583i,1.672272+0.8698606i,1.692708+0.02713398i,
 0.1664147-1.464067i,-0.6496252-1.655365i,-0.3944012-0.4606687i,-0.7537365+0.3073461i,
 -1.556247+0.3100925i,0.1550612+1.652639i,0.01961903+0.7737306i,1.68035+0.9939642i,
 1.78702+0.103106i,1.291099-0.6523168i,0.4208774-0.9108285i,-0.8138225+0.2705191i,
 -1.606952+0.3237317i,-0.8732339+0.854722i,1.039143+1.616512i,1.681558+0.9887982i,
 0.7549856-0.7285228i,1.262935-0.6302111i,-0.5989876-1.687877i,-0.3743775-0.4899487i,
 -1.744228-0.5375728i,-1.516853+0.2750378i,-0.8335972+0.7399392i,
 -0.03111804+0.6592211i,0.5190284+0.09958155i,1.598747+0.1686445i,1.184511-0.4442197i,
 -0.5149598-1.484886i,-1.168673-1.230752i,-0.505945+0.1895986i,-1.430026+0.03442641i,
 0.06406594+1.334762i,-0.2785636+0.5794072i,1.305439+1.046659i,1.525923+0.4044627i,
 1.291645-0.2355201i,0.7046942-0.5829725i
};

const float mean_in[2*52] = {
  -0.002801,-0.001319,0.000619,0.002338,0.003245,0.002902,0.001239,-0.001215,-0.003457,
  -0.004229,-0.002923,0.000030,0.003187,0.004866,0.004111,0.001250,-0.002243,-0.004613,
  -0.004734,-0.002598,0.000759,0.003683,0.004866,0.003758,0.000928,-0.002286,-0.004461,
  -0.002506,0.000572,0.003393,0.004687,0.003859,0.001245,-0.002083,-0.004532,-0.004873,
  -0.002744,0.000873,0.004102,0.005162,0.003470,0.000007,-0.003223,-0.004458,-0.003278,
  -0.000723,0.001678,0.002778,0.002538,0.001517,0.000348,-0.000724,0.001517,0.002888,
  0.002972,0.002033,0.000369,-0.001730,-0.003455,-0.003560,-0.002210,0.000699,0.003464,
  0.004726,0.003657,0.000674,-0.002723,-0.004911,-0.004557,-0.001857,0.001611,0.004155,
  0.004937,0.003143,0.000153,-0.002969,-0.004637,-0.004105,0.001536,0.003884,0.004560,
  0.003285,0.000408,-0.002812,-0.004574,-0.004498,-0.001990,0.001373,0.004296,0.005060,
  0.003147,-0.000472,-0.003667,-0.004876,-0.003546,-0.000431,0.002596,0.003641,0.003018,
  0.001027,-0.000622,-0.001690,-0.002025,-0.001861
};

const float std_in[2*52] = {
  0.705987,0.712985,0.715984,0.710446,0.706627,0.711434,0.715377,0.712315,0.708409,0.711200,
  0.714397,0.712777,0.709545,0.710609,0.713690,0.712636,0.709293,0.711077,0.714375,0.712414,
  0.708085,0.710263,0.714894,0.713154,0.707299,0.708790,0.715342,0.707630,0.707000,0.714685,
  0.716715,0.709428,0.705274,0.711627,0.716612,0.711057,0.704658,0.707428,0.713964,0.713374,
  0.706441,0.704360,0.710523,0.714952,0.710675,0.703944,0.707337,0.715074,0.714238,0.705734,
  0.704286,0.712670,0.715589,0.708963,0.705941,0.712021,0.715820,0.711238,0.707965,0.710969,
  0.714914,0.712653,0.709524,0.711071,0.714132,0.712923,0.709764,0.711074,0.714153,0.712296,
  0.708854,0.710419,0.714810,0.712379,0.707746,0.709410,0.715224,0.713840,0.707810,0.715327,
  0.715931,0.708683,0.706276,0.713513,0.716744,0.710521,0.704557,0.709600,0.715218,0.711905,
  0.705018,0.705532,0.712106,0.713965,0.708675,0.704167,0.708745,0.715143,0.712871,0.704651,
  0.705812,0.714111,0.715435,0.707134
};

const float mean_o[2*52] = {
  -0.002808,-0.001326,0.000626,0.002345,0.003239,0.002896,0.001246,-0.001222,-0.003451,-0.004236,
  -0.002930,0.000023,0.003181,0.004859,0.004104,0.001257,-0.002237,-0.004620,-0.004741,-0.002591,
  0.000752,0.003690,0.004859,0.003752,0.000921,-0.002293,-0.004467,-0.002500,0.000579,0.003386,
  0.004681,0.003865,0.001238,-0.002077,-0.004539,-0.004866,-0.002738,0.000880,0.004109,0.005169,
  0.003463,0.000001,-0.003216,-0.004451,-0.003285,-0.000716,0.001671,0.002785,0.002531,0.001510,
  0.000341,-0.000731,0.001447,0.002818,0.003042,0.002103,0.000299,-0.001800,-0.003386,-0.003630,
  -0.002140,0.000629,0.003394,0.004656,0.003587,0.000604,-0.002793,-0.004841,-0.004487,-0.001927,
  0.001541,0.004225,0.004867,0.003213,0.000083,-0.003039,-0.004707,-0.004175,0.001466,0.003954,
  0.004630,0.003215,0.000339,-0.002742,-0.004644,-0.004428,-0.002060,0.001443,0.004366,0.005130,
  0.003217,-0.000402,-0.003737,-0.004946,-0.003476,-0.000361,0.002526,0.003711,0.002948,0.001097,
  -0.000692,-0.001760,-0.002095,-0.001931
};

const float std_o[2*52] = {
  0.705393,0.712541,0.715544,0.709867,0.706533,0.711260,0.715011,0.711802,0.708324,0.710597,0.713940,
  0.712523,0.709451,0.710540,0.713497,0.712330,0.709155,0.710466,0.713859,0.712066,0.707861,0.709730,
  0.714688,0.712869,0.706931,0.708359,0.714862,0.707370,0.706656,0.714426,0.716525,0.708920,0.704986,
  0.711323,0.716129,0.710855,0.704407,0.707100,0.713564,0.712918,0.706221,0.704131,0.710105,0.714646,
  0.710161,0.703809,0.706814,0.714737,0.714054,0.705657,0.704174,0.712392,0.715201,0.708467,0.705799,
  0.711840,0.715439,0.710991,0.707433,0.710839,0.714450,0.712305,0.709040,0.710519,0.713607,0.712504,
  0.709485,0.710558,0.713594,0.712131,0.708558,0.710194,0.714244,0.712286,0.707261,0.709102,0.715087,
  0.713781,0.707534,0.715123,0.715865,0.708058,0.705772,0.713134,0.716639,0.709866,0.704464,0.709208,
  0.715051,0.711879,0.704976,0.705325,0.711860,0.713892,0.708034,0.703633,0.708405,0.714984,0.712271,
  0.704536,0.705378,0.713845,0.715294,0.707028
};


const float L1_BIAS[52] = {
  -0.257672,0.010955,-0.427076,-0.674760,-0.003050,-0.354949,-0.017629,0.044782,-0.011473,-0.010642,0.064564,
  0.813054,0.017445,0.548345,0.006756,-0.053699,-0.026147,-0.482557,-0.117330,-0.258870,-0.320991,-0.429637,
  -0.045513,-0.010844,-0.220136,-0.071144,0.113705,-0.008028,-0.297397,0.305242,-0.006648,-0.020427,-0.002411,
  -0.319708,-0.032194,0.456231,-0.209027,-0.064414,0.007566,0.026169,-0.254766,0.005862,0.010840,0.055728,
  -0.173064,0.031788,-0.667923,-0.426306,-0.031856,0.035470,0.011146,-0.023091
};


const float L1_WEIGHTS[2*52][52] = {
  {0.015622,-0.118225,-0.216345,0.087524,0.103408,-0.257011,-0.146548,0.069903,0.013814,0.014035,-0.040006,-0.253056,-0.069315,0.095431,-0.173083,-0.085477,0.036833,0.122120,-0.066324,-0.075206,0.009255,0.146178,-0.019650,0.142067,0.027454,0.031346,-0.240769,0.053807,0.121753,0.119201,0.234918,0.121578,0.019032,-0.131507,-0.052606,0.158118,-0.033236,-0.043719,-0.114136,-0.149605,0.039071,-0.056052,-0.061718,0.051228,0.134713,0.100022,-0.142806,-0.048505,-0.084823,0.101552,-0.037126,0.088339},
  {0.068933,0.049082,0.014130,-0.104489,0.149704,-0.203339,0.000991,-0.041159,0.138566,-0.045635,0.004831,-0.138682,-0.075059,-0.146256,-0.186896,0.094229,0.029530,0.103387,-0.052581,0.050165,0.000204,0.044107,-0.034954,-0.014555,0.061277,0.039234,-0.134573,0.343200,0.021754,0.210124,0.171168,0.050602,-0.112127,-0.040845,0.061296,0.208924,-0.037357,0.057496,-0.324747,-0.142393,0.019304,-0.123123,0.121722,-0.076426,-0.038517,-0.043050,0.080577,0.001887,-0.052695,-0.027471,-0.133667,0.050442},
  {-0.063232,0.220224,-0.061702,-0.061969,0.170974,-0.084334,-0.054960,-0.027829,0.057996,-0.121633,-0.017514,0.100749,-0.002106,-0.170390,-0.068084,0.154756,-0.039303,-0.010836,-0.013424,0.036155,0.071102,-0.044232,-0.060333,-0.274354,0.102124,-0.022435,-0.095171,0.337535,-0.023876,0.070127,0.112893,-0.047013,-0.080483,0.005953,0.074314,0.208693,0.076531,0.035823,-0.252244,-0.047891,0.029053,-0.071653,0.066584,-0.222654,-0.043711,-0.048172,0.025576,-0.054204,0.069003,0.003827,-0.121782,-0.020287},
  {-0.067195,0.264770,0.189614,-0.008580,0.067499,0.179398,0.019867,0.028153,-0.037938,-0.066515,-0.051662,0.206105,0.051910,-0.051614,0.174785,0.117380,0.003535,-0.186228,-0.131000,-0.009287,0.155724,-0.118117,-0.043559,-0.149127,0.056121,0.059677,-0.057660,-0.008902,-0.000141,-0.112798,-0.111148,-0.093986,-0.069616,-0.024268,-0.053585,0.047196,-0.067064,0.030706,-0.070649,0.080026,-0.033065,-0.034033,0.081920,-0.095387,-0.057155,-0.130735,0.010160,0.030535,0.093611,-0.081724,0.062626,-0.147628},
  {-0.017641,0.119528,0.185541,-0.027527,-0.067631,0.307471,0.073878,-0.051336,-0.085635,0.002515,-0.054074,0.135036,0.111856,0.012508,0.131217,-0.068593,0.024646,-0.208749,-0.002450,0.088142,-0.025096,-0.162535,0.040261,-0.078015,0.009781,0.034215,0.157457,-0.069473,-0.090575,-0.228039,-0.206192,-0.079407,0.050017,0.025342,0.065348,0.127628,0.033307,0.157270,0.090141,0.027609,-0.084123,0.028480,0.042072,0.029588,-0.083751,-0.119781,0.002430,0.005820,0.073435,0.033790,0.164418,-0.150674},
  {0.023072,-0.099243,0.107788,0.020227,-0.131072,0.157464,0.045236,-0.037111,-0.024645,-0.057138,-0.005621,0.005843,0.058218,0.067632,0.204177,-0.162279,-0.028611,0.006443,0.025615,0.103397,-0.024617,-0.039867,-0.088149,0.034373,0.077338,-0.048545,0.024645,-0.285845,-0.029318,-0.093952,-0.119276,-0.051089,0.090081,0.030705,-0.053479,0.150115,0.034776,0.014124,0.232309,0.073757,0.057889,0.125718,-0.005451,0.164066,-0.060676,-0.029481,-0.171175,0.014188,0.061361,-0.004066,0.074037,0.009859},
  {0.026185,-0.093725,-0.069887,-0.014148,-0.055059,-0.122374,0.043454,0.116798,-0.090751,-0.062598,0.121578,-0.200046,0.022436,-0.061392,0.045047,-0.144887,-0.046366,0.137152,-0.028733,-0.057915,-0.052656,0.016210,-0.139767,0.116750,-0.020381,-0.051013,0.142164,-0.225841,-0.056440,0.088153,-0.036988,-0.020279,0.047336,0.017207,-0.038196,0.030076,0.009303,-0.040684,0.131466,0.049350,-0.028478,0.102349,-0.000230,0.127192,-0.024335,0.132052,-0.047651,0.062897,-0.059029,-0.012416,0.012864,-0.099981},
  {-0.069237,-0.145747,-0.069349,-0.045217,-0.018199,-0.114719,0.032353,0.035228,0.178806,-0.046915,0.132005,0.056062,-0.087667,-0.066531,-0.068570,-0.200625,0.079554,-0.006248,0.020323,-0.056713,0.025542,-0.007956,0.005225,0.138509,0.003852,0.004438,0.117874,0.029137,-0.100754,0.092068,0.110024,-0.013775,-0.021846,0.017325,0.022000,-0.049474,0.061939,-0.127015,-0.089806,-0.115346,0.047494,0.021756,0.009001,0.129564,-0.053411,0.000182,0.108096,-0.079593,-0.040472,-0.072478,-0.188556,0.068386},
  {-0.062788,-0.098968,-0.058809,-0.084488,0.000503,-0.025224,0.054327,-0.011221,0.167813,0.032939,0.109755,0.006059,-0.049366,0.016349,-0.142193,0.048047,0.022607,0.064779,-0.013412,0.009601,-0.042814,-0.058443,0.025280,0.081985,-0.057418,-0.046334,0.153383,0.183967,0.110505,0.095432,0.132424,0.072868,-0.013207,-0.033029,0.030436,-0.163278,0.022585,-0.043591,-0.110181,-0.000610,0.010054,-0.049393,-0.063430,0.095015,-0.035394,0.111115,0.155397,-0.044511,-0.047559,-0.078505,-0.096020,0.057770},
  {0.057234,0.018191,0.040705,-0.069942,-0.013669,0.163661,0.044020,-0.135205,-0.039900,0.062477,-0.054840,0.085202,-0.080807,0.191926,-0.095196,0.049748,0.076011,-0.016837,0.012645,0.038725,-0.003445,-0.037394,0.181778,-0.034731,-0.048502,0.018003,-0.026464,0.046107,0.135502,-0.174062,0.197471,0.070329,-0.066343,-0.107982,0.053080,-0.193722,-0.072537,0.104082,-0.142834,-0.047634,0.050472,-0.000085,-0.086595,-0.000322,0.023627,0.056506,0.094891,0.002632,-0.073829,-0.050919,0.010025,0.063490},
  {0.084643,0.130021,-0.067491,0.067198,-0.025322,0.099802,-0.077349,-0.116228,-0.137136,0.020112,-0.118401,0.064741,-0.024225,0.208512,-0.010914,0.158195,0.023819,0.068543,0.046114,0.037695,0.065133,0.047660,0.062560,-0.134349,-0.019488,-0.083474,-0.073518,-0.033220,0.171617,-0.099302,0.114401,0.043590,0.090203,0.021960,-0.141826,-0.131296,0.052435,0.157752,-0.023634,-0.093717,0.033755,-0.029898,-0.086983,-0.120561,0.011455,-0.047746,-0.072004,0.048590,0.041632,0.099331,0.148340,0.090668},
  {0.074834,0.111948,-0.043579,0.166311,-0.021790,-0.034685,-0.136184,0.054531,-0.229874,-0.083254,-0.148804,-0.128427,-0.030202,0.073163,0.039108,0.075216,-0.050744,0.075952,0.034613,0.020623,-0.085571,0.017527,0.034227,-0.102732,-0.076850,0.053302,-0.220704,-0.176566,0.031940,0.132402,-0.093944,0.054039,0.020483,-0.059102,-0.128698,-0.049991,0.052619,0.191261,0.051125,-0.009530,0.046908,-0.021191,-0.023997,-0.115425,0.048084,0.019265,-0.110134,0.052055,0.037591,0.087874,0.136483,-0.008194},
  {-0.026595,-0.039086,-0.132424,0.133386,0.031892,-0.220855,0.030051,0.166396,-0.031796,-0.078691,-0.133185,-0.109764,-0.000969,-0.042319,0.101824,-0.019217,0.004864,0.109260,0.016635,-0.003233,0.071497,0.029650,-0.088683,-0.053990,0.075693,-0.086475,-0.120498,-0.036663,0.010716,0.150519,-0.032926,-0.031560,-0.067866,-0.053551,0.038708,0.125858,-0.095860,0.007673,0.124599,0.043707,-0.016110,-0.061128,0.039854,0.003374,0.021697,-0.097985,-0.010996,-0.018159,-0.002839,-0.014521,0.030946,-0.057970},
  {-0.054465,-0.117720,0.009496,-0.087317,0.171352,-0.153526,0.004903,0.140583,0.158045,-0.098000,0.049102,0.027651,0.115773,-0.055123,0.106122,-0.065710,0.018327,0.098193,-0.080665,0.060458,0.080473,-0.008554,-0.176037,0.123709,-0.027764,-0.027421,-0.156115,-0.086139,0.017291,0.086581,0.031966,-0.017904,-0.149000,0.003984,0.047737,0.061176,0.008638,0.013756,-0.014720,0.080083,-0.006218,-0.073771,0.128098,0.049016,-0.078575,-0.097103,0.118923,-0.059289,0.050097,-0.062025,-0.134390,-0.124127},
  {-0.050983,-0.060772,0.076755,-0.112141,0.117460,0.119189,0.019781,0.014586,0.159350,-0.126525,0.165602,0.159255,0.059422,-0.069190,0.027463,-0.063627,0.028601,-0.042052,-0.068445,0.093456,0.117398,-0.159254,0.037858,0.114891,0.108890,0.030402,-0.016730,0.043844,0.077056,-0.143967,0.048935,-0.033463,-0.009360,-0.035495,0.077968,0.047456,0.000039,-0.125916,-0.110174,0.164728,-0.104501,-0.126264,0.061042,0.145233,0.019433,-0.072753,0.149351,-0.080964,0.056501,-0.200452,-0.185614,-0.002488},
  {0.049193,-0.129331,0.105472,-0.072168,-0.004687,0.227968,0.135845,-0.115562,-0.025815,-0.004629,0.191204,0.091829,-0.041118,0.121755,-0.056825,-0.052776,-0.047068,-0.034911,0.018723,0.020204,0.004802,-0.000435,0.103753,0.037582,0.095206,0.044126,0.049272,0.165689,0.009459,-0.186598,-0.009439,-0.110095,-0.002322,-0.062991,0.135559,0.099230,0.052621,-0.094173,-0.232564,0.025895,-0.053310,0.058925,-0.022581,0.037871,-0.003092,0.010033,0.023542,-0.064872,-0.039925,0.021405,0.013791,-0.061801},
  {0.023144,0.015595,0.117202,0.040523,-0.169648,0.173044,-0.056144,-0.159466,-0.074504,0.135556,0.079614,-0.043758,-0.057180,0.035043,0.034685,-0.010334,-0.020205,-0.070955,0.035858,0.012068,-0.038120,-0.052744,0.146698,0.009727,0.041217,-0.023952,0.102476,0.188602,-0.009283,-0.233263,0.099456,0.020091,0.060223,-0.045440,-0.055906,0.011093,0.058939,-0.150288,-0.180550,0.065300,-0.045087,0.126975,-0.094620,-0.081603,-0.033550,-0.040563,-0.056349,-0.022784,-0.000398,-0.014574,0.088362,-0.022716},
  {-0.047651,0.208010,0.065595,0.075456,-0.116269,0.130159,-0.018864,-0.073205,-0.198776,0.131028,0.114453,-0.043428,-0.130109,-0.017351,0.023612,0.046458,-0.026792,-0.110927,0.028918,-0.080956,-0.043472,-0.079036,-0.017334,-0.192672,0.018268,-0.057317,0.095087,0.098944,-0.152625,-0.135490,-0.078262,0.150950,0.129053,0.090999,-0.064115,0.038803,0.004633,-0.084725,-0.048561,-0.123091,0.011951,0.190988,-0.208185,-0.005791,0.012915,0.128911,-0.064014,0.014449,-0.081618,0.041329,0.152401,0.143550},
  {-0.056048,0.111174,-0.048471,-0.042260,-0.041799,-0.149156,0.049801,0.078861,-0.007241,0.067300,-0.121593,-0.024029,-0.168484,-0.163993,0.025645,0.048928,-0.106132,-0.032775,-0.052023,-0.046999,0.003963,0.042235,-0.042130,-0.066722,0.053273,-0.023481,0.202533,-0.074503,-0.064543,0.073586,-0.022645,0.026567,-0.053130,0.063534,0.010457,-0.076682,0.064065,0.075843,0.091363,-0.120962,-0.036803,0.021540,-0.013950,-0.019462,-0.020334,0.010810,-0.080431,-0.013419,-0.075130,0.095884,0.065416,0.138221},
  {0.013102,-0.002300,-0.054444,-0.033738,0.116597,-0.194610,0.093579,0.204906,0.051216,-0.056863,-0.179647,0.073298,-0.023705,-0.103497,0.011886,0.008351,0.008210,0.077689,0.002591,-0.079468,-0.014004,0.080103,-0.117972,-0.099761,0.001710,-0.001050,0.121102,-0.117376,-0.002456,0.145643,0.065481,0.035410,-0.036388,0.072543,0.008023,-0.076693,0.004885,0.244731,0.110548,0.009212,-0.007392,-0.077201,0.029927,-0.021101,0.039488,-0.050919,0.015263,-0.054691,0.076902,-0.031466,-0.080882,-0.045569},
  {-0.018822,-0.131982,-0.044797,-0.084074,0.078253,-0.048670,0.006079,-0.010277,0.244855,-0.205839,-0.117050,0.150605,-0.067531,0.173893,-0.043200,-0.012118,0.041019,0.014050,0.073829,-0.001068,0.009251,-0.024642,-0.094086,0.168818,-0.060417,-0.023191,0.060836,-0.130021,-0.037949,0.041634,-0.013112,-0.000840,0.011199,-0.103939,0.140725,-0.245798,-0.003498,0.123542,0.206105,-0.052962,0.050367,-0.136333,0.093671,-0.024448,0.044654,-0.086124,0.034748,-0.108618,0.075831,-0.170538,-0.235756,0.018481},
  {-0.037518,-0.283925,-0.042688,0.053906,-0.030574,0.090165,-0.049080,-0.139231,0.116764,-0.093809,-0.089655,-0.001473,0.056345,0.095192,-0.021023,0.031096,0.060300,0.075980,-0.000991,0.034204,-0.069429,0.034304,0.121997,0.236370,0.005358,-0.036296,-0.045890,0.000090,0.080570,-0.105381,0.027272,-0.030817,-0.007995,-0.094304,0.065253,-0.174387,-0.075573,0.080312,-0.045642,0.025561,0.097166,0.005061,0.046920,-0.032569,0.113035,-0.060465,-0.022811,-0.021627,0.131089,-0.038905,-0.064131,-0.059212},
  {-0.033094,-0.179709,-0.033263,0.148263,-0.066918,0.092588,-0.076892,-0.152410,-0.052909,-0.089137,-0.070353,0.005884,0.016879,0.147617,0.113222,0.020296,0.054941,0.051388,-0.066893,-0.035846,-0.051946,0.096106,0.157633,0.228302,-0.052120,0.083448,-0.179333,0.151470,0.094373,-0.172079,-0.061057,0.044046,0.095342,0.012284,-0.081694,0.027053,0.026322,-0.037153,-0.169131,0.070589,0.068328,0.108052,0.068821,-0.134764,0.053542,-0.005344,-0.151337,-0.011548,-0.032020,-0.010448,-0.016085,-0.021993},
  {0.011658,0.004345,0.019064,0.149964,-0.139358,-0.041206,-0.065016,-0.156581,-0.180323,-0.007866,0.181686,-0.010897,0.105730,0.042478,0.068649,0.034813,-0.151976,-0.010314,-0.008686,0.004976,-0.031341,0.015115,0.119803,-0.019845,0.076724,-0.023448,-0.180812,0.207543,-0.001267,0.051276,-0.049766,-0.002312,0.031214,0.023144,-0.133343,-0.002520,-0.019793,-0.074851,-0.191522,-0.026044,-0.004458,0.119639,0.033725,-0.017506,0.042467,0.083834,-0.187368,0.011599,0.027250,0.233313,0.177136,-0.055748},
  {0.041971,0.139151,0.060001,0.027472,-0.001187,-0.117580,-0.106854,-0.024574,-0.091030,0.136047,0.132358,-0.010215,0.061988,-0.120693,-0.016361,-0.048035,0.049685,-0.033860,-0.045155,0.027594,0.067699,-0.008742,-0.036487,-0.271752,0.009355,-0.061626,-0.113321,0.186572,0.078689,0.078821,-0.007637,-0.040192,-0.041251,-0.020790,-0.105823,0.050043,0.056011,-0.112238,-0.040920,-0.002241,0.026281,0.010700,-0.092898,0.065471,0.048918,0.084900,0.018720,-0.009927,-0.149827,0.093449,0.142249,-0.050514},
  {0.087481,0.254226,0.115207,-0.059910,0.053496,-0.008708,0.060642,0.122120,0.033089,0.033917,0.047987,0.117833,0.009621,-0.159247,-0.006659,-0.165273,0.007651,-0.152674,-0.028734,0.067079,0.116338,-0.079408,-0.038654,-0.227141,-0.005269,-0.013282,0.021552,-0.174095,0.004086,-0.019821,-0.002720,-0.046173,-0.069821,0.028836,0.070434,0.102893,0.031611,-0.067377,0.141592,-0.029367,-0.087633,-0.128102,-0.032567,0.096762,-0.096164,-0.002374,0.023399,-0.087525,-0.124393,-0.160378,-0.060672,0.053402},
  {0.074645,-0.183522,0.119651,-0.060186,0.010136,0.289406,0.064130,0.012781,0.108682,0.074420,-0.128024,0.102647,-0.014486,0.118872,-0.036375,0.045469,-0.008905,-0.083881,-0.074565,0.054373,-0.018398,-0.092932,0.018935,0.116381,0.061042,-0.010589,0.093909,-0.171285,-0.050538,-0.303396,0.040772,0.001362,-0.052943,-0.033629,0.188071,0.062703,-0.022264,0.094131,0.175007,-0.076866,-0.083565,-0.027073,0.023182,-0.000228,-0.083620,-0.007444,0.015377,-0.149223,0.001231,-0.123356,-0.131178,0.095116},
  {0.062314,-0.179196,0.021480,0.004415,-0.057727,0.047328,0.058197,0.011628,-0.079525,-0.050962,-0.095895,-0.195690,-0.072413,0.123344,0.062071,0.155230,-0.085673,0.021113,0.030741,-0.069198,-0.116348,-0.106248,0.036417,0.194557,0.055577,-0.011802,0.157088,-0.032440,-0.054816,-0.066756,-0.097098,-0.039106,0.042490,0.058393,0.127146,-0.014802,0.017043,0.174774,-0.022682,-0.101215,-0.039450,0.047046,-0.030076,-0.222022,-0.020233,-0.077875,-0.073433,-0.000213,-0.004849,-0.040316,-0.061101,0.057891},
  {-0.061344,-0.091575,-0.054405,0.084297,-0.044202,-0.090024,-0.080995,-0.097720,-0.093319,-0.058938,-0.085652,-0.147357,-0.083240,-0.031853,0.092306,0.091500,-0.056265,0.066651,0.009677,-0.046825,-0.094960,0.047857,-0.058647,0.151381,-0.020045,-0.052550,0.120297,0.193991,-0.088916,0.038060,-0.104199,0.037527,0.065241,0.094828,-0.118694,-0.112928,0.094337,-0.007183,-0.135141,-0.137979,0.026493,0.033671,0.062462,-0.170746,-0.046845,-0.008221,-0.048435,-0.039241,0.010443,0.023554,0.122436,0.076287},
  {0.017000,0.091208,-0.006902,-0.000067,0.029113,-0.102526,0.043552,-0.013265,-0.190599,-0.107636,-0.012514,0.024524,-0.042616,-0.083767,0.078167,-0.083491,0.030985,0.072669,0.022592,-0.047130,-0.050908,0.024312,-0.007746,0.058467,0.009562,0.049614,0.158194,0.140054,-0.078591,0.086033,-0.119797,-0.052888,0.045661,-0.018834,-0.058137,-0.227309,-0.041104,-0.020035,-0.208893,-0.016886,0.069284,-0.002227,0.117524,0.074089,-0.045821,0.020679,-0.012644,0.056032,-0.005872,0.087859,0.129351,0.039587},
  {-0.118860,0.135301,-0.072131,-0.140872,0.059278,-0.158427,-0.052661,0.048442,-0.154186,-0.115232,0.006019,0.064394,0.048845,-0.000861,-0.037333,-0.192849,0.000188,0.016616,-0.004026,-0.048813,0.016414,0.038211,-0.015803,-0.161948,-0.053281,0.001010,-0.009706,-0.035059,0.112462,0.184764,0.087003,-0.058464,-0.064340,-0.074462,-0.090001,-0.121231,-0.071173,0.035527,-0.061434,0.075365,-0.040836,-0.053580,0.038266,0.153144,-0.063531,-0.108368,0.066505,0.082767,0.002281,0.081553,0.078856,-0.079805},
  {0.002571,0.221929,-0.025132,-0.039363,0.003899,-0.078620,-0.003795,0.062784,0.106464,0.058393,-0.147384,0.063842,0.162759,-0.014954,-0.329375,-0.139257,0.155365,0.010643,0.074811,-0.009551,-0.026065,-0.016423,-0.099446,-0.066529,-0.023734,0.022501,-0.195053,-0.105354,0.056527,0.064799,0.304082,-0.085884,0.056668,-0.079048,-0.077563,-0.114320,-0.025568,0.077369,0.009448,0.059705,-0.023922,0.001388,-0.021325,0.150616,0.088924,-0.001325,0.007217,-0.015058,-0.017324,0.041606,-0.048573,-0.109862},
  {0.035037,0.033761,-0.021339,0.020446,0.026262,0.097826,-0.078366,-0.039037,0.175896,0.151901,-0.094030,0.054224,0.082539,0.233868,-0.209294,0.010045,0.064098,-0.021971,-0.009391,0.095621,0.001932,-0.039068,-0.028204,-0.010215,0.010323,0.081421,-0.229339,-0.047013,0.022031,-0.095640,0.144007,-0.103777,0.084826,-0.113839,0.073865,-0.055770,-0.035342,0.136411,0.023819,0.044727,0.054278,0.099233,-0.044130,-0.005982,0.064470,0.023595,0.000364,0.030840,-0.010186,0.011566,-0.189347,-0.142264},
  {-0.020249,-0.072543,-0.033131,0.064197,-0.084831,-0.065443,-0.035860,0.039770,0.101598,0.161302,0.018987,0.010671,0.099967,0.126788,0.044137,0.220315,0.006371,-0.032636,0.008790,0.016654,0.060481,0.053406,-0.036937,0.115813,-0.017221,-0.010463,-0.255573,0.022580,-0.037821,0.002587,0.038467,-0.037663,0.109299,-0.045535,0.015992,0.210185,-0.000965,0.072731,0.014240,0.136165,0.094752,0.033126,-0.171197,-0.226300,-0.011260,0.015425,-0.105220,-0.049236,0.003841,-0.038590,-0.085612,-0.144939},
  {-0.053040,-0.237875,0.062233,0.100295,-0.044640,-0.041033,0.101671,0.098667,0.004122,-0.003862,0.123736,0.002514,0.053292,-0.083646,0.046070,0.178796,-0.006988,-0.004441,-0.047287,0.042840,0.063131,-0.014940,-0.046908,0.179333,0.125588,-0.001075,-0.111417,-0.007469,-0.032014,0.078159,-0.177673,0.112386,0.004683,0.038946,0.049321,0.161580,-0.022157,-0.093214,-0.112212,-0.077403,-0.020026,0.063241,-0.050811,-0.217001,0.036519,-0.009797,-0.095613,0.103945,-0.103651,-0.086747,-0.048008,0.070828},
  {-0.020963,-0.046033,-0.040305,0.010149,0.117453,-0.180983,0.097790,0.103206,-0.130050,-0.033405,0.152824,0.032294,-0.002071,-0.055565,0.150220,0.075718,-0.025282,-0.026480,-0.098590,-0.057020,0.082919,-0.009944,-0.010936,0.122096,-0.044596,0.025682,-0.103389,-0.058895,-0.010261,0.112950,-0.225813,0.108930,-0.069547,0.051128,0.047003,0.120488,-0.046410,-0.191783,-0.047121,-0.094573,-0.050385,-0.072823,-0.020855,-0.066801,0.018065,0.011993,-0.040534,-0.013461,-0.054619,-0.050988,0.139377,0.086984},
  {-0.050240,0.036223,0.122188,-0.078565,0.195418,0.038012,0.066923,0.042072,-0.224733,-0.122697,0.058534,0.007113,-0.077992,-0.033748,0.160571,-0.116824,-0.008654,-0.011877,-0.061350,0.016911,0.083788,-0.096794,-0.075853,-0.094751,0.017501,0.003438,-0.025673,-0.069895,0.037980,-0.044392,-0.066377,0.013317,-0.085242,-0.087536,0.066340,0.055267,0.071489,-0.146054,-0.012102,-0.123285,-0.037515,-0.083348,0.125941,0.109309,-0.049719,-0.047896,-0.019474,-0.032458,-0.021079,-0.063125,0.183622,0.087136},
  {-0.068937,0.054085,0.020882,-0.037849,0.119836,0.190161,0.015703,-0.028753,-0.117405,-0.076368,-0.011499,0.022614,0.005398,0.116568,-0.085869,-0.253518,0.087735,-0.110157,0.008764,0.002890,0.095152,-0.118174,0.032998,-0.147852,0.145208,0.052404,0.078046,-0.024620,0.047935,-0.220967,0.064696,0.025667,-0.000385,-0.018022,-0.041106,0.042490,0.035192,0.100045,0.042267,-0.015278,-0.109903,-0.000465,0.121299,0.273126,-0.075146,0.015419,0.055038,0.029248,0.046047,-0.003253,0.110416,0.030606},
  {-0.034439,0.180154,0.011643,-0.021615,-0.099631,0.045236,0.017248,-0.026127,0.067896,-0.032159,-0.078926,-0.105047,0.034681,0.060924,-0.140177,-0.138358,-0.049567,-0.023875,-0.032691,-0.066309,-0.101646,-0.068509,0.124895,-0.134884,0.022870,-0.057352,0.118830,-0.021578,-0.066478,-0.082355,0.099316,-0.018679,0.006017,0.075577,-0.099956,0.091864,-0.005228,0.183190,-0.021466,0.142152,-0.021125,-0.009898,-0.034335,0.178990,-0.011847,-0.091599,-0.023150,-0.038073,-0.064471,0.103072,-0.112856,-0.015963},
  {0.100901,-0.013612,-0.086915,0.090615,-0.161597,-0.018237,-0.065613,-0.015482,0.095149,0.122794,-0.213420,-0.129996,0.092180,-0.038354,-0.072663,-0.002463,-0.082301,0.035226,0.004176,-0.156827,-0.092973,0.076780,0.085792,0.000140,-0.048648,0.016256,0.185798,0.047964,-0.097506,0.009905,0.016242,-0.035269,0.008334,0.176679,-0.158605,0.075438,-0.009042,0.167072,-0.072230,0.047228,0.029846,0.086834,-0.170210,-0.037964,0.071018,-0.016553,-0.107667,0.006912,0.060195,0.120616,-0.159096,-0.024504},
  {0.001023,-0.146305,-0.121417,-0.005923,-0.055650,-0.138288,-0.018218,0.054302,0.079168,0.173536,-0.067000,0.018961,0.064872,-0.108019,0.145351,0.090955,-0.124227,0.086787,0.081206,-0.072974,-0.025921,-0.017493,-0.041400,0.098140,-0.015205,-0.045493,0.214553,0.031827,-0.097894,0.152797,-0.192878,0.000872,0.044132,0.164633,-0.100919,-0.123805,0.075265,0.116313,-0.064199,0.086612,0.040665,0.108791,-0.154601,-0.117645,-0.026332,0.011537,-0.019555,0.009536,0.041203,0.131488,-0.130388,-0.071136},
  {-0.032313,0.012378,-0.108679,-0.110513,-0.018655,-0.175396,-0.034593,0.148217,0.087123,0.128884,0.006318,0.015692,0.001302,-0.114546,0.097152,0.143515,0.057578,0.083369,0.090438,-0.005938,-0.030453,0.067224,-0.105667,0.083931,-0.075247,-0.005192,0.076902,0.104383,0.056731,0.151296,-0.163217,-0.042621,0.017117,0.005924,0.077695,-0.158905,-0.042199,-0.113090,-0.064925,0.064069,0.030725,-0.061460,-0.102960,-0.134558,0.042909,0.056233,0.080340,0.018760,0.026549,-0.081243,0.058613,-0.063011},
  {0.042743,-0.074881,-0.047146,-0.025295,0.095493,-0.151276,-0.013405,0.069384,-0.171085,0.139976,0.082448,0.059534,0.028891,-0.015216,0.018109,0.048970,0.112385,0.083350,0.063546,0.072001,-0.010634,-0.020615,-0.101297,-0.035448,0.025874,-0.062908,-0.057180,-0.115678,0.067286,0.186111,-0.027064,-0.021058,-0.082715,-0.093132,0.081019,-0.165418,-0.114141,-0.146232,0.022533,-0.010422,0.013083,-0.125194,-0.104003,-0.088297,0.053679,0.025658,0.017044,0.087396,-0.027581,-0.007110,0.148632,0.022728},
  {0.028065,0.105067,0.033595,0.021127,0.088316,-0.039113,-0.043934,0.056970,-0.128366,-0.110081,0.113119,-0.049402,0.025140,0.108694,-0.120116,0.049189,0.056832,-0.070367,0.017363,0.004647,0.036819,0.024398,-0.007007,-0.067103,0.021525,-0.007877,-0.188824,0.003767,0.267199,-0.016379,0.099018,0.014197,-0.018219,-0.159695,0.162003,-0.087957,0.048129,-0.027565,0.073512,0.026076,0.068933,-0.104057,0.167790,0.023245,0.046695,0.001898,0.099267,0.063117,-0.062361,-0.123898,0.090916,0.006234},
  {0.060692,0.115741,0.017911,-0.034815,-0.152486,0.143482,0.022145,-0.143034,-0.040739,-0.119053,-0.040085,-0.013869,-0.017846,0.157721,-0.142227,0.029058,0.007702,-0.064986,-0.096485,0.053363,0.012604,0.001711,0.173898,-0.054613,0.064878,-0.013002,-0.119181,-0.046732,0.008060,-0.134110,0.216405,0.069896,0.190991,-0.022844,0.124920,0.045622,-0.029432,-0.024446,0.106296,0.016549,-0.002856,0.111765,0.210224,-0.015487,0.059055,0.088495,-0.028602,-0.060321,0.026897,-0.082900,0.029991,-0.103761},
  {-0.030101,0.110451,0.063226,0.076934,-0.257148,-0.056556,-0.101681,-0.124361,0.152347,-0.144124,-0.115839,0.028122,-0.043274,-0.062543,-0.103417,-0.048392,-0.061955,-0.021376,0.049811,0.002341,0.067275,-0.024271,0.019555,-0.061356,-0.047420,-0.014589,-0.144274,-0.009024,-0.083223,-0.019106,0.086375,0.031209,0.140154,0.110848,-0.040885,0.113406,0.027396,0.073693,0.035484,-0.077446,0.061772,0.172436,0.156457,-0.011448,0.001947,0.030854,-0.117590,0.014163,-0.046202,-0.003954,-0.042692,0.062607},
  {0.024245,-0.106420,0.152889,0.029129,-0.056796,-0.061612,-0.055249,-0.067379,0.128607,-0.045933,-0.028122,0.108789,-0.075717,-0.151834,0.082809,-0.123021,-0.055925,-0.099123,-0.019446,0.008562,0.003441,-0.110684,0.020077,0.084126,-0.004565,0.022724,0.015047,0.049354,-0.030119,-0.015642,-0.168476,0.076542,0.124668,0.055908,-0.087836,0.174954,0.026965,0.117391,-0.049312,-0.115823,-0.088572,0.066399,0.053411,0.123661,0.093407,0.057552,-0.041610,-0.030005,0.039514,0.123403,-0.046655,0.155511},
  {0.017381,-0.095781,0.002334,-0.007060,0.062285,0.011194,-0.097418,0.090493,0.070230,0.189750,-0.115853,0.035414,-0.145355,0.004613,0.220468,-0.138396,0.058313,-0.021515,-0.067494,0.032675,0.094021,-0.033693,-0.014624,0.074894,-0.008496,0.006794,-0.085181,0.019891,-0.017407,-0.072499,-0.189900,0.176883,0.042372,-0.033347,-0.085894,0.084963,-0.032579,0.056571,0.002406,-0.146736,-0.021084,-0.008668,-0.170154,0.051903,-0.014413,0.027721,-0.033657,-0.037569,-0.002832,0.167743,-0.031354,0.140061},
  {-0.008774,-0.105796,0.087201,-0.016017,0.178979,0.179338,0.108643,0.033094,-0.102458,0.262328,0.037366,-0.012715,-0.066925,0.121890,0.089880,-0.062752,0.005066,-0.173941,0.030638,0.062833,0.030493,-0.059207,-0.010783,0.089564,0.081565,-0.057919,0.086600,0.066509,0.070966,-0.188430,-0.037563,0.032686,-0.130176,-0.116748,-0.056981,0.038644,0.006398,0.037906,0.007523,-0.060544,-0.057013,-0.118149,-0.259258,0.146358,0.000266,-0.109558,0.078216,-0.017357,0.133843,0.002275,0.055260,0.081350},
  {-0.057680,-0.095650,0.074998,-0.059309,0.207550,0.249439,0.012089,-0.008708,-0.130020,0.072888,-0.036993,-0.306246,-0.035852,0.135136,-0.107261,-0.040745,0.095066,-0.059351,-0.041357,-0.080005,-0.024469,-0.084927,0.024753,-0.021953,-0.009649,-0.020651,0.034785,0.021247,0.133712,-0.151728,0.048680,-0.014339,-0.163273,-0.048144,-0.010449,0.047997,0.034108,-0.041875,-0.086617,0.033012,-0.131450,-0.221090,-0.194293,-0.043775,-0.083528,-0.143779,0.010214,-0.067908,0.174830,0.024569,0.136119,-0.062011},
  {-0.008792,0.101152,-0.044435,0.051618,-0.038086,0.049601,0.093283,-0.033697,-0.056924,-0.072297,-0.074980,-0.269437,0.069178,-0.014701,-0.218614,0.131363,-0.066695,0.054884,-0.028996,-0.132769,-0.038779,0.046631,0.029859,-0.024369,-0.015437,0.031477,0.213476,0.054676,-0.108997,-0.172045,0.223414,-0.083331,-0.068916,0.152143,0.023759,0.081361,0.038445,0.012212,-0.054925,0.079303,-0.021160,0.042058,0.043153,-0.179231,-0.078337,-0.062574,0.060539,0.054951,-0.007439,-0.170024,0.043300,-0.094959},
  {-0.104234,0.153018,-0.160707,-0.082544,-0.113333,-0.177943,0.087786,0.061639,0.063018,-0.226942,0.087381,-0.019673,0.110411,-0.234472,-0.150135,0.202864,-0.100646,0.113049,0.043869,-0.136565,-0.101951,0.091810,-0.032318,-0.165560,-0.025552,-0.025351,0.324897,0.088036,-0.210743,0.073167,0.149262,-0.179810,0.138724,0.144339,0.051686,-0.005838,0.001614,-0.056298,-0.012622,0.310200,0.038441,0.124466,0.286951,-0.233474,-0.046083,0.112226,0.008176,-0.067712,0.011428,-0.032569,-0.048179,-0.204433},
  {0.046751,0.157323,0.069310,-0.107460,0.150867,-0.070358,0.019438,-0.056227,0.215797,-0.059414,0.000603,-0.037657,0.114413,-0.225634,-0.033427,0.204966,0.003745,0.015489,-0.059546,0.057310,0.031688,-0.034812,0.032206,-0.137675,0.032028,-0.006055,0.056624,0.257437,-0.095710,0.052990,-0.010723,-0.076476,-0.154696,0.092551,0.047118,0.225218,0.047622,-0.036314,-0.381827,0.038685,0.011644,-0.037479,0.082221,-0.171050,-0.028309,0.027930,0.010405,-0.036678,0.067011,-0.027803,-0.127909,-0.004811},
  {-0.008720,0.205927,0.260311,-0.165018,0.053876,0.103643,0.141803,0.012955,-0.019943,-0.076319,-0.020212,0.223957,0.028069,-0.191096,0.134294,0.100131,-0.024424,-0.214768,-0.059603,-0.015838,-0.037993,-0.101123,0.027961,-0.208387,0.031071,-0.052569,0.111203,0.169747,-0.120803,-0.131084,-0.107390,-0.061406,-0.046574,-0.000947,0.112927,0.157222,0.048157,-0.045848,-0.156297,0.053549,-0.022738,-0.051456,0.117651,-0.080172,-0.067526,-0.131277,0.122100,-0.109634,0.047207,-0.123670,-0.078959,-0.078232},
  {-0.019788,0.175165,0.170677,0.004986,-0.030953,0.255298,0.007406,-0.086987,-0.090142,-0.068472,0.047601,0.213233,-0.015020,-0.024972,0.181447,-0.013871,0.062306,-0.201925,-0.047214,0.020269,-0.023621,-0.161834,0.037103,-0.116825,-0.001487,-0.020401,0.170477,-0.063097,0.024240,-0.290434,-0.230340,-0.007285,0.022196,0.028820,0.055646,-0.045965,0.095607,-0.077787,-0.003135,0.146342,-0.045891,0.075987,0.065776,-0.042660,-0.032318,-0.116226,0.079450,-0.064872,0.178979,-0.141143,0.051602,-0.069605},
  {0.036285,-0.050853,0.122839,0.044997,-0.172500,0.105930,0.002088,-0.012704,-0.114058,0.036628,0.084515,0.069319,0.006631,0.006725,0.192182,-0.104426,-0.078537,-0.088748,-0.008087,0.036819,0.010822,-0.025354,0.099400,0.055083,0.086705,0.040419,0.140552,-0.341726,-0.014228,-0.092483,-0.091646,-0.138372,0.037875,0.031692,-0.026902,0.002428,0.045141,-0.070908,0.274619,0.125513,0.003084,0.155114,-0.077905,0.166823,-0.082553,-0.057063,-0.007077,-0.076568,-0.017658,0.041319,0.115204,-0.054819},
  {-0.012104,-0.122183,-0.058231,0.117181,-0.091419,-0.046692,-0.041318,0.036101,-0.146914,0.122814,0.082706,-0.153270,-0.016191,0.142425,-0.016436,-0.155171,-0.043736,0.113677,0.019498,-0.089033,-0.068900,-0.013276,-0.079481,0.154641,-0.066160,-0.075699,0.099300,-0.247359,0.000477,0.089469,-0.034674,-0.049114,0.089844,-0.006806,-0.056606,0.027856,-0.036017,-0.096576,0.150682,0.007792,0.011896,0.093616,-0.019490,0.179504,-0.018330,0.053474,-0.056029,0.010319,0.006810,0.059214,0.172892,-0.014436},
  {0.014655,-0.132815,-0.105005,-0.027448,-0.011314,-0.151365,0.000257,0.022109,0.090688,0.068925,0.052575,-0.152412,-0.036768,-0.016006,-0.039367,-0.144179,-0.024491,0.217683,0.056795,-0.058651,0.002140,0.086089,-0.118787,0.184658,-0.081879,0.015479,0.042569,0.073676,0.019558,0.200483,0.009676,0.028476,0.002028,-0.013633,0.074511,-0.142101,-0.002905,0.006199,-0.016608,-0.085336,0.096291,-0.019640,-0.076661,0.122090,-0.028380,-0.011116,0.045028,0.031885,-0.103804,0.019877,-0.081403,0.115429},
  {-0.099915,-0.082985,-0.101839,-0.153070,0.044453,-0.109165,0.036092,0.038106,0.135562,-0.083344,0.092810,0.043203,-0.099524,-0.087468,-0.097678,-0.075281,0.068288,0.166139,0.080625,-0.032217,-0.069121,0.056854,-0.057738,0.072667,-0.068504,-0.074302,0.031125,0.086554,0.013718,0.195038,0.074190,0.082212,-0.122823,-0.049589,-0.019560,-0.134513,0.032614,-0.144034,-0.181928,-0.112593,0.041313,-0.165908,0.032701,0.082265,-0.004689,-0.034777,0.148143,0.025798,-0.020486,-0.063591,-0.153837,0.053968},
  {-0.069589,0.015996,-0.004601,-0.038894,-0.017950,0.100240,0.029037,-0.103723,0.028890,0.044632,0.015279,0.076075,-0.074881,0.077925,-0.108358,-0.025409,0.067270,0.018912,-0.039564,0.049827,-0.042191,-0.066768,0.134153,-0.039951,-0.043853,-0.015332,0.018497,0.069265,0.094627,-0.059387,0.147326,0.109884,-0.066881,-0.084761,0.039757,-0.114025,-0.092702,0.007061,-0.184299,-0.037809,0.048874,-0.097138,-0.051270,-0.053099,-0.071005,0.046309,0.001204,-0.027257,-0.060403,-0.083694,-0.026467,0.097218},
  {0.005515,0.199823,0.085416,-0.069610,0.077121,0.178494,-0.033454,-0.050332,-0.078657,0.004887,-0.059957,0.123626,-0.010186,0.127789,0.002352,0.068319,0.045165,-0.046840,0.045585,0.046508,-0.002876,-0.027706,0.019906,-0.183459,-0.019178,0.017056,-0.145484,0.023195,0.085670,-0.077016,-0.033027,0.034492,0.025877,-0.110462,0.054437,-0.071557,-0.073221,0.159240,-0.043676,-0.112848,0.005532,-0.073930,-0.061829,-0.093657,0.023025,-0.031692,0.033259,-0.023903,0.010224,0.082506,0.114754,0.094175},
  {0.049193,0.094534,0.000088,0.171854,-0.069649,0.010699,-0.171372,-0.078375,-0.213657,0.014707,-0.136942,-0.010167,0.087082,0.175528,-0.020898,0.179944,0.011503,0.054038,0.017792,0.024292,0.032017,0.078755,0.050777,-0.206784,-0.052369,-0.018673,-0.191762,-0.086892,0.047639,-0.010047,-0.049520,0.008679,0.047204,-0.003422,-0.184820,-0.027295,0.052297,0.184347,0.106771,0.016659,0.030649,0.014761,-0.067468,-0.166254,0.099622,0.010397,-0.096182,0.004431,-0.043539,0.201396,0.262928,-0.015199},
  {0.073227,-0.028392,0.030595,0.151473,-0.079229,-0.141695,-0.094110,0.015525,-0.161621,-0.089391,-0.154656,-0.220319,0.041719,-0.023081,0.047635,0.030521,-0.001516,-0.030015,-0.002909,-0.009127,-0.075582,0.030442,-0.120392,0.007371,-0.053994,0.068093,-0.075015,-0.158805,-0.067374,0.108966,-0.063197,-0.107075,-0.068183,-0.052709,-0.037562,0.194794,-0.003071,0.087210,0.096750,0.026483,0.065704,0.029592,0.103160,0.024842,0.113224,-0.094434,-0.118337,0.080862,-0.048353,0.091240,0.117674,-0.084297},
  {-0.005416,0.015388,-0.044271,0.023369,0.004530,-0.167304,0.050086,0.071038,0.041105,-0.145227,-0.027402,-0.063006,0.127789,-0.097306,0.071334,-0.048300,0.072174,0.045552,-0.083772,-0.024485,0.046384,-0.050659,-0.162800,0.013983,0.126942,0.043049,-0.085200,-0.002066,0.002952,0.173776,-0.085528,-0.031652,-0.085344,0.014719,0.090436,0.149894,-0.006941,0.018967,0.080335,0.006203,-0.032779,-0.074703,0.038193,0.118110,-0.087612,-0.014802,-0.080770,-0.014257,0.031975,0.011846,-0.046655,-0.114259},
  {0.084813,-0.041284,0.091609,-0.104153,0.109844,-0.059468,-0.001247,0.021365,0.149614,-0.074471,0.134007,0.001568,0.064412,-0.125933,0.014628,-0.128732,0.069951,-0.159901,-0.043950,0.008535,-0.007331,-0.023879,-0.000160,0.055021,0.013277,0.020538,-0.025533,0.080324,0.035663,-0.012244,-0.029964,0.037722,-0.033075,0.077911,0.103469,0.115979,0.108027,-0.102618,-0.099376,0.045440,-0.066082,-0.042747,0.121787,0.138950,-0.076454,-0.099783,0.122147,-0.073543,0.127635,-0.103835,-0.165514,-0.085690},
  {0.018900,-0.104229,0.120256,-0.084952,-0.007525,0.207121,0.088876,-0.063515,0.086372,0.027117,0.093472,0.040790,-0.026379,0.138733,-0.078948,-0.083121,-0.012377,-0.094956,-0.014209,0.074089,0.020534,-0.022903,0.051770,0.065098,0.028110,0.071951,0.154531,0.113838,-0.012345,-0.207652,0.013869,-0.070342,0.048442,-0.007797,0.051489,0.064141,-0.002520,-0.130431,-0.117434,-0.006752,-0.064447,0.010825,-0.024282,0.140195,-0.086942,-0.092253,0.105366,-0.049607,-0.064165,-0.181877,-0.086042,0.054548},
  {-0.025923,0.016585,0.166572,0.045322,-0.136616,0.244777,0.087250,-0.275747,-0.007966,0.173174,0.008931,-0.065785,-0.088672,0.080171,0.012997,-0.058879,0.054378,-0.153169,-0.006874,-0.032992,-0.093367,-0.017823,0.160005,-0.065088,0.012553,0.074046,0.142908,0.169231,-0.014441,-0.337065,-0.010406,0.110766,0.070409,-0.027024,0.054752,-0.040979,0.093307,-0.111958,-0.085390,-0.115570,-0.027983,0.156692,-0.216404,-0.021345,-0.054774,0.097057,-0.035815,-0.082706,-0.076009,-0.017124,0.124629,0.101212},
  {0.018728,0.127290,0.068339,0.158838,-0.104496,0.162617,-0.019659,-0.081473,-0.232561,0.167084,-0.035710,0.018531,-0.045030,0.028224,-0.050337,0.094066,0.008881,0.024699,-0.051210,-0.144206,-0.071151,-0.072299,0.104425,-0.037762,-0.062980,0.006657,0.108063,-0.069867,-0.074521,-0.092597,0.026669,0.071879,0.134714,0.067554,-0.051309,-0.031861,0.058474,0.020140,0.077715,-0.145403,0.028650,0.076302,-0.118399,-0.052924,-0.043217,0.081518,-0.093274,0.001071,-0.120989,0.101642,0.091581,0.077882},
  {-0.108374,0.060164,-0.064606,0.015298,0.088641,-0.180149,-0.011167,0.099351,-0.043209,0.093069,-0.132343,-0.059304,-0.046747,-0.143366,0.025299,0.115537,0.017389,0.167395,0.073451,-0.093206,-0.057904,-0.019422,-0.155393,-0.110550,-0.063796,-0.019548,0.123434,-0.162494,-0.086796,0.184565,0.033727,0.059929,-0.047175,0.150010,-0.111231,-0.101992,0.030893,0.138008,0.192082,-0.032071,0.010383,-0.007826,-0.102437,-0.095161,-0.026803,0.067879,-0.011402,-0.023172,-0.111296,0.061586,0.019610,0.155780},
  {-0.064575,0.065062,-0.147184,0.079202,0.084009,-0.309203,-0.070166,0.181272,0.008257,0.068615,-0.105224,-0.028104,-0.067577,-0.105705,0.006074,0.069402,0.003138,0.065634,0.031874,-0.004942,-0.073461,0.046659,-0.101412,0.008268,-0.143533,0.057780,0.045131,-0.255632,-0.084413,0.144177,0.039119,0.065641,-0.029978,0.049140,-0.054902,-0.069622,-0.000486,0.141621,0.146115,-0.048843,0.074759,-0.075459,0.097868,-0.107514,0.043962,0.023439,-0.006927,0.010260,-0.004638,0.007646,0.025280,0.051299},
  {0.016531,-0.066350,-0.069100,-0.133937,0.090768,-0.084903,0.051724,-0.005834,0.149373,-0.128077,-0.090972,0.054906,0.009326,-0.059645,0.008333,-0.055498,0.118060,0.071241,0.052284,-0.044786,-0.052693,0.076985,-0.039741,0.063573,-0.036453,-0.038765,-0.097390,-0.023840,0.019112,0.101058,-0.001491,0.015389,-0.077654,0.023724,0.013125,-0.141195,0.022440,0.074051,0.211775,0.074462,-0.051683,-0.109942,0.165307,-0.050947,0.054301,-0.092982,0.055242,-0.094412,0.073413,-0.042790,-0.125713,-0.017242},
  {-0.031026,-0.219984,0.006833,-0.067562,0.054085,0.029237,-0.003993,0.045605,0.075058,-0.159426,-0.017386,0.105661,0.074665,0.124776,0.014246,0.009218,0.087308,0.061600,0.058772,-0.004242,0.104567,0.051328,0.009516,0.154360,-0.057589,0.032250,-0.102006,-0.016492,0.123448,0.053371,-0.015646,0.017950,-0.009550,-0.074057,0.071798,-0.110782,-0.021160,0.073240,0.009408,0.051001,0.003591,-0.053827,0.235235,0.020605,0.041566,-0.137116,0.076987,-0.093337,0.106740,0.003452,-0.098073,-0.006585},
  {0.055949,-0.152132,-0.043617,0.078162,-0.108649,0.219286,-0.049904,-0.173619,-0.043712,-0.077732,0.064937,0.095184,0.127253,0.095822,-0.049165,0.030438,-0.052164,-0.024899,-0.006865,0.013878,0.066272,-0.026883,0.233801,0.166132,-0.044127,-0.065201,-0.190027,0.129771,0.052319,-0.125637,0.044472,-0.049115,0.106923,-0.106812,-0.054451,0.032976,-0.037354,0.027174,-0.103328,0.095857,0.065105,0.088388,-0.002050,-0.032419,0.004898,-0.021841,-0.079522,-0.000223,0.070229,0.145252,0.032450,-0.088706},
  {0.009708,0.106918,-0.036422,0.043328,-0.123387,-0.001413,-0.083476,-0.008917,-0.174430,0.017954,0.097492,-0.001124,0.076808,0.005792,0.083582,0.048959,-0.059229,-0.005281,-0.055963,0.069092,0.014699,-0.009765,0.135198,-0.034060,0.021307,-0.025425,-0.153253,0.250865,0.026785,0.032817,0.068409,-0.068854,0.014932,0.014661,-0.135611,0.114478,-0.050295,-0.225405,-0.119521,-0.030833,0.013308,0.065803,0.058021,-0.094855,0.115294,0.038827,-0.055435,-0.009578,-0.090658,0.144011,0.104772,-0.148829},
  {-0.030457,0.096828,0.012118,0.044853,-0.056651,-0.080034,-0.142054,0.053697,-0.177512,0.045054,0.205225,-0.058432,0.026145,-0.123180,0.029749,-0.062525,-0.055264,-0.038419,0.003442,0.007169,0.002026,-0.033472,0.038428,-0.200441,0.036722,-0.044822,-0.131464,0.079046,-0.109805,0.085687,-0.014189,0.069674,-0.017204,-0.057035,-0.192340,0.119578,-0.006951,-0.107655,-0.119320,0.073807,-0.060927,0.048758,-0.097300,0.027332,0.093986,0.105074,-0.130056,-0.004993,-0.134280,0.181140,0.213798,-0.017385},
  {-0.004362,0.241168,0.083202,0.062128,0.125307,-0.024648,-0.017495,0.128213,-0.112266,0.149871,0.108197,-0.030922,-0.056910,-0.196525,0.000092,-0.068411,-0.003154,-0.025806,-0.035186,0.058956,-0.000968,0.012627,-0.104485,-0.218179,0.102981,0.095328,0.022849,-0.091584,0.011955,-0.018751,0.012163,0.073943,-0.095709,0.081624,-0.083549,0.163202,0.060528,-0.013172,0.069888,-0.074486,0.017204,-0.011595,-0.124273,0.060601,0.029789,0.132696,-0.028936,-0.062761,-0.063935,0.076303,0.067991,0.066289},
  {-0.052638,0.142897,0.041031,-0.102055,0.118664,0.129259,0.122609,0.078019,0.015798,0.010941,-0.036087,0.091295,-0.008532,-0.020700,-0.001588,-0.138707,-0.024676,-0.092898,-0.031330,-0.012641,0.018740,-0.076398,-0.124924,-0.111832,0.040266,0.039985,0.149925,-0.151292,0.003523,-0.062320,0.026518,0.030167,-0.067259,-0.025436,0.159087,0.102115,-0.019369,0.019540,0.148920,0.021950,-0.080298,-0.024894,-0.177155,0.088576,-0.086927,0.050165,0.133505,0.019274,0.029216,-0.089756,-0.093089,0.018530},
  {0.027087,-0.094389,0.084067,-0.029130,0.129553,0.323438,0.030617,0.005842,0.191296,0.059549,-0.177315,-0.000734,-0.048373,0.042865,0.025292,-0.045525,0.070978,-0.030097,-0.005532,0.001297,-0.074359,-0.003029,0.000226,0.110902,-0.021074,-0.053158,0.113596,-0.058869,-0.010372,-0.257319,0.043880,0.088261,-0.081199,0.037997,0.051920,0.016549,-0.043424,0.196948,0.133418,-0.109023,-0.059115,-0.031715,-0.017421,0.046185,-0.049342,-0.050508,0.096023,-0.048653,0.034335,-0.141615,-0.115594,-0.008621},
  {-0.062045,-0.134148,-0.148137,0.102170,-0.102097,-0.022971,-0.001979,-0.087660,-0.098836,-0.040016,-0.088804,-0.207577,-0.011260,0.083079,0.084158,0.158824,-0.005195,0.062912,0.045716,-0.112025,-0.075949,0.044993,0.149089,0.165147,-0.055515,-0.069056,0.211164,0.168655,0.035606,-0.013691,-0.025365,0.017699,0.073722,0.030853,-0.066704,-0.194015,0.029532,0.129158,-0.126681,-0.094057,0.073047,0.113754,0.084531,-0.087191,0.088087,-0.111245,-0.112612,0.014808,0.024291,0.056190,0.065529,0.055458},
  {0.029600,-0.097367,-0.138381,-0.014330,0.016773,-0.212374,-0.117343,-0.062555,-0.182643,-0.107811,0.040348,-0.096399,-0.072223,-0.186574,0.034707,0.017119,0.047358,0.089979,-0.011685,-0.075790,-0.062550,0.057700,0.059383,0.006732,-0.097106,0.022084,0.000824,0.196299,-0.042726,0.206725,-0.068828,0.008268,-0.037529,0.045501,-0.080990,-0.100078,-0.033988,0.023396,-0.235235,0.057323,0.109826,0.056569,0.173272,0.017566,-0.033405,0.065597,0.066175,0.124136,-0.037223,0.137474,0.174703,-0.073569},
  {-0.042183,0.112216,-0.082557,-0.072373,0.076539,-0.336358,-0.054580,-0.010528,-0.110219,-0.075048,0.157635,0.038122,0.100147,-0.065493,-0.037054,-0.091625,0.059555,0.013225,0.029257,-0.013814,0.027654,0.027552,-0.000453,-0.130717,-0.095414,-0.017578,-0.068467,0.152580,0.099671,0.284154,0.002521,-0.018682,0.008069,-0.018188,0.002786,-0.228333,-0.029109,-0.092337,-0.072089,0.008282,0.050586,-0.106428,0.077146,0.143601,0.096522,-0.028702,0.122211,-0.005236,-0.002204,0.087867,0.135825,-0.068522},
  {-0.056030,0.232938,0.036131,0.044985,0.060289,-0.112595,-0.110752,0.023882,-0.001592,0.014820,-0.068185,0.168000,0.107987,-0.033924,-0.168948,-0.218381,0.038551,0.119785,-0.047713,0.066290,0.031616,0.042379,-0.019245,-0.202731,-0.052904,-0.041187,-0.092602,-0.042772,0.023366,0.054726,0.202183,-0.045231,0.091287,-0.017515,-0.067492,-0.173787,-0.051489,0.029149,0.063969,-0.040956,0.034635,-0.064407,-0.126590,0.204703,0.054911,0.056750,0.043058,0.054172,-0.074144,0.145720,-0.052972,-0.059970},
  {0.025441,0.093036,0.045438,0.009774,-0.003788,0.071901,-0.108401,-0.007067,0.159417,0.037222,-0.093783,0.017347,0.073431,0.167771,-0.089109,-0.050500,0.001724,-0.078567,-0.023869,0.044046,0.078507,-0.020583,-0.099123,-0.040819,0.062719,-0.028317,-0.186010,-0.168151,0.003407,-0.079431,0.145689,-0.067444,-0.038462,-0.094728,0.033127,-0.002371,-0.021397,0.047643,0.151288,0.116077,-0.066188,0.005172,-0.082244,0.099525,0.046202,0.009902,-0.099203,0.012480,0.008693,0.039752,-0.142569,-0.193142},
  {0.024168,-0.065114,-0.005890,0.084401,-0.108792,-0.020307,0.027101,0.037733,0.191096,0.010858,-0.017612,-0.024490,0.114801,0.092032,-0.023523,0.147718,-0.012603,-0.011297,-0.118334,0.095003,0.089981,-0.035553,-0.073686,0.058181,0.005180,0.051820,-0.171168,-0.124584,0.048097,-0.028682,0.032011,-0.043741,-0.013410,0.053878,0.085096,0.247646,-0.057654,-0.014615,0.144596,-0.007957,0.026599,0.066387,-0.018863,-0.187216,0.011450,-0.023701,-0.005090,-0.011494,-0.062295,-0.138727,-0.247618,-0.078795},
  {0.036555,-0.111292,0.047205,0.192974,-0.077252,0.056662,0.053499,0.021282,0.046934,0.039696,0.006124,0.032513,-0.009961,-0.011286,0.055801,0.263769,-0.098030,-0.056666,-0.079476,-0.071092,-0.049279,0.018750,0.006232,0.067796,0.105812,0.027234,-0.017759,0.001566,-0.026989,-0.022582,-0.060849,0.019134,0.085144,0.042206,0.052285,0.063282,0.090525,-0.043697,-0.017148,-0.073773,-0.033111,0.098378,-0.001531,-0.231848,0.023536,-0.021459,-0.104085,-0.012643,0.053304,0.006894,-0.063879,-0.021676},
  {-0.001848,-0.063830,-0.007161,0.018638,0.072001,-0.096679,-0.001331,-0.002596,-0.002280,-0.117687,0.189867,-0.132903,-0.036799,-0.116737,0.260077,0.111382,-0.018369,-0.110045,-0.068678,0.052610,0.021630,0.033784,-0.089506,0.169563,0.001275,0.011234,-0.048288,0.082677,-0.075053,-0.024010,-0.166064,0.097859,-0.079235,0.000595,0.139932,0.199074,0.013752,-0.119928,0.022972,-0.084427,-0.027230,0.010673,0.091897,-0.095668,-0.040579,0.034433,0.011588,0.040142,-0.017791,-0.128476,0.122995,0.151679},
  {0.014594,0.022223,0.104338,-0.018672,0.041786,0.058287,0.089410,-0.050369,-0.187445,-0.139497,0.154168,-0.013273,-0.067760,-0.030472,0.172644,-0.060685,0.023848,-0.119455,0.043667,0.024510,-0.033326,-0.012533,0.037764,0.030815,0.015422,0.054797,0.058077,0.046646,0.019188,-0.000967,-0.077026,0.059012,-0.097261,-0.001466,0.017427,0.062136,-0.072829,-0.143531,-0.034092,-0.060916,-0.062244,-0.097567,0.035694,0.047355,-0.070395,-0.036018,0.111430,-0.001793,0.033248,-0.095212,0.198831,0.060431},
  {0.037114,0.148139,0.122620,-0.106787,0.074523,0.143043,0.020285,-0.034344,-0.174076,-0.130149,0.012319,-0.014948,-0.049967,0.044710,-0.040563,-0.206095,-0.028294,-0.087352,-0.031052,0.015760,0.004752,-0.002958,0.015816,-0.139327,0.048319,-0.031821,0.178098,0.033091,0.079242,-0.149838,-0.013228,0.092654,-0.042512,-0.132184,-0.007666,-0.042202,0.013636,-0.073776,-0.028835,-0.074852,-0.111676,-0.062226,0.157169,0.253285,-0.056293,0.016777,0.112494,0.067161,0.071089,0.014305,0.155202,0.009981},
  {-0.005500,0.134999,-0.015696,-0.078609,-0.028942,0.087938,0.048019,-0.121063,0.051817,-0.068831,-0.100123,-0.019358,0.057695,0.090878,-0.095655,-0.214576,0.006446,-0.007500,-0.047971,-0.033737,-0.107630,0.040577,0.077821,-0.157640,0.029689,-0.016185,0.166169,-0.045528,-0.012570,-0.111284,0.092437,-0.053051,0.028388,-0.008919,-0.042367,0.002528,-0.100333,0.081631,0.050585,0.052269,-0.024197,-0.065604,0.054282,0.223475,-0.030120,-0.020082,-0.043249,-0.020846,0.010136,0.003255,-0.037344,-0.007709},
  {0.089894,0.023077,-0.124265,0.046987,-0.140140,0.065916,0.069635,-0.092776,0.189418,0.120578,-0.216106,-0.119663,0.099238,0.024579,-0.067955,-0.023948,-0.087466,0.076435,-0.043184,-0.029593,-0.039880,0.095687,0.068384,0.063468,-0.052634,-0.016611,0.061450,0.024265,-0.053842,-0.077298,0.174089,-0.140471,0.132939,0.021728,-0.068765,-0.018615,0.086362,0.112373,0.074594,0.115343,0.078405,0.131913,-0.021873,-0.018973,0.008250,-0.039639,-0.005398,-0.018266,0.026480,0.140100,-0.106325,-0.119701},
  {-0.031865,-0.084667,-0.095606,0.018085,-0.070983,-0.162093,-0.025834,0.043036,0.174058,0.082151,-0.067619,-0.038676,0.060145,-0.106997,0.052978,0.191783,-0.049959,0.125062,-0.007612,-0.082817,-0.076630,0.024327,-0.064474,0.078893,-0.136285,-0.012706,0.041068,0.056893,-0.174067,0.206388,0.015780,-0.125185,0.086301,0.061225,-0.140786,-0.123987,-0.020250,0.149344,-0.142758,0.073392,0.032224,0.077957,-0.148426,-0.133735,0.025716,0.042124,-0.015568,-0.028135,-0.029709,0.039805,-0.197002,-0.099705},
  {-0.084687,-0.100283,-0.041460,-0.027593,0.027409,-0.228292,0.003310,0.068564,0.103858,0.069236,0.076961,0.047207,0.085279,-0.070851,0.065657,0.171724,0.045735,0.077003,0.017640,-0.070671,-0.036761,0.084826,-0.155109,0.124789,-0.049084,-0.078690,-0.034757,-0.008311,-0.001284,0.155332,-0.073889,0.027197,0.033183,0.024969,0.035495,-0.030677,-0.067780,-0.030222,-0.062740,0.058774,0.049829,0.001498,-0.141029,-0.132142,0.075797,0.043058,-0.032369,-0.021482,-0.061603,-0.020654,-0.027823,-0.071714},
  {0.056204,-0.010463,-0.106242,-0.019838,0.070693,-0.139327,0.002373,-0.011057,-0.112571,0.108386,0.053905,0.124269,0.006730,0.061570,0.091628,0.048960,0.051741,0.001238,-0.046089,0.054116,0.070008,0.016288,-0.089926,0.101879,0.004785,0.029893,-0.141657,-0.022311,0.025878,0.085871,-0.036715,0.005687,0.036174,-0.188221,0.041914,-0.297329,-0.118613,-0.173079,0.036645,-0.102756,0.042408,-0.110459,0.014096,-0.063650,0.041998,-0.030530,-0.038950,0.111824,-0.024859,-0.053838,0.033492,0.061228},
  {-0.072889,0.099728,0.019747,-0.092305,0.100857,0.035507,0.002371,-0.016400,-0.187372,-0.036321,0.190859,-0.027459,0.064637,0.111689,-0.067101,0.046440,0.087431,-0.053462,-0.096744,0.090642,0.080291,-0.094319,0.002034,-0.051161,-0.012763,-0.046061,-0.149704,-0.082528,0.189286,-0.048599,0.034885,0.022989,-0.076634,-0.211285,0.075911,-0.116448,0.007081,-0.085326,0.062644,-0.065530,-0.025762,-0.172591,0.083376,-0.050817,0.124814,0.063987,-0.025831,0.054522,0.028001,-0.016096,0.176543,0.004321},
  {0.075338,0.108230,0.034800,-0.077291,-0.077833,0.088180,-0.007400,-0.107972,-0.058152,-0.187419,0.076054,-0.001563,0.059523,0.151165,-0.255162,-0.047657,0.017018,-0.083318,-0.040648,0.099105,0.039830,-0.030541,0.088949,-0.135900,0.042384,-0.047332,-0.207273,-0.033529,0.044448,-0.062531,0.211415,0.070390,-0.005977,-0.082395,0.118790,0.025693,0.014357,-0.030161,-0.002511,-0.082255,-0.017224,0.091575,0.143938,0.037041,0.097172,0.084772,0.001920,-0.054936,-0.016736,-0.147643,0.084944,-0.046684},
  {0.039687,0.052157,0.093267,0.018548,-0.115073,0.145781,0.093809,-0.113056,0.075836,-0.150071,-0.058969,-0.091317,0.003566,-0.071973,-0.168348,-0.136079,-0.041059,-0.082504,-0.060225,0.018627,0.030507,0.002588,0.077725,-0.079960,0.066982,0.037000,-0.072979,-0.056871,-0.055589,-0.144657,0.113845,0.010407,0.061926,-0.029996,0.051443,0.232295,-0.027111,0.054839,-0.049456,-0.011338,-0.035401,0.192398,0.205262,0.151128,-0.017487,-0.026528,-0.073572,-0.012986,-0.034535,-0.029020,-0.017543,0.021851},
  {0.044116,0.011653,0.008130,0.126096,-0.118667,0.111392,-0.083853,-0.002004,0.063812,0.014325,-0.086736,-0.055184,-0.043570,-0.029254,0.085406,-0.025074,-0.039936,0.005442,-0.049408,0.052536,0.015805,-0.113140,0.041016,0.043820,0.062703,-0.079623,0.031992,0.060402,-0.089983,0.006525,-0.082214,0.124900,0.068782,0.076483,-0.205601,0.164045,0.088683,0.035526,-0.135627,-0.028803,0.018093,0.150749,0.052537,0.169483,-0.014658,0.009492,0.016737,0.028728,0.009088,0.213575,-0.032990,0.106132},
  {-0.017848,-0.131180,0.052366,-0.012584,-0.007484,-0.049147,0.008191,0.036635,0.107145,0.165922,-0.037124,0.087602,-0.100537,-0.162757,0.104346,-0.031049,-0.009506,-0.128797,-0.071497,0.009018,0.063018,0.000518,-0.021680,0.027409,0.000104,0.000423,0.026006,0.031589,-0.169414,0.013618,-0.095721,0.114001,-0.046939,0.115519,0.005313,0.113230,-0.001550,0.044018,-0.031067,-0.118680,-0.001877,0.020037,-0.151043,-0.027332,-0.018986,-0.057157,-0.006833,-0.018115,0.041726,0.071090,-0.144365,0.037722},
  {-0.081009,-0.126483,0.062807,-0.002904,0.096252,-0.016143,-0.009241,0.035429,-0.002582,0.279547,-0.007388,0.056892,-0.065513,0.132358,0.191025,-0.071688,-0.044943,-0.096033,0.022062,0.017596,0.057420,0.003565,-0.086412,0.171557,0.040474,0.002483,0.074292,0.068824,0.044305,-0.096302,-0.172400,-0.001473,-0.079519,-0.009082,-0.099192,-0.118914,0.024550,0.094585,-0.029604,0.033845,-0.078735,-0.105170,-0.183347,0.138350,-0.019359,-0.094887,-0.048593,0.007932,0.110434,0.034309,0.011781,-0.003220},
  {-0.024908,0.001773,-0.021903,-0.077002,0.263629,0.083805,0.008802,0.112580,-0.099800,0.168484,0.048592,-0.024976,0.052362,0.114106,-0.042214,0.082325,0.074853,0.060739,-0.062463,-0.073509,0.000129,-0.051855,-0.072480,-0.076774,-0.011013,-0.000436,0.071496,0.047721,0.082968,-0.093829,-0.002647,0.018754,-0.114302,-0.098233,0.147811,0.008131,0.038235,-0.013221,-0.005930,0.113033,-0.031027,-0.311788,-0.184896,-0.079570,0.011827,-0.063962,0.115092,-0.021499,0.110471,-0.043797,0.154141,-0.037267},
  {0.045009,0.031547,-0.095907,0.013571,0.133410,0.123053,0.096544,0.005563,-0.049283,0.022624,0.020686,-0.191258,0.026525,0.173661,-0.196679,0.156728,-0.004869,0.044862,0.023466,-0.067438,-0.109091,0.075596,0.074959,-0.095600,-0.056136,-0.027535,0.104702,-0.030296,-0.011004,-0.031622,0.165291,-0.105896,-0.022062,-0.009399,0.093617,0.013629,-0.000704,0.031542,0.011445,0.177017,0.020340,0.006216,0.021872,-0.176771,0.009414,-0.067306,-0.063104,-0.037721,0.056904,-0.126386,0.149033,-0.115976},
  {0.060682,0.019552,-0.102528,0.011965,-0.104793,-0.020073,0.027982,-0.044345,-0.099713,-0.192163,0.030519,-0.170878,0.090274,-0.164681,-0.117367,0.257778,-0.087417,0.143443,0.061992,-0.119524,-0.184897,0.048514,0.046940,-0.124989,-0.175928,-0.037880,0.126870,0.029815,-0.002614,0.096811,0.102928,-0.155483,0.143726,0.105082,0.107960,-0.138061,-0.009907,0.007393,-0.066494,0.245631,0.051977,0.117517,0.233816,-0.196426,0.019246,-0.003786,0.021799,0.001556,-0.016195,-0.049606,0.045507,-0.140594},
  {-0.043267,0.042803,-0.089152,-0.031623,-0.287767,-0.218964,-0.009788,0.004464,0.087750,-0.342516,0.026927,0.205198,0.034542,-0.150386,-0.024411,0.110580,-0.060758,0.037039,0.034007,-0.175554,0.032673,0.045136,0.063893,-0.105839,-0.092616,0.006286,0.035676,-0.001078,-0.173488,0.178163,0.112307,-0.001501,0.121085,0.240628,-0.021694,-0.035604,-0.051782,-0.001202,0.026761,0.080712,0.071654,0.126380,0.138291,-0.152330,0.049643,0.061128,0.107259,0.023487,-0.056142,0.060337,-0.062234,-0.108418},
  {-0.101867,-0.116108,-0.038691,-0.042295,-0.264035,-0.161660,-0.068075,-0.055373,0.090619,-0.119997,0.054166,0.402526,-0.090463,-0.099502,0.129420,-0.088056,0.011140,0.019320,0.005547,0.001486,0.019571,0.060662,0.111221,0.002608,-0.139107,-0.067535,-0.094187,-0.046129,0.008209,0.193646,-0.205784,0.033931,0.228340,0.054694,-0.003730,-0.163390,-0.045502,-0.107937,0.060238,-0.160447,0.007455,0.225485,0.157305,0.066179,0.060467,0.075144,0.005888,-0.055206,-0.113203,0.031868,-0.148155,0.090764}
};


const float L2_BIAS[2*52] = {
  0.157195,0.072193,-0.035439,-0.126320,-0.081899,-0.001953,0.081786,0.033099,-0.003965,-0.028709,0.001168,
  0.036264,0.031349,-0.012334,-0.073890,-0.087751,-0.042296,0.058714,0.089379,0.063621,0.019602,-0.022528,
  0.004750,0.012372,0.007208,-0.033544,-0.051988,0.037221,0.092493,0.106291,0.041323,-0.036188,-0.069527,
  -0.063285,-0.049350,0.004054,0.005553,0.002819,0.028574,0.028254,0.019648,0.008989,0.004817,0.026118,
  -0.016253,-0.018025,-0.074108,-0.064073,-0.011094,0.101192,0.132221,0.088347,0.006004,-0.085327,-0.129239,
  -0.035141,0.067551,0.086074,0.030196,-0.020338,-0.038882,-0.013075,0.040270,-0.000574,-0.036411,-0.076371,
  -0.034423,0.035204,0.101458,0.065949,0.017444,-0.019258,-0.046593,0.006473,0.015359,-0.007622,-0.053561,
  -0.046789,0.077645,0.115564,0.068819,-0.038396,-0.080836,-0.085604,-0.049000,0.012731,0.028655,0.024424,
  0.017366,0.007243,0.046889,0.001973,-0.002918,0.003261,-0.010268,-0.023915,-0.040953,-0.044434,0.003027,
  0.070859,0.120979,0.062148,-0.000989,-0.125427
};


const float L2_WEIGHTS[52][2*52] = {
  {0.002600,0.007330,0.003316,0.001247,-0.006744,-0.003867,-0.012359,-0.002097,-0.002654,-0.000439,0.005940,0.010639,0.002032,-0.001506,-0.008368,0.001505,0.002099,0.001263,0.000873,-0.010255,-0.000738,-0.001632,0.000748,0.010285,0.001158,-0.002933,-0.019054,-0.003323,0.004413,0.012810,0.012391,-0.000219,0.003778,-0.000342,-0.004409,0.003218,-0.001215,-0.001811,0.005808,0.003826,0.003410,-0.002027,-0.007861,0.000804,0.013497,0.011991,-0.006750,-0.019370,-0.020029,-0.001187,0.021958,0.023994,0.018753,0.006569,0.001067,-0.009587,-0.005575,-0.004697,0.002117,0.001680,0.008169,0.007205,0.011000,0.001649,-0.006043,-0.005095,-0.003905,0.006795,0.003293,0.004675,-0.005586,0.000134,0.001716,0.010794,0.001528,-0.005721,-0.010893,-0.008983,0.004637,0.006877,0.005606,-0.001625,-0.004788,-0.005812,-0.003113,-0.003219,-0.000308,0.000209,0.004982,-0.008725,-0.003927,-0.000475,-0.007239,-0.008272,0.002651,0.005405,0.001156,-0.012168,-0.013238,-0.007575,0.014006,0.029406,0.013872,-0.007960},
  {-0.082842,0.036074,0.122295,0.107854,0.039993,-0.049112,-0.105131,-0.091432,-0.017287,0.052248,0.085581,0.049561,-0.008589,-0.075312,-0.087861,-0.039026,0.027081,0.101891,0.101748,0.022463,-0.066484,-0.141775,-0.112812,-0.011690,0.108431,0.149199,-0.043825,-0.102766,-0.093987,-0.004782,0.080261,0.070748,0.017964,-0.048668,-0.066477,-0.012709,0.029876,0.053849,0.044822,-0.005814,-0.041441,-0.034942,-0.022281,0.020178,0.029281,0.024226,-0.018322,-0.047069,-0.021820,0.017278,0.054667,0.054629,0.120732,0.133247,0.055205,-0.038281,-0.109480,-0.103766,-0.036802,0.046412,0.099043,0.060386,0.004216,-0.052168,-0.079908,-0.055863,0.015794,0.082748,0.091626,0.047282,-0.049913,-0.112455,-0.105016,-0.010386,0.090760,0.136052,0.092906,-0.027881,-0.117499,-0.047443,0.055944,0.090409,0.050224,-0.012572,-0.065430,-0.055804,0.011980,0.067892,0.051281,-0.005628,-0.042338,-0.057453,-0.016742,0.009239,0.044139,0.026486,0.007820,-0.043136,-0.020704,0.013340,0.034237,0.046684,0.027381,-0.026273},
  {-0.000167,0.001295,0.002670,0.001265,0.000567,0.000479,-0.003128,-0.004899,-0.004915,-0.001191,0.004040,0.006953,0.006305,-0.001264,-0.005642,-0.005725,-0.002981,0.003857,0.005708,0.001670,-0.001732,-0.004293,-0.001412,0.001567,0.001221,-0.000118,-0.003720,-0.000401,0.003012,0.002191,0.002312,-0.001259,-0.002703,-0.001542,-0.000274,0.000095,0.000809,0.001442,0.001554,0.004136,0.002089,-0.002081,-0.005174,-0.005989,-0.002910,0.002266,0.005114,0.003443,0.001467,-0.003086,-0.002910,-0.001233,0.003506,0.000846,-0.001040,0.000737,-0.002726,-0.003061,-0.003731,-0.001861,0.003765,0.007302,0.006488,0.001514,-0.005000,-0.006725,-0.005114,0.002786,0.005047,0.004851,0.001265,-0.004794,-0.004461,0.000210,0.000700,0.002054,-0.001835,-0.004112,0.001136,0.002876,0.002246,-0.001003,-0.003058,-0.002406,-0.001467,0.001184,0.002709,0.002153,0.001412,0.002044,-0.000422,-0.001347,-0.002875,-0.005828,-0.002654,0.002998,0.006635,0.004542,0.001863,-0.002074,-0.005418,-0.002517,0.000561,0.002694},
  {0.008488,-0.011358,-0.009922,-0.013763,-0.018889,0.009572,0.013170,0.012768,0.017303,-0.000312,-0.018125,-0.012569,-0.009944,-0.003172,0.003985,0.002529,0.010285,0.010860,0.011216,-0.005305,-0.015603,-0.015081,0.000669,-0.004792,0.014603,0.012568,0.004967,-0.008835,-0.010458,-0.006315,-0.003337,-0.001012,0.008123,0.007714,0.006545,0.018498,-0.013235,-0.011342,-0.015620,-0.018800,0.003362,0.013631,0.015489,0.013281,0.006296,-0.008298,-0.013087,-0.011386,-0.007786,-0.001381,0.008086,0.011130,-0.009549,-0.013263,-0.022805,0.013549,0.009255,0.012695,0.017244,-0.013800,-0.012375,-0.011186,-0.009876,0.001505,0.009776,0.009081,0.010621,0.008014,0.005095,-0.000622,-0.008786,-0.011793,-0.001365,0.008708,0.010080,0.014504,0.010023,0.002176,-0.014191,-0.005813,-0.004625,-0.000577,0.008262,0.007959,0.004221,0.011989,-0.004357,-0.006021,-0.011888,-0.022304,0.009164,0.017636,0.019251,0.013775,0.003771,-0.010624,-0.012609,-0.013562,-0.007712,0.008696,0.011282,0.006390,0.015798,0.015971},
  {0.054592,0.147513,0.140537,0.075576,-0.037203,-0.085487,-0.096199,-0.024901,0.004944,-0.006970,-0.006314,0.031447,0.058239,0.098019,0.024289,-0.045471,-0.108682,-0.096588,0.008087,0.077256,0.106059,0.036444,-0.045889,-0.046540,-0.020051,0.021500,-0.014019,-0.042281,-0.000007,0.065654,0.061964,0.018817,-0.060396,-0.091734,-0.048380,0.043447,0.108499,0.060989,-0.017767,-0.076241,-0.035345,0.045095,0.088437,0.013688,-0.069871,-0.139060,-0.068422,0.082113,0.175850,0.186861,0.043827,-0.124981,0.190028,0.092166,-0.035371,-0.142479,-0.112303,-0.049735,0.037081,0.048015,0.030592,0.025185,0.044234,0.053611,0.021913,-0.030246,-0.108563,-0.091367,-0.017258,0.084280,0.100217,0.064756,-0.029417,-0.096968,-0.063237,-0.008832,0.043478,0.039803,-0.027584,0.000989,0.046143,0.037252,-0.031653,-0.079653,-0.062123,0.011074,0.095998,0.081293,0.018756,-0.087335,-0.089514,-0.020914,0.047476,0.060165,-0.015276,-0.099347,-0.090841,0.030937,0.133457,0.150636,0.047768,-0.098680,-0.214961,-0.174666},
  {-0.060848,-0.042828,0.015982,0.056510,0.064343,0.001925,-0.022294,-0.033473,0.004897,0.037797,0.028460,-0.017281,-0.056276,-0.033723,0.018169,0.057724,0.049163,0.017650,-0.016007,-0.026736,0.000688,0.017246,0.009531,-0.019506,-0.026689,-0.004126,0.053622,0.034375,-0.006139,-0.027871,-0.033538,-0.000463,0.004763,-0.008478,-0.019893,-0.000279,0.025136,0.044119,0.029872,-0.009419,-0.041768,-0.041965,-0.000299,0.023590,0.011057,-0.004495,-0.013196,0.012482,0.021183,0.030536,0.001640,-0.026266,-0.010231,0.062083,0.071753,0.025339,-0.026551,-0.054630,-0.032666,0.022943,0.034745,0.005672,-0.033826,-0.044915,-0.005578,0.048190,0.065709,0.026356,-0.026052,-0.054148,-0.030948,0.010353,0.015271,0.012552,-0.009833,-0.014240,0.015088,0.046672,0.005700,-0.027415,-0.042325,-0.025107,0.012358,0.008941,0.009452,-0.001362,0.009461,0.024384,0.023864,-0.004600,-0.027315,-0.049034,-0.020114,0.022752,0.028407,0.018920,-0.010765,-0.005464,-0.003090,0.018495,0.012449,-0.025651,-0.030266,-0.039234},
  {-0.036905,0.033674,0.008364,0.016133,-0.005097,0.011325,0.040303,0.050071,0.002413,-0.005398,-0.041175,-0.053307,-0.032073,-0.013150,0.044011,0.024166,0.009587,0.005120,-0.035038,0.042732,0.036943,0.002012,-0.071826,-0.069219,-0.032402,0.007002,0.080952,0.045769,0.008630,-0.023205,-0.047877,-0.037582,-0.057129,-0.011683,-0.016257,0.025328,0.042780,0.031458,-0.003622,-0.023952,-0.037120,0.023426,0.027123,0.031261,0.003625,-0.011241,-0.027576,-0.050995,-0.020686,0.027958,0.054889,0.081716,0.014075,0.064948,0.016907,-0.021631,-0.007436,-0.000629,0.024413,-0.001812,-0.040742,-0.072509,-0.051899,-0.021573,0.068617,0.048294,0.033825,-0.010239,-0.017137,-0.015135,0.029125,0.011814,-0.013815,-0.045359,-0.003668,0.018551,0.062793,0.079596,0.010653,-0.015610,-0.064933,-0.021423,-0.031835,0.001322,0.012802,0.034564,0.015806,0.026087,0.000206,-0.012252,-0.021521,-0.016113,0.017898,0.014639,0.003593,-0.039982,-0.057612,-0.026005,0.003532,0.022172,0.061135,0.049550,0.018378,-0.052337},
  {-0.003447,0.031799,0.008987,-0.035694,-0.002653,0.019062,0.096271,0.056876,-0.033246,-0.069100,-0.050603,0.012537,0.092506,0.066832,0.026347,-0.062910,-0.075253,0.000165,0.069996,0.082140,0.004555,-0.057721,-0.077718,-0.042698,0.049304,0.084739,-0.003341,-0.049803,-0.061315,-0.042763,0.003500,0.039515,0.025864,0.028384,0.047248,0.029664,-0.035290,-0.062939,-0.087137,-0.028767,0.035157,0.080852,0.080213,0.020125,-0.057007,-0.079949,-0.054336,-0.012078,0.020496,0.015502,0.033631,0.028947,-0.018607,-0.020690,-0.015322,0.015261,0.031959,0.045974,-0.018370,-0.052308,-0.067984,-0.028313,0.031097,0.086556,0.042428,-0.037311,-0.066529,-0.056514,0.013797,0.074410,0.060626,-0.034087,-0.092398,-0.045669,0.027709,0.083526,0.074898,0.003882,-0.053969,-0.017888,0.000403,0.031510,0.040621,0.016626,0.034110,0.008338,-0.027341,-0.037344,-0.068249,-0.009799,0.030182,0.079744,0.090548,0.018697,-0.060834,-0.071104,-0.057731,-0.007329,0.013694,0.048077,0.037519,0.014228,0.014005,-0.053129},
  {0.035584,0.094172,0.065344,-0.032588,-0.096899,-0.082305,-0.008862,0.077566,0.098368,0.020422,-0.058358,-0.089354,-0.043177,0.044858,0.065073,0.039068,-0.039990,-0.053685,-0.012855,0.025068,0.075692,0.017958,-0.053591,-0.077926,-0.036260,0.049458,0.069064,0.002000,-0.076837,-0.077507,-0.033381,0.039673,0.093784,0.072550,-0.001037,-0.056899,-0.091357,-0.051259,0.046478,0.092803,0.080633,0.009353,-0.079359,-0.095764,-0.035085,0.050779,0.085885,0.046986,-0.019011,-0.052912,-0.038308,0.006664,0.091805,0.025321,-0.075450,-0.102019,-0.032189,0.056206,0.103556,0.055222,-0.027147,-0.100125,-0.064301,0.021215,0.074070,0.059491,-0.008254,-0.050445,-0.051459,0.014881,0.049605,0.051963,-0.009944,-0.057252,-0.055495,-0.003450,0.077210,0.078836,-0.054557,-0.104202,-0.057447,0.016992,0.079049,0.094593,0.032880,-0.064271,-0.088953,-0.057737,0.014513,0.060098,0.089791,0.019974,-0.054142,-0.101037,-0.054660,0.013346,0.088233,0.062612,0.008447,-0.047205,-0.071643,-0.019065,0.043812,0.054458},
  {0.026943,-0.043525,-0.057821,-0.036720,-0.013541,0.006292,0.008599,0.012753,0.042332,0.056299,0.024167,-0.042162,-0.100360,-0.112539,-0.043774,0.051341,0.129993,0.122708,0.038521,-0.049686,-0.128506,-0.126166,-0.058312,0.022027,0.094170,0.121301,0.008525,-0.077969,-0.133073,-0.119564,-0.029835,0.064923,0.136239,0.123784,0.035557,-0.076500,-0.143056,-0.131880,-0.046062,0.068951,0.145772,0.139430,0.045565,-0.068103,-0.158039,-0.139196,-0.038463,0.087791,0.159604,0.112851,-0.010458,-0.112786,-0.068919,-0.060207,-0.014570,0.034372,0.032325,0.024294,0.020285,0.023375,0.010510,-0.024211,-0.070502,-0.093226,-0.036070,0.047223,0.122074,0.118798,0.049337,-0.067746,-0.128711,-0.123856,-0.047937,0.044781,0.108860,0.129968,0.069547,-0.012288,-0.135097,-0.100829,-0.016158,0.078533,0.139590,0.120180,0.021135,-0.070171,-0.143820,-0.128452,-0.040166,0.076498,0.149099,0.140772,0.049622,-0.063317,-0.147293,-0.143084,-0.046445,0.079077,0.169675,0.137424,0.023105,-0.109049,-0.149769,-0.073141},
  {-0.024979,-0.060394,-0.090612,-0.084612,-0.034147,0.044845,0.111960,0.135990,0.098069,-0.029028,-0.133570,-0.167797,-0.112993,0.027723,0.111737,0.143151,0.109546,0.047360,-0.041753,-0.139100,-0.129985,-0.087779,0.002606,0.102163,0.130617,0.105725,-0.050159,-0.076472,-0.050916,0.002392,-0.015754,-0.019695,-0.018277,0.016748,0.090948,0.120610,0.059521,-0.049677,-0.138041,-0.144672,-0.052101,0.068079,0.134886,0.105627,0.036202,-0.060263,-0.079518,-0.079801,-0.033906,0.000509,0.053066,0.055794,-0.065189,-0.038690,-0.018394,0.044504,0.098121,0.117352,0.073129,-0.033537,-0.126070,-0.158356,-0.095576,0.029716,0.133216,0.154254,0.108530,0.024597,-0.089595,-0.138369,-0.133648,-0.068809,0.039302,0.119232,0.135966,0.096046,0.031839,-0.069759,-0.070182,-0.028697,0.026437,0.028936,0.001359,0.020214,0.067099,0.068694,0.060176,-0.032184,-0.125783,-0.152622,-0.054054,0.068682,0.144758,0.129548,0.044465,-0.085026,-0.115320,-0.106979,-0.041410,0.046680,0.059557,0.063802,0.066413,0.043596},
  {-0.241714,-0.115977,0.072535,0.181383,0.091358,-0.057190,-0.126714,-0.048170,0.057205,0.102693,0.038682,-0.042735,-0.070051,-0.011533,0.054286,0.053855,0.011732,-0.056775,-0.051670,0.004363,0.030127,0.032437,-0.017367,-0.031350,-0.008381,0.042032,0.015909,-0.072818,-0.091446,-0.054818,0.011055,0.070572,0.055168,0.024333,0.014772,-0.009017,-0.006742,-0.027355,-0.066022,-0.043441,0.009841,0.047775,0.050767,-0.011804,-0.022060,-0.003177,0.078645,0.076434,-0.033804,-0.181785,-0.193497,-0.038565,-0.008274,0.167019,0.178081,0.016872,-0.126286,-0.119784,0.002847,0.103103,0.086503,0.005400,-0.087583,-0.069661,0.011611,0.072306,0.045841,-0.025753,-0.067230,-0.035420,0.025874,0.037563,0.015521,-0.041464,-0.035874,0.018004,0.057422,0.040236,-0.083881,-0.063872,0.003702,0.081949,0.079413,0.026547,-0.012655,-0.027995,-0.024648,-0.025616,-0.031112,-0.017467,-0.007164,0.053452,0.055917,0.027253,-0.029230,-0.033666,0.002700,0.054965,0.000523,-0.097042,-0.150375,-0.066900,0.103887,0.257542},
  {-0.063226,-0.038054,-0.030594,0.023266,0.095979,0.080577,0.059987,0.009139,-0.077836,-0.090474,-0.091382,-0.009236,0.052737,0.126795,0.115102,0.064154,-0.030197,-0.083881,-0.115629,-0.055941,-0.004724,0.057977,0.116330,0.062387,0.035268,0.000200,-0.054557,-0.074276,-0.053450,-0.044011,0.035951,0.103628,0.113556,0.088444,0.013857,-0.076178,-0.092421,-0.057281,-0.031956,0.047439,0.067891,0.061010,0.046491,0.013474,-0.032906,-0.075181,-0.093675,-0.030597,0.019821,0.069883,0.102263,0.081359,0.003509,0.049415,0.067016,0.077265,0.015368,-0.050381,-0.095209,-0.100696,-0.067279,0.010454,0.099845,0.102733,0.113771,0.070427,-0.058497,-0.112724,-0.123997,-0.036135,0.052746,0.101896,0.098178,0.102905,0.022381,-0.031481,-0.102899,-0.054364,-0.057893,-0.000817,0.037633,0.076440,0.115275,0.024793,-0.043142,-0.076156,-0.100843,-0.069962,-0.008111,0.034059,0.087174,0.059862,0.014763,-0.036585,-0.049572,-0.041305,-0.043360,-0.016429,-0.012038,0.058875,0.082569,0.051952,-0.005476,-0.054258},
  {0.031456,-0.028811,-0.054598,-0.018186,0.019446,0.014665,-0.044292,-0.037285,-0.011325,0.045593,0.063089,0.013629,-0.034276,-0.049740,0.008411,0.069998,0.042774,-0.039316,-0.093348,-0.078382,0.022252,0.093500,0.068275,-0.010699,-0.077042,-0.068420,0.054311,0.049138,-0.013293,-0.058441,-0.026084,0.019953,0.049103,0.032846,-0.001290,-0.018187,-0.004451,0.026985,0.020156,-0.022748,-0.051301,-0.020405,0.024206,0.047619,0.034563,-0.038377,-0.061263,-0.018577,0.074806,0.086778,0.007322,-0.121731,-0.095944,-0.088057,0.001108,0.038792,0.011707,-0.028233,-0.028593,0.012831,0.066209,0.037103,-0.026002,-0.041669,-0.036456,0.023292,0.043253,0.008586,-0.066810,-0.053637,-0.012393,0.066685,0.093805,0.026125,-0.063200,-0.107951,-0.040980,0.035591,0.036826,-0.050082,-0.073305,-0.020552,0.031050,0.064390,0.029959,-0.034755,-0.032148,0.014882,0.027215,0.002252,-0.054215,-0.048046,0.003960,0.032062,0.054675,0.005134,-0.041208,-0.055805,0.011455,0.070882,0.034483,-0.034854,-0.122657,-0.087637},
  {-0.149831,-0.109021,0.003378,0.089725,0.134921,0.095782,-0.007739,-0.087893,-0.120743,-0.088090,-0.011935,0.043118,0.070376,0.042385,0.012273,0.007732,-0.028166,-0.033057,-0.027755,-0.023876,0.008021,0.013340,0.028880,0.023516,0.005132,-0.041124,-0.035127,0.058459,0.103097,0.078374,0.005370,-0.109702,-0.112319,-0.031590,0.052236,0.109177,0.048525,-0.044258,-0.050680,-0.010024,0.063799,0.084818,-0.008784,-0.093250,-0.122405,-0.022702,0.075098,0.138056,0.089071,-0.011411,-0.119323,-0.098854,-0.006504,0.101223,0.153561,0.102776,0.008160,-0.101294,-0.139721,-0.098170,0.000562,0.055877,0.099592,0.081235,0.014184,-0.029344,-0.057928,-0.046966,-0.019486,0.012409,0.008507,0.033174,0.023882,0.027376,0.009034,-0.044218,-0.066885,-0.044583,0.075995,0.070682,0.007703,-0.089267,-0.115893,-0.049669,0.037534,0.101494,0.084311,0.004632,-0.065774,-0.078883,-0.000142,0.048287,0.044529,-0.050871,-0.095008,-0.058510,0.051127,0.121971,0.130412,0.010936,-0.107498,-0.125641,-0.060671,0.039415},
  {-0.040470,0.059498,0.108425,0.102008,0.028133,-0.066494,-0.125823,-0.102690,-0.011588,0.084530,0.136176,0.104913,0.000754,-0.078305,-0.116572,-0.071217,0.009947,0.064653,0.063600,0.017927,0.008267,0.007953,0.000624,-0.017354,-0.060959,-0.058028,0.088407,0.110642,0.049352,-0.063150,-0.160272,-0.113323,0.019261,0.145668,0.174456,0.074842,-0.068472,-0.152460,-0.131256,-0.039337,0.054351,0.092819,0.086535,0.046646,0.021778,-0.035230,-0.073353,-0.105158,-0.077793,0.013507,0.125106,0.147581,0.117130,0.112098,0.027633,-0.070983,-0.117137,-0.098665,-0.014067,0.077873,0.130620,0.109590,0.013873,-0.085957,-0.131032,-0.089635,0.003602,0.087666,0.087529,0.043605,-0.012476,-0.034337,-0.017918,-0.017076,-0.030591,-0.039696,0.003171,0.058105,0.067590,-0.038086,-0.123536,-0.121776,-0.024386,0.113484,0.181726,0.098017,-0.042042,-0.163327,-0.158395,-0.057612,0.072579,0.132877,0.099858,0.034684,-0.023003,-0.066655,-0.077658,-0.078615,-0.062306,0.015203,0.093424,0.136183,0.090606,-0.024207},
  {0.004002,0.002514,0.006206,-0.009176,-0.002997,-0.022092,-0.008685,-0.006355,0.014122,0.013613,0.003539,-0.006360,0.001158,-0.015671,-0.000975,-0.001816,-0.004065,-0.002719,-0.007599,0.001732,0.008668,0.004044,-0.002054,-0.004005,0.005947,-0.009347,0.000777,-0.005387,0.000866,0.002916,0.012198,0.005129,0.014102,-0.000262,-0.007577,-0.005531,0.002001,0.002511,-0.004157,-0.012236,-0.006662,0.005413,0.004414,0.021637,0.000251,0.000538,-0.011239,-0.000569,0.003648,-0.000941,-0.016133,-0.012034,-0.014636,0.010747,0.000701,-0.019979,-0.005957,0.002459,0.006008,0.011384,0.012602,0.002474,-0.009642,0.007308,-0.001924,0.002570,-0.002910,-0.008874,-0.005583,0.000290,0.021044,0.012509,0.011997,0.001076,-0.003069,-0.008069,0.002285,-0.001138,0.001855,-0.004048,0.004098,0.010023,0.016650,-0.009675,-0.008484,-0.015452,0.007457,-0.003842,0.001325,0.002201,-0.004857,0.007699,0.009446,-0.006883,-0.004832,-0.008361,-0.012170,-0.003932,0.011601,0.007155,0.010012,0.005284,-0.015027,-0.009617},
  {-0.004366,-0.003885,-0.003474,-0.004488,0.002323,0.003961,0.004956,0.005338,-0.000843,-0.003592,-0.003676,-0.004067,-0.003182,0.001067,-0.000154,0.000254,0.005137,0.003007,0.002431,-0.000070,-0.002775,-0.001875,-0.002625,-0.001670,0.000810,0.001682,0.006019,0.002490,-0.001876,-0.007243,-0.007408,-0.000308,0.004722,0.007823,0.002691,-0.007318,-0.007374,-0.005827,0.004557,0.010573,0.008047,0.002023,-0.006259,-0.006316,-0.001638,0.003077,0.002292,-0.001566,-0.003824,-0.002344,0.004902,0.007959,-0.001962,0.001174,0.003129,0.002802,0.005083,0.005791,-0.001209,-0.003897,-0.004725,-0.005697,-0.000032,0.003401,0.002355,0.002036,0.005024,0.001550,0.001290,0.000190,-0.005117,-0.002922,-0.001372,-0.000608,0.002632,0.000910,0.004134,0.003981,-0.000406,-0.007706,-0.007291,-0.001683,0.002853,0.008485,0.006922,-0.004371,-0.005002,-0.007388,0.000795,0.009040,0.009236,0.004527,-0.005521,-0.010590,-0.005884,-0.000331,0.004129,0.002111,-0.001431,-0.002807,0.002019,0.005610,0.005697,0.000332},
  {-0.001486,0.001231,0.002255,-0.000481,0.002386,0.000918,0.000414,-0.003395,0.000546,0.002626,0.001499,0.000539,0.003451,0.002720,0.000610,-0.008882,-0.002027,0.004036,-0.007608,-0.002772,-0.007395,0.008053,0.009489,0.004078,-0.007127,-0.010943,0.002616,0.007434,0.006780,0.001579,-0.008013,-0.003456,-0.006359,-0.002615,0.012213,0.000051,0.000517,0.002048,0.000569,0.001439,-0.009068,-0.011870,-0.005863,-0.003998,0.002836,0.001373,0.010141,-0.000465,0.004695,-0.006955,-0.003279,-0.004670,-0.003868,-0.005771,-0.005842,0.003823,-0.004542,0.003894,-0.001826,-0.002339,0.000108,0.004925,-0.000088,-0.000680,0.002712,-0.007556,0.001200,-0.005497,-0.001894,-0.004447,-0.002734,-0.000276,0.005010,0.006866,-0.003245,-0.003530,-0.000226,-0.006188,0.013799,0.003518,0.001021,-0.003147,-0.009263,-0.001959,0.006995,0.008235,0.006195,-0.003892,-0.005456,0.006879,0.004136,-0.002781,-0.005133,-0.000592,0.003597,0.009340,0.007508,0.003048,-0.000499,0.003740,-0.001773,-0.006016,0.001549,0.009688},
  {0.017033,0.006760,-0.001286,-0.011146,-0.012458,-0.003088,0.007134,0.006469,0.001386,-0.003900,-0.004537,0.003565,0.009373,0.001446,0.003299,-0.011045,-0.008306,-0.005448,0.004290,0.014768,0.005743,-0.000333,-0.005339,-0.008163,0.001929,0.005793,0.004829,-0.016878,-0.019014,-0.011990,0.004895,0.016554,0.014930,0.005082,-0.015278,-0.017773,-0.010310,0.003790,0.012299,0.005284,-0.001349,-0.013396,-0.000344,0.009087,0.005812,-0.003481,-0.013724,-0.007816,-0.001418,0.004483,0.015247,-0.000146,-0.002851,-0.015310,-0.013893,-0.004685,0.002306,0.008831,0.006994,-0.001116,-0.006845,0.002198,0.001541,0.001781,0.002020,-0.005314,-0.003931,-0.005727,0.002519,0.005705,0.011206,0.002990,-0.006662,-0.011332,-0.009947,0.005988,0.007149,0.008939,-0.016326,-0.008668,-0.000675,0.014679,0.019979,0.003630,-0.015293,-0.013266,-0.010103,0.002225,0.014418,0.017505,0.003771,-0.001447,-0.005374,0.003284,0.005116,0.007749,-0.006471,-0.007047,-0.006836,0.003021,0.015682,0.005165,-0.005078,-0.012442},
  {-0.014720,-0.008640,0.003644,0.005728,0.008448,0.004402,-0.000219,-0.000461,-0.001228,0.000164,-0.000164,-0.003124,0.002549,-0.000475,0.003963,0.001836,0.001305,-0.001743,0.000456,-0.002007,-0.006524,-0.004661,-0.000272,0.003933,0.002657,-0.000105,0.001879,0.002035,-0.002390,-0.007872,-0.003252,-0.000047,-0.001524,0.002678,-0.001343,0.002209,-0.001069,0.001404,-0.001221,-0.000168,0.006601,0.001506,0.003851,-0.003052,-0.005694,-0.003380,-0.000697,-0.001541,-0.000101,0.000025,-0.000855,0.000532,0.004984,0.009123,0.014001,0.005713,-0.004401,-0.001457,-0.005086,-0.000406,0.001818,0.000473,0.000515,-0.002563,0.001977,0.002931,0.010637,-0.000206,-0.004790,-0.002276,-0.006806,0.001184,0.001335,0.002018,0.003025,0.002238,-0.001665,-0.002178,-0.001816,-0.000060,-0.004442,-0.002237,0.000409,0.004796,0.000513,0.001428,0.000166,0.003428,-0.004567,0.000514,0.001951,-0.001284,0.004464,0.002215,-0.005073,-0.002795,-0.004650,0.002657,0.000495,-0.001059,0.001449,0.003778,-0.004312,-0.003052},
  {0.017930,0.015024,0.002839,-0.007529,-0.011222,-0.005958,0.001919,0.006483,0.003601,-0.003925,-0.001991,-0.002955,0.000760,0.008063,-0.003859,-0.007914,-0.008731,-0.001489,0.006617,0.014691,0.012059,0.002568,-0.003266,-0.002482,0.005289,0.007974,-0.007977,-0.014792,-0.008453,0.004808,0.005462,0.007803,0.000546,-0.003284,0.001101,0.000482,0.005697,-0.007306,-0.012242,-0.004396,-0.002821,-0.000782,0.010545,0.001844,0.004015,-0.001159,-0.004627,-0.004611,-0.007784,-0.003500,-0.000408,0.009555,0.003042,-0.010649,-0.013972,-0.011358,0.001511,0.007979,0.009603,0.002746,-0.006589,-0.005711,0.000804,0.005545,-0.003815,-0.002735,-0.014191,-0.002879,0.007458,0.008737,0.009430,-0.001571,-0.006912,-0.010669,0.000249,0.001398,0.004340,-0.000884,-0.004721,0.001290,0.009093,0.014297,0.005501,-0.000832,-0.000913,-0.003161,0.000572,-0.006565,-0.002331,-0.010194,-0.004439,0.003624,0.010100,0.005786,0.002656,-0.000553,-0.006048,-0.005235,-0.005487,0.000223,-0.004407,0.006409,0.009959,0.001621},
  {0.003350,-0.030965,-0.008817,0.034924,0.002673,-0.018403,-0.093913,-0.055497,0.032228,0.067293,0.049336,-0.012166,-0.090224,-0.064961,-0.025590,0.061453,0.073408,-0.000269,-0.068445,-0.080265,-0.004489,0.056401,0.075911,0.041748,-0.048079,-0.082505,0.003276,0.048466,0.059593,0.041539,-0.003512,-0.038383,-0.025125,-0.027561,-0.046064,-0.028998,0.034340,0.061348,0.084990,0.028113,-0.034262,-0.078850,-0.078206,-0.019755,0.055614,0.077927,0.053086,0.011814,-0.019942,-0.015122,-0.032744,-0.028271,0.018261,0.020151,0.014945,-0.014779,-0.031195,-0.044973,0.017809,0.050922,0.066275,0.027657,-0.030201,-0.084445,-0.041287,0.036426,0.064890,0.055081,-0.013593,-0.072685,-0.059245,0.033325,0.090257,0.044662,-0.026977,-0.081448,-0.073060,-0.003782,0.052475,0.017314,-0.000450,-0.030601,-0.039512,-0.016004,-0.033226,-0.008179,0.026488,0.036382,0.066557,0.009543,-0.029382,-0.077803,-0.088346,-0.018201,0.059393,0.069341,0.056334,0.007158,-0.013436,-0.046905,-0.036720,-0.014005,-0.013627,0.051942},
  {0.083036,-0.035596,-0.121948,-0.107879,-0.040137,0.048928,0.105001,0.091284,0.017226,-0.052291,-0.085441,-0.049326,0.008830,0.075070,0.087473,0.038707,-0.027109,-0.101416,-0.101246,-0.022380,0.066056,0.140915,0.112194,0.011819,-0.107562,-0.148382,0.043377,0.102049,0.093498,0.004894,-0.079741,-0.070368,-0.017833,0.048492,0.066119,0.012700,-0.029742,-0.053656,-0.044642,0.005755,0.041202,0.034792,0.022122,-0.019993,-0.029034,-0.023918,0.018292,0.046729,0.021576,-0.017263,-0.054450,-0.054407,-0.120329,-0.133005,-0.055431,0.037921,0.109276,0.103677,0.036830,-0.046440,-0.098891,-0.060253,-0.004086,0.052244,0.079693,0.055483,-0.015986,-0.082489,-0.091168,-0.046939,0.049754,0.111917,0.104529,0.010493,-0.090026,-0.135262,-0.092506,0.027502,0.116854,0.047297,-0.055508,-0.089834,-0.049922,0.012454,0.065101,0.055492,-0.011912,-0.067632,-0.051075,0.005544,0.042141,0.057229,0.016707,-0.009218,-0.043919,-0.026330,-0.007743,0.042850,0.020537,-0.013384,-0.034027,-0.046363,-0.027269,0.026042},
  {-0.012352,-0.001089,0.007149,0.013153,0.012212,0.000809,-0.005446,-0.002007,-0.005325,0.000976,0.004793,-0.000421,-0.002641,0.004149,0.002437,0.004023,0.002946,-0.002009,-0.003768,0.002750,0.000797,-0.004471,-0.006704,-0.007457,-0.003098,0.009187,0.002171,-0.004100,-0.012889,-0.009174,0.007019,0.011999,0.004881,-0.004353,-0.009901,-0.007662,0.000302,0.010236,0.006919,0.004101,-0.001773,-0.004457,-0.004566,-0.004194,-0.008213,-0.004357,-0.000219,0.004586,0.010545,0.009625,0.002617,-0.008211,0.007152,0.011339,0.013761,0.001425,-0.008487,-0.010044,-0.009544,-0.000234,0.004784,0.000689,-0.001706,-0.000567,-0.001140,0.003400,0.006665,-0.002032,-0.006087,0.000274,-0.000453,0.001401,-0.002687,-0.002999,-0.003064,0.006628,0.005518,0.004108,-0.011559,-0.006120,-0.001456,0.007598,0.007779,0.000182,-0.010647,-0.008038,-0.003418,0.010748,0.008702,0.004298,-0.002842,-0.010261,-0.007096,-0.002107,0.000105,0.000423,0.002082,0.004482,0.007050,0.008874,0.001480,-0.007035,-0.013364,-0.011189},
  {-0.031024,0.028445,0.003716,0.044638,-0.001059,-0.005327,-0.011233,-0.004464,0.003981,-0.010590,0.001713,0.018577,-0.020730,0.040051,0.000124,-0.026941,-0.004974,0.007660,0.012449,-0.002163,0.017923,-0.022417,0.006445,-0.002958,-0.014470,-0.010871,0.027157,0.026274,-0.011192,-0.024630,-0.005593,0.006565,-0.016758,-0.029274,0.013198,0.013363,0.027381,0.021577,-0.017487,0.002759,-0.023405,0.009937,0.016378,0.001766,-0.017375,0.005751,0.036260,-0.020115,-0.004488,0.019779,0.003866,-0.022060,0.038535,-0.013122,-0.016514,0.019558,-0.006196,0.009469,-0.008736,-0.002178,-0.004435,-0.021004,0.003488,-0.011040,0.003775,-0.015611,-0.020705,0.020499,-0.010438,0.038507,-0.027081,0.006828,0.017274,-0.003293,0.004290,-0.011932,-0.012028,-0.039728,-0.023897,0.013340,0.004859,0.009020,0.011742,0.018453,0.036339,0.008425,0.004332,0.006953,-0.006677,0.032025,0.011725,-0.034154,-0.036860,0.042190,0.019580,0.003856,-0.028404,0.006848,0.014239,-0.023304,-0.012624,-0.017064,0.006064,0.023166},
  {-0.150693,-0.085093,-0.029386,0.006761,0.019519,0.033326,0.057738,0.099356,0.082703,0.017664,-0.056811,-0.090774,-0.090588,-0.051606,-0.015824,0.027000,0.058415,0.074508,0.082931,0.052151,0.007912,-0.042802,-0.077044,-0.090935,-0.079250,-0.041666,0.059638,0.084621,0.093919,0.057335,0.006482,-0.040518,-0.067315,-0.069452,-0.043646,-0.033601,0.002471,0.044440,0.072801,0.093158,0.071124,0.006774,-0.052856,-0.086921,-0.060506,-0.046425,-0.023453,-0.016578,-0.001615,0.044944,0.129139,0.154406,0.007805,0.065956,0.080707,0.060002,0.047163,0.051480,0.040564,-0.012422,-0.068405,-0.095797,-0.087345,-0.027755,0.021278,0.071728,0.070884,0.072999,0.045107,0.033809,-0.018163,-0.070884,-0.091421,-0.087445,-0.056255,-0.000861,0.051448,0.089619,0.065245,0.012308,-0.036114,-0.077490,-0.090438,-0.079062,-0.028980,0.008464,0.051983,0.064881,0.074149,0.062715,0.026906,-0.014537,-0.078641,-0.110914,-0.080457,-0.021115,0.030152,0.042551,0.026028,0.039318,0.065865,0.098313,0.048653,-0.043639},
  {0.019683,0.168944,0.185689,0.060058,-0.076922,-0.141492,-0.072578,0.026683,0.078433,0.069430,-0.007497,-0.077547,-0.062878,-0.019860,0.080043,0.109119,0.059439,-0.035750,-0.113199,-0.106597,-0.054684,0.051743,0.123011,0.104650,0.036865,-0.071388,-0.103233,-0.008814,0.072243,0.087569,0.075754,0.004422,-0.046749,-0.051412,-0.034981,-0.018689,-0.018779,-0.001068,0.025515,0.063648,0.065411,0.027832,-0.040461,-0.079150,-0.086436,-0.025697,0.020717,0.055285,0.059055,0.041215,0.020158,0.001703,0.186794,0.094492,-0.050245,-0.147803,-0.133792,-0.019905,0.074620,0.102450,0.035673,-0.058364,-0.091581,-0.033187,0.046451,0.094785,0.069434,-0.028255,-0.097953,-0.107290,-0.044355,0.045696,0.107155,0.116838,0.045935,-0.060905,-0.138128,-0.120475,0.077283,0.128062,0.080191,0.000137,-0.059322,-0.080121,-0.052086,-0.005385,0.008501,0.030401,0.029839,0.053738,0.038169,0.013258,-0.026640,-0.080902,-0.083522,-0.015534,0.043817,0.080205,0.073469,0.028649,-0.005072,-0.029835,-0.051156,-0.087148},
  {0.001159,-0.003358,-0.005748,-0.003990,-0.002569,0.001932,0.003582,0.003801,0.002457,0.000991,-0.000485,-0.001403,-0.002488,-0.000840,-0.000163,0.000618,-0.000376,0.000801,0.001377,0.001605,0.002480,0.001184,0.000637,-0.000996,-0.003210,-0.001048,-0.000948,0.000928,0.000821,0.001611,0.000727,0.001351,-0.000962,-0.000443,-0.000350,-0.000420,-0.002090,-0.002583,-0.001344,0.000597,0.002235,0.003180,0.003643,0.001064,-0.000496,-0.002695,-0.002849,-0.003851,-0.002629,-0.000087,0.003295,0.004459,-0.005098,-0.006763,-0.002349,0.003541,0.004333,0.003655,0.002828,0.000638,-0.002507,-0.003249,-0.002212,-0.003919,-0.000073,0.000814,0.001500,0.002530,0.001161,0.000442,-0.000057,-0.000114,-0.001717,-0.001584,-0.002783,-0.001547,-0.001412,0.000268,0.001733,0.002573,0.001431,-0.000196,-0.002059,-0.000027,-0.000983,-0.000235,-0.002483,-0.000319,-0.000710,-0.000161,0.002799,0.002186,0.002432,0.003394,-0.000301,-0.002794,-0.003009,-0.003467,-0.001903,0.000884,0.002013,0.002652,0.005443,0.003638},
  {0.073287,0.051173,-0.019206,-0.068350,-0.077823,-0.003441,0.026109,0.039999,-0.004598,-0.043936,-0.033251,0.020614,0.066922,0.039405,-0.022400,-0.069364,-0.058996,-0.021060,0.019588,0.032320,-0.000312,-0.020294,-0.011226,0.023057,0.031775,0.004735,-0.064202,-0.041237,0.007294,0.033526,0.040689,0.000895,-0.005277,0.009882,0.023507,0.000429,-0.029856,-0.052620,-0.036003,0.010239,0.049224,0.050019,0.000988,-0.026800,-0.012348,0.005671,0.015186,-0.015606,-0.026051,-0.037123,-0.002536,0.031413,0.011447,-0.074689,-0.086423,-0.031010,0.031715,0.065949,0.040003,-0.026257,-0.040691,-0.006734,0.039589,0.052935,0.005839,-0.057851,-0.078477,-0.031113,0.031614,0.065023,0.037454,-0.012087,-0.018282,-0.015352,0.011278,0.016691,-0.018054,-0.055773,-0.006726,0.032807,0.051044,0.030388,-0.014339,-0.010985,-0.011759,0.001214,-0.011093,-0.029140,-0.028538,0.004994,0.032180,0.058639,0.024683,-0.025974,-0.033127,-0.022495,0.012171,0.005394,0.003023,-0.022363,-0.014684,0.031182,0.036640,0.047481},
  {0.149573,0.108530,-0.003231,-0.089488,-0.134702,-0.095742,0.007388,0.087491,0.120652,0.087982,0.011956,-0.043028,-0.070245,-0.042137,-0.012224,-0.007592,0.028061,0.032733,0.027798,0.023619,-0.008139,-0.013297,-0.028507,-0.023369,-0.005146,0.041133,0.034895,-0.058476,-0.103120,-0.078437,-0.005310,0.109502,0.112381,0.031670,-0.051820,-0.108834,-0.048429,0.044000,0.050329,0.009803,-0.063693,-0.084784,0.008907,0.093171,0.122191,0.022557,-0.075041,-0.137582,-0.088610,0.011409,0.118821,0.098073,0.006575,-0.101259,-0.153285,-0.102418,-0.008234,0.101091,0.139417,0.098073,-0.000389,-0.055524,-0.099257,-0.080991,-0.014323,0.029326,0.057715,0.046813,0.019345,-0.012450,-0.008649,-0.033082,-0.023825,-0.027265,-0.009217,0.044100,0.066595,0.044337,-0.076170,-0.070824,-0.007576,0.089065,0.115966,0.049753,-0.037384,-0.101224,-0.084088,-0.004763,0.065423,0.078479,-0.000044,-0.048112,-0.044242,0.051180,0.095017,0.058603,-0.050932,-0.121807,-0.130089,-0.010868,0.107047,0.125044,0.060210,-0.039129},
  {0.168039,0.115193,-0.002813,-0.056896,-0.062130,-0.098908,-0.025984,0.036835,0.091869,0.103270,0.053598,0.039740,-0.027020,-0.068393,-0.050384,-0.040076,0.005328,0.084083,0.073908,0.076120,0.022264,-0.058990,-0.032796,-0.102596,-0.082421,-0.026031,0.081700,0.073735,0.038157,-0.024527,-0.083306,-0.070753,-0.050558,0.039780,0.093379,0.103365,0.087409,0.041728,-0.038505,-0.025627,-0.063883,-0.073554,-0.062852,-0.004553,0.027698,0.074418,0.091930,0.073312,0.007800,-0.092107,-0.118299,-0.124532,0.012887,-0.084632,-0.154699,-0.072682,-0.078648,-0.014363,0.077956,0.077760,0.048528,0.023201,-0.017912,-0.103344,-0.054839,-0.002756,0.010410,0.068602,0.047492,0.103099,0.067734,-0.010292,-0.062927,-0.021669,-0.051446,0.009672,0.010616,0.110936,-0.010079,-0.047461,-0.094171,-0.116339,-0.032570,-0.015098,0.066996,0.104937,0.087288,0.034967,-0.053833,-0.114528,-0.064930,-0.045276,-0.034636,-0.006880,0.032011,0.090658,0.126374,0.048650,-0.056662,-0.090890,-0.102105,-0.115296,0.003237,0.131403},
  {-0.026494,-0.083821,-0.064935,-0.059077,0.018309,-0.005797,0.030488,-0.009418,0.027524,0.040900,0.019802,-0.027777,-0.027894,-0.096774,-0.020614,0.017642,0.051059,0.047054,-0.024127,-0.039640,-0.039722,-0.005808,0.030070,0.015064,0.016867,-0.043486,0.009703,0.018913,0.007341,-0.032792,-0.007854,0.000009,0.069106,0.053195,0.010295,-0.042740,-0.065008,-0.030810,0.005322,0.024265,0.010020,-0.016256,-0.048860,0.035117,0.039681,0.084007,0.015181,-0.049923,-0.096304,-0.113153,-0.061787,0.047899,-0.143331,-0.030028,0.025072,0.040765,0.047401,0.028282,-0.013307,0.002479,0.019675,-0.000979,-0.046824,-0.016799,-0.024922,0.017301,0.055323,0.031177,-0.002253,-0.046303,-0.006323,-0.004709,0.048565,0.059348,0.021616,-0.021048,-0.028073,-0.027639,0.028206,-0.005282,-0.017888,-0.002783,0.054123,0.025464,0.015743,-0.045061,-0.042775,-0.056534,-0.003699,0.064406,0.046496,0.030188,-0.011015,-0.057364,-0.004440,0.042156,0.032246,-0.024495,-0.051530,-0.070810,-0.004069,0.069859,0.096894,0.082246},
  {0.001996,0.002913,0.000612,-0.000036,-0.002059,0.002326,0.003466,0.003037,-0.003105,-0.004573,-0.002938,0.000427,0.003318,0.006639,0.000753,-0.002799,-0.002850,-0.002741,0.001927,0.002828,-0.001192,-0.000620,-0.000526,0.000070,0.000149,0.002713,-0.000485,0.000380,-0.000168,-0.000307,-0.003006,-0.001858,-0.003072,0.000214,0.003335,0.001712,-0.000955,-0.002632,-0.001023,0.002406,0.002858,0.000740,-0.000966,-0.004793,-0.001237,0.000195,0.002704,0.000054,-0.001429,-0.000647,0.002702,0.003713,0.004890,-0.002909,-0.003175,0.000896,0.001418,0.002106,-0.000016,-0.002395,-0.004554,-0.002285,0.003615,0.001938,0.001890,-0.001941,-0.002988,-0.002644,0.001387,0.002710,-0.001735,-0.000635,-0.002795,-0.001748,0.001009,0.002790,0.000628,-0.000496,-0.000893,0.000951,-0.000293,-0.001579,-0.003274,0.001566,0.002940,0.003594,-0.001007,-0.000941,-0.002503,-0.000316,0.002558,0.001214,-0.000582,0.000487,-0.000688,0.000535,0.002496,0.001529,-0.001488,-0.001597,-0.001716,-0.000274,0.003977,0.001540},
  {-0.035808,-0.047510,0.009002,-0.015336,-0.035976,-0.030206,0.008279,0.045134,0.066313,0.022833,-0.054199,-0.104711,-0.063054,-0.023399,0.047211,0.063979,0.022174,-0.025301,-0.004706,0.040230,0.017794,-0.029515,-0.072651,-0.128270,-0.059096,0.051105,0.110936,0.058973,-0.052698,-0.133976,-0.081585,-0.078649,0.001956,0.053065,0.089290,0.094075,0.055228,-0.022826,-0.090383,-0.119449,-0.079109,0.002090,0.081831,0.133532,0.064261,0.001476,-0.103479,-0.100974,-0.050544,0.005827,0.035989,0.065874,-0.011798,-0.020697,0.008153,0.027123,0.009634,0.034986,0.032289,0.021701,-0.028424,-0.080194,-0.071918,-0.012538,0.046593,0.084314,0.047825,-0.022664,-0.025332,-0.012031,0.010662,0.004998,-0.056449,-0.078009,-0.061792,0.041172,0.083101,0.098954,-0.079302,-0.128300,-0.107441,-0.063648,0.045266,0.086387,0.064688,0.079645,0.025982,-0.023688,-0.081842,-0.101312,-0.084195,0.004784,0.102568,0.137129,0.091480,0.021116,-0.072926,-0.113831,-0.038833,0.012488,0.072159,0.076181,0.042951,0.013758},
  {0.044956,0.093869,0.068275,0.044760,0.035466,0.050678,0.023038,-0.024903,-0.093001,-0.116275,-0.072424,0.010679,0.070657,0.069803,0.047140,0.031000,0.036508,0.013549,-0.019489,-0.064278,-0.096751,-0.074940,-0.036362,0.015647,0.042805,0.057664,0.087205,0.039346,-0.033425,-0.117958,-0.139067,-0.088439,0.011226,0.078259,0.088387,0.036351,0.020670,0.034639,0.045293,0.023108,-0.048337,-0.126633,-0.134882,-0.061653,0.058668,0.110305,0.100626,0.044509,0.015070,0.012341,0.014305,-0.043365,0.138710,0.047924,-0.003745,-0.021656,-0.010965,-0.026324,-0.069851,-0.100185,-0.061314,0.030543,0.090567,0.114345,0.060263,0.010657,-0.024092,-0.027230,-0.035742,-0.052417,-0.070189,-0.065787,-0.005305,0.034052,0.071927,0.077616,0.066104,0.038788,-0.054516,-0.116369,-0.129495,-0.071881,0.021153,0.104379,0.125699,0.073631,0.012082,-0.029371,-0.013986,0.001609,-0.047796,-0.082100,-0.109209,-0.058420,0.053520,0.138452,0.132408,0.058471,-0.027049,-0.066239,-0.048066,-0.026132,-0.080042,-0.101892},
  {0.010567,0.001772,-0.007699,0.001407,0.013648,0.003325,0.002629,-0.008213,-0.004832,-0.001803,0.015680,0.016298,0.014306,0.004043,-0.002705,-0.010653,-0.005577,0.004102,0.005412,-0.002488,0.006260,-0.003569,0.002004,-0.001440,-0.008305,-0.004168,-0.003387,-0.008964,-0.003354,0.003131,0.002854,0.011669,0.014190,-0.002670,0.007928,0.006647,-0.003262,0.001620,-0.013644,-0.008544,-0.001925,0.001065,0.013272,0.010209,-0.002942,-0.014426,-0.012906,0.005855,0.007678,0.003858,-0.012222,-0.018307,-0.008426,-0.004483,-0.002701,0.001077,0.004634,-0.005644,-0.009160,-0.008904,0.008443,0.011831,0.011401,0.004924,-0.011876,-0.013798,-0.009308,-0.001722,-0.003024,0.015322,0.007321,0.000734,0.001303,0.002901,-0.010551,-0.003151,0.000095,-0.000109,0.001302,0.002211,0.003367,0.002431,0.009738,-0.005972,0.008343,-0.002118,-0.002331,0.004531,-0.009694,-0.009812,-0.000831,0.000905,0.011715,0.009036,-0.001059,-0.011183,-0.008624,-0.002180,0.000662,0.008243,-0.002219,-0.011433,-0.002750,0.001268},
  {0.025182,0.060767,0.091053,0.084840,0.034185,-0.045123,-0.112412,-0.136563,-0.098498,0.029129,0.134120,0.168531,0.113569,-0.027874,-0.112299,-0.143880,-0.110098,-0.047522,0.042016,0.139792,0.130545,0.088084,-0.002706,-0.102625,-0.131074,-0.106136,0.050360,0.076787,0.051172,-0.002382,0.015882,0.019734,0.018353,-0.016847,-0.091351,-0.121113,-0.059766,0.049900,0.138610,0.145265,0.052329,-0.068358,-0.135500,-0.106058,-0.036377,0.060595,0.079884,0.080178,0.034050,-0.000550,-0.053379,-0.056040,0.065486,0.038887,0.018387,-0.044834,-0.098513,-0.117751,-0.073410,0.033674,0.126608,0.159041,0.096027,-0.029741,-0.133797,-0.154996,-0.109093,-0.024728,0.090084,0.139049,0.134311,0.069063,-0.039545,-0.119776,-0.136484,-0.096384,-0.031930,0.070018,0.070475,0.028831,-0.026511,-0.029032,-0.001335,-0.020366,-0.067428,-0.068990,-0.060379,0.032297,0.126295,0.153285,0.054294,-0.068955,-0.145352,-0.130156,-0.044692,0.085402,0.115826,0.107470,0.041642,-0.046905,-0.059838,-0.064061,-0.066768,-0.043867},
  {-0.020215,-0.170849,-0.188082,-0.060621,0.078093,0.143563,0.073790,-0.026870,-0.079663,-0.070423,0.007513,0.078533,0.063716,0.020020,-0.080946,-0.110564,-0.060139,0.036426,0.114472,0.108099,0.055496,-0.052342,-0.124802,-0.106045,-0.037389,0.072163,0.104721,0.009082,-0.072903,-0.088386,-0.076753,-0.004465,0.046906,0.051755,0.035048,0.018722,0.019080,0.001420,-0.025493,-0.064086,-0.066175,-0.028093,0.040758,0.079799,0.087306,0.025961,-0.020756,-0.055968,-0.059750,-0.041613,-0.020166,-0.001382,-0.189077,-0.095184,0.051077,0.149628,0.135448,0.020012,-0.075598,-0.103894,-0.036307,0.058924,0.092673,0.033466,-0.046761,-0.095960,-0.070220,0.028725,0.099205,0.108577,0.045020,-0.046316,-0.108461,-0.118350,-0.046336,0.061697,0.140019,0.122203,-0.077899,-0.129335,-0.081293,-0.000107,0.059648,0.080830,0.052625,0.005398,-0.008601,-0.030458,-0.029916,-0.054052,-0.038471,-0.013595,0.026648,0.081466,0.084256,0.015447,-0.044388,-0.080965,-0.074252,-0.028914,0.005262,0.030262,0.051831,0.087907},
  {-0.166567,-0.131318,-0.016547,0.080699,0.112082,0.127827,0.052842,-0.028011,-0.093478,-0.129277,-0.081600,-0.025065,0.051936,0.073358,0.083956,0.060889,0.005095,-0.079572,-0.094959,-0.091229,-0.030920,0.032617,0.054742,0.104506,0.074913,0.003759,-0.103280,-0.098981,-0.057396,0.030948,0.090154,0.107822,0.090184,0.012544,-0.083367,-0.122775,-0.119460,-0.073496,0.034461,0.073905,0.104498,0.094007,0.046655,-0.007664,-0.050930,-0.084155,-0.102632,-0.085881,-0.014424,0.109222,0.156082,0.144233,-0.000927,0.094236,0.163494,0.112515,0.067670,-0.026248,-0.096457,-0.120837,-0.080464,-0.012682,0.049476,0.111569,0.073761,0.022880,-0.019484,-0.078077,-0.083518,-0.084674,-0.047790,0.034277,0.082535,0.057496,0.053463,-0.017650,-0.051393,-0.106116,-0.017190,0.042624,0.097808,0.115390,0.061634,0.019663,-0.067645,-0.131492,-0.121366,-0.050206,0.053724,0.122893,0.105028,0.074252,0.018116,-0.030387,-0.082084,-0.100808,-0.093844,-0.037879,0.053082,0.090959,0.144044,0.131806,0.013441,-0.127430},
  {-0.006421,-0.007218,0.003626,0.008792,0.004706,-0.001190,-0.006266,-0.005106,-0.002227,0.003805,0.001975,0.000169,0.000287,-0.001005,-0.001045,0.003051,0.004009,-0.000099,-0.001664,-0.003527,-0.006525,-0.002613,0.001358,0.004265,0.001268,0.001288,-0.005102,-0.004043,-0.001974,0.001888,0.003475,0.001897,0.000067,-0.001554,-0.001171,0.000195,0.002693,0.003235,0.000617,-0.001180,-0.002105,-0.001996,-0.002445,-0.000963,0.001334,0.003691,0.005715,0.000295,-0.003673,-0.003499,-0.004840,0.000402,0.001894,0.003600,0.007589,0.001610,-0.005643,-0.005976,-0.003040,0.002647,0.004413,0.003085,0.000282,-0.003128,-0.000034,0.001535,0.004515,-0.000459,-0.001195,-0.005021,-0.005464,-0.001658,0.001044,0.000733,0.001828,0.002882,-0.003736,-0.004755,-0.004142,0.004152,0.004003,0.002875,-0.000159,-0.002411,-0.002283,-0.000407,0.002077,0.000126,0.000546,0.002128,-0.003704,-0.001570,-0.001885,0.000739,0.000350,0.002455,0.004112,0.002889,0.000417,-0.005313,-0.004818,0.001751,0.000220,0.003516},
  {-0.042847,-0.105864,-0.113293,-0.040595,0.028941,0.106361,0.088973,0.037126,-0.028978,-0.025429,-0.008440,-0.013823,-0.045769,-0.036158,-0.012031,0.038900,0.086439,0.075505,0.010330,-0.058694,-0.092933,-0.037985,0.030231,0.042745,0.009144,0.009962,0.008487,0.035017,-0.005755,-0.050894,-0.067297,-0.022406,0.014309,0.064993,0.049045,-0.016462,-0.075611,-0.047162,0.016914,0.071203,0.034138,-0.040268,-0.065066,-0.046132,0.050123,0.095874,0.069189,-0.056327,-0.129624,-0.128802,-0.000826,0.109249,-0.106845,-0.085223,0.020985,0.135942,0.094041,0.035459,-0.033180,-0.058892,-0.052395,-0.028743,-0.013574,-0.050216,-0.005807,0.021005,0.082965,0.082685,0.022563,-0.061522,-0.113717,-0.072807,-0.005182,0.066015,0.056717,0.027530,-0.029066,-0.024553,0.009943,0.003787,-0.039969,-0.042249,-0.007740,0.073785,0.060804,0.024228,-0.079181,-0.049794,-0.019094,0.050954,0.068443,-0.000150,-0.047648,-0.024141,0.021782,0.083432,0.081867,-0.016289,-0.116314,-0.120706,-0.053732,0.059254,0.176113,0.140174},
  {-0.026816,0.043278,0.057472,0.036564,0.013549,-0.006234,-0.008593,-0.012815,-0.042269,-0.056058,-0.023994,0.042099,0.100003,0.112135,0.043554,-0.051214,-0.129573,-0.122277,-0.038424,0.049497,0.128070,0.125794,0.058164,-0.021890,-0.093808,-0.120882,-0.008488,0.077666,0.132592,0.119113,0.029689,-0.064663,-0.135695,-0.123291,-0.035453,0.076191,0.142508,0.131372,0.045866,-0.068732,-0.145255,-0.138871,-0.045336,0.067862,0.157475,0.138668,0.038350,-0.087425,-0.158996,-0.112456,0.010313,0.112271,0.068502,0.059944,0.014547,-0.034208,-0.032161,-0.024260,-0.020265,-0.023277,-0.010391,0.024234,0.070312,0.092852,0.035881,-0.047116,-0.121669,-0.118357,-0.049135,0.067477,0.128280,0.123463,0.047856,-0.044571,-0.108446,-0.129523,-0.069319,0.012225,0.134620,0.100480,0.016115,-0.078179,-0.139036,-0.119722,-0.021058,0.069885,0.143265,0.127903,0.040008,-0.076231,-0.148516,-0.140204,-0.049400,0.063131,0.146764,0.142480,0.046194,-0.078787,-0.169047,-0.136903,-0.023073,0.108565,0.149150,0.072892},
  {0.038738,-0.057314,-0.104353,-0.098022,-0.026874,0.064093,0.121144,0.098813,0.011011,-0.081416,-0.131151,-0.101080,-0.000886,0.075346,0.112351,0.068711,-0.009466,-0.062261,-0.061435,-0.017283,-0.007895,-0.007573,-0.000702,0.016643,0.058726,0.055869,-0.085035,-0.106566,-0.047519,0.060844,0.154403,0.109224,-0.018570,-0.140413,-0.168358,-0.072204,0.066032,0.147051,0.126690,0.037989,-0.052399,-0.089404,-0.083440,-0.045036,-0.021088,0.033909,0.070708,0.101403,0.075065,-0.012889,-0.120515,-0.142187,-0.112853,-0.107641,-0.026335,0.068332,0.112728,0.094782,0.013403,-0.075034,-0.125752,-0.105556,-0.013469,0.082777,0.126285,0.086441,-0.003291,-0.084459,-0.084407,-0.042087,0.012056,0.033156,0.017355,0.016425,0.029500,0.038193,-0.002964,-0.055850,-0.065063,0.036675,0.118914,0.117376,0.023518,-0.109405,-0.175158,-0.094518,0.040542,0.157464,0.152875,0.055632,-0.069971,-0.128125,-0.096345,-0.033608,0.022065,0.064131,0.074778,0.075879,0.060208,-0.014562,-0.089962,-0.131231,-0.087457,0.023086},
  {0.006158,-0.001851,0.002959,0.006449,0.000733,-0.004850,0.002224,-0.005473,-0.002108,0.001104,0.003475,0.003843,0.007036,0.006633,-0.003308,-0.012734,-0.003038,-0.000853,0.002835,0.005064,-0.006529,-0.002450,0.006443,0.004284,-0.000572,0.002896,-0.009924,0.009361,-0.000436,0.006386,0.004583,-0.008669,-0.008840,-0.005568,0.000462,0.001453,0.010138,0.001971,-0.001515,-0.001362,0.003211,-0.000741,-0.002541,-0.005770,-0.000190,0.000883,0.004252,0.007038,0.006520,-0.005473,-0.002522,-0.010066,0.004009,0.000575,-0.004597,-0.001041,-0.002331,-0.003332,-0.001211,0.004019,0.001868,0.001874,0.005018,0.004004,-0.002377,-0.011455,-0.002607,-0.000771,0.003048,0.006884,-0.005471,-0.002900,0.003974,-0.001483,0.002090,0.003891,-0.003449,-0.008274,-0.002508,0.005327,0.011032,-0.008891,-0.005953,-0.004439,-0.001254,0.003069,0.011902,0.002779,-0.002608,0.001079,-0.002085,-0.000246,-0.000044,0.000790,0.000206,0.000299,0.002899,0.004377,-0.000000,-0.003537,-0.002287,-0.009653,-0.003995,0.008153},
  {0.074502,0.020135,-0.058506,-0.102830,-0.090157,-0.032284,0.021019,0.090740,0.059949,0.040809,0.018417,-0.009572,-0.059870,-0.093526,-0.069944,0.040556,0.093208,0.091248,0.070977,-0.002047,-0.069471,-0.097443,-0.070830,0.013080,0.079667,0.063419,-0.009173,-0.028818,-0.022728,-0.033322,-0.019475,-0.012974,0.021414,0.069063,0.056053,0.039500,0.001897,-0.056382,-0.051438,-0.041275,-0.005922,0.024217,0.038984,0.041222,0.063987,0.069317,0.009131,-0.025947,-0.117827,-0.084138,-0.061351,0.056353,-0.065460,-0.104378,-0.054663,-0.042164,0.065994,0.084645,0.080260,0.033207,-0.011052,-0.050161,-0.058131,-0.050969,-0.055334,0.027793,0.054596,0.082937,0.074148,0.024195,-0.087069,-0.100004,-0.095746,-0.019792,0.086678,0.066491,0.021116,-0.004336,-0.053133,-0.029772,-0.025374,-0.004877,0.031104,0.044181,0.048079,0.027117,-0.023541,-0.067486,-0.054091,-0.052957,-0.024613,0.011775,0.041254,0.033855,0.025765,0.043233,-0.008684,-0.019072,-0.080249,-0.122868,-0.045223,0.068045,0.084582,0.063865},
  {-0.008936,-0.017740,-0.013014,-0.001050,0.011318,0.009609,0.001130,-0.004561,-0.006352,-0.001427,0.006931,0.008600,0.003961,0.000210,-0.005991,0.004334,0.016483,0.000741,0.004777,-0.010653,-0.009746,0.003490,0.017161,0.007517,0.000721,-0.008171,0.000666,0.005140,0.007958,0.001238,-0.007427,-0.002813,0.000713,0.001930,0.002561,-0.000351,0.000805,0.002925,0.003955,-0.003017,-0.003636,-0.008757,-0.001305,0.002279,0.006658,0.003456,0.000305,0.000672,-0.006132,-0.004372,-0.000516,0.004267,-0.017194,0.000288,0.009317,0.015269,0.009856,0.001465,-0.010185,-0.005533,0.003881,0.010763,0.007237,0.002540,-0.009653,-0.000196,0.010750,0.005656,0.000677,-0.005117,-0.014935,-0.005219,0.008869,0.008909,0.003709,-0.006253,-0.014470,-0.001501,0.009378,0.005022,-0.005211,-0.009642,-0.002569,-0.001948,0.009805,0.001851,0.003926,-0.001285,0.002446,-0.001495,-0.001995,-0.004440,-0.006241,0.001774,0.004530,0.008506,0.003133,-0.001058,-0.009993,-0.005707,-0.003037,0.006314,0.007882,-0.000956},
  {0.001600,0.013866,0.008057,0.003669,-0.008066,-0.011619,-0.014203,-0.009852,0.001993,0.009745,0.011010,0.008192,0.000584,-0.005294,-0.007199,-0.002004,-0.001253,-0.003348,-0.006213,0.003154,-0.001973,-0.000354,0.001445,-0.001765,0.000933,0.001174,-0.003551,-0.004738,-0.001212,0.001379,0.005596,0.013575,0.003011,0.001903,-0.005008,-0.006213,-0.007806,-0.006149,-0.001088,0.001326,0.010496,0.014729,0.006936,-0.002201,-0.014220,-0.012261,-0.001937,0.005629,0.010820,0.010632,-0.003649,-0.003542,0.007620,0.004263,-0.002098,-0.014199,-0.012030,-0.009016,0.007097,0.011329,0.010181,0.005759,-0.002888,-0.011649,-0.005985,-0.006794,-0.000923,0.000191,0.000628,0.002521,-0.002914,0.003347,0.005023,-0.003223,0.003074,0.001399,-0.003487,-0.000336,0.000013,0.003732,0.004770,0.012323,0.001016,-0.000272,-0.004311,-0.010492,-0.010408,0.000206,-0.002367,0.003415,0.008613,0.007261,0.006428,-0.000111,-0.010533,-0.015389,-0.006966,0.003669,0.014421,0.012102,-0.001492,-0.005253,-0.011029,-0.007776},
  {-0.074355,-0.019827,0.058282,0.102569,0.089870,0.032230,-0.020823,-0.090335,-0.059859,-0.040666,-0.018292,0.009672,0.059677,0.093023,0.069631,-0.040548,-0.092886,-0.090735,-0.070729,0.002249,0.069328,0.097036,0.070316,-0.013138,-0.079361,-0.063250,0.009243,0.028809,0.022817,0.033359,0.019343,0.012858,-0.021613,-0.068875,-0.055982,-0.039310,-0.001817,0.056244,0.051308,0.041242,0.005932,-0.023942,-0.038875,-0.041214,-0.063831,-0.068986,-0.008939,0.025749,0.117186,0.083702,0.061161,-0.055808,0.065222,0.104316,0.054528,0.041857,-0.065826,-0.084470,-0.079935,-0.033106,0.010989,0.049924,0.057836,0.050632,0.055192,-0.027797,-0.054369,-0.082536,-0.073750,-0.023975,0.086888,0.099585,0.095294,0.019623,-0.086205,-0.066200,-0.020954,0.004464,0.053148,0.029882,0.025187,0.004836,-0.031248,-0.044154,-0.047894,-0.026938,0.023462,0.067325,0.053958,0.052824,0.024606,-0.011731,-0.041138,-0.033918,-0.025869,-0.043262,0.008621,0.019087,0.079935,0.122285,0.045089,-0.067641,-0.084031,-0.063666},
  {0.049280,0.030904,-0.012013,0.007698,0.035923,0.023768,-0.024568,-0.063324,-0.063496,-0.019238,0.068285,0.120948,0.072723,0.027547,-0.062861,-0.070449,-0.024983,0.021670,0.018994,-0.055611,-0.031943,0.027178,0.098402,0.149668,0.068965,-0.051305,-0.138222,-0.074494,0.046247,0.136132,0.096825,0.089767,0.021800,-0.045269,-0.077580,-0.099349,-0.069910,0.008479,0.086895,0.122783,0.090140,-0.011705,-0.088529,-0.139074,-0.062186,0.003232,0.109102,0.116433,0.056317,-0.017000,-0.056631,-0.096083,0.005302,-0.007617,-0.014876,-0.016636,-0.005992,-0.032687,-0.040472,-0.019642,0.043746,0.105735,0.089333,0.020669,-0.072517,-0.099646,-0.059167,0.025638,0.031053,0.017711,-0.022066,-0.009506,0.059014,0.092309,0.059599,-0.046746,-0.104545,-0.126311,0.070554,0.127617,0.128303,0.068837,-0.029622,-0.082082,-0.066380,-0.089501,-0.031111,0.011568,0.077228,0.100776,0.088453,0.002150,-0.104300,-0.135553,-0.087851,-0.003343,0.092754,0.118229,0.035208,-0.020930,-0.093432,-0.092468,-0.048174,0.008719},
  {-0.036271,-0.096968,-0.067597,0.033128,0.099446,0.084666,0.009166,-0.079814,-0.101279,-0.020955,0.060263,0.092316,0.044802,-0.046122,-0.067268,-0.040575,0.040832,0.055097,0.013398,-0.025669,-0.077808,-0.018181,0.055534,0.080367,0.037276,-0.051165,-0.071298,-0.002089,0.079247,0.079923,0.034457,-0.040773,-0.096486,-0.074636,0.001234,0.058542,0.093996,0.052670,-0.048049,-0.095558,-0.083055,-0.009657,0.081815,0.098633,0.036399,-0.052060,-0.088279,-0.048484,0.019210,0.053945,0.039070,-0.006886,-0.094905,-0.026534,0.077295,0.104977,0.033357,-0.057548,-0.106438,-0.056780,0.028038,0.103327,0.066481,-0.021889,-0.076514,-0.061580,0.008089,0.051966,0.053204,-0.015081,-0.050892,-0.053358,0.010273,0.058921,0.057015,0.003310,-0.079841,-0.081318,0.056338,0.107512,0.059346,-0.017427,-0.081372,-0.097468,-0.033847,0.066160,0.091559,0.059282,-0.015103,-0.061904,-0.092435,-0.020458,0.055853,0.104307,0.056438,-0.013593,-0.090800,-0.064643,-0.009120,0.048169,0.073442,0.019690,-0.044816,-0.055548},
  {0.090863,0.075747,0.042182,-0.056976,-0.140154,-0.116776,-0.079765,-0.006128,0.085019,0.122413,0.111926,0.002455,-0.072750,-0.119064,-0.134680,-0.080377,0.013589,0.081002,0.128468,0.077892,0.018403,-0.032436,-0.119039,-0.076280,-0.040869,0.015611,0.084850,0.101451,0.070232,0.020367,-0.056111,-0.134945,-0.139752,-0.109917,0.003771,0.104821,0.125865,0.086904,0.018229,-0.092030,-0.109822,-0.086561,-0.035247,0.001123,0.055990,0.086539,0.106110,0.055369,-0.006197,-0.094764,-0.147310,-0.114683,-0.011488,-0.069611,-0.100688,-0.118451,-0.021275,0.075809,0.111683,0.140851,0.096398,-0.012582,-0.112740,-0.113505,-0.119918,-0.074523,0.056381,0.113049,0.143112,0.035821,-0.042278,-0.104180,-0.110875,-0.120180,-0.032700,0.034403,0.122214,0.065529,0.069025,-0.006924,-0.056989,-0.087606,-0.125516,-0.027527,0.050856,0.112476,0.134279,0.077835,-0.007804,-0.064676,-0.124173,-0.086921,-0.003481,0.063968,0.097190,0.065628,0.033002,0.014268,-0.002224,-0.068685,-0.132319,-0.086689,-0.012012,0.071881}
};


float ReLU(float x);


void DNN_u(hls::stream<axis_data>&LS_stream, hls::stream<axis_data>&DNN_out);
void separate_complex_u(hls::stream<axis_data>&LS_stream, float y_sep[2*52]);
void normalize_u(float LS_data[2*52], float norm_data[2*52], const float mean[2*52], const float std[2*52]);
void L2_u(const float bias[52], const float w[52*2][52], float x[52*2], float y_L2[52]);
void L3_u(const float bias[2*52], const float w[52][2*52], float x[52], float y_L3[2*52]);
void denormalize_u(float DNN_data[2*52], float denorm_data[2*52], const float mean_o[2*52], const float std_o[2*52]);
void reconstruct_complex_u(float y_L3[52*2], hls::stream<axis_data>&DNN_out);
# 2 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.h" 2




const COMPLEXD preamble[200][52] = {
  {0.04594161+0.4319842i,0.02829762+0.2159984i,-0.5911033+0.6534573i,-0.3843374+0.7709873i,-0.5684851-0.07371457i,-0.8221473+0.1264263i,0.2294792+0.1942747i,-0.7110538+0.8687049i,-0.4081798-0.3513074i,0.2084641+0.8469589i,0.443772+0.35162i,0.2689997-0.1956961i,-0.2481629-0.4842703i,-0.8323304-0.3405268i,-1.16503+0.1627201i,0.3955546-0.06853064i,-0.05939899-0.4415805i,-0.04344464+1.108211i,0.3697448+0.7298977i,-1.118894+0.4968397i,0.1591728-0.2647463i,-0.3400401+1.121814i,-0.8276994-0.2603478i,-1.099223+0.18322i,-1.031767+0.701175i,-0.6497308+1.063521i,0.3180692+0.7918798i,-1.135916+0.415677i,-0.9093887+0.9101918i,-0.2603945-0.4623317i,-0.793824-0.3314233i,0.4468132+0.5739586i,-1.097808+0.668332i,0.04096699-0.4005977i,-0.1510928+1.166567i,-1.021994-0.17299i,-1.20418+0.3932917i,-0.9689484+0.9516087i,-0.416453+1.222121i,0.1829457+1.057877i,-1.200054+0.1506857i,-1.104279+0.7640916i,-0.0479339-0.4656896i,-0.64587-0.4376667i,0.3826898+0.717882i,-1.101854+0.522303i,0.1085056-0.2626593i,-0.2963957+1.062815i,-0.8079785-0.1657284i,-0.9976713+0.2454639i,-0.8962546+0.6671453i,-0.5676665+0.9286817i},
    {0.6377806+2.051117i,1.417587+1.443862i,-1.28342+0.8329443i,-0.838295+1.714623i,0.2889023-0.7993001i,-0.6524355-0.5354086i,1.559135+1.053256i,-1.137093+1.213885i,0.8398184-0.5897446i,0.4330713+2.028495i,1.220318+1.56117i,1.545056+0.7203496i,1.289464-0.132079i,0.5735695-0.6496038i,-0.310068-0.6295164i,1.361766+1.38716i,1.591159+0.5038728i,-0.8747386+1.676009i,-0.02036272+2.156286i,-0.640964-0.6832059i,1.710173+1.195802i,-1.405597+1.239851i,1.038569-0.8566018i,-0.1541969-1.105269i,-1.252895-0.4951918i,-1.69171+0.7148037i,-0.04876137+2.548955i,-0.8896878-0.9316181i,-1.663419+0.1401617i,1.905436-0.1368802i,0.9847271-1.055766i,0.6493869+2.478899i,-1.347675-0.4398041i,2.044568+0.5297933i,-1.187039+1.944634i,0.4052007-1.213162i,-0.8482948-0.9388622i,-1.64669+0.08420952i,-1.600552+1.397857i,-0.704758+2.382061i,-0.2781927-1.236337i,-1.402605-0.4845819i,2.108202+0.4897653i,1.518205-0.7208155i,0.05934133+2.548841i,-0.9483107-0.8273585i,1.95073+1.045066i,-1.387303+1.482162i,0.8236777-0.9316196i,-0.3200973-0.9291469i,-1.166956-0.2303655i,-1.378621+0.8032696i},
    {-1.363905+0.4745833i,-0.7467064+1.077741i,-0.4355227-1.238412i,-1.100013-0.7938334i,0.9836603-0.02878986i,0.7302099-0.7355272i,-0.4660621+1.047931i,-0.6194033-1.081079i,0.8150886+0.5030689i,-1.308004+0.1444228i,-0.9531472+0.8228689i,-0.2330836+1.136602i,0.5412629+0.9160351i,1.002551+0.2354991i,0.9115526-0.5937169i,-0.6528251+1.078595i,0.1837244+1.110691i,-1.183811-0.6826062i,-1.332548+0.1109319i,0.5898165-0.876812i,-0.2429321+1.048332i,-0.7854285-0.9061422i,0.7961993+0.2509896i,0.7468309-0.3873006i,0.3482752-0.8528338i,-0.2300643-0.999312i,-1.13289-0.2912546i,0.769566-0.4321752i,0.3619401-0.968811i,-0.02208417+1.069609i,0.6844175+0.764353i,-1.413565-0.1234324i,0.8640863-0.8098693i,-0.4859031+1.261524i,-0.8134909-1.272977i,1.139418+0.4823311i,1.187094-0.5179799i,0.5512733-1.312265i,-0.459678-1.489864i,-1.339156-0.9555078i,1.29533-0.1107184i,0.8935319-1.047218i,-0.3430298+1.403779i,0.6231154+1.159634i,-1.552678-0.449318i,1.128769-0.6084448i,-0.819265+1.216082i,-0.4835986-1.418975i,0.9315507+0.8205741i,1.229369-0.08258507i,0.8855275-0.9726602i,0.04882656-1.443708i},
    {0.4726306-0.404709i,0.4059781-0.1531414i,1.096676-0.57241i,0.8064986-0.7129278i,1.154923+0.156844i,1.357283-0.1699632i,0.3447863+0.112032i,0.9208574-0.8175901i,1.138701+0.2841046i,0.2147166-0.3790286i,0.279833+0.06744791i,0.6312678+0.3354882i,1.053089+0.2851961i,1.307701-0.02360232i,1.285267-0.3921746i,0.5722928+0.1661904i,0.8664214+0.1885273i,0.5393666-0.5066875i,0.4554151-0.2983121i,1.13325-0.3628972i,0.608384+0.06084i,0.8154249-0.6039487i,1.041824+0.1022731i,1.232407-0.09666079i,1.258813-0.4081776i,1.054546-0.6907397i,0.3282331-0.5652559i,1.416274-0.3089866i,1.21566-0.7112477i,0.8372384+0.4103413i,1.267235+0.2273326i,0.163866-0.2585619i,1.30307-0.6416143i,0.722951+0.3971855i,0.4615098-0.7438244i,1.397691-0.08407558i,1.330105-0.503646i,1.011128-0.7608559i,0.6184949-0.7410551i,0.3506356-0.4783238i,1.295851-0.3368809i,1.094812-0.6057369i,0.8322555+0.2140917i,1.091674+0.07892871i,0.4225052-0.2901299i,1.131199-0.4104309i,0.672693+0.08899698i,0.733505-0.5517276i,1.05285-0.02344331i,1.121154-0.2061504i,1.073456-0.3929902i,0.9251367-0.5187345i},
    {-0.9661869-0.1085212i,-0.7846948+0.5239426i,0.0847096-1.045498i,-0.6074103-0.9206479i,0.9288146+0.1909532i,0.8780561-0.5401348i,-0.4667696+0.8993467i,-0.4050885-1.099478i,0.8825648+0.4658045i,-1.142199+0.1306115i,-0.7439685+0.8007644i,0.006263881+1.045825i,0.7410287+0.7312716i,1.088618+0.0005888309i,0.8618702-0.7855961i,-0.2832256+1.064769i,0.5361325+0.9260671i,-1.17392-0.4344459i,-1.121006+0.3958949i,0.408416-1.13367i,0.2887986+1.001503i,-1.023573-0.6441597i,1.009355-0.2969728i,0.5769672-0.9294775i,-0.144031-1.104729i,-0.7740825-0.7668483i,-0.7695115+0.4851644i,0.09728505-0.9287591i,-0.4703659-0.785868i,0.6645574+0.174314i,0.6128881-0.3347853i,-0.3915153+0.5018863i,-0.162307-0.6939088i,0.3669731+0.3046079i,-0.5897073-0.121179i,0.3557253-0.3444073i,0.1103985-0.507817i,-0.1603287-0.504686i,-0.37221-0.3630057i,-0.4718641-0.1356772i,0.3116549-0.2724704i,0.133922-0.4607357i,0.01251943+0.3517621i,0.2688895+0.2274431i,-0.519231-0.1217743i,0.3315225-0.3377994i,-0.2064135+0.3676792i,-0.2241519-0.5215544i,0.3377283+0.1621487i,0.3965569-0.1302392i,0.2707377-0.3897127i,0.02471865-0.5217532i},
    {0.2661578-0.3657335i,-0.01774026+0.07299771i,1.623247-0.03159853i,1.291903-0.4856793i,0.8991892+1.243836i,1.511039+1.021016i,-0.2567966+0.156332i,1.756926-0.3251103i,0.4692796+1.418732i,0.3068211-0.8302251i,-0.3374317-0.2397102i,-0.4263749+0.6547912i,0.1143502+1.393411i,1.017966+1.584501i,1.819972+1.125352i,-0.4971445+0.3196626i,-0.1488767+1.156142i,0.9686525-0.976842i,0.1242844-0.7634193i,1.98724+0.647155i,-0.3087854+0.7559034i,1.36505-0.7663509i,1.039588+1.440737i,1.704463+1.030863i,1.965549+0.3039271i,1.718937-0.4240997i,0.299399-0.7639095i,1.878538+0.7875217i,1.968027-0.008708724i,0.09421321+1.2698i,0.8920112+1.516385i,-0.05916928-0.607955i,2.061384+0.4078544i,-0.2262099+1.016544i,1.115598-0.9402459i,1.376221+1.410996i,1.958751+0.7599906i,1.966161-0.09844232i,1.421124-0.7324954i,0.6226255-0.8508353i,1.649617+1.016442i,1.878904+0.3173852i,-0.01333898+0.9098589i,0.5547984+1.250448i,0.4324107-0.6054143i,1.634645+0.7636687i,-0.1345882+0.4067239i,1.492113-0.3848302i,0.6773759+1.256256i,1.319309+1.149556i,1.773057+0.6452891i,1.803586-0.05998683i},
    {0.4451918-0.2309155i,0.2294567-0.1980296i,0.6265734+0.1551387i,0.6076185-0.04031666i,0.2569336+0.2833846i,0.4235863+0.2827399i,0.1909344-0.06278805i,0.5624917+0.0523807i,0.2177742+0.1794053i,0.4135976-0.116649i,0.3007541-0.1153447i,0.2008196-0.04928164i,0.1525891+0.07462648i,0.1959477+0.2182i,0.3377457+0.3094664i,0.2059223-0.1570282i,0.08217429+0.00591894i,0.6194316-0.1023581i,0.4367098-0.246402i,0.5325059+0.339341i,0.04273803-0.02053222i,0.6525673-0.1090312i,0.279158+0.3848942i,0.5309253+0.348787i,0.6811652+0.1466565i,0.6444594-0.0987266i,0.2121892-0.2072748i,0.6542487+0.1397614i,0.616717-0.08730154i,0.2977925+0.3381998i,0.5165437+0.2929389i,0.09742421+0.01780028i,0.5681685-0.1055744i,0.3578836+0.3178993i,0.1741885-0.1045116i,0.6087654+0.01661903i,0.4788666-0.1584469i,0.258271-0.1649281i,0.1149833+0.008558476i,0.1659191+0.2338688i,0.3463494-0.212895i,0.1260484-0.1007481i,0.6530635-0.02892513i,0.4829384-0.2335026i,0.5204884+0.353591i,0.02769909-0.01364062i,0.650791-0.1493719i,0.3288558+0.4229984i,0.117083-0.2136315i,-0.007975603+0.05424616i,0.1025636+0.3260674i,0.3721119+0.4313496i},
    {1.447578-0.002088117i,1.451818-0.8282917i,-0.264026+0.6803311i,0.583649+0.813464i,-0.6751434-1.141432i,-0.9207326-0.3009762i,1.189218-1.28321i,0.2567168+0.8308479i,-0.4275356-1.345351i,1.485723-0.1811647i,1.312173-0.9839838i,0.6717287-1.454242i,-0.08902191-1.387038i,-0.5941954-0.8607426i,-0.6298115-0.1691245i,0.8742846-1.140126i,0.2758102-1.268281i,0.8712825+0.2110452i,1.075457-0.2725607i,-0.3017832-0.05763124i,0.5963599-0.9936318i,0.4382274+0.2040231i,-0.08628788-0.7992229i,-0.2163623-0.5059587i,-0.185097-0.2040166i,-0.01183206+0.04662238i,0.6425898+0.1494809i,-0.3121779-0.6726497i,-0.4136383-0.2151176i,0.8253311-1.050224i,0.2914556-1.288491i,0.9641298+0.3130039i,-0.6852185-0.52119i,1.205162-0.9916052i,0.03990464+0.6755726i,-0.1902154-1.416995i,-0.761197-0.8336273i,-0.7979683-0.004191907i,-0.269192+0.6461034i,0.5604798+0.784581i,-0.6325365-1.135417i,-0.8844461-0.3361616i,1.200543-1.223636i,0.4564232-1.595167i,0.9933795+0.6067071i,-0.8392807-0.7289683i,1.424921-0.8914093i,-0.2014227+0.6958293i,0.01535425-1.567893i,-0.6688552-1.091258i,-0.8801941-0.2860526i,-0.5203907+0.4604462i},
    {1.16903-0.4975942i,1.11108-1.014672i,0.1401586+0.183092i,0.7377102+0.2249169i,-0.3988232-1.062217i,-0.5367087-0.3979031i,1.028904-1.440559i,0.5315677+0.4460073i,-0.3808474-1.344984i,1.537596-0.6038621i,1.266984-1.359375i,0.5515721-1.737251i,-0.2325011-1.534818i,-0.675755-0.8624371i,-0.5580178-0.07453679i,0.8064399-1.649505i,0.03595302-1.629812i,1.371612-0.1018202i,1.457706-0.8371071i,-0.2024812+0.2183617i,0.3682918-1.631911i,1.117625+0.1207781i,-0.5598916-0.7210605i,-0.3868371-0.06880876i,0.1565217+0.312346i,0.8067352+0.2553199i,1.315039-0.8267623i,-0.1098474+0.1137221i,0.4772715+0.2736225i,-0.1706156-1.245896i,-0.4254421-0.7154828i,1.134554-1.067364i,0.1782141+0.1820261i,0.1109822-1.363535i,1.137104-0.243555i,-0.3383892-0.4356103i,-0.03281489+0.0002194127i,0.4686455+0.1282783i,0.9161608-0.09350496i,1.102898-0.5331568i,-0.1170322-0.2562421i,0.2397066-0.02805241i,0.2212324-1.146843i,-0.03318857-0.8913966i,0.9285222-0.6563148i,0.06332911-0.2965071i,0.53813-1.058288i,0.5837125-0.1843001i,0.05044125-0.8727913i,-0.04371923-0.6087978i,0.03271386-0.323088i,0.2774956-0.1252783i},
    {1.50982-0.5277519i,0.9274834-0.7615491i,1.574355+0.9928826i,1.962702+0.4222619i,-0.02579343+0.7168061i,0.5059849+1.247242i,0.5894381-0.8917549i,1.934605+0.8460706i,-0.2624762+0.3729044i,1.758644-0.702776i,0.9747738-1.034514i,0.1548502-0.775955i,-0.3061126-0.04369996i,-0.1860604+0.8166883i,0.4602272+1.400902i,0.5377025-1.016051i,-0.1608408-0.4845543i,2.233813+0.04489335i,1.838517-0.7549215i,0.8567337+1.544835i,0.1317465-0.8784006i,2.267278+0.5329573i,-0.3058411+0.8282657i,0.3805865+1.497116i,1.348328+1.562031i,2.132874+0.9771858i,1.88765-0.8531139i,0.8981829+1.634592i,1.823863+1.317297i,-0.4501394-0.06183162i,-0.2937072+0.8893238i,1.439747-1.092379i,1.381341+1.527796i,-0.2471394-0.5137901i,2.305484+0.008732102i,0.01453155+1.243936i,0.8954827+1.59475i,1.798675+1.293892i,2.293648+0.4767351i,2.13717-0.4673954i,0.4685131+1.499074i,1.417987+1.478007i,-0.2398764-0.424148i,-0.3422048+0.4919866i,1.700026-0.8094365i,1.015184+1.442326i,0.1088519-0.644911i,2.069898+0.3286388i,0.0290746+0.8144534i,0.6298296+1.201941i,1.298145+1.128803i,1.747542+0.6851244i},
    {-0.6893539-0.1651808i,-0.9671311+0.3201883i,0.6073704+0.002952682i,0.1628867-0.3774013i,0.166649+1.27395i,0.630021+0.8988442i,-1.01115+0.5747534i,0.4702621-0.2119051i,-0.1890693+1.333697i,-0.641886-0.2890165i,-0.9919983+0.1838859i,-0.9787372+0.7751124i,-0.6023775+1.241858i,-0.00533668+1.385615i,0.5740427+1.124778i,-1.144144+0.3516305i,-1.0103+1.035102i,0.1823682-0.614542i,-0.5911697-0.6112194i,0.9450998+0.9692386i,-1.331056+0.7628892i,0.5831349-0.6176403i,0.04066272+1.745375i,0.8805915+1.317601i,1.220247+0.4201948i,0.8626433-0.4796531i,-0.9286425-0.629189i,1.153647+0.7116481i,0.9802971-0.1889413i,-0.5396698+1.614601i,0.3056615+1.555979i,-1.141207-0.09977311i,0.9470614+0.2277068i,-0.8036714+1.259116i,-0.1145996-0.5741666i,0.4668252+1.232622i,0.8062969+0.6944454i,0.7547341+0.07043713i,0.3375519-0.3963538i,-0.2858493-0.5143978i,0.5990738+1.104389i,0.8672312+0.4942768i,-0.9433099+1.052656i,-0.3631429+1.443677i,-0.6056914-0.4721797i,0.8249785+0.831102i,-1.101336+0.7728108i,0.3818727-0.4243167i,0.04020986+1.416311i,0.6071303+1.055928i,0.7946814+0.4380719i,0.5511546-0.1275662i},
    {-1.226088-1.201534i,-1.471837-0.8478258i,-0.3219853-1.050036i,-0.6711947-1.343904i,-0.6016198-0.1293517i,-0.2674777-0.4531214i,-1.502783-0.5390797i,-0.5101578-1.287868i,-0.7741024-0.06830475i,-1.369367-1.171905i,-1.543668-0.7414821i,-1.398169-0.29423i,-0.9902967-0.04193897i,-0.5046509-0.1175801i,-0.1795433-0.5037945i,-1.542335-0.4342489i,-1.177583-0.05016998i,-1.094484-1.443453i,-1.517385-1.103775i,-0.1402264-0.888182i,-1.289205-0.1284455i,-0.9577563-1.437553i,-0.3418598-0.2771153i,-0.20174-0.742067i,-0.3989539-1.15945i,-0.7998018-1.331498i,-1.398823-0.8794587i,-0.3828326-0.9415684i,-0.6381359-1.184541i,-0.7569267-0.2447781i,-0.4834674-0.4355429i,-1.337551-0.7041721i,-0.535928-1.042682i,-0.9100317-0.2889588i,-1.113411-1.069442i,-0.4821574-0.6399719i,-0.5468801-0.9014621i,-0.7509489-1.035483i,-0.9621665-1.00125i,-1.075642-0.8619292i,-0.6608475-0.7367299i,-0.7226448-0.8223668i,-0.9479055-0.5975541i,-0.8906345-0.5758387i,-0.9202462-0.8932478i,-0.7132109-0.5948772i,-1.104298-0.7491528i,-0.6410632-0.875342i,-0.9571402-0.4425581i,-0.7425152-0.4300854i,-0.5626123-0.5735661i,-0.5213131-0.8102151i},
    {-1.525787-0.1859533i,-1.33195+0.6088113i,0.02931197-1.236198i,-0.7980871-1.19389i,0.7651473+0.4959868i,0.8714666-0.3262606i,-1.072033+0.8877339i,-0.3471403-1.273076i,0.4549051+0.8446255i,-1.490579-0.2867348i,-1.367288+0.4909531i,-0.7919644+1.022408i,-0.009296774+1.086527i,0.6547371+0.649631i,0.9114981-0.1208726i,-1.265481+0.7715351i,-0.5213334+1.212358i,-1.005816-1.20465i,-1.607975-0.501331i,0.9610044-0.5852238i,-0.9589429+1.180073i,-0.6624576-1.434085i,0.8336049+0.7364391i,1.064579-0.2201788i,0.6089347-1.07514i,-0.2757579-1.406694i,-1.556277-0.319417i,0.7541498-0.6377038i,0.1395394-1.149804i,-0.01716848+1.032892i,0.574524+0.5938077i,-1.415167-0.03905273i,0.5180648-0.7533784i,-0.5618692+0.9883947i,-0.7851837-1.05014i,0.6602005+0.4196057i,0.7591939-0.3021104i,0.3785065-0.9361696i,-0.3255856-1.191482i,-1.038771-0.9412896i,0.791501+0.1581863i,0.6864902-0.59652i,-0.7705579+0.9818379i,-0.00875797+1.033693i,-1.260915-0.7285594i,0.8322073-0.1448292i,-1.174891+0.7267556i,-0.1595287-1.232981i,0.2990006+0.9482341i,0.8151317+0.3261165i,0.8154283-0.4936015i,0.283935-1.130329i},
    {0.1705076+0.6672778i,-0.1163935+0.4424188i,-0.05945829+1.371791i,0.1819069+1.113099i,-0.7207395+1.075344i,-0.4982363+1.327802i,-0.3595967+0.4757393i,0.08349445+1.189512i,-0.6952428+0.9439043i,0.037253+0.6371262i,-0.2146475+0.5180612i,-0.4777575+0.5815684i,-0.6412888+0.7912794i,-0.6392951+1.056027i,-0.4712741+1.263437i,-0.3292502+0.5227091i,-0.5756976+0.6519355i,0.1482656+0.9261026i,0.05441361+0.6496945i,-0.3315968+1.341176i,-0.4974866+0.5619505i,0.1427693+1.038003i,-0.6498635+1.104492i,-0.4312108+1.308389i,-0.1357614+1.315608i,0.08766519+1.128028i,-0.02210821+0.6018478i,-0.238881+1.320256i,0.01926179+1.197841i,-0.6641527+0.9103497i,-0.5636798+1.182845i,-0.2339894+0.5302216i,-0.02057809+1.219908i,-0.6452581+0.886781i,0.01098232+0.6803764i,-0.2803946+1.273765i,-0.02761279+1.15339i,0.04272888+0.8931823i,-0.1066187+0.6838989i,-0.3500695+0.6733876i,-0.03956198+0.98965i,-0.1006086+0.7783263i,-0.2305383+1.12829i,-0.06695016+0.992641i,-0.441897+1.066324i,-0.2974438+0.6723107i,-0.02057236+1.054532i,-0.5528019+1.049481i,-0.1780842+0.5872078i,-0.4810535+0.6106752i,-0.6697743+0.8714668i,-0.5948317+1.200718i},
    {0.1896689-0.03502466i,0.38619-0.2248131i,-0.2266608-0.2546188i,-0.03345566-0.09174281i,-0.04733581-0.6150948i,-0.1569578-0.4281287i,0.2377868-0.4978153i,0.08223327-0.2032116i,-0.0434429-0.4391609i,0.1689888-0.4399007i,0.04527709-0.477402i,-0.04631062-0.3845628i,-0.008455237-0.2501633i,0.1388132-0.2051224i,0.2744704-0.3083098i,-0.1250169-0.249611i,0.02641087-0.1176287i,-0.08466311-0.6002063i,-0.2141322-0.4212021i,0.328114-0.5464078i,0.01068468-0.06408785i,-0.08702265-0.6498454i,0.3889902-0.2717027i,0.384537-0.5048945i,0.2274207-0.6817545i,-0.01263536-0.7166754i,-0.3076388-0.3332905i,0.3520431-0.6672067i,0.08759997-0.7946717i,0.3621944-0.03624289i,0.5312591-0.3138964i,-0.3110198-0.09825219i,0.1769491-0.8492911i,0.3328431+0.05437783i,-0.4092847-0.5110784i,0.529501-0.6038817i,0.2502011-0.8516594i,-0.1220099-0.8401695i,-0.3832026-0.5791766i,-0.395744-0.2151443i,0.3140204-0.7997174i,-0.03375354-0.83873i,0.4618079-0.1068594i,0.5280003-0.4315824i,-0.2119025-0.03693793i,0.06911071-0.7997814i,0.353922-0.06750966i,-0.3174777-0.4176678i,0.3910145-0.585553i,0.1743201-0.7233273i,-0.06706565-0.6915425i,-0.2257171-0.5230714i},
    {-0.1747107-0.3656212i,-0.02736108-0.08397065i,0.3164664-0.7197399i,0.09644657-0.6146267i,0.5350623-0.2901246i,0.4784545-0.4418072i,0.1836121-0.213322i,0.2917168-0.4956062i,0.3116807-0.2413802i,0.2060718-0.4595701i,0.1514454-0.4301465i,0.1023364-0.3536724i,0.110044-0.2336922i,0.2106701-0.1249651i,0.3836149-0.1038801i,0.008834391-0.5009834i,-0.04865304-0.2873552i,0.498866-0.6457782i,0.2558981-0.7459447i,0.5677478-0.06191956i,-0.1566197-0.3917162i,0.6445443-0.6324944i,0.1830791+0.108797i,0.5251133+0.06830394i,0.7584114-0.1994534i,0.7511562-0.5626784i,0.1278986-0.8608063i,0.7250875-0.07977893i,0.7960141-0.442468i,-0.05429721+0.04288559i,0.2874646+0.1587758i,-0.06013263-0.7416197i,0.7811521-0.2839999i,-0.1507378-0.0924768i,0.4369058-0.8349687i,0.4633209+0.1092239i,0.7204171-0.1182623i,0.771795-0.4588169i,0.5910057-0.753638i,0.2614373-0.8620556i,0.6173106+0.01547783i,0.7763739-0.2918834i,-0.1416674-0.08882581i,0.1304743+0.114646i,0.09210071-0.8118839i,0.7084782-0.1275148i,-0.1981709-0.2642457i,0.5902581-0.7317956i,0.2726281+0.1333707i,0.589505+0.03264262i,0.7778742-0.2522537i,0.7411279-0.6041707i},
    {-0.3899789+1.983966i,0.9193478+1.639857i,-1.994187-0.5810201i,-1.906163+0.7005891i,0.741922-1.632036i,-0.4727606-1.806716i,1.204257+1.18077i,-1.942177-0.08283444i,1.278174-1.061857i,-0.6081839+1.706524i,0.5678698+1.608326i,1.422291+0.7925056i,1.571827-0.3806499i,0.9464375-1.38455i,-0.1712818-1.765383i,0.964217+1.339055i,1.553742+0.3291817i,-1.683531+0.8021035i,-0.8303455+1.572222i,-0.6148881-1.65063i,1.223196+0.9816641i,-1.84059+0.07700276i,1.110573-1.118622i,0.1486883-1.66405i,-0.945416-1.500854i,-1.711205-0.6950048i,-1.207994+1.383525i,-0.1977005-1.78288i,-1.32229-1.393888i,1.665636+0.3449857i,1.518253-0.9053975i,-0.8933361+1.791493i,-0.7492966-1.90706i,1.557907+1.08998i,-2.209563+0.2643889i,1.256529-1.570062i,-0.09681682-2.136568i,-1.506496-1.672644i,-2.269763-0.3904449i,-2.003992+1.076596i,0.5407217-2.018331i,-0.9189971-1.966189i,1.664749+0.9807352i,1.838882-0.408895i,-1.411029+1.542202i,-0.1617845-1.965937i,1.062098+1.487383i,-2.016453-0.409503i,1.542251-0.8468511i,0.6521432-1.720381i,-0.5937121-1.861618i,-1.674963-1.192583i},
    {-0.3867624+0.7571971i,0.2282219+0.7000978i,-1.047636-0.5234932i,-1.122357+0.1307731i,0.379169-0.9669403i,-0.3083906-1.157401i,0.6082361+0.5676485i,-1.253521-0.1288957i,0.6181127-0.8573338i,-0.289064+0.9392396i,0.4497089+0.724903i,0.839572+0.07867497i,0.6951458-0.6386625i,0.1313473-1.056236i,-0.5323156-0.9980981i,0.6065246+0.2826631i,0.6500224-0.3052938i,-0.6974373+0.4951442i,-0.1967746+0.6492428i,-0.6368577-0.7406607i,0.5368702+0.06579238i,-0.8647645+0.1487938i,0.1821162-0.7741303i,-0.2952018-0.8635737i,-0.7300844-0.6342905i,-0.9267231-0.1774975i,-0.3742162+0.5900046i,-0.490356-0.811498i,-0.8480108-0.4604193i,0.5377622-0.3003853i,0.2661524-0.7153075i,-0.1584366+0.598416i,-0.6619435-0.6793306i,0.5325767-0.01828265i,-0.7984508+0.2336315i,0.05292813-0.80061i,-0.4270502-0.7823193i,-0.7709762-0.4632258i,-0.8218743-0.01365251i,-0.5816002+0.3426701i,-0.1674427-0.7193671i,-0.5076872-0.5772482i,0.3125718+0.02320783i,0.2890956-0.2787104i,-0.4866282+0.2398703i,-0.1276227-0.6173137i,0.05251559+0.3242838i,-0.6726042-0.3926527i,0.4202267-0.2253934i,0.2733546-0.6219824i,-0.1400951-0.8594858i,-0.6575257-0.7560929i},
    {-0.8923551+0.185661i,-0.3660411+0.7335733i,-0.1153239-1.403759i,-0.7766411-0.9892029i,1.302971-0.3374303i,0.9976838-1.079882i,0.004179037+0.8724704i,-0.5058431-1.247643i,1.241146+0.0177467i,-0.8716023+0.1872309i,-0.3123538+0.7005156i,0.4161413+0.7254778i,0.962644+0.297757i,1.107187-0.3428746i,0.8394488-0.9024552i,-0.03508695+0.5986922i,0.5227071+0.5100393i,-0.6354375-0.6951334i,-0.7327573-0.1504393i,0.769366-0.9336228i,0.033114+0.6378131i,-0.3646441-1.107741i,1.08348+0.0478145i,1.113753-0.6403347i,0.6742008-1.210308i,-0.05622514-1.36093i,-0.9787191-0.2503476i,0.9637817-1.046359i,0.2657916-1.391607i,0.7567549+0.6199415i,1.174688-0.00267319i,-0.8063985+0.150649i,0.5755606-1.19697i,0.3699039+0.6596177i,-0.6006939-0.8613149i,1.046412-0.2882577i,0.8396419-0.8208322i,0.3767165-1.116749i,-0.1598017-1.09038i,-0.5840197-0.7614192i,1.027008-0.3363266i,0.844808-0.8810733i,-0.0638653+0.6576092i,0.5884356+0.6268933i,-0.8332592-0.7363259i,1.231507-0.5775257i,-0.5340156+0.6864271i,0.01021488-1.513359i,1.078198+0.5809927i,1.452576-0.2559618i,1.161062-1.151487i,0.3291718-1.626172i},
    {0.4388732-0.7536228i,0.03302677-0.8132144i,0.861766+0.2479648i,1.052333-0.2365462i,-0.3799449+0.4433773i,0.1554772+0.7609517i,-0.3211412-0.9770529i,1.24571+0.08793725i,-0.7162361+0.3077795i,0.6754656-1.185301i,-0.09680883-1.245677i,-0.7306787-0.7794527i,-0.9126741-0.005033842i,-0.5506594+0.7112869i,0.1922681+1.035033i,-0.4932338-1.148623i,-0.9746579-0.4639368i,1.404475-0.7298654i,0.7966252-1.377048i,0.6081669+1.156835i,-0.928914-0.9736178i,1.710105-0.3250556i,-0.7941272+0.9457945i,0.1960995+1.400278i,1.273407+1.069904i,1.869109+0.07655085i,0.6732275-1.793938i,1.015078+1.330467i,1.814185+0.4296459i,-1.30968+0.4279619i,-0.5084795+1.290834i,-0.1518909-1.731919i,1.54706+0.7248846i,-1.287697+0.01036833i,1.26097-1.278656i,0.1985635+1.298976i,1.140431+0.949706i,1.618888+0.09684835i,1.437577-0.8400596i,0.7103705-1.425488i,0.693814+1.066007i,1.363453+0.4676464i,-0.9923627+0.06871081i,-0.5228409+0.7930898i,0.2024832-1.365729i,1.032428+0.6861986i,-0.8700863-0.2990277i,1.139509-0.7698435i,-0.03259459+0.8233515i,0.6526702+0.719833i,1.077998+0.2255296i,1.08102-0.3826657i},
    {1.817998+1.295737i,2.200997+0.1598103i,-0.8049952+1.317272i,0.2257556+1.856842i,-0.389071-1.23071i,-1.078268-0.3438435i,1.999792-0.3819284i,-0.3301855+1.589703i,0.2110516-1.395567i,1.687582+1.242211i,2.079065+0.2270956i,1.730268-0.807412i,0.795199-1.377476i,-0.2876559-1.208012i,-0.9990534-0.3788597i,1.952101-0.323853i,1.257058-1.13366i,0.7279516+1.673358i,1.592549+1.140496i,-0.9467825+0.1725105i,1.552812-0.6708741i,0.1914171+1.493275i,-0.09587352-0.9677718i,-0.656193-0.3480262i,-0.7165108+0.4562567i,-0.2874666+1.111996i,1.156003+1.138526i,-0.6343204-0.143833i,-0.6045091+0.6037778i,1.078798-0.7991269i,0.3462561-0.9650888i,1.292529+1.028966i,-0.6941558+0.02657221i,1.514858-0.4074095i,0.01750654+1.320317i,0.1316992-1.007992i,-0.5641475-0.5538695i,-0.8376844+0.2615645i,-0.5292596+1.099383i,0.2691234+1.571091i,-0.2660125-1.038785i,-0.9161649-0.2870568i,1.877463-0.3544343i,1.204442-1.153166i,0.7951651+1.702623i,-0.7538403-0.762724i,2.035113+0.1229025i,-0.6724373+1.244496i,0.6820185-1.351429i,-0.3461078-1.124444i,-0.9912025-0.3024549i,-0.9732417+0.7375542i},
    {-0.1321682-0.429813i,-0.4790588-0.7019132i,-0.40317+0.4776828i,-0.07947591+0.1740775i,-1.295647+0.07105432i,-1.040234+0.4574122i,-0.7430779-0.7930892i,-0.1265003+0.3804111i,-1.404817-0.106742i,-0.08825402-0.6096573i,-0.5773264-0.8819682i,-1.135495-0.745023i,-1.454547-0.2550262i,-1.350309+0.3246072i,-0.8787927+0.6742636i,-1.01905-0.8112934i,-1.38784-0.3822221i,0.04930278-0.3686082i,-0.3138222-0.7516889i,-0.5042896+0.5964702i,-1.216697-0.5199194i,0.01708251-0.1366201i,-1.151853+0.3516922i,-0.7477946+0.5543445i,-0.3074977+0.4550814i,-0.03058103+0.09409914i,-0.3801312-0.7015861i,-0.4713957+0.5309616i,-0.1016349+0.2354546i,-1.288682+0.02666289i,-1.023073+0.4035471i,-0.7376387-0.6922367i,-0.2265114+0.2582023i,-1.187884-0.07039385i,-0.3242262-0.4526753i,-0.6711388+0.3416496i,-0.4005888+0.199552i,-0.3111881-0.05601707i,-0.4046319-0.273185i,-0.5896618-0.3579657i,-0.5677913+0.1042933i,-0.4928688-0.01876738i,-0.808261-0.06871243i,-0.7345616-0.01387153i,-0.6539003-0.1788246i,-0.6487256-0.06081038i,-0.6555052-0.1294226i,-0.6755271-0.04141654i,-0.6949992-0.2038775i,-0.7940374-0.1876406i,-0.8701732-0.07079435i,-0.8282523+0.1043661i},
    {-0.2688716-0.9703298i,-0.7848743-0.7308518i,0.5219033-0.05063607i,0.3730147-0.549259i,-0.4439622+0.5353286i,0.02149333+0.4793032i,-0.8138117-0.4419245i,0.3631764-0.2610854i,-0.6264638+0.3103242i,-0.2224325-0.7130648i,-0.5686259-0.5893401i,-0.7606968-0.2898127i,-0.7307733+0.0554567i,-0.5009719+0.3051102i,-0.1721727+0.3606565i,-0.6024946-0.4884785i,-0.7325673-0.1920707i,0.1679653-0.4005578i,-0.08090447-0.5923603i,-0.09535298+0.3069661i,-0.6294899-0.4024178i,0.2172286-0.1717467i,-0.5857648+0.1594203i,-0.3315025+0.3025325i,-0.04514198+0.2636881i,0.1592589+0.06187596i,0.06745023-0.4758602i,-0.2909351+0.3179097i,-0.000487596+0.2627225i,-0.6913736-0.3240146i,-0.726237-0.01206811i,0.07505009-0.5543291i,-0.2419615+0.4029837i,-0.5964687-0.5916841i,0.3438422-0.003071265i,-0.8156415+0.1335144i,-0.5250173+0.465656i,-0.06162737+0.539073i,0.3630754+0.2811132i,0.5254067-0.2168478i,-0.797038+0.4388784i,-0.2821846+0.688181i,-0.7740677-0.8128009i,-1.105624-0.3009022i,0.5265131-0.5999383i,-0.5238643+0.7236322i,-0.6058732-0.9885212i,0.5956319+0.2604556i,-1.145033+0.1079433i,-0.7617323+0.6427119i,-0.1194622+0.7937515i,0.4650745+0.4851289i},
    {-0.03644565+0.8036851i,0.587558+0.3898127i,-1.440996-0.08067942i,-1.093197+0.643765i,-0.314305-1.403128i,-1.115081-1.126713i,0.8883001-0.06594363i,-1.33697+0.4753655i,-0.02352341-1.416759i,0.2469362+0.874746i,0.824388+0.2241042i,0.8266798-0.6396064i,0.2636766-1.285363i,-0.57856-1.401399i,-1.286176-0.9395273i,0.8721426-0.3089024i,0.5150232-1.0689i,-0.3909203+0.9655623i,0.4060755+0.7084192i,-1.472605-0.427478i,0.6610989-0.8231125i,-0.6447493+0.8666329i,-0.7976627-1.217889i,-1.312341-0.6301035i,-1.294899+0.1235174i,-0.7963085+0.6439006i,0.3896877+0.2966694i,-1.142517-0.1489721i,-0.8618032+0.3260898i,-0.2630859-0.9301661i,-0.6989262-0.7637687i,0.2674028-0.04717699i,-0.8496661-0.002269707i,-0.06404311-0.681645i,-0.2455292+0.2644492i,-0.6516995-0.5272825i,-0.7309789-0.2593468i,-0.6383237-0.02909975i,-0.4543082+0.07932977i,-0.2789291+0.06412306i,-0.4781614-0.4225504i,-0.538615-0.3312012i,-0.06505889-0.2063934i,-0.0514654-0.3433991i,-0.5187199+0.07823636i,-0.33931-0.6452641i,0.002563333+0.1600711i,-0.8870658-0.3143776i,0.2257832-0.5543032i,-0.1160532-0.894374i,-0.6434117-0.9098841i,-1.066603-0.5351168i},
    {-0.9258371+0.5475319i,-1.016468+0.8107214i,-0.2870879+0.6008716i,-0.5064508+0.4725723i,-0.4705709+1.152073i,-0.3267474+0.9902915i,-0.8964235+0.8639488i,-0.4031143+0.659014i,-0.6826011+1.06449i,-0.6497698+0.5979484i,-0.7608756+0.6401424i,-0.8598338+0.7344494i,-0.9096198+0.8964968i,-0.8456641+1.096519i,-0.6359509+1.238143i,-0.8691351+0.4563317i,-1.095741+0.7037635i,-0.111814+0.5872341i,-0.3794799+0.2856216i,-0.4041865+1.423867i,-1.174443+0.5031102i,0.06570853+0.6993777i,-1.042013+1.390712i,-0.5699057+1.564523i,-0.08378702+1.382975i,0.1765299+0.9137204i,-0.3922738+0.01049123i,-0.2122448+1.620721i,0.2433076+1.176822i,-1.501038+1.149263i,-1.07286+1.694067i,-0.8469033-0.1470218i,0.2504099+1.400698i,-1.633881+0.9949498i,0.0413916+0.009357437i,-0.5231861+1.870328i,0.1499697+1.531227i,0.4040604+0.8371812i,0.1260203+0.1753406i,-0.5020496-0.1133995i,-0.07842537+1.578925i,0.2469896+1.041195i,-1.358354+1.20939i,-0.9256584+1.574976i,-0.8261348+0.08176206i,0.02178972+1.257152i,-1.343008+0.898378i,-0.08832342+0.3205981i,-0.6772209+1.544074i,-0.2087441+1.416327i,0.06537165+1.019802i,0.01676631+0.5451893i},
    {0.3986021+2.246737i,1.70252+1.687966i,-1.674371-0.05694816i,-1.321323+1.2786i,0.8488733-1.669276i,-0.4556049-1.517773i,1.957615+0.9566557i,-1.358628+0.6238751i,1.297283-1.161024i,0.4061441+1.7697i,1.323868+1.321911i,1.747865+0.458782i,1.577273-0.4364501i,0.9379911-1.032687i,0.0922311-1.140105i,1.296351+1.106576i,1.662557+0.3352347i,-0.8469976+0.8885289i,-0.1769825+1.476052i,-0.08889865-1.156466i,1.491706+0.9896755i,-1.105107+0.2857412i,1.381309-0.7875087i,0.5484105-1.238757i,-0.3822224-1.076545i,-1.014974-0.3785272i,-0.5805769+1.364985i,0.314723-1.333671i,-0.6449318-1.043785i,1.896867+0.5643524i,1.84591-0.530067i,-0.4372798+1.763164i,-0.1144302-1.581759i,1.845508+1.297721i,-1.619124+0.3256528i,1.744473-1.219182i,0.4904783-1.849415i,-0.8960094-1.494011i,-1.719204-0.3000531i,-1.557675+1.152206i,1.128297-1.779448i,-0.3367081-1.839144i,2.135246+1.30778i,2.435622-0.1238689i,-1.101012+1.784203i,0.3861139-1.961656i,1.658632+1.878602i,-1.800837-0.254125i,2.239242-0.8519351i,1.121113-1.853904i,-0.3889993-1.894661i,-1.570113-0.942229i},
    {0.9382821+1.251296i,1.405619+0.4536512i,-1.183589+0.9443598i,-0.4577918+1.597954i,-0.4746025-1.1759i,-1.303826-0.5288649i,1.597488-0.08005444i,-0.9552959+1.5231i,-0.07080895-1.43303i,1.24869+1.422494i,1.756384+0.314656i,1.3825-0.8608177i,0.3085599-1.480883i,-0.9010171-1.215388i,-1.610471-0.2122412i,1.541996-0.5283181i,0.6432452-1.305202i,0.5945449+1.743671i,1.41739+0.9766405i,-1.440127+0.5679572i,0.9034779-0.9527639i,0.1557225+1.63711i,-0.9238992-0.7214614i,-1.25474+0.1336567i,-0.9669991+0.9571493i,-0.2544988+1.37904i,1.01174+0.697607i,-0.9621962+0.4667792i,-0.5687034+1.004497i,0.03789301-0.7124637i,-0.5212843-0.4826759i,0.8905864+0.4421542i,-0.7376552+0.5750149i,0.432063-0.4964658i,0.1717672+1.025239i,-0.5363004-0.301673i,-0.7209108+0.1640561i,-0.585372+0.6298914i,-0.2081802+0.9053353i,0.2386046+0.8972933i,-0.4974312-0.1766258i,-0.6180912+0.2109485i,0.5849515-0.123494i,0.2916993-0.3735542i,0.1764681+0.8913524i,-0.4751917-0.2568399i,0.7909223+0.3330137i,-0.6753603+0.6285992i,0.3857979-0.5836642i,-0.2213161-0.6879503i,-0.8051678-0.3490188i,-1.045106+0.3415391i},
    {-0.1589454-0.07603147i,0.1535766+0.01310996i,-0.4499804-0.7812225i,-0.5931308-0.381827i,0.4477649-0.9813299i,-0.005553979-1.173813i,0.5292008+0.05847811i,-0.73221-0.5295121i,0.6387572-0.9288537i,-0.1524893+0.2929958i,0.3856157+0.2343006i,0.7637746-0.1574538i,0.8094556-0.7072995i,0.4916319-1.174627i,-0.06928878-1.343406i,0.6756812+0.1675285i,0.9722698-0.4063118i,-0.7743229+0.129986i,-0.1886036+0.5447279i,-0.5172135-1.397602i,1.069616-0.1311008i,-1.004856-0.005858274i,0.4709011-1.515666i,-0.3523972-1.550337i,-0.9775384-1.01698i,-1.074342-0.2113177i,0.1403118+0.6035102i,-0.7539865-1.18349i,-1.005323-0.5082378i,0.8102341-1.086624i,0.2277794-1.430372i,0.4670389+0.3899178i,-0.8646817-0.8438911i,0.9369453-0.7470659i,-0.5042027+0.3319501i,-0.09813578-1.422321i,-0.6903064-1.116871i,-0.9391961-0.493959i,-0.7145053+0.1395341i,-0.1285104+0.462905i,-0.4760406-1.25535i,-0.8517882-0.7258886i,0.822072-0.8422669i,0.3671927-1.252011i,0.2627298+0.3184654i,-0.6510652-0.890035i,0.769987-0.5840912i,-0.4521463+0.07898621i,0.02242725-1.158906i,-0.4023753-0.9674362i,-0.5865397-0.5675206i,-0.4695159-0.1717632i},
    {-0.894423-1.557485i,-1.601073-0.7024958i,1.58971-0.8352221i,0.8293576-1.750928i,0.3662125+1.577936i,1.455288+0.9377276i,-1.885644-0.1021863i,1.375809-1.503664i,-0.2033643+1.716118i,-1.107598-1.776447i,-1.872343-0.6785436i,-1.733707+0.6464042i,-0.7731966+1.553835i,0.532234+1.620688i,1.55965+0.8385473i,-1.854777+0.01751101i,-1.280564+1.140241i,0.1184092-2.020893i,-1.071324-1.670574i,1.746043+0.2588536i,-1.63605+0.5762395i,0.7454515-1.820658i,0.457097+1.524854i,1.44053+0.8156117i,1.73063-0.3496414i,1.206524-1.411616i,-0.9478799-1.553116i,1.54612+0.2460345i,1.437979-0.8190933i,-0.7213503+1.165477i,0.2753817+1.279726i,-1.11976-1.157045i,1.441786-0.1223712i,-1.18464+0.633359i,0.4127731-1.568612i,0.5117882+1.153962i,1.247378+0.5506569i,1.457612-0.3955329i,1.023069-1.285651i,0.105227-1.713775i,0.8823115+1.06965i,1.501035+0.2183174i,-1.443357+0.4582596i,-0.6968503+1.234726i,-0.3938091-1.73688i,1.277498+0.7427486i,-1.588692-0.09238634i,1.138707-1.276372i,-0.1990756+1.358829i,0.8241663+1.115483i,1.45155+0.2878363i,1.413856-0.7359951i},
    {0.3511365+0.1848392i,0.2209238-0.4346439i,-0.958174+1.008417i,-0.3003094+1.044585i,-1.48263-0.5006797i,-1.684921+0.1781958i,0.1784721-0.705708i,-0.7229297+1.21926i,-1.280739-0.8956761i,0.5561305+0.3939703i,0.5045791-0.4515709i,-0.1008716-1.069262i,-0.9756598-1.139027i,-1.687696-0.6133505i,-1.882355+0.252957i,0.2410735-0.8812469i,-0.5814573-1.203811i,0.1891763+1.073947i,0.6405557+0.3248908i,-1.731075+0.6910446i,-0.1464422-1.113454i,-0.2031657+1.293294i,-1.712974-0.5944048i,-1.894219+0.2759966i,-1.464779+1.065377i,-0.6162927+1.388399i,0.6849101+0.2682889i,-1.706691+0.7813326i,-0.966939+1.312023i,-1.148097-1.062962i,-1.73556-0.415187i,0.5199645-0.275931i,-1.214035+1.042655i,-0.770414-0.9956031i,0.1547216+0.7613766i,-1.580736+0.0346928i,-1.351223+0.6141355i,-0.8542022+0.9051504i,-0.3236873+0.844691i,0.04733231+0.5089036i,-1.380495+0.1109403i,-1.213204+0.5487773i,-0.3981046-0.6643875i,-0.884899-0.664421i,0.07406072+0.5202332i,-1.457063+0.1478378i,0.03215428-0.5248473i,-0.7405573+0.9832917i,-1.103045-0.7322019i,-1.53337-0.24126i,-1.544985+0.4332913i,-1.104787+0.9672614i},
    {-2.377819-0.08067112i,-2.097611+1.049148i,-0.1195233-1.390897i,-1.205203-1.336341i,0.6743388+0.9626162i,0.8396197-0.03679325i,-1.677101+1.220243i,-0.5073706-1.263543i,0.08647608+1.357244i,-1.951494-0.3218341i,-1.966369+0.5606174i,-1.455273+1.268911i,-0.6234809+1.53195i,0.2082936+1.244174i,0.7115465+0.501711i,-1.975699+0.7465134i,-1.355394+1.473255i,-0.9310636-1.34423i,-1.854897-0.8716452i,0.9799369+0.2081427i,-1.984792+1.203354i,-0.2941006-1.532759i,0.1813206+1.72936i,1.027346+0.8266958i,1.078287-0.433092i,0.2818058-1.430344i,-2.085278-1.013385i,1.183905+0.1357047i,0.7187216-1.032104i,-0.9391585+1.94004i,0.2471759+1.689927i,-2.298559-0.4339118i,0.9729865-0.4024345i,-1.557375+1.610703i,-0.856903-1.515733i,0.5445644+1.344794i,1.019235+0.337794i,0.7671725-0.7497834i,-0.1128479-1.451333i,-1.252174-1.451351i,0.8423201+1.053983i,1.091674-0.09605846i,-1.859987+1.490723i,-0.7424468+1.9792i,-1.762502-1.310575i,1.161607+0.5950235i,-2.348726+1.007816i,0.108009-1.591322i,-0.1050744+2.017802i,0.9763056+1.235314i,1.297871-0.07520128i,0.6870996-1.292438i},
    {-0.308602-0.6815869i,-0.7443552-0.2182117i,1.11727-0.1475032i,0.7397634-0.7106745i,0.2508356+1.207701i,0.9316428+0.9349211i,-0.9798868+0.02387125i,1.142209-0.5189155i,-0.1731427+1.322405i,-0.3696524-1.001764i,-1.019516-0.3928598i,-1.110736+0.518262i,-0.5657822+1.279827i,0.3621908+1.494369i,1.209662+1.035971i,-1.225922+0.1615542i,-0.87544+1.067698i,0.3348492-1.22992i,-0.6029491-1.005287i,1.477941+0.5145143i,-1.073148+0.7162486i,0.7186905-1.080817i,0.5236331+1.425359i,1.254493+0.876403i,1.453101-0.00351154i,1.041209-0.7920083i,-0.5911642-0.8565921i,1.358332+0.4240282i,1.241862-0.4009581i,-0.3170363+1.23664i,0.4842074+1.270542i,-0.7932668-0.5083387i,1.291965+0.04409629i,-0.6427386+0.9281567i,0.2812108-0.9581249i,0.7567621+1.063793i,1.195333+0.4728842i,1.159834-0.2571789i,0.6707825-0.7943717i,-0.04372643-0.8944324i,0.9689769+0.8038203i,1.187809+0.1327332i,-0.6092178+0.7974942i,-0.0103826+1.114362i,-0.3143955-0.6894377i,1.025319+0.4781929i,-0.6949262+0.4179064i,0.6395844-0.5765081i,0.2222316+0.9775497i,0.7003925+0.7472515i,0.9354841+0.2941878i,0.8589531-0.1958034i},
    {-1.184383-0.4561532i,-0.8831509+0.1833418i,-0.1500055-1.552353i,-0.823577-1.328375i,0.7982211-0.372201i,0.6629157-1.059532i,-0.4956712+0.3937027i,-0.5665687-1.445592i,0.6709913-0.1104722i,-1.115817-0.3203123i,-0.7443344+0.2152522i,-0.1242965+0.3821924i,0.4496902+0.114571i,0.7141946-0.4522119i,0.5548962-1.049912i,-0.4343821+0.312791i,0.1706151+0.2619699i,-0.9783126-0.9273902i,-1.031956-0.3322039i,0.3115785-1.24332i,-0.1231649+0.3034726i,-0.7827041-1.141356i,0.6358808-0.4754618i,0.4718277-1.020216i,-0.000461547-1.320323i,-0.5423585-1.239093i,-0.8806814-0.3168167i,0.1689805-1.140072i,-0.2971865-1.194863i,0.2800661-0.1435052i,0.3839957-0.5371087i,-0.6046791-0.2181183i,-0.07616122-1.011886i,-0.02021424-0.1439592i,-0.525179-0.7545987i,0.1741262-0.5513759i,0.1025418-0.7311682i,-0.03459182-0.8538529i,-0.2200107-0.9047622i,-0.4290765-0.8524256i,0.2173541-0.4191461i,0.2506844-0.7017205i,-0.4632505-0.1135935i,-0.1258515+0.003062441i,-0.6173371-0.9518536i,0.4332324-0.5066121i,-0.7145165-0.1523566i,-0.0395459-1.209418i,0.1364896+0.07914974i,0.481414-0.2728989i,0.5158151-0.7765487i,0.2098818-1.191952i},
    {0.7249349-0.1013652i,0.5082595-0.5139051i,-0.06903085+0.668355i,0.3660631+0.5688726i,-0.624293-0.262922i,-0.6451463+0.1819935i,0.413273-0.5879739i,0.05596354+0.6925668i,-0.4772653-0.5543942i,0.7504398+0.08950759i,0.6616974-0.4167168i,0.2538259-0.7548239i,-0.2884572-0.7427615i,-0.6934397-0.3701118i,-0.7488832+0.1794843i,0.4532137-0.656854i,-0.07049857-0.7713828i,0.5489735+0.4856157i,0.7176042+0.02213098i,-0.5316228+0.3797903i,0.185452-0.6364111i,0.2424427+0.5550653i,-0.4964965-0.3308864i,-0.5775869+0.02788445i,-0.4442721+0.3709079i,-0.1284882+0.5864215i,0.6229706+0.2970795i,-0.6939999+0.1375852i,-0.4454969+0.5879551i,-0.04280635-0.8039215i,-0.567774-0.5819512i,0.8340172+0.01373676i,-0.6160865+0.5115033i,0.123658-0.8200366i,0.4543696+0.6365224i,-0.7198763-0.2075722i,-0.6323287+0.299517i,-0.2635071+0.6003224i,0.1708602+0.5973893i,0.4811096+0.3543312i,-0.5574458-0.04278637i,-0.459731+0.282418i,0.2332256-0.5378943i,-0.1131755-0.5909258i,0.4818222+0.392595i,-0.6512506-0.0566558i,0.592207-0.4306869i,-0.1768692+0.7157629i,-0.3388662-0.7337753i,-0.7564551-0.3379752i,-0.8019876+0.2621658i,-0.4189294+0.7509595i},
    {0.5075528+0.04196263i,0.171326-0.123852i,0.5188949+0.8464643i,0.7222335+0.4949706i,-0.3170237+0.739516i,0.01753264+0.9649898i,-0.09149992-0.07199338i,0.6433629+0.6244621i,-0.3305249+0.5602482i,0.4395453+0.02272036i,0.1450216-0.05310013i,-0.1271287+0.04922751i,-0.2941422+0.2840444i,-0.3010255+0.5816024i,-0.1233737+0.8449748i,0.1094787-0.1205984i,-0.2434706+0.006779742i,0.7584429+0.4784151i,0.6746362+0.05408645i,0.001025824+1.055816i,-0.1579455-0.176506i,0.7944408+0.6574442i,-0.4825684+0.6629958i,-0.1601937+1.020537i,0.3106284+1.072204i,0.6897654+0.807654i,0.6163238-0.02121683i,0.07938898+1.040174i,0.4851334+0.9447681i,-0.4291265+0.2155888i,-0.4285568+0.6296672i,0.478858-0.1202058i,0.2502036+1.046858i,-0.3250223-0.01113116i,0.8096128+0.4373346i,-0.3607384+0.8310005i,0.02998368+1.073736i,0.4892261+1.001461i,0.7909917+0.6439135i,0.7847291+0.1748226i,-0.1604052+1.011633i,0.3036923+1.071608i,-0.3796101+0.0226445i,-0.5022956+0.4697784i,0.6139935-0.04779949i,0.1182826+1.060567i,-0.2308847-0.07994052i,0.759245+0.5338395i,-0.355107+0.7183018i,-0.0229228+0.9557992i,0.3607517+0.9130945i,0.6009833+0.646449i},
    {0.7757127+0.665477i,0.8417675+0.2800162i,0.07303403+0.8787556i,0.4863295+0.9557133i,-0.1662846+0.1188096i,-0.2536117+0.5724131i,0.6647215-0.1463845i,0.5198695+1.066209i,-0.271899+0.06627491i,1.046826+0.2146294i,0.7085673-0.2480788i,0.1253282-0.332451i,-0.3534454+0.03214062i,-0.4313616+0.6374133i,-0.05442406+1.122907i,0.1283463-0.3737133i,-0.3588992-0.003383175i,1.133976+0.2314229i,0.7905048-0.2586032i,0.4710759+1.206444i,-0.2865404-0.08005826i,1.137309+0.3557678i,-0.2100835+0.990659i,0.3176533+1.216691i,0.8668879+1.033184i,1.158748+0.5226607i,0.529742-0.4205347i,0.7806146+1.167272i,1.193165+0.6677545i,-0.4636636+0.8212873i,0.03736943+1.276504i,-0.04107565-0.4272089i,1.207454+0.7524068i,-0.5155363+0.7760837i,0.7000194-0.4434622i,0.6857598+1.270489i,1.180454+0.7784427i,1.183581+0.08712056i,0.7031624-0.3983025i,0.03012244-0.4013424i,1.123014+0.7616111i,1.121647+0.111632i,0.01708338+1.162255i,0.6411299+1.150384i,-0.3744444+0.1224609i,1.028389+0.109302i,0.09563725+1.09826i,0.0249538-0.2146641i,0.9939648+0.6052625i,0.905076+0.07885012i,0.4720635-0.2035284i,-0.01198118-0.0792418i},
    {0.8075857+0.7529748i,0.8558242+0.1158218i,-0.3497227+1.13956i,0.2861328+1.201471i,-0.6890196-0.03910878i,-0.7691215+0.585361i,0.4909575-0.3182139i,0.2068078+1.183704i,-0.608179-0.07685368i,0.8189145+0.2673339i,0.5129288-0.2150947i,-0.02416404-0.3462925i,-0.4843094-0.07932161i,-0.6253886+0.4093351i,-0.4020498+0.8375318i,0.06501769-0.2198172i,-0.3236794-0.04516841i,0.5717705+0.4463752i,0.4502491+0.1010868i,-0.06165195+0.8271088i,-0.1470894+0.0050112i,0.4124255+0.5339888i,-0.3063559+0.4950033i,-0.1411283+0.6773058i,0.08886117+0.711827i,0.2797384+0.5975716i,0.2742416+0.20068i,-0.0009584575+0.65766i,0.1875727+0.6072577i,-0.1933544+0.3166835i,-0.1584649+0.489392i,0.1169007+0.1837851i,0.1238304+0.555888i,-0.1069932+0.3198608i,0.1790047+0.3306372i,-0.001693456+0.4908415i,0.0804271+0.4717052i,0.1141124+0.4110654i,0.09404128+0.3581094i,0.04877419+0.3447938i,0.07717744+0.3939808i,0.07163122+0.3511451i,0.066202+0.4378536i,0.1231959+0.4127239i,-0.05409309+0.4288475i,0.09858955+0.2483029i,0.118117+0.5508946i,-0.1606604+0.2955202i,0.2994692+0.283776i,0.1777165+0.08984998i,-0.08452535+0.03404218i,-0.3405969+0.2062664i},
    {0.7632558-0.1010644i,0.872423-0.3061128i,0.2503318-0.3724186i,0.3376468-0.2456915i,0.6476921-0.6976413i,0.4990766-0.7292252i,0.7777941-0.1874133i,0.1839121-0.5074033i,0.9232838-0.6175852i,0.3640182-0.01861783i,0.6844598+0.03630343i,0.9801908-0.148687i,1.082006-0.5001593i,0.9201969-0.8404909i,0.56919-0.9927623i,0.9004515+0.01454746i,1.111709-0.3079875i,0.02906407-0.1723964i,0.302353+0.1082039i,0.4017801-1.026719i,1.057868-0.05083593i,-0.1105852-0.4064233i,1.065506-0.8962787i,0.6488336-1.151186i,0.1390606-1.06846i,-0.2066412-0.6493445i,0.2254943+0.338634i,0.2738407-1.240838i,-0.2044851-0.855663i,1.401524-0.6222652i,1.060247-1.140863i,0.6392003+0.4313821i,-0.08155227-1.017617i,1.401934-0.4097027i,-0.09713861+0.1009947i,0.6894601-1.247343i,0.1317631-1.128483i,-0.206027-0.6835864i,-0.1731036-0.137857i,0.1983078+0.2462761i,0.3846626-1.161379i,-0.0307492-0.8712878i,1.258377-0.4688141i,1.05735-0.8984104i,0.4573776+0.2286613i,0.2165594-0.9896023i,1.145181-0.2124927i,-0.04071689-0.2394365i,0.8915693-0.945814i,0.4994268-1.045389i,0.1254284-0.881742i,-0.06969049-0.5138158i},
    {0.6676593-0.2605081i,0.4406095-0.300088i,0.8516863+0.31972i,0.9724588+0.0664335i,0.1663015+0.3671439i,0.4397847+0.5658745i,0.2613457-0.4005666i,1.072312+0.2494959i,-0.01685529+0.2964609i,0.8003516-0.489684i,0.3580213-0.5433778i,-0.01399816-0.2798292i,-0.1146465+0.171568i,0.1136477+0.5775044i,0.5545806+0.7290813i,0.08113286-0.4186125i,-0.1247982-0.004975144i,1.076303-0.3063064i,0.7032848-0.5678201i,0.812833+0.6584894i,-0.06226508-0.2029111i,1.159487-0.1118538i,0.1702024+0.6066561i,0.6046945+0.7116452i,1.003093+0.5113654i,1.17696+0.1023351i,0.6748815-0.5571231i,0.8241102+0.6325587i,1.11717+0.3112974i,-0.06998342+0.2541077i,0.1925387+0.596093i,0.4525436-0.5565709i,0.9952863+0.4910514i,-0.09450351+0.04176606i,1.025715-0.3211339i,0.4113394+0.6805084i,0.8407089+0.6076977i,1.114841+0.2710232i,1.097555-0.159058i,0.8035991-0.4642483i,0.6742684+0.6289027i,0.9925458+0.3862407i,-0.001211301+0.1231136i,0.1813264+0.4376112i,0.5611526-0.4159419i,0.8009559+0.4343067i,0.11954-0.04460439i,0.9032392-0.09108341i,0.3449057+0.3981699i,0.5792547+0.4273674i,0.7761744+0.3196157i,0.8706939+0.1239791i},
    {-0.6069288-0.3017602i,-0.7020156+0.308965i,0.7902358-0.7333234i,0.1306846-0.9703524i,0.9871329+0.8477845i,1.357541+0.1484573i,-0.7372441+0.8034118i,0.4353153-1.145629i,0.8745052+1.153857i,-1.030644-0.2923006i,-0.9662797+0.6394389i,-0.2854141+1.284657i,0.6485929+1.302298i,1.345994+0.6964064i,1.462198-0.2051323i,-0.5446046+1.088609i,0.2998201+1.320044i,-0.6601948-0.8117151i,-1.017325-0.03720212i,1.212912-0.6389493i,-0.09087413+1.263158i,-0.3404126-1.029561i,1.349233+0.541006i,1.373192-0.3275902i,0.8102726-0.991769i,-0.04830282-1.104154i,-0.9206338+0.1975266i,0.9349627-0.7401868i,0.213276-0.9570284i,0.8395512+0.7971018i,1.087379+0.2049459i,-0.4879461+0.4875323i,0.4754854-0.6206749i,0.3954317+0.7242049i,-0.2813299-0.3222825i,0.8072398+0.1158299i,0.7185594-0.2211429i,0.4635265-0.4622064i,0.101499-0.5247607i,-0.2498471-0.3537444i,0.854436+0.1251741i,0.7593837-0.2991316i,0.0164887+0.7152013i,0.4703271+0.6938787i,-0.3817619-0.24288i,0.8583136-0.05514691i,-0.2097534+0.564662i,0.2372589-0.5628244i,0.5680152+0.5836161i,0.7994753+0.263958i,0.7992514-0.1277525i,0.5671102-0.4485207i},
    {2.029265+0.5197914i,2.182723-0.907903i,-0.8986635+1.12508i,0.4114169+1.418347i,-1.071856-1.717216i,-1.507513-0.5716674i,1.592409-1.441572i,-0.1767008+1.104155i,-0.4013454-1.878562i,1.57601+0.2392953i,1.683949-0.7336608i,1.188015-1.551i,0.30833-1.892873i,-0.5944232-1.627023i,-1.145894-0.8582351i,1.570188-1.010405i,0.9277795-1.737678i,0.513165+0.9842877i,1.37506+0.4805028i,-1.245975-0.4438017i,1.357859-1.418841i,-0.00015978+0.9953365i,-0.517036-1.701285i,-1.119754-0.9117905i,-1.062066+0.0572749i,-0.4084299+0.7331836i,1.197704+0.3375449i,-0.9568482-0.4749946i,-0.6730527+0.2271914i,0.5331693-1.501926i,-0.1299066-1.440682i,1.085953+0.1190066i,-0.7904655-0.4339302i,1.070761-1.079773i,-0.08728309+0.5734912i,-0.1403497-1.522076i,-0.7626615-1.104459i,-1.012442-0.3383242i,-0.7025282+0.4657126i,0.0961177+0.908322i,-0.5651089-1.631115i,-1.172683-0.8470855i,1.586883-1.081066i,0.8719342-1.824557i,0.6298246+1.012236i,-1.014438-1.336023i,1.762468-0.5719304i,-0.882141+0.6026843i,0.4395628-1.994521i,-0.5800093-1.802176i,-1.273509-1.006151i,-1.324629+0.07810943i},
    {0.7304693-2.097967i,-0.481734-2.135265i,1.589207+0.2952268i,1.750554-0.9169697i,-0.8797949+0.8686295i,0.3004159+1.139849i,-1.164511-1.603286i,1.704989-0.5623097i,-1.059118+0.551855i,0.2216226-2.043205i,-0.7848714-1.703867i,-1.284932-0.8215179i,-1.085697+0.1203622i,-0.3592373+0.6676086i,0.4956913+0.6139904i,-0.9026684-1.109106i,-0.9927321-0.3545634i,0.7844781-1.305056i,0.1355311-1.526719i,0.6598605+0.2511998i,-0.8131739-0.758615i,0.9035038-0.9038874i,-0.2845923+0.2554205i,0.2931609+0.2772781i,0.7266988-0.06675032i,0.8230706-0.5803838i,0.161765-1.136745i,0.3707079-0.05918973i,0.5251614-0.3438154i,-0.3104437-0.4513531i,-0.1840401-0.3019193i,0.2321825-0.8211198i,0.07426524-0.1811946i,-0.07903093-0.8865355i,0.4847285-0.2657587i,-0.4738656-0.5029008i,-0.4108755-0.1021416i,-0.04328578+0.2080375i,0.5079269+0.192576i,0.9522896-0.2336626i,-0.8206188-0.1461497i,-0.3691684+0.4190389i,-0.2114589-1.590945i,-0.8836843-1.151812i,1.273629-0.7053739i,-0.7082965+0.4200269i,0.06506979-1.795125i,0.9586241+0.4393005i,-1.229395-0.6889729i,-1.038411+0.2263786i,-0.2820897+0.8048468i,0.6861603+0.7487635i},
    {-1.24566+0.9919105i,-0.6682528+1.419737i,-0.9344268-0.5227525i,-1.447733+0.04674654i,0.5798885-0.0005187123i,0.04402616-0.5699939i,-0.1292696+1.451148i,-1.330309-0.1538997i,0.5960366+0.2459244i,-1.076215+1.189026i,-0.4160268+1.391135i,0.19061+1.127851i,0.4750143+0.5619556i,0.3424383-0.03192104i,-0.1171119-0.3991287i,-0.1693654+1.225427i,0.2734089+0.8763977i,-1.261442+0.492346i,-1.021982+0.9951744i,-0.3403926-0.4099638i,0.02118305+1.101558i,-1.212035+0.1699415i,0.3209163+0.102501i,-0.05413852-0.2980146i,-0.5922037-0.3639843i,-1.040638-0.07444625i,-1.002971+0.9013652i,-0.3000107-0.3142645i,-0.7821748-0.2183459i,0.2264894+0.6721431i,0.2263667+0.2049714i,-0.7991847+0.970809i,-0.4896227-0.2341097i,0.00417273+0.8666173i,-1.030689+0.3246982i,0.08320231+0.126549i,-0.1971637-0.1089421i,-0.5481056-0.1352098i,-0.8442501+0.03940801i,-0.9909166+0.3507923i,0.07478901+0.1240911i,-0.1866102-0.1439043i,-0.2766197+1.033891i,0.1052552+0.8270389i,-1.144547+0.4305708i,0.1334728-0.08389615i,-0.5408593+1.18698i,-0.8661406-0.2674191i,0.3625439+0.6439081i,0.3284977+0.06240254i,-0.0853501-0.3505216i,-0.6637929-0.3861955i},
    {0.0896272-1.271136i,-0.7330745-1.428398i,0.3048179+0.3432109i,0.4834715-0.4118121i,-1.226321+0.4057223i,-0.5725439+0.6139494i,-1.116398-0.9977809i,0.2603726-0.1747112i,-1.237255+0.05787258i,-0.2689154-1.010083i,-0.747655-1.015954i,-1.124394-0.742233i,-1.260687-0.2979906i,-1.093302+0.1443803i,-0.6733826+0.3901865i,-0.9284602-0.94762i,-1.252454-0.5488759i,0.118756-0.6142219i,-0.2528322-0.981012i,-0.3396794+0.3543323i,-1.144909-0.6662292i,0.08547748-0.4537907i,-0.9212456+0.1731706i,-0.5078504+0.2520886i,-0.1759874+0.05425764i,-0.06490342-0.2789204i,-0.4290858-0.718039i,-0.4198862+0.03992217i,-0.2501329-0.1301764i,-0.8881225-0.2908652i,-0.7849066-0.1089991i,-0.5029223-0.6079663i,-0.4330435-0.08351949i,-0.7673766-0.4298328i,-0.3447321-0.3475716i,-0.6991385-0.2084123i,-0.6275625-0.1726297i,-0.5660449-0.1556033i,-0.4905301-0.1426312i,-0.3800263-0.167517i,-0.8377541-0.3589907i,-0.85506-0.1497368i,-0.4070307-0.7027689i,-0.7107629-0.7647919i,-0.09164368-0.06225376i,-1.126059-0.1953816i,-0.1812473-0.8391267i,-0.4800287+0.3611391i,-1.0979-0.8100165i,-1.327617-0.3228723i,-1.162679+0.2198381i,-0.6529159+0.5275412i},
    {-2.229712-0.737698i,-2.588237+0.0829226i,-0.1526652-0.4755065i,-0.831446-0.9915134i,-0.8490948+1.433064i,-0.1978762+0.9172897i,-2.519555+0.3368311i,-0.3375637-0.643514i,-1.444893+1.484886i,-1.903332-0.8841507i,-2.466073-0.2438387i,-2.506641+0.619275i,-1.989832+1.327233i,-1.130272+1.555243i,-0.308637+1.183506i,-2.615303+0.08611448i,-2.403476+0.9853337i,-0.8596407-1.096635i,-1.796035-1.052273i,-0.03139615+0.8673732i,-2.611897+0.512621i,-0.4041634-0.8506427i,-1.23898+1.588364i,-0.3917904+1.25844i,0.04989872+0.4812587i,-0.08920088-0.3856934i,-1.57485-1.0403i,-0.2316827+1.031501i,0.05813314+0.2310074i,-2.319353+1.043765i,-1.594901+1.552858i,-1.838808-1.057487i,0.0349596+0.8807316i,-2.722645+0.5471081i,-0.3099189-0.9931441i,-1.20244+1.813663i,-0.1619329+1.429294i,0.3903433+0.4317852i,0.1484596-0.7073845i,-0.7959762-1.417667i,-0.5350043+1.7822i,0.307394+0.9351691i,-2.909057+0.7042769i,-2.200438+1.653323i,-1.464098-1.46226i,-0.024112+1.376045i,-2.935008+0.138533i,0.07337258-0.7772552i,-1.638839+1.841856i,-0.5171677+1.704262i,0.2549523+0.8819592i,0.3195081-0.2436257i},
    {-0.2548707-0.4488682i,-0.4875888-0.1388872i,0.4730519-0.1552298i,0.2244391-0.3901438i,0.11473+0.4759755i,0.3577709+0.2958863i,-0.4122285+0.05323594i,0.3177864-0.2420584i,-0.05038239+0.4413305i,-0.2080086-0.3141196i,-0.3847908-0.08543801i,-0.3641109+0.2090715i,-0.1450413+0.4138538i,0.1562012+0.4089518i,0.3637037+0.1948011i,-0.3358759+0.1641684i,-0.1296402+0.3471914i,-0.1060407-0.2515294i,-0.2407659-0.06376512i,0.2110773-0.06270789i,-0.03833437+0.2026388i,-0.06040571-0.06647515i,0.08085862+0.03222508i,0.006549214+0.002552568i,-0.03483234+0.06448758i,0.02205103+0.1330561i,0.1851136-0.0222109i,-0.08206152+0.2337914i,0.1012948+0.2640056i,-0.2381089-0.06724985i,-0.2497945+0.143564i,0.1209076-0.2306874i,0.1119643+0.3038791i,-0.2438623-0.091823i,0.274797-0.03613906i,-0.1418475+0.251237i,0.0258972+0.2884855i,0.1715907+0.2216209i,0.248977+0.0895763i,0.2404494-0.06243822i,-0.1263591+0.2589122i,0.03676548+0.3131691i,-0.1981085-0.1846665i,-0.3145785-0.009282449i,0.3093885-0.1527102i,-0.1056598+0.3975065i,-0.1517611-0.3396831i,0.4014845+0.2207394i,-0.4317123+0.1628617i,-0.246713+0.445393i,0.09856336+0.5345106i,0.4293725+0.3583918i},
    {0.1342321+0.351472i,0.2150768+0.2555772i,-0.03246123+0.07572731i,-0.02828539+0.1100205i,0.2382482+0.1056194i,0.2486152+0.01503728i,0.01299878+0.3573026i,-0.003743586-0.1527567i,0.3916822+0.3024438i,-0.2891728+0.2004647i,-0.1666391+0.466625i,0.1279435+0.5852435i,0.4419382+0.4644767i,0.5981336+0.1510594i,0.5026113-0.1958979i,-0.008931093+0.652095i,0.3607005+0.6051613i,-0.4303774-0.07239147i,-0.4511432+0.3139765i,0.4024471-0.3798281i,0.1845049+0.7346407i,-0.3839534-0.2942382i,0.7548044+0.139534i,0.6220773-0.3100351i,0.2098254-0.5728645i,-0.2918667-0.4945195i,-0.6026745+0.4482402i,0.4064017-0.5866133i,-0.1491465-0.623078i,0.7784863+0.5309566i,0.8780848-0.02459659i,-0.3957962+0.761634i,0.0422342-0.6735997i,0.66107+0.6954923i,-0.7078208+0.0744506i,0.7303337-0.3620748i,0.2477244-0.6598317i,-0.3110553-0.562565i,-0.6629044-0.1188843i,-0.6288961+0.4436583i,0.4181235-0.5807797i,-0.1315643-0.6040587i,0.7333167+0.5145686i,0.8086514-0.003460968i,-0.3419239+0.6788465i,0.06106538-0.5487788i,0.5406582+0.5988471i,-0.5259093+0.05966741i,0.5915767-0.2049085i,0.2592793-0.4252878i,-0.1222358-0.3881839i,-0.3877359-0.1274421i},
    {0.7924982-0.1635426i,0.08737618-0.5261579i,0.472512+1.462857i,0.8770695+0.8647273i,-0.9706024+0.9383004i,-0.500985+1.369576i,-0.2677657-0.2699653i,0.5341816+1.069161i,-0.8416405+0.5499656i,0.4846085+0.1419363i,0.1079079-0.08141381i,-0.3001087-0.04456465i,-0.5963776+0.2052577i,-0.6965192+0.5638221i,-0.5829271+0.9102482i,0.1207574-0.009120222i,-0.2513596-0.03848596i,0.4136861+0.972132i,0.588906+0.5984163i,-0.6809198+0.9625763i,0.1522698-0.1540314i,0.1825818+1.318226i,-0.8110231+0.1207868i,-0.9734362+0.6853958i,-0.7209368+1.255871i,-0.1287512+1.542074i,0.9401308+0.7758435i,-1.031919+1.083874i,-0.4750901+1.594901i,-0.4706898-0.4901895i,-1.077153+0.003089854i,1.041389+0.3459531i,-0.8139164+1.469354i,-0.1208006-0.6061804i,0.6993162+1.440574i,-1.262779+0.4026446i,-1.093365+1.204407i,-0.4408683+1.707922i,0.386122+1.667088i,0.9895177+1.09677i,-1.251966+0.8561462i,-0.7814261+1.537018i,-0.1890849-0.6189908i,-0.9210754-0.2655077i,1.069675+0.6601022i,-1.025567+1.223009i,0.2093298-0.5279768i,0.370117+1.583307i,-1.078347+0.06741584i,-1.164382+0.8013681i,-0.7748407+1.426291i,-0.07729237+1.672676i},
    {-1.049862-0.7166992i,-1.625531-0.3344021i,0.2484602+0.3836408i,0.05577806-0.2526875i,-1.129606+1.335271i,-0.4613942+1.342297i,-1.694524-0.2566721i,0.2965553+0.268855i,-1.642486+1.098817i,-0.6112598-0.8042838i,-1.390425-0.6951696i,-1.939768-0.09678264i,-1.979025+0.7351388i,-1.465089+1.408191i,-0.6319335+1.593284i,-1.728444-0.5152107i,-2.0574+0.2639912i,0.219641-0.3799494i,-0.4524348-0.8527344i,-0.34082+1.498297i,-1.88049-0.2935568i,0.4604936+0.1860116i,-1.728929+1.260994i,-0.9738308+1.682993i,-0.07385613+1.54932i,0.5853051+0.8457122i,0.01486735-1.053298i,-0.5032758+2.000472i,0.5569341+1.438093i,-2.597266+0.4148439i,-2.130704+1.611392i,-0.6435714-1.516827i,0.3207773+1.853892i,-2.648679-0.04993463i,0.8411872-0.5787973i,-1.429947+2.105104i,-0.1290837+2.069031i,0.8147677+1.202914i,0.9639764-0.04763689i,0.2789068-1.079465i,-0.7113007+2.105734i,0.3908244+1.619945i,-2.521431+0.1345154i,-2.23973+1.283467i,-0.3133426-1.291482i,-0.124843+1.892813i,-2.306762-0.394957i,0.8041745-0.06560628i,-1.74735+1.675247i,-0.6611987+1.943169i,0.3186134+1.449775i,0.7333222+0.461785i},
    {0.878099+1.420609i,1.313096+0.6809043i,-0.9151011+0.9595685i,-0.312525+1.458494i,-0.1794921-0.6301934i,-0.7358529-0.1920993i,1.152133+0.3647156i,-0.6410579+1.075123i,0.3266734-0.5685477i,0.5743054+1.318675i,1.046175+0.8502911i,1.128321+0.1754157i,0.7589451-0.4147057i,0.08446036-0.6383557i,-0.5847518-0.3715054i,1.17481+0.5637299i,1.018237-0.1393497i,-0.2012051+1.399719i,0.4904953+1.36536i,-0.7358676-0.08162809i,1.088705+0.2730796i,-0.5338114+1.108409i,0.2258598-0.5246229i,-0.3641899-0.3924419i,-0.7630987+0.06604312i,-0.8114861+0.685547i,0.1712825+1.451578i,-0.5856954-0.3857884i,-0.9673858+0.2456481i,1.09911-0.171456i,0.4964761-0.6852434i,0.5652518+1.511335i,-0.929994-0.135152i,1.289464+0.147698i,-0.5836558+1.372862i,0.04831-0.7637473i,-0.6844765-0.4273966i,-1.021548+0.2894223i,-0.8253549+1.040904i,-0.2085789+1.487249i,-0.2860886-0.6124922i,-0.8309696-0.11883i,1.197394+0.2343199i,0.8439912-0.3918676i,0.06985737+1.492902i,-0.503341-0.4603862i,1.167956+0.7091795i,-0.8783692+0.840853i,0.6492221-0.5532253i,-0.07624809-0.6826715i,-0.7368073-0.3244108i,-1.0341+0.385692i},
    {-0.6345291+0.6616368i,-0.2459343+0.7228575i,-0.8238946-0.3169589i,-1.007201+0.05136035i,0.2151506-0.2513905i,-0.1217511-0.5567813i,-0.1112109+0.8126904i,-1.023071-0.2927957i,0.4474912-0.009958683i,-0.9143807+0.749924i,-0.3647263+0.9877576i,0.2256417+0.7974253i,0.5505369+0.2500607i,0.4294264-0.3857541i,-0.08598455-0.7859596i,0.02284885+0.9710754i,0.4882971+0.5180768i,-1.262661+0.3460207i,-0.8996405+0.869229i,-0.4231619-0.815914i,0.2837425+0.7872469i,-1.287642-0.004467275i,0.4436925-0.3950981i,-0.05855085-0.8037128i,-0.7216262-0.7994183i,-1.241254-0.358424i,-0.9754613+0.9457575i,-0.4433708-0.9363797i,-1.121553-0.6222692i,0.7023649+0.1523417i,0.4554805-0.5597555i,-0.5144286+1.140111i,-0.9128422-0.7424639i,0.5971233+0.3747586i,-1.217053+0.5292359i,0.001943641-0.7312843i,-0.6201756-0.7219654i,-1.058518-0.333454i,-1.138773+0.2094649i,-0.8753213+0.6498328i,-0.2893716-0.595593i,-0.721471-0.4624076i,0.257756+0.3374064i,0.2521491-0.07554027i,-0.7239807+0.619832i,-0.3727078-0.509222i,0.03106361+0.5949994i,-0.962835-0.03426099i,0.2139327-0.1475003i,-0.06631206-0.4508744i,-0.4810711-0.5160419i,-0.8512301-0.3044679i},
    {0.6483179-0.4554833i,0.267419-1.292536i,-0.8536156+0.8865371i,-0.01305533+0.6681052i,-1.878146-0.7704238i,-1.831468+0.05699021i,-0.1113411-1.448238i,-0.4843824+0.7832067i,-1.602683-1.163965i,0.4862077-0.3756766i,0.2212496-1.131517i,-0.4648806-1.541519i,-1.250168-1.414905i,-1.764179-0.8172612i,-1.771314-0.04000699i,-0.1084544-1.335176i,-0.8400756-1.47106i,0.07802809+0.331739i,0.3367093-0.3203605i,-1.529663+0.1825582i,-0.4097587-1.343053i,-0.34093+0.5142435i,-1.527747-0.8823643i,-1.645848-0.266835i,-1.363559+0.2906896i,-0.796501+0.5581747i,0.2177096-0.08118056i,-1.610802-0.0619421i,-1.201311+0.4427404i,-0.8329523-1.364169i,-1.415716-1.062199i,0.2822946-0.3282672i,-1.497683+0.1720253i,-0.4316922-1.335411i,-0.3124128+0.5032798i,-1.557488-0.8495594i,-1.651338-0.2100299i,-1.325498+0.3457953i,-0.725365+0.575758i,-0.1138743+0.3816292i,-1.637684-0.6370319i,-1.587453+0.002099442i,-0.2426698-1.26119i,-0.8796482-1.363551i,0.05528974+0.2621392i,-1.70968-0.4437849i,0.1456194-0.9944611i,-0.9906636+0.626397i,-1.117958-1.403262i,-1.69209-0.9311498i,-1.847373-0.1705767i,-1.46621+0.5465216i},
    {0.07360524-0.07075051i,0.1273197-0.4481731i,-0.8611897+0.1624101i,-0.4765308+0.3301357i,-0.8758513-0.8484644i,-1.143196-0.4661814i,0.1714377-0.6538753i,-0.7303293+0.3651666i,-0.7093323-1.018775i,0.1865549+0.05271708i,0.2682922-0.4610388i,-0.006103205-0.8957675i,-0.4877605-1.041213i,-0.9354891-0.8454497i,-1.14711-0.4232014i,0.1244103-0.6573467i,-0.2174734-0.9376463i,-0.2751817+0.3157629i,0.07383179+0.06758918i,-1.128241-0.292121i,0.05501344-0.7560216i,-0.5981869+0.3636117i,-0.7929845-0.9501632i,-1.137603-0.6058319i,-1.185333-0.1027118i,-0.888413+0.3269309i,0.1247431+0.2275449i,-1.272318-0.3516711i,-1.105459+0.1862655i,-0.2995638-1.121477i,-0.8601172-1.035773i,0.3044391-0.02833471i,-1.231302-0.04344719i,-0.05449006-1.019135i,-0.3231545+0.4758075i,-1.073898-0.8306366i,-1.252332-0.3180692i,-1.061953+0.1824164i,-0.6018957+0.4403159i,-0.09184273+0.3460217i,-1.160254-0.5905394i,-1.165658-0.09001876i,-0.06544837-0.9302554i,-0.5387511-1.036157i,0.04480572+0.1899213i,-1.173121-0.3936675i,0.1379007-0.7051601i,-0.6843375+0.3635509i,-0.7231148-0.9880541i,-1.093135-0.6703832i,-1.175277-0.1848813i,-0.9237093+0.2423483i},
    {0.08610868+0.3627834i,0.1295103+0.5065243i,0.3555066-0.01598888i,0.116188-0.01242046i,0.7299026+0.4274257i,0.7510026+0.09537804i,0.1291111+0.7980675i,0.09764792-0.2180752i,0.8689291+0.5402895i,-0.2624811+0.5287797i,0.05170323+0.8820131i,0.5285281+0.9091526i,0.8841177+0.5944723i,0.9181073+0.1303428i,0.6314103-0.2172362i,0.4326209+0.883898i,0.7718067+0.6496493i,-0.232015+0.3416477i,-0.06490987+0.6790161i,0.3670052-0.2156657i,0.6122348+0.7278907i,-0.1761669+0.1758747i,0.772988+0.08067713i,0.5093114-0.161028i,0.1508044-0.1637883i,-0.1121983+0.0763918i,0.07806274+0.6823753i,0.2429348-0.1046949i,0.01566286+0.07539077i,0.6538476+0.2795973i,0.5256055+0.1013212i,0.2836775+0.5476016i,0.2301782+0.1210694i,0.4591768+0.409666i,0.1520233+0.2693629i,0.4986005+0.2600119i,0.4708129+0.1494956i,0.3549381+0.0517851i,0.1670967+0.05327555i,0.006959626+0.2037989i,0.6414372+0.1608871i,0.4666668-0.03867582i,0.4458747+0.6708682i,0.664839+0.4904248i,-0.06338705+0.4013453i,0.535003-0.01639969i,0.3649451+0.6817921i,0.04441213+0.0559816i,0.6778293+0.3203805i,0.5992338+0.09292734i,0.4004141-0.03168754i,0.1703901-0.004736558i},
    {0.2132522-0.6242599i,0.29847-0.7845369i,-0.2763861-0.7287737i,-0.1656196-0.5826582i,-0.01073144-1.174943i,-0.2164872-1.12024i,0.3705943-0.755158i,-0.3659477-0.6768314i,0.1944274-1.236444i,0.115627-0.3981329i,0.3997468-0.5649796i,0.5073241-0.8954744i,0.361495-1.226816i,0.02204579-1.380656i,-0.3402016-1.266901i,0.544277-0.7537696i,0.4741342-1.131578i,-0.1665989-0.3225131i,0.2133869-0.3388482i,-0.4821306-1.096086i,0.5339719-0.9663348i,-0.3249849-0.4151241i,-0.01884959-1.385612i,-0.3571684-1.246926i,-0.5299214-0.9259856i,-0.4603467-0.5686982i,0.1846414-0.3313375i,-0.4656282-1.133014i,-0.5481626-0.7719387i,0.3912917-1.257686i,0.04496475-1.421641i,0.3447034-0.3623191i,-0.5839745-1.006019i,0.5748965-1.1077i,-0.2722527-0.2579905i,-0.1757494-1.492107i,-0.5730867-1.226721i,-0.6988661-0.747328i,-0.4642989-0.2932139i,0.02650539-0.1119289i,-0.5100909-1.377072i,-0.732354-0.8918965i,0.5714497-1.303345i,0.1122339-1.55202i,0.3865076-0.2677706i,-0.6421146-1.01216i,0.5685022-1.136931i,-0.2165409-0.2867136i,-0.1821753-1.379014i,-0.4503489-1.115889i,-0.4843112-0.7722327i,-0.3103053-0.5070128i},
    {0.9894617-0.1500575i,0.8208057-0.5771203i,0.2404546+0.3214068i,0.5983783+0.2060848i,-0.08188679-0.348064i,-0.0203842-0.05871272i,0.495568-0.529845i,0.4134675+0.08272497i,0.1265221-0.3789692i,0.5751352-0.224333i,0.4926073-0.3471293i,0.3714721-0.3798524i,0.2799451-0.3327858i,0.255307-0.2573922i,0.2838848-0.2110592i,0.3684052-0.2173204i,0.3810382-0.1937169i,0.2512601-0.2238903i,0.2229514-0.1416539i,0.3989587-0.3991084i,0.440862+0.006176781i,0.07065372-0.3352183i,0.6691812-0.3282889i,0.5296641-0.5639191i,0.2322168-0.6445063i,-0.06616819-0.4806931i,-0.004606852+0.230862i,0.2915672-0.8157774i,-0.1241948-0.6485134i,1.008319-0.2098704i,0.8617806-0.6799529i,0.2646026+0.5047197i,-0.1020302-0.8233373i,1.101708-0.06026782i,-0.3453331+0.1909255i,0.580799-0.9985163i,-0.01525961-0.9706901i,-0.4421197-0.5389076i,-0.4638928+0.07528394i,-0.06164664+0.5454313i,0.1293624-1.053592i,-0.3746636-0.6967766i,1.191729-0.3340434i,0.8966727-0.8640923i,0.3514836+0.6310421i,-0.2198972-0.844828i,1.174112-0.1096948i,-0.3579232+0.2473479i,0.5674762-1.027081i,-0.02197628-0.9815449i,-0.4430499-0.5558415i,-0.4795706+0.05168818i},
    {-0.9560177-0.02705189i,-0.7948627+0.2999097i,-0.4042284-0.6683146i,-0.7750655-0.5659925i,0.1438254+0.0282367i,0.11118-0.3742562i,-0.6792226+0.4563234i,-0.6014459-0.7162129i,0.1095111+0.2575039i,-1.092903-0.03653152i,-0.9003364+0.3911749i,-0.4610473+0.5958974i,0.01870393+0.4568307i,0.2928062+0.02369024i,0.206626-0.4920515i,-0.6490994+0.6067135i,-0.1184475+0.5721555i,-1.10647-0.4064524i,-1.123434+0.1148852i,-0.06178406-0.7190365i,-0.3077462+0.5747387i,-0.9458383-0.5322284i,0.2162757-0.1147252i,0.04609928-0.5076326i,-0.3148756-0.6958353i,-0.69731-0.6234834i,-0.9760211+0.02508148i,-0.08004157-0.5484363i,-0.4292009-0.672524i,-0.07047299+0.3370506i,0.1360519+0.01164851i,-0.9438739+0.1637377i,-0.2067484-0.6489392i,-0.2484989+0.4490687i,-0.9221552-0.4131645i,0.137925-0.1918049i,-0.0570504-0.5283865i,-0.413325-0.654945i,-0.7557617-0.5278195i,-0.9329726-0.2239843i,0.02559788-0.3257794i,-0.2131411-0.5501578i,-0.3261416+0.3655022i,-0.06045309+0.1981822i,-0.9040733-0.1201929i,-0.04803453-0.3917982i,-0.5489764+0.3525854i,-0.6228182-0.54181i,-0.004709503+0.1083405i,0.03494863-0.2061747i,-0.1323583-0.4732761i,-0.4273331-0.5737218i},
    {-0.7312873-1.094919i,-1.25153-0.7591314i,0.4751342-0.5000216i,0.1259206-1.137072i,-0.3369804+0.7663817i,0.3878689+0.411982i,-1.61955-0.233873i,0.3312108-1.150877i,-0.48199+0.8750945i,-1.26554-1.172324i,-1.635572-0.4064217i,-1.390859+0.3920946i,-0.6895356+0.8069731i,0.08711691+0.6529638i,0.5550401+0.0436047i,-1.458527+0.09678644i,-0.9567928+0.6258264i,-0.7006974-1.312563i,-1.294194-0.9217533i,0.5518115-0.3636144i,-1.209934+0.4112287i,-0.3841277-1.325354i,0.1354038+0.5226135i,0.5245551-0.09148499i,0.3998465-0.8063924i,-0.1704343-1.243418i,-1.322638-0.6643035i,0.3563268-0.593277i,-0.07960556-1.027986i,-0.2942226+0.4409544i,0.09964788+0.09846767i,-1.098875-0.2390972i,-0.08182772-0.7022116i,-0.5225577+0.1849593i,-0.6912217-0.6686304i,-0.1349517-0.146701i,-0.1435751-0.3431844i,-0.2249253-0.4880475i,-0.3484321-0.5833673i,-0.5105002-0.6219094i,-0.2508579-0.03490591i,-0.1063613-0.2028363i,-0.8565952-0.1497561i,-0.6956788+0.0832879i,-0.548265-0.7715118i,-0.09546774+0.02548613i,-0.9921039-0.3099145i,-0.06164426-0.6426716i,-0.5659912+0.230639i,-0.1976253+0.1658826i,0.03579663-0.1223349i,0.02585189-0.4848286i},
    {0.2365868+0.5072128i,0.1124436+0.4212049i,0.01298602+0.6359513i,0.01226558+0.5669166i,0.07749475+0.5202109i,0.09011232+0.4177108i,0.05682988+0.7751275i,-0.2417586+0.3629022i,0.4021471+0.4937755i,-0.2787335+0.9141171i,0.06384657+1.083975i,0.4706813+0.9410748i,0.6740071+0.5120478i,0.5026534+0.0290992i,0.01364961-0.2090094i,0.5523698+1.125544i,0.8302892+0.6070298i,-0.6489353+1.068202i,-0.1316199+1.394302i,-0.4512539-0.1930478i,0.8606748+0.7982862i,-0.8012219+0.9190341i,0.389382-0.2765544i,-0.2411563-0.3346832i,-0.7645496+0.03432393i,-0.9266963+0.6637878i,-0.01758043+1.529292i,-0.6178951-0.232739i,-0.9938088+0.3660906i,0.9075631+0.01327841i,0.3418336-0.4611266i,0.4359053+1.537614i,-0.9733986+0.07568458i,1.076722+0.2441327i,-0.58988+1.48853i,-0.163561-0.5667911i,-0.8653582-0.1722081i,-1.126118+0.5960621i,-0.8037404+1.345473i,-0.05954636+1.685741i,-0.6948189-0.3430295i,-1.100952+0.3643071i,0.9484195-0.06048262i,0.2905287-0.5154479i,0.5130754+1.498818i,-0.9730185+0.1906209i,0.9510733+0.1582077i,-0.4044587+1.432707i,-0.2614227-0.3510627i,-0.7550376+0.08569057i,-0.8223802+0.7070292i,-0.476566+1.184718i},
    {-0.7077854-0.3773551i,-0.4153416-0.2285542i,-0.4794331-0.9660137i,-0.6152189-0.771497i,-0.01375479-0.7024707i,-0.1188887-0.8579033i,-0.3335253-0.3364175i,-0.4901608-0.892212i,0.009342113-0.5506626i,-0.6243557-0.4679698i,-0.4249288-0.2791235i,-0.1303039-0.2917492i,0.07149261-0.5275048i,0.03151324-0.8453805i,-0.2359786-1.029869i,-0.0743277-0.317697i,0.0716468-0.6010127i,-0.5829025-0.3808792i,-0.3040472-0.2815679i,-0.5660862-0.8513668i,-0.001806845-0.6752579i,-0.4798913-0.3937083i,-0.3728876-0.9028313i,-0.5365068-0.7644429i,-0.5481064-0.5631173i,-0.4177314-0.4217025i,-0.09724366-0.5448819i,-0.5286251-0.5362372i,-0.3889571-0.4012081i,-0.4389817-0.8583024i,-0.576578-0.6941113i,-0.07876126-0.7994496i,-0.3491045-0.3350941i,-0.5191895-0.8750728i,0.01835354-0.6233832i,-0.5548065-0.3922469i,-0.3037397-0.2829957i,-0.05005062-0.3914176i,0.04843317-0.6480743i,-0.06135927-0.8962406i,-0.3174879-0.2710541i,-0.07114675-0.3593778i,-0.6814673-0.6837488i,-0.6346083-0.4249794i,-0.1985221-1.02208i,-0.1333257-0.2424289i,-0.7384708-0.8223442i,0.1657702-0.7974147i,-0.567118-0.149507i,-0.1429536-0.06825291i,0.244868-0.3351718i,0.3268875-0.8354617i},
    {-2.142238-1.683924i,-2.286919-0.6635301i,0.01178034-2.168685i,-0.9782793-2.440875i,0.1867459+0.0252549i,0.5818715-0.9043661i,-1.982912-0.1166093i,-0.5702393-2.364197i,-0.1799809+0.2300906i,-2.140668-1.462151i,-2.122816-0.5173156i,-1.503116+0.1766651i,-0.5961788+0.2968733i,0.1556755-0.1941009i,0.4003857-1.038598i,-1.753488-0.1513132i,-0.9959008+0.2000756i,-1.493014-1.953054i,-1.930922-1.304953i,0.141913-1.415061i,-1.330736-0.05264926i,-1.070926-1.972009i,-0.09173838-0.3799323i,0.08504361-0.9945105i,-0.1533041-1.561115i,-0.6735446-1.843171i,-1.597059-1.328999i,-0.08765687-1.170044i,-0.3842673-1.580937i,-0.8602208-0.2575252i,-0.435557-0.4287549i,-1.494686-1.171705i,-0.2528268-1.202576i,-1.208764-0.4777573i,-0.8509194-1.593297i,-0.5156808-0.479263i,-0.2753311-0.7516071i,-0.2165825-1.130198i,-0.3931176-1.506258i,-0.7919636-1.729246i,-0.4182-0.3120491i,-0.03807888-0.7137643i,-1.711626-0.6570889i,-1.327694-0.1364265i,-1.05223-1.987526i,-0.01896657-0.325003i,-1.956494-0.9408688i,-0.02445756-1.758999i,-0.9842085+0.1687262i,-0.1905372-0.004988497i,0.3058857-0.6637534i,0.2557983-1.498137i},
    {-0.1108099-0.6609341i,-0.08457819-0.5545651i,0.1369402-0.8540867i,0.002746525-0.8533148i,0.2443345-0.5685551i,0.2508143-0.6983323i,-0.02722335-0.544788i,0.08440736-0.7902364i,0.1095716-0.5748129i,0.02802942-0.7331453i,0.001574896-0.7379019i,-0.06615905-0.7140417i,-0.1221405-0.6081624i,-0.07309859-0.4477489i,0.1165339-0.3488855i,-0.2129549-0.900282i,-0.344309-0.6368469i,0.3872827-1.001077i,0.07222158-1.15875i,0.4296668-0.2823838i,-0.4683518-0.7084845i,0.521069-1.003487i,-0.04177943-0.09942872i,0.362459-0.1477928i,0.6445621-0.4517901i,0.667047-0.8774665i,-0.05089149-1.340711i,0.6378004-0.2124669i,0.8327039-0.6994354i,-0.4947538-0.1059271i,0.02682592+0.1661255i,-0.4738844-1.3307i,0.9533504-0.5457609i,-0.6645901-0.1396366i,0.2559837-1.562571i,0.5560997+0.1191101i,0.9574457-0.4205464i,0.8802245-1.081037i,0.3826208-1.504086i,-0.2555491-1.479814i,0.8492504-0.2840802i,0.891838-0.8917854i,-0.3814439+0.03802674i,0.1967798+0.1541019i,-0.5566353-1.190132i,0.8889799-0.6931677i,-0.5071847-0.0989164i,0.1184944-1.466705i,0.5810648-0.05504842i,0.8446202-0.5713643i,0.6770642-1.115176i,0.1912045-1.376794i},
    {-0.001250638-0.36379i,0.1038585-0.1445941i,0.4401823-0.634768i,0.2742156-0.5912454i,0.553636-0.2068024i,0.5880608-0.3151025i,0.1491327-0.2702367i,0.5328581-0.5478171i,0.3392454-0.05170008i,0.1875329-0.6400334i,-0.0001664473-0.4752735i,-0.03560485-0.1884135i,0.1536194+0.07565878i,0.5031933+0.1446095i,0.8265603-0.06023116i,-0.189131-0.2444612i,0.01849832+0.1203678i,0.304837-0.9411196i,-0.08408556-0.7455559i,0.9684315-0.3602045i,-0.06479771+0.06004097i,0.4155035-0.9298748i,0.708094+0.1060988i,0.9040198-0.2335267i,0.8308992-0.5989878i,0.5546133-0.8161161i,-0.01184965-0.6111323i,0.8138937-0.3681563i,0.7081648-0.62537i,0.2568026+0.0775697i,0.5355536+0.06971364i,-0.0348937-0.5902339i,0.8593886-0.409104i,0.003433229+0.03087568i,0.4035449-0.9047936i,0.7248247+0.1193469i,0.9727538-0.2330116i,0.9108473-0.6833856i,0.5412888-0.9783831i,0.05901467-0.9325621i,0.9918013-0.1370231i,0.9557308-0.6203189i,0.1351924+0.2348039i,0.5869885+0.2089029i,-0.1390494-0.5923123i,0.8661848-0.4952688i,0.1138392+0.05123536i,0.3129798-0.770801i,0.6390027-0.08019347i,0.7080715-0.2954518i,0.6576611-0.4833432i,0.5340815-0.6111575i},
    {0.5797799-1.95658i,-0.07268608-2.122514i,0.9374112-0.5255815i,1.19411-1.237599i,-0.659749-0.3480318i,0.07943329-0.009078539i,-0.6389257-2.04784i,1.280935-0.9949524i,-0.8645438-0.5004225i,0.412582-2.290986i,-0.4021216-2.195845i,-0.9403158-1.59954i,-0.9583923-0.8163008i,-0.4799307-0.2220395i,0.2489641-0.07235735i,-0.6669925-1.905286i,-0.9608462-1.247008i,1.013046-1.764199i,0.4349011-2.206538i,0.5382257-0.1217151i,-0.8937858-1.697024i,1.263615-1.396639i,-0.6224641-0.2049917i,0.1812935+0.07369307i,0.9927745-0.2582479i,1.385425-1.066025i,0.3421156-2.420328i,0.7893441-0.07528674i,1.321726-0.8140528i,-0.9829061-0.6136304i,-0.3221963-0.05488646i,-0.2780382-2.223985i,1.068445-0.6440589i,-0.8823754-0.9285498i,0.6859057-1.928644i,0.1698608-0.2608664i,0.6835814-0.5427955i,0.8871436-1.039251i,0.7549553-1.513698i,0.3936858-1.792213i,0.2648934-0.5083836i,0.6072661-0.7378058i,-0.5198469-1.197088i,-0.4121188-0.8087508i,0.3201545-1.752207i,0.3194317-0.5615741i,-0.412926-1.494716i,0.7324549-1.22087i,-0.3206538-0.7277452i,0.04206775-0.5638504i,0.4138242-0.65979i,0.6364266-0.9506511i},
    {0.02601158+1.422566i,0.758586+1.292942i,-0.8684571+0.1014395i,-0.8153464+0.8738688i,0.6171041-0.6257961i,-0.1625015-0.6655561i,1.133625+0.9775984i,-0.9227102+0.5761091i,0.9029161-0.4551596i,0.1792079+1.516234i,0.9061143+1.254398i,1.295064+0.5812202i,1.15467-0.1908777i,0.5392423-0.6915164i,-0.2620495-0.6673498i,1.213573+0.9108524i,1.294592+0.1041042i,-0.4617142+1.344763i,0.3202708+1.518125i,-0.6483816-0.341583i,1.261972+0.4108494i,-0.6257291+1.071151i,0.3507166-0.6042873i,-0.3135124-0.4489603i,-0.7052135+0.07044038i,-0.6815224+0.6906218i,0.2693904+1.249777i,-0.4070758-0.2045429i,-0.6406536+0.2900617i,0.8810797-0.02466491i,0.4633467-0.3636279i,0.4319034+1.16154i,-0.4910278-0.03747475i,0.9665294+0.3141193i,-0.3746338+0.948219i,0.2652554-0.3704444i,-0.2267014-0.2473871i,-0.5302027+0.1479716i,-0.5247132+0.6390465i,-0.2214387+1.019274i,0.1093615-0.3397077i,-0.3339553-0.1383388i,0.9187108+0.494699i,0.8203281+0.006812432i,-0.07217621+1.10644i,-0.0759033-0.3124131i,0.8246655+0.7797652i,-0.5537962+0.5091639i,0.668013-0.145025i,0.2191478-0.3150934i,-0.2200332-0.1713037i,-0.4669822+0.1960332i},
    {-1.713558-1.313976i,-1.785039-0.2558598i,0.5006816-1.949803i,-0.5198941-2.170642i,0.7780943+0.3154903i,1.14609-0.6341224i,-1.468356+0.2188921i,-0.03029118-2.092242i,0.3458079+0.5772325i,-1.635309-1.217392i,-1.666966-0.2594813i,-1.084448+0.4957267i,-0.1558433+0.706197i,0.693832+0.2744479i,1.0699-0.6040366i,-1.440499+0.1566865i,-0.632546+0.6759891i,-0.96832-1.909556i,-1.60099-1.192708i,0.9604182-1.119125i,-1.005122+0.4660368i,-0.5484983-1.968338i,0.6517713+0.130714i,0.9060818-0.6902725i,0.5818351-1.449342i,-0.1212469-1.806431i,-1.298751-1.086222i,0.6527109-0.956498i,0.2592782-1.471512i,-0.3078836+0.2731198i,0.2560175+0.05181782i,-1.219508-0.9110822i,0.5190377-1.040246i,-0.7755334+0.1135677i,-0.4542146-1.588119i,0.3343239-0.04411624i,0.5900875-0.5837657i,0.4592545-1.169294i,-0.005670316-1.55149i,-0.6086204-1.567404i,0.4464757-0.1544523i,0.6155819-0.7378294i,-1.043274-0.05551332i,-0.5129684+0.2685547i,-0.7682499-1.567579i,0.5932314-0.2452561i,-1.347472-0.4509784i,0.3544567-1.527476i,-0.3247586+0.4417728i,0.4105957+0.2221574i,0.8594379-0.4421989i,0.7770972-1.274387i},
    {0.7534966+0.738198i,1.262571+0.2044434i,-0.7363847+0.01560994i,-0.3252912+0.5849431i,0.2403411-1.261895i,-0.3659268-0.998228i,1.24589-0.06694952i,-0.5740558+0.1892955i,0.697766-1.120601i,0.4942892+0.6944965i,1.038317+0.3755178i,1.280355-0.2211772i,1.098682-0.8569352i,0.544862-1.251998i,-0.1528138-1.209042i,1.249951+0.2219518i,1.3444-0.5005508i,-0.3772527+0.6244478i,0.3292089+0.8544697i,-0.4493427-1.081414i,1.386638-0.06880023i,-0.687482+0.3040091i,0.7009145-1.300371i,-0.05252867-1.340853i,-0.6772119-0.8973501i,-0.8939228-0.1443983i,0.1551498+0.9893649i,-0.4269209-1.312119i,-0.9756894-0.6073139i,1.503586-0.8127577i,0.847636-1.493745i,0.686424+1.07214i,-0.8928879-0.985072i,1.657858-0.4757677i,-0.5898239+0.8174506i,0.2445763-1.613561i,-0.6231467-1.23447i,-1.0161-0.3990692i,-0.7742723+0.4630287i,-0.05600568+0.9453576i,-0.200619-1.356307i,-0.7634464-0.78054i,1.407735-0.494742i,0.9902644-1.125381i,0.2852709+0.8539053i,-0.3925632-1.101641i,1.338933-0.01042343i,-0.6792672+0.2173149i,0.7468694-1.215288i,0.04141048-1.289719i,-0.556789-0.9065927i,-0.7841316-0.2314586i},
    {0.820127-0.1985847i,0.4879036-0.9042927i,-0.5114059+0.9468321i,0.2006838+0.7883309i,-1.352604-0.5150644i,-1.359332+0.2043314i,0.2084074-1.057928i,-0.1829785+0.9223784i,-1.173633-0.8447899i,0.7352952-0.1577836i,0.4469699-0.8710333i,-0.2466692-1.202367i,-0.9716415-0.9757032i,-1.335535-0.3302784i,-1.162804+0.3607989i,-0.1041208-1.006971i,-0.7180002-0.8856801i,0.3493325+0.1365462i,0.2808778-0.3634666i,-0.6442985+0.3550421i,-0.4128327-0.6274912i,-0.07447103+0.1543069i,-0.668417-0.23721i,-0.6344926-0.09959359i,-0.5940475+0.001206959i,-0.5321466+0.1184182i,-0.1268903+0.2483346i,-0.8306204-0.345935i,-0.9182114+0.02455892i,0.0125674-0.6923289i,-0.4434027-0.8516584i,0.2262154+0.3605387i,-1.153085-0.1397797i,0.2758445-0.6963681i,-0.4570978+0.7077961i,-0.832819-0.8677254i,-1.196135-0.3803759i,-1.152882+0.2238712i,-0.7338706+0.6541319i,-0.1429773+0.7197198i,-1.053675-0.6888996i,-1.251728-0.1322931i,0.3683912-0.7220234i,-0.1391546-1.070332i,0.08254657+0.7484121i,-1.288381-0.5832393i,0.7085755-0.4148224i,-1.015848+0.7953499i,-0.4610787-1.348296i,-1.270607-1.015574i,-1.671945-0.1832704i,-1.39465+0.7438217i},
    {0.5525529-0.9588689i,-0.5182519-1.26544i,0.7752287+1.403966i,1.214173+0.3830469i,-1.627643+1.291801i,-0.6883278+1.875302i,-1.155363-1.092686i,1.141968+0.8736721i,-1.908914+0.8721598i,0.4321194-1.136055i,-0.7170603-1.332389i,-1.731054-0.7124248i,-2.085475+0.4446361i,-1.568849+1.55879i,-0.4263432+2.040831i,-1.493324-1.003546i,-2.067103+0.09359673i,0.9972572-0.6533678i,-0.01774159-1.283226i,0.4046368+1.680384i,-1.807734-0.1667349i,0.9438038-0.2602343i,-0.9515265+1.534629i,-0.03074848+1.531221i,0.6073194+0.9693757i,0.7182075+0.197692i,-0.2634958-0.6288644i,0.07873432+1.064687i,0.3921421+0.6188643i,-1.131375+0.5067146i,-0.8465235+0.8901621i,-0.3361208-0.4130049i,0.01119827+0.9008422i,-1.023356+0.06360416i,0.2881474+0.1251134i,-0.795516+0.8489441i,-0.3905882+0.9940762i,0.02435058+0.8699089i,0.2859721+0.5190819i,0.2846646+0.07580433i,-0.7605315+0.9007353i,-0.3210688+1.021517i,-0.8546961-0.2289198i,-1.090513+0.1732621i,0.2847446-0.02089956i,-0.7026883+0.9793395i,-0.5178087-0.434662i,0.1996452+0.8293536i,-1.167954+0.2349475i,-1.080591+0.7428804i,-0.6903574+1.119814i,-0.1161179+1.193162i},
    {0.1911213-1.358368i,-0.763907-1.421832i,0.7613762+0.8994966i,1.076495-0.01168073i,-1.556547+0.9422145i,-0.7096278+1.475788i,-1.101771-1.345493i,1.005493+0.5930804i,-1.855431+0.4458622i,0.4268153-1.260474i,-0.5657975-1.475394i,-1.442774-1.015013i,-1.816116-0.1320801i,-1.5656+0.7572415i,-0.8487995+1.287076i,-0.8174508-1.276748i,-1.50154-0.7655991i,0.955291-0.05023573i,0.6693786-0.8793705i,-0.7153798+1.393325i,-1.036414-1.330645i,0.9785922+0.6619134i,-1.933167+0.3772103i,-1.364954+1.306013i,-0.2989767+1.656426i,0.7605418+1.220847i,1.020523-0.9422811i,-0.8893189+1.636059i,0.2603831+1.572505i,-1.903417-0.7978938i,-2.074592+0.3262745i,0.7073078-1.309238i,-0.4413879+1.735539i,-1.473719-1.395008i,1.347865+0.4150679i,-2.047998+0.8090906i,-1.168251+1.713187i,0.1229787+1.844386i,1.21936+1.08929i,1.566481-0.2248261i,-1.760527+1.467979i,-0.4783262+2.013257i,-1.653097-1.580701i,-2.379529-0.3859364i,1.352648-0.9848869i,-1.094134+1.879657i,-1.080043-1.871063i,1.319381+0.9886827i,-2.341829+0.3542733i,-1.650827+1.517578i,-0.3754816+1.958418i,0.8784812+1.469755i},
    {-0.7273207-1.24516i,-1.358517-0.7897407i,0.9805933-0.08068886i,0.7434034-0.8880899i,-0.6723501+1.307732i,0.2748983+1.287309i,-1.68486-0.7554837i,1.228929-0.3936958i,-1.330027+1.229742i,-0.3731647-1.729754i,-1.453251-1.330523i,-2.02829-0.3147713i,-1.81451+0.8421347i,-0.9069343+1.599151i,0.2792515+1.608268i,-1.854025-0.9771762i,-2.112327+0.1978563i,0.925168-1.403767i,-0.204101-1.921303i,0.7903835+1.489519i,-2.202687-0.5519202i,1.477153-0.8961558i,-1.178811+1.776325i,0.2130459+1.931062i,1.395419+1.132335i,1.781512-0.2634127i,-0.1823569-2.198829i,0.9628244+1.674677i,1.784724+0.4359817i,-2.254076+0.9295092i,-1.162806+1.94882i,-0.9768221-2.137071i,1.527125+1.109718i,-2.491498+0.2514963i,1.131186-1.701694i,-0.3569572+2.137036i,1.077113+1.626725i,1.825256+0.3051586i,1.525285-1.173575i,0.3420992-2.082448i,0.479283+1.880792i,1.508828+0.8784888i,-2.278893+0.4021204i,-1.495998+1.514727i,-0.4227494-1.968192i,0.9416245+1.31934i,-2.131487-0.3154683i,1.214794-0.9823256i,-0.9208408+1.60444i,0.2556197+1.588862i,1.151599+0.8422933i,1.370803-0.2956641i},
    {0.1208202-0.02630905i,0.01625528+0.1432175i,0.5392728+0.000111975i,0.352028-0.1179116i,0.4650025+0.4176621i,0.572755+0.2330442i,0.08300219+0.3100799i,0.3637905-0.0430874i,0.3818422+0.3545724i,0.156968+0.09728516i,0.1635381+0.1831982i,0.1919401+0.2363575i,0.2240948+0.2814339i,0.2844582+0.3266874i,0.3890467+0.3325215i,0.106802+0.101393i,0.08396184+0.2592125i,0.4092698-0.04980954i,0.2184519-0.07120369i,0.5339494+0.2957559i,0.05742645+0.2503982i,0.418046-0.03219312i,0.3499633+0.3861762i,0.4519567+0.2873901i,0.4587129+0.1746495i,0.413365+0.1066779i,0.324871+0.05092733i,0.3469888+0.3213618i,0.4483701+0.2900017i,0.07883489+0.1802706i,0.1117569+0.3479068i,0.3274108-0.1073248i,0.4885662+0.4195744i,-0.01881554+0.1233954i,0.5797188-0.008543037i,0.2179357+0.5049071i,0.4579965+0.477896i,0.616565+0.3015628i,0.6235573+0.06928646i,0.4844513-0.1138833i,0.3423038+0.5248227i,0.5640576+0.4292836i,-0.08253302+0.1495147i,-0.02448631+0.42045i,0.3849586-0.2467192i,0.5380403+0.5628538i,-0.1561916+0.05370076i,0.7264481-0.06142482i,0.1623396+0.6506587i,0.5370775+0.6097359i,0.7658477+0.3136228i,0.71223-0.04616774i},
    {-1.792486+0.7336718i,-1.065917+1.436638i,-0.83154-1.372571i,-1.659974-0.8008615i,1.04687-0.01881554i,0.6521153-0.9437985i,-0.6534613+1.557286i,-1.225463-1.209005i,0.9704568+0.5750898i,-1.864749+0.5802355i,-1.228904+1.365824i,-0.2373248+1.576436i,0.6704533+1.114345i,1.089058+0.1775322i,0.8226854-0.8242305i,-0.8661991+1.588968i,0.1991978+1.530847i,-1.892511-0.6506605i,-2.044683+0.4454568i,0.555826-1.255746i,-0.3574193+1.756599i,-1.612518-1.1687i,1.260018+0.2680944i,0.9874592-0.8878693i,0.02433832-1.590972i,-1.164523-1.498111i,-2.09861+0.5182863i,0.5234998-1.321094i,-0.5982412-1.603932i,0.7355154+1.252029i,1.201778+0.2207118i,-1.796081+1.006143i,-0.0083974-1.494539i,0.2145909+1.546858i,-1.885252-0.6302469i,1.094953-0.3047893i,0.4840231-1.190717i,-0.5411694-1.472137i,-1.491483-1.034385i,-1.928503-0.1070929i,0.7830078-0.7134206i,-0.00488218-1.279349i,0.04840991+1.366789i,0.7160518+0.7560652i,-1.748791+0.2522306i,0.45272-0.8487297i,-0.5935217+1.333851i,-1.09165-1.009846i,0.7267781+0.5416037i,0.7808751-0.2746148i,0.3213339-0.9714358i,-0.4904492-1.24937i},
    {0.8844967-0.7154173i,0.5318785-0.7816507i,0.9060419+0.01126906i,0.995265-0.2788701i,0.2701992-0.06542156i,0.4934799+0.04720795i,0.4399405-0.5979355i,0.849445-0.1565105i,0.2932222-0.2507701i,0.76629-0.4972204i,0.60829-0.5594658i,0.4500735-0.5176426i,0.3513713-0.393356i,0.347853-0.2395262i,0.4350935-0.1195937i,0.5844911-0.5186616i,0.4584469-0.4732396i,0.7684755-0.2277441i,0.7700516-0.3467229i,0.4450537-0.1529334i,0.6082522-0.497089i,0.6668717-0.1086159i,0.3832366-0.4104653i,0.3368824-0.2720899i,0.3881924-0.1171149i,0.5400928-0.01789092i,0.884067-0.1993802i,0.2654886-0.1683818i,0.4211648+0.015759i,0.486907-0.647958i,0.274923-0.5064292i,0.9454949-0.3397433i,0.3246168-0.02798807i,0.5959107-0.6669635i,0.797335-0.006419295i,0.2257299-0.3848188i,0.2519384-0.1463104i,0.417479+0.02211986i,0.6497334+0.05417651i,0.8550537-0.06141554i,0.2043131-0.3157268i,0.2633358-0.07454211i,0.6887395-0.6848596i,0.4144198-0.6864829i,0.968542-0.09238335i,0.1226978-0.2017419i,0.8763733-0.6861108i,0.6057246+0.2142885i,0.2017155-0.6835174i,0.0178799-0.3389748i,0.1169205+0.05825946i,0.4724815+0.2942367i},
    {-0.3382562-0.6562313i,-0.1436577-0.2734507i,0.2059896-1.37618i,-0.2120345-1.203688i,0.8862072-0.7048204i,0.7584203-1.141793i,0.100937-0.1115468i,-0.06483634-1.324066i,0.8414118-0.4994072i,-0.3869205-0.5585392i,-0.1308036-0.2003832i,0.297922-0.07803727i,0.7192618-0.2535786i,0.9447372-0.6679858i,0.85325-1.150226i,0.02116691-0.02119778i,0.5554592-0.03006694i,-0.4909692-1.096196i,-0.5605829-0.5254351i,0.7039648-1.458074i,0.3609031+0.1048581i,-0.4223047-1.314642i,1.114985-0.7593852i,0.8920565-1.333651i,0.3477698-1.616342i,-0.2436444-1.473005i,-0.5436395-0.387853i,0.602106-1.527086i,0.01344219-1.576147i,0.9477437-0.2620552i,1.097175-0.8370118i,-0.3579048-0.120069i,0.2814588-1.619158i,0.7821174-0.06066756i,-0.6246589-0.9068208i,0.9901834-1.203074i,0.4940872-1.583448i,-0.1267163-1.530425i,-0.5433949-1.075777i,-0.5400891-0.4701299i,0.6144896-1.455854i,0.04678621-1.491857i,0.8509393-0.3505377i,0.9160953-0.859357i,-0.1569749-0.2495585i,0.2035571-1.331364i,0.6133317-0.3763806i,-0.2275687-0.7788176i,0.5657531-0.990578i,0.3248896-1.081859i,0.1307464-1.010145i,0.0513454-0.8760947i},
    {0.5685339+0.535505i,0.7640595+0.5927421i,0.6297231+0.008484735i,0.5135557+0.1485292i,1.081407+0.2162272i,0.9952093+0.05227857i,0.7509844+0.5785832i,0.627107+0.0018985i,1.084402+0.3887981i,0.4792847+0.3661433i,0.6042341+0.5375367i,0.8079627+0.591793i,0.997564+0.5086013i,1.093551+0.3313i,1.064773+0.1375593i,0.6432555+0.5444763i,0.8303022+0.5809322i,0.5654485+0.04064852i,0.4566515+0.2136516i,1.105029+0.1117224i,0.6239046+0.6160039i,0.6939445-0.1242874i,1.133642+0.5361369i,1.249436+0.2492538i,1.141249-0.06397591i,0.8355645-0.2363481i,0.2554392+0.1515672i,1.27612+0.006391195i,0.9822302-0.2567917i,0.9888535+0.8034229i,1.288012+0.543935i,0.2297953+0.3902947i,1.137688-0.1766095i,0.8050601+0.8421713i,0.409398-0.157741i,1.357165+0.3662021i,1.294835-0.02020861i,0.997918-0.2866708i,0.5886716-0.3064202i,0.2495031-0.0533377i,1.426217+0.1713524i,1.219437-0.233798i,0.7915571+0.956029i,1.251465+0.7967169i,0.07799485+0.1845451i,1.384943-0.1398158i,0.614937+0.9857373i,0.4363829-0.3767222i,1.482407+0.5189352i,1.463886-0.009495649i,1.095601-0.3826522i,0.5799333-0.4072301i},
    {1.456085+0.9875839i,1.388403+0.2295135i,0.1022059+1.668818i,0.8535611+1.637024i,-0.4453717+0.2889943i,-0.4518757+1.000166i,0.9095045-0.1038251i,0.6515538+1.551525i,-0.2103899+0.2155355i,1.231517+0.628695i,0.9682586+0.1812991i,0.5178038+0.02258999i,0.1044488+0.171131i,-0.1106463+0.5150439i,-0.07570845+0.8914875i,0.7556652+0.2396004i,0.4198085+0.1694918i,0.803994+1.088683i,0.9654588+0.798508i,-0.001433292+0.927925i,0.681486+0.232472i,0.5753909+1.204154i,0.04956374+0.3748254i,-0.06560052+0.7061983i,0.05781826+1.039356i,0.3690737+1.217227i,0.9470577+0.8714634i,-0.01439064+0.8789697i,0.223164+1.129691i,0.3646292+0.2366078i,0.1100417+0.4211015i,0.875411+0.6918283i,0.1627205+0.9406649i,0.5434352+0.3596508i,0.5721722+0.9954627i,0.2240117+0.5214429i,0.1764334+0.6649337i,0.1892272+0.8126062i,0.271623+0.9568965i,0.4444575+1.057503i,0.2328247+0.359428i,0.02266889+0.5556327i,0.934779+0.5113316i,0.7217569+0.2044359i,0.5966924+1.285336i,-0.06271898+0.3279482i,1.126243+0.6255928i,-0.007839757+1.212916i,0.4705523-0.01485399i,-0.009529371+0.142631i,-0.2694341+0.5811574i,-0.1807488+1.086299i},
    {-0.01056427-0.2538387i,-0.001971953-0.4010724i,-0.1161599-0.05718974i,0.09614877-0.1122771i,-0.4666739-0.2228303i,-0.3446626+0.04920066i,-0.2365315-0.7209981i,0.297337-0.03255974i,-0.6525051-0.1460173i,0.1588369-0.7851852i,-0.2848454-0.8755779i,-0.6768599-0.6136627i,-0.7733778-0.1374623i,-0.5039238+0.2794756i,-0.01371549+0.3949258i,-0.6867528-0.7092857i,-0.834449-0.2206544i,0.3506737-0.8095909i,-0.123799-1.00085i,0.3430782+0.256302i,-0.8468629-0.3762194i,0.4695675-0.6911529i,-0.3151436+0.4189645i,0.1943541+0.3697134i,0.5475151-0.002508691i,0.5711329-0.5170463i,-0.2614363-1.025484i,0.4599135+0.1950447i,0.6406563-0.3101165i,-0.7041189+0.2499724i,-0.2092237+0.5093754i,-0.6080287-0.9428251i,0.6786022-0.111285i,-0.8580337+0.1377496i,0.1220202-1.099208i,0.2425643+0.4904494i,0.6753952+0.02532502i,0.665158-0.6140152i,0.2130449-1.064708i,-0.4185338-1.069979i,0.6012029+0.06927262i,0.612604-0.5301627i,-0.4768667+0.3754309i,0.06642406+0.3894632i,-0.6978111-0.6116821i,0.4557959-0.4257386i,-0.4336681+0.1736478i,-0.2083394-0.7746612i,0.2133491-0.004421824i,0.2643235-0.2973633i,0.1306118-0.5200142i,-0.0839351-0.5952732i},
    {0.08528367-0.4516571i,-0.08498236-0.2570558i,0.4776392+0.05040498i,0.4286287-0.06922364i,-0.0004907036+0.1243934i,0.05901461+0.1940955i,0.2153712-0.2790751i,0.3133903+0.2762621i,-0.1144013-0.209094i,0.6023031-0.016856i,0.5673147-0.2947428i,0.3376101-0.5297542i,-0.04160159-0.5793391i,-0.4168696-0.3469097i,-0.5732138+0.1328525i,0.7243904-0.6773252i,0.1487985-0.9493915i,0.8956767+0.7251177i,1.280258+0.0671463i,-0.7271082+0.7106893i,0.3855377-1.215736i,0.8805663+1.054848i,-1.079436-0.3377077i,-0.9949394+0.6114436i,-0.2811024+1.25925i,0.6861776+1.257326i,1.511725-0.3406905i,-0.6001964+1.105765i,0.3126437+1.351229i,-0.7929862-0.9701852i,-1.191982-0.1115504i,1.318275-0.8316452i,-0.1480943+1.369084i,-0.4653235-1.296219i,1.543838+0.5481261i,-1.22561+0.4673848i,-0.5716118+1.298009i,0.4857865+1.488928i,1.412621+0.9209409i,1.726295-0.1272713i,-0.8858829+1.099377i,0.1199325+1.525847i,-0.7738341-1.196459i,-1.305939-0.2620243i,1.461912-0.7989034i,-0.2452468+1.410454i,-0.4202242-1.347652i,1.513206+0.5862348i,-1.185943+0.4186778i,-0.544091+1.208106i,0.4521486+1.364095i,1.284054+0.8154873i},
    {-0.6340058+0.1857719i,-0.01570172+0.6479912i,-0.1312398-1.389846i,-0.6458821-0.8606898i,1.29964-0.6540728i,0.8945104-1.204472i,0.3478212+0.5642097i,-0.3125399-1.114592i,1.212668-0.2211239i,-0.5191851+0.005327947i,-0.1025091+0.4259694i,0.4915636+0.5156865i,1.03504+0.2194428i,1.291734-0.3713846i,1.114431-1.02112i,0.06986199+0.6231416i,0.8000078+0.5591572i,-0.7199798-0.8196622i,-0.7619159-0.04228693i,0.8795677-1.383109i,0.5165083+0.7196571i,-0.5891632-1.106041i,1.430076-0.4556074i,1.108967-1.16583i,0.41704-1.482679i,-0.2924489-1.277893i,-0.614705-0.00133539i,0.7543715-1.267815i,0.1203504-1.336469i,1.01429+0.2062558i,1.226957-0.3604562i,-0.4453172+0.1298357i,0.5696921-1.285323i,0.644935+0.465694i,-0.5140895-0.877677i,1.25901-0.5462639i,0.967218-1.131378i,0.3525059-1.406334i,-0.3132415-1.218113i,-0.7080405-0.6308607i,1.232975-0.8874432i,0.6968321-1.377398i,0.6394634+0.5917961i,1.196339+0.1314819i,-0.7047947-0.2336071i,0.9542295-1.164516i,0.2931358+0.5742322i,-0.2876273-1.142488i,1.202859-0.2017595i,1.111402-0.7898678i,0.6967878-1.185113i,0.1437917-1.251729i},
    {0.4777498+0.09224547i,0.8840183-0.8932077i,-1.759335-0.02913845i,-0.8651151+0.4660575i,-1.328218-2.167711i,-1.907084-1.405824i,0.6370152-1.425999i,-1.261574+0.1748186i,-0.818455-2.216067i,0.3279066-0.1166959i,0.635961-0.8945339i,0.3929678-1.692553i,-0.2997978-2.164383i,-1.142978-2.091388i,-1.752412-1.490199i,0.6074578-1.281236i,0.1055558-1.992334i,-0.4849001+0.2925629i,0.2862877-0.100614i,-1.829072-1.017686i,0.3300914-1.680837i,-0.8526596+0.1731768i,-1.135975-1.936214i,-1.599824-1.356787i,-1.584018-0.6541987i,-1.152959-0.1528384i,-0.03039808-0.303696i,-1.429759-1.119909i,-1.341045-0.6190416i,-0.2255632-1.634409i,-0.6873888-1.72453i,-0.1047074-0.3658172i,-1.384939-1.145636i,0.1529786-1.265764i,-1.061554-0.214816i,-0.710928-1.863151i,-1.287941-1.644141i,-1.623505-1.072144i,-1.509394-0.373004i,-0.9376582+0.1133107i,-1.074675-2.017079i,-1.685806-1.472728i,0.5619458-1.272769i,0.07569209-1.976768i,-0.4642664+0.2736715i,-1.523179-1.789732i,0.6133571-0.9090805i,-1.570788-0.2111931i,-0.3498737-2.125016i,-1.141027-2.017519i,-1.683213-1.450527i,-1.760684-0.6767312i},
    {1.329106-0.03954862i,0.902857-0.6838157i,0.2455386+1.338319i,0.9392952+1.059883i,-0.8810472+0.0148661i,-0.7680146+0.7431021i,0.6484304-0.8158456i,0.5219105+1.305903i,-0.7315845-0.4453492i,1.380322+0.1272892i,1.070788-0.6129874i,0.3413772-0.9916627i,-0.4770857-0.8060709i,-0.9876853-0.1225176i,-0.9296066+0.7383957i,0.7437627-0.9258879i,-0.1216219-0.9991493i,1.247358+0.9258248i,1.455297+0.09211918i,-0.6577342+1.103937i,0.3095526-1.016122i,0.91937+1.220885i,-0.9709622-0.105517i,-0.9016668+0.7216979i,-0.3214311+1.315081i,0.50546+1.401276i,1.4276+0.1337501i,-0.6623538+1.058595i,0.0887704+1.414972i,-0.4619346-0.7690221i,-0.9215966-0.09802544i,1.260977-0.2645003i,-0.2753509+1.234518i,-0.05747961-0.852854i,1.074296+0.8536515i,-0.8323001+0.2634656i,-0.5517378+0.8894336i,0.03877101+1.194579i,0.6736267+1.072593i,1.089481+0.596883i,-0.7027991+0.4541975i,-0.355915+0.960032i,0.199197-0.7144735i,-0.3697789-0.5064517i,1.113212+0.425067i,-0.628415+0.6076186i,0.6319413-0.6139607i,0.3934564+1.133773i,-0.5056283-0.4003325i,-0.7459117+0.1742861i,-0.5789799+0.7866989i,-0.05692354+1.174608i},
    {1.204524+0.6173401i,1.178567+0.344928i,0.7230614+0.8636748i,0.9990873+0.8486656i,0.5089287+0.3826076i,0.5211722+0.6544934i,0.9745857+0.1940763i,0.977882+0.8188013i,0.5514024+0.397614i,1.122138+0.3918877i,0.9465948+0.2482148i,0.7343423+0.2731215i,0.6131462+0.4324013i,0.6417229+0.6168016i,0.783718+0.7165064i,0.7515188+0.3423009i,0.6705113+0.468757i,0.9895412+0.4224767i,0.8742806+0.3568373i,0.940087+0.6335992i,0.7002453+0.5043523i,0.9490432+0.4118117i,0.8562388+0.6585524i,0.9642919+0.6039321i,0.9974979+0.4842574i,0.9290929+0.3750534i,0.6822947+0.4348644i,1.028772+0.4436242i,0.926966+0.3209535i,0.9353159+0.7193583i,1.070045+0.6002269i,0.6131528+0.61837i,0.9441914+0.2587541i,0.9646906+0.7799799i,0.5584059+0.4008721i,1.148987+0.3842347i,0.9783202+0.1911814i,0.7061843+0.1734516i,0.4893217+0.3628859i,0.4687056+0.6652693i,1.015585+0.1233047i,0.6846759+0.1021817i,1.266041+0.6970213i,1.284787+0.3425504i,0.6538066+0.9539428i,0.6698855+0.05950216i,1.296176+0.7126413i,0.3872563+0.6894876i,1.049259+0.06879288i,0.6819767+0.0599219i,0.4203117+0.3068497i,0.4064891+0.656461i},
    {1.138244+0.5555965i,1.164908-0.4806708i,-1.113835+1.212955i,-0.1362284+1.432751i,-1.32213-1.06114i,-1.720811-0.1721119i,0.8946586-0.8284449i,-0.6958264+1.313847i,-0.822659-1.324578i,0.9318004+0.615122i,1.053246-0.3051023i,0.5657483-1.084091i,-0.2962418-1.369693i,-1.12978-1.04402i,-1.555751-0.2752081i,0.8216748-0.6405329i,0.1791579-1.178109i,0.05799113+1.117184i,0.6753889+0.6307623i,-1.42518+0.03667577i,0.5438497-0.771605i,-0.4945692+1.031546i,-0.760035-0.9947588i,-1.233935-0.5146924i,-1.333506+0.1480089i,-1.022018+0.7467508i,0.2945744+0.9236628i,-1.368415-0.4487318i,-1.430058+0.3198579i,0.4062596-1.059708i,-0.3957922-1.309581i,0.6300086+0.9119588i,-1.636016-0.1870767i,0.8762022-0.7975196i,-0.7046977+1.32511i,-0.8494241-1.373414i,-1.59899-0.7151012i,-1.753344+0.2875303i,-1.220436+1.168921i,-0.2322654+1.508731i,-1.334022-1.201825i,-1.860611-0.2635955i,1.084573-0.8810638i,0.2278013-1.587129i,0.3249293+1.505736i,-1.769848-0.8282963i,1.376155-0.3925862i,-1.335658+1.329722i,-0.3772036-1.769772i,-1.491541-1.304408i,-2.035876-0.2167233i,-1.735906+0.9672414i},
    {-0.4098443+0.6520099i,0.3062199+0.5125787i,-1.201064-0.6492451i,-1.145074+0.06726086i,0.1742418-1.276286i,-0.5341641-1.30659i,0.6239916+0.1487864i,-1.194914-0.1712563i,0.3660014-1.130193i,-0.1599377+0.6065142i,0.4549077+0.308878i,0.7109168-0.3155127i,0.4873962-0.9418216i,-0.08764935-1.252394i,-0.7100689-1.101101i,0.6051795-0.1299201i,0.5212201-0.7342184i,-0.5233047+0.400366i,0.04987312+0.3748497i,-0.8973973-0.6966798i,0.4599125-0.5465035i,-0.5869797+0.2143931i,-0.3436322-0.9762182i,-0.6943135-0.7043278i,-0.7528792-0.3007662i,-0.5362901-0.003474414i,0.006507671-0.1145679i,-0.4947591-0.3760042i,-0.3862364-0.2430094i,-0.187948-0.4727915i,-0.2226355-0.4191951i,-0.2635641-0.3025591i,-0.1939489-0.473593i,-0.1688187-0.181624i,-0.4383373-0.4832307i,0.06511316-0.4115807i,-0.01981491-0.6319725i,-0.2632308-0.739405i,-0.5338566-0.6378155i,-0.6666101-0.3629599i,0.1171267-0.6518956i,-0.1566276-0.8173154i,0.01605165+0.05034628i,0.2263945-0.192485i,-0.6978925-0.1982894i,0.05201552-0.7852917i,-0.183382+0.1775999i,-0.6172768-0.7711021i,0.3726925-0.2726574i,0.3267861-0.698241i,-0.01026278-1.022381i,-0.5188006-1.048946i},
    {-1.162552+0.2711201i,-0.537914+0.6781201i,-0.7640817-1.326746i,-1.253556-0.7890378i,0.7105502-0.667417i,0.2834147-1.220756i,-0.1867445+0.6293742i,-0.9838247-1.075086i,0.6897134-0.26605i,-1.103784+0.1549727i,-0.5902308+0.5495631i,0.0579756+0.5366875i,0.5573579+0.1170602i,0.6799505-0.5295209i,0.3595473-1.111237i,-0.3065324+0.6103215i,0.3272905+0.3927743i,-1.238415-0.5620447i,-1.127683+0.08869906i,0.0617616-1.249032i,-0.000426577+0.5069392i,-1.042179-0.8608477i,0.5896704-0.461734i,0.3309585-0.9710568i,-0.1701799-1.207844i,-0.7007445-1.095366i,-1.092181-0.153456i,0.2235444-1.047149i,-0.304056-1.23044i,0.2753962+0.2993014i,0.586961-0.19954i,-1.080334+0.05275697i,0.06322526-1.212747i,-0.0173889+0.5040342i,-1.049364-0.8781988i,0.6254896-0.4638261i,0.3606892-1.015332i,-0.1869534-1.274699i,-0.7717934-1.136758i,-1.14404-0.6681973i,0.5783383-0.675025i,0.2083827-1.156111i,-0.1789182+0.5658011i,0.4006124+0.3056809i,-1.267292-0.4650174i,0.5514343-0.9379171i,-0.5709329+0.6209718i,-0.713741-1.333497i,0.6788182+0.09272812i,0.7623299-0.6453953i,0.3399063-1.266015i,-0.3888505-1.462534i},
    {-0.1229182-0.8618175i,0.1090688-0.9078376i,-0.1405993-1.417209i,-0.1650946-1.303159i,0.2479914-1.233975i,0.2415477-1.323748i,-0.1049231-1.019247i,0.0493037-1.518396i,0.2267139-0.9591373i,-0.29694-1.336319i,-0.3149965-1.097268i,-0.1710346-0.8896881i,0.07898888-0.8124701i,0.3332565-0.9038956i,0.4920326-1.136999i,-0.402372-1.016978i,-0.2037373-0.7559019i,-0.0640474-1.797381i,-0.4401821-1.640625i,0.7346138-1.21692i,-0.5376717-0.7463201i,0.169592-2.027363i,0.5057213-0.4992485i,0.9185399-0.9830058i,0.8919407-1.650878i,0.4012339-2.14102i,-0.8637629-1.706373i,1.049667-1.469717i,0.6476417-2.080953i,0.1411297-0.1754125i,0.8091043-0.4850101i,-1.039077-1.29592i,0.9245109-1.886495i,-0.2076147-0.1291349i,-0.4989553-2.246713i,1.145929-0.8016648i,1.179863-1.647506i,0.6255085-2.322235i,-0.2617136-2.45427i,-1.020787-1.942012i,1.316373-1.41581i,0.8552591-2.226614i,0.1144563+0.05076404i,0.9444153-0.3437921i,-1.197217-1.274064i,0.9705907-2.002745i,-0.1301425-0.06238415i,-0.5836763-2.184222i,1.109567-0.9302384i,1.01164-1.692093i,0.4556299-2.186795i,-0.2678865-2.195542i},
    {0.04748901-0.5042887i,0.2294398-0.626976i,-0.1061757-0.7535092i,0.02011706-0.6636674i,-0.008695892-0.843755i,-0.006720046-0.7200364i,0.01983771-0.898606i,0.2288014-0.7543389i,-0.08922689-0.6409748i,0.0577465-1.035775i,-0.1572738-0.9744955i,-0.2642028-0.7495528i,-0.1616063-0.4971029i,0.1119757-0.3912997i,0.3939262-0.522817i,-0.3704729-0.7354962i,-0.2229076-0.4335172i,0.02982753-1.243188i,-0.2805815-1.093242i,0.5276332-0.7941889i,-0.2595024-0.4658355i,0.0919008-1.222365i,0.3261265-0.4502783i,0.4591624-0.7036952i,0.4008231-0.9607891i,0.2127281-1.110915i,-0.1842842-1.012525i,0.4075576-0.7354438i,0.3882921-0.9498279i,-0.1073109-0.4306406i,0.154011-0.3633848i,-0.3015548-1.074924i,0.5756605-0.8033929i,-0.3293423-0.3995579i,0.09915645-1.367689i,0.4596706-0.3094637i,0.7002149-0.7071157i,0.5900145-1.175101i,0.1757435-1.436681i,-0.3055232-1.33323i,0.7072213-0.6385034i,0.6227928-1.109362i,-0.1185748-0.1803471i,0.3254721-0.2293876i,-0.478949-1.016149i,0.6123739-0.9596364i,-0.2261953-0.3043271i,-0.02139683-1.326187i,0.4801576-0.4287696i,0.6101235-0.7842366i,0.4772682-1.143528i,0.1341003-1.330508i},
    {-0.3057006+0.4683068i,-0.1461156+0.686491i,-0.01288396-0.1564498i,-0.3200465-0.02080216i,0.6066367+0.2990004i,0.4861321-0.08243553i,0.0175173+0.9040294i,-0.319965-0.1782165i,0.6913142+0.3950413i,-0.4514447+0.6770845i,-0.05040392+0.9276714i,0.4048891+0.8243855i,0.6482422+0.4414381i,0.5560585+0.01750189i,0.2148777-0.2057772i,0.2856041+0.7468154i,0.4812285+0.4688018i,-0.3078701+0.4414671i,-0.1094848+0.6062222i,0.02619524+0.01071965i,0.2384306+0.4934362i,-0.1459517+0.2473268i,0.2603389+0.2636891i,0.2190805+0.1828592i,0.148857+0.1117268i,0.03183847+0.07044863i,-0.2360042+0.2495935i,0.369059+0.1478523i,0.2130778-0.03979848i,0.1845864+0.6970815i,0.4340239+0.5424323i,-0.3935373+0.3717072i,0.385577-0.06094583i,0.06516177+0.814396i,-0.2791016-0.09024384i,0.6012207+0.38144i,0.5293621+0.004454006i,0.2201772-0.23569i,-0.1766955-0.2118202i,-0.4630695+0.07077075i,0.6248394+0.1374981i,0.3806135-0.1903964i,0.1522813+0.8918345i,0.5155213+0.6948081i,-0.5305123+0.3067391i,0.5171956-0.08442278i,-0.01913567+0.8979011i,-0.2580657-0.1939545i,0.6356517+0.4694761i,0.596495+0.05569891i,0.2954313-0.2243003i,-0.1083845-0.2323793i},
    {0.7178414+0.379666i,0.5858566-0.01278323i,-0.09527009+0.9614056i,0.3102014+0.9286931i,-0.4538005+0.06764901i,-0.5081936+0.4574063i,0.4611781-0.06442676i,0.0320846+0.9157618i,-0.2191023-0.09041255i,0.5633174+0.5400084i,0.5614837+0.2212942i,0.3845619-0.02885079i,0.1041167-0.1349031i,-0.1890868-0.0682029i,-0.4023443+0.1562295i,0.6035925+0.2432828i,0.4506635-0.06990174i,0.03090272+0.9656714i,0.43115+0.898322i,-0.577822+0.1463689i,0.7577019+0.1041706i,-0.3153853+1.029622i,-0.05864874-0.4480838i,-0.5812223-0.2039548i,-0.8362701+0.3528174i,-0.6570326+0.9753113i,0.6234732+1.242995i,-0.9557216+0.04862455i,-0.934125+0.8220729i,0.5340284-0.678832i,-0.2793393-0.7418423i,1.084419+0.9565258i,-1.084254+0.5877465i,0.7922435-0.5790269i,0.1567847+1.536107i,-0.7551551-0.4637292i,-1.080324+0.2821517i,-0.8416705+1.045352i,-0.1764559+1.462622i,0.5881631+1.354191i,-0.9498898-0.06697163i,-0.9812696+0.68882i,0.6728383-0.5686507i,-0.06646103-0.7389228i,0.8971432+1.112009i,-1.045379+0.3243766i,0.9493448-0.3472514i,-0.1198149+1.470931i,-0.5111572-0.598765i,-0.9907981+0.03274042i,-0.9248894+0.8155085i,-0.3613138+1.342175i},
    {0.3094697-0.9721359i,-0.3904874-1.099161i,0.6738483+0.6051292i,0.9356363-0.104515i,-1.020546+0.70584i,-0.3172065+1.098561i,-0.8486638-1.06109i,1.007563+0.2494764i,-1.29471+0.4870515i,0.303324-1.234867i,-0.5939143-1.271169i,-1.292628-0.6963914i,-1.431405+0.1996753i,-0.9404406+0.9589149i,-0.07580789+1.199283i,-1.076401-0.9438296i,-1.416988-0.138146i,0.7960443-0.8119038i,0.07152134-1.249806i,0.3964901+0.9814178i,-1.279477-0.4850434i,0.9216321-0.4581516i,-0.7515051+0.9356684i,0.03652595+1.05737i,0.7086374+0.6385671i,0.9402058-0.1126844i,-0.0769052-1.142126i,0.4435674+0.7870399i,0.8210694+0.1561814i,-1.037971+0.4091246i,-0.4939145+0.816434i,-0.5001602-0.8899385i,0.5552967+0.3186644i,-0.922562+0.1022492i,0.2488036-0.6198795i,-0.1626644+0.5662035i,0.1796221+0.3760004i,0.314379+0.06634862i,0.2570967-0.2163811i,0.08722525-0.3975136i,-0.230049+0.336829i,-0.01599935+0.3082071i,-0.5250679-0.3098287i,-0.6322836-0.07968421i,0.2362552-0.336562i,-0.363475+0.436993i,-0.3483986-0.6198674i,0.3367727+0.2860825i,-0.8383824-0.01307905i,-0.6820605+0.4212399i,-0.2585971+0.6665037i,0.2474574+0.575394i},
    {-0.5630608+0.5846938i,0.1651204+1.17744i,-0.0401948-1.39169i,-0.7448478-0.7042685i,1.907129-0.5435046i,1.307291-1.334378i,0.748534+1.279245i,-0.5137286-1.068466i,1.952879-0.08774821i,-0.5602776+0.7337894i,0.2397002+1.237812i,1.176337+1.125123i,1.836235+0.4454145i,1.921246-0.5080764i,1.375285-1.312446i,0.6659971+1.332387i,1.59145+0.9281886i,-0.9552627-0.2629647i,-0.69806+0.7502289i,0.9228201-1.616276i,1.229171+1.252394i,-0.8741463-0.7328522i,2.0126-0.592806i,1.35429-1.428123i,0.3193303-1.630291i,-0.588002-1.11635i,-0.5885791+0.8020593i,0.8097317-1.55184i,-0.1569469-1.370958i,1.861477+0.3652644i,1.851812-0.5861922i,-0.1542789+1.039681i,0.3402791-1.452212i,1.529851+0.7443265i,-0.7466185-0.1752645i,1.555193-0.8992693i,0.8342944-1.34377i,0.01023821-1.235585i,-0.5525045-0.6426948i,-0.6165366+0.1610502i,1.256388-1.076961i,0.497636-1.302186i,1.318627+0.7410021i,1.683849+0.05001736i,-0.4344922+0.4509692i,0.9244601-1.183388i,0.9175209+0.9037474i,-0.3738791-0.6747645i,1.56915-0.2820218i,1.221563-0.8617138i,0.6204063-1.083148i,0.04554501-0.8997892i},
    {-0.05365885-0.7854894i,-0.3115757-0.7075709i,0.208008-0.2978192i,0.1699184-0.5184407i,-0.2484933-0.1470856i,-0.07079405-0.1441463i,-0.2872147-0.5567052i,0.09698691-0.3696846i,-0.2942477-0.3054549i,-0.02374578-0.5643703i,-0.1314286-0.5830985i,-0.2323914-0.5428606i,-0.2975483-0.4523293i,-0.3014378-0.3356398i,-0.233817-0.2324615i,-0.1207534-0.6075227i,-0.2530118-0.5676177i,0.1046699-0.3455981i,0.09538455-0.4976623i,-0.2200792-0.1801787i,-0.1741675-0.6359823i,0.08349729-0.2476351i,-0.3669445-0.3851285i,-0.301787-0.2282079i,-0.1522163-0.1505971i,0.009416482-0.1857041i,0.1110511-0.4671546i,-0.2528873-0.2063284i,-0.1120052-0.1627737i,-0.2600192-0.586327i,-0.3515232-0.4666644i,0.125951-0.4864884i,-0.2628628-0.1648517i,-0.14732-0.6904848i,0.1098241-0.1741935i,-0.4558142-0.4238174i,-0.4091991-0.1814315i,-0.1980425-0.02009344i,0.08379418-0.04409567i,0.2850361-0.263319i,-0.516111-0.2214627i,-0.2989599+0.01153741i,-0.2567972-0.8303069i,-0.5145023-0.6276819i,0.3372211-0.4908504i,-0.3942133-0.0259683i,-0.1514049-0.8597294i,0.213882-0.07103983i,-0.579518-0.4286215i,-0.4893875-0.117995i,-0.2179555+0.06067941i,0.1075672+0.01969917i},
    {-1.337269-0.9220589i,-1.415971+0.07333998i,0.7826083-1.466367i,-0.163061-1.688359i,0.9570032+0.6556929i,1.30839-0.2022614i,-1.082821+0.4627123i,0.2953694-1.522393i,0.486162+0.8189651i,-1.093163-0.8279146i,-1.156579-0.05210223i,-0.7404454+0.5725035i,-0.05157975+0.8017572i,0.6154054+0.5705208i,0.9986485-0.00474995i,-1.01009+0.09038226i,-0.5704412+0.609815i,-0.1484976-1.356889i,-0.7811544-1.069011i,1.063257-0.1542755i,-0.9872782+0.27675i,0.3740556-1.370388i,0.3471707+0.8097752i,0.9839346+0.3349018i,1.175173-0.4555637i,0.8072318-1.197933i,-0.7709488-1.28883i,1.179829-0.01473105i,1.076594-0.8465462i,-0.523038+0.8159748i,0.2891263+0.8667976i,-0.9902225-0.9994879i,1.154906-0.3493893i,-0.9161841+0.4686524i,0.2043638-1.451121i,0.5062001+0.7614577i,1.062655+0.2176482i,1.175376-0.5721447i,0.7646527-1.288193i,-0.03390389-1.605073i,0.8377669+0.7400554i,1.344195-0.04499625i,-1.270575+0.4116783i,-0.5251463+1.083084i,-0.5562006-1.698643i,1.310414+0.4267915i,-1.524152+0.03005929i,0.8985351-1.530983i,0.07874995+1.23936i,1.05005+0.7974406i,1.493813-0.1625294i,1.211679-1.169087i},
    {1.046513+0.6688266i,1.314442+0.3104987i,-0.1677044+0.3496823i,0.1014829+0.7870277i,0.5518171-0.8113886i,-0.04021605-0.6462709i,1.604582+0.2885565i,-0.3814226+0.6215178i,1.013049-0.9935877i,0.9853963+1.255117i,1.694182+0.744027i,1.900117-0.1472353i,1.449236-0.9842257i,0.5284863-1.324846i,-0.4118631-0.9618259i,2.060781+0.2349061i,1.809373-0.7817433i,0.2357437+1.573311i,1.299633+1.451561i,-0.8499014-0.4672109i,2.042782-0.4263315i,-0.1732059+1.438711i,0.2832232-1.416868i,-0.6218354-0.8472123i,-0.9302931+0.1663159i,-0.5074368+1.123716i,1.403536+1.308893i,-0.8004572-0.3054473i,-0.7140108+0.668922i,1.209958-1.163332i,0.2694972-1.254545i,1.677136+0.921586i,-0.7688376+0.1465784i,1.592262-0.8030963i,0.3823078+1.417388i,-0.09634865-1.05306i,-0.6667669-0.3515821i,-0.6573386+0.5519359i,-0.07142624+1.238661i,0.8169236+1.387538i,-0.4152627-0.7441475i,-0.7080419+0.09751213i,1.564443-0.7349003i,0.7992416-1.154003i,1.217182+1.169342i,-0.5688072-0.3196603i,1.718165-0.3241152i,-0.003013964+1.119303i,0.3872102-1.049504i,-0.2788392-0.6418343i,-0.523113+0.08112679i,-0.2541667+0.7751244i},
    {-1.421126-0.8328676i,-1.270495+0.07460997i,0.5351812-1.923344i,-0.4056051-2.015242i,1.167975+0.2818039i,1.500185-0.665226i,-1.210977+0.4311519i,0.2302027-2.202422i,0.8127187+0.8207616i,-1.627338-1.172366i,-1.645421+0.003279694i,-0.8806909+0.9267493i,0.3182071+1.133776i,1.374234+0.5049961i,1.771292-0.6665412i,-1.370826+0.6059577i,-0.272636+1.190012i,-1.002627-2.141137i,-1.763976-1.154963i,1.652831-1.305079i,-0.8675128+1.010837i,-0.430135-2.384645i,1.421628+0.4921206i,1.78372-0.7028919i,1.287691-1.844566i,0.1767881-2.389738i,-1.714154-1.101928i,1.557182-1.299926i,0.7334726-2.130102i,0.3482939+1.023858i,1.275412+0.3948195i,-1.645786-0.5580397i,1.175554-1.64861i,-0.3066586+0.939569i,-0.7766765-1.969814i,1.395988-0.02097938i,1.438223-1.043648i,0.8325819-1.86307i,-0.1504491-2.118792i,-1.072143-1.699066i,1.461854-0.4192179i,1.239034-1.398081i,-0.5116455+0.7979679i,0.4776551+0.7793294i,-1.287264-1.362221i,1.417005-0.8074372i,-1.027717+0.4516582i,0.0864775-2.056614i,0.7899475+0.5973583i,1.370094-0.1813543i,1.334408-1.159699i,0.6844372-1.905262i},
    {1.500759+0.4734962i,1.20332-0.2982838i,-0.02473481+1.492263i,0.6805621+1.373146i,-0.6230255-0.06937334i,-0.6879458+0.5409292i,0.9124936-0.2268113i,0.08699855+1.291398i,-0.1231571-0.4073581i,1.048554+0.859675i,1.190677+0.2963204i,0.9599227-0.2747816i,0.3947467-0.6078297i,-0.2947555-0.5092736i,-0.7886626+0.03318968i,1.322603+0.0199248i,0.8332776-0.5963776i,0.4580628+1.563456i,1.15475+1.16322i,-0.9181936+0.4051419i,1.151647-0.3248801i,0.01642476+1.530802i,-0.253593-0.6077599i,-0.7661883-0.08011405i,-0.8574423+0.6431463i,-0.4975839+1.28299i,0.9560016+1.415365i,-0.9770668+0.04366713i,-0.9874265+0.9262995i,0.9030142-0.8394681i,-0.07416258-1.023068i,1.481126+1.310218i,-1.311634+0.5434797i,1.360166-0.7537895i,0.1950956+2.035422i,-0.7903554-0.8534808i,-1.361387+0.1557584i,-1.113243+1.276972i,-0.1992493+1.936982i,0.8945699+1.832648i,-1.125952-0.2464635i,-1.190184+0.7812619i,1.110383-0.7697953i,0.1767827-1.020167i,1.195567+1.460613i,-1.132976+0.1778313i,1.4804-0.2790478i,-0.2759355+1.724716i,-0.1732989-0.9637107i,-0.9675487-0.3925334i,-1.221855+0.5776855i,-0.7810082+1.506144i},
    {1.637683+0.4752303i,1.474132-0.5981981i,-0.6206943+1.682037i,0.4756714+1.762614i,-1.334566-0.7876112i,-1.646031+0.2924539i,1.250244-0.9936327i,-0.174739+1.856755i,-0.8961394-1.26081i,1.654743+0.6840348i,1.60694-0.4734908i,0.8305107-1.330909i,-0.3109118-1.493446i,-1.289129-0.8927726i,-1.658523+0.1882243i,1.311919-0.9098872i,0.3306404-1.473115i,0.8341571+1.62693i,1.567965+0.7797446i,-1.540938+0.6766897i,0.9123488-1.2064i,0.2147952+1.785522i,-1.130371-0.9507687i,-1.564435+0.03352557i,-1.283802+1.058313i,-0.4325707+1.671704i,1.374179+0.9398417i,-1.502957+0.4075066i,-1.025747+1.310281i,0.1426798-1.384795i,-0.8610892-1.128569i,1.550999+0.6339691i,-1.468783+0.7763124i,0.8168138-1.26216i,0.3279139+1.801927i,-1.256777-0.9103716i,-1.668932+0.1548484i,-1.30065+1.249171i,-0.3097157+1.859119i,0.8479455+1.693474i,-1.581125-0.4822313i,-1.634746+0.6918291i,0.9831035-1.292396i,-0.1643322-1.574389i,1.290842+1.404998i,-1.745457+0.02040596i,1.50229-0.8502243i,-0.4604269+1.914484i,-0.7214537-1.495007i,-1.629798-0.6309737i,-1.767361+0.6279765i,-1.051476+1.683643i},
    {0.1435524+0.2673497i,-0.06086893-0.1929197i,-0.4965912+0.9779982i,-0.02769362+0.7609515i,-1.17817+0.3256353i,-0.9506086+0.7720653i,-0.5490736-0.3081309i,-0.09082532+0.6843321i,-1.050429+0.3319653i,-0.1945031-0.0609611i,-0.5385033-0.1347162i,-0.7976003+0.03579554i,-0.8523165+0.2975343i,-0.7327352+0.4879395i,-0.5553526+0.536511i,-0.6145069+0.1279011i,-0.6678232+0.228083i,-0.3752761+0.2861073i,-0.411864+0.2215092i,-0.5674966+0.4235311i,-0.5476807+0.1686955i,-0.4113103+0.3937353i,-0.6660126+0.298006i,-0.6338122+0.3986949i,-0.5358533+0.451701i,-0.4262519+0.4179723i,-0.4210777+0.2076399i,-0.5070435+0.426391i,-0.4170635+0.3586407i,-0.6157725+0.3571823i,-0.5138708+0.4171948i,-0.6381489+0.2445413i,-0.3854633+0.2120127i,-0.5203347+0.4996364i,-0.7122895+0.1530873i,-0.2328839+0.2312604i,-0.3646096-0.01101322i,-0.6758702-0.07081448i,-0.9546877+0.1554772i,-0.9651141+0.556204i,-0.3978395-0.2512121i,-0.8730236-0.1985419i,0.1301086+0.383358i,0.008540449-0.1415788i,-0.5557649+1.015558i,-1.026274-0.2283123i,0.2241147+0.298145i,-1.031901+0.8390206i,-0.5446883-0.4336435i,-1.046783-0.1878022i,-1.216201+0.3226952i,-0.9884018+0.7810092i},
    {0.3639303+0.9602798i,0.3941068+0.4038128i,-0.7977335+1.298482i,-0.2636721+1.399457i,-0.9368802+0.1357315i,-1.099475+0.6192199i,0.1726142+0.1959476i,-0.5094969+1.287599i,-0.6611515+0.06464934i,0.1804279+0.8907738i,0.1992782+0.5071126i,-0.002622403+0.2036331i,-0.3309331+0.07929374i,-0.665027+0.1651101i,-0.8896922+0.4286515i,0.1752023+0.4851941i,-0.01681014+0.1717533i,-0.3697877+1.234705i,0.01528455+1.118827i,-0.9975653+0.4944129i,0.2159479+0.3373705i,-0.6432198+1.250328i,-0.5618384-0.02540753i,-0.9468486+0.2449836i,-1.066158+0.7044956i,-0.8595148+1.132489i,0.01974588+1.197552i,-1.023651+0.4454344i,-0.9892505+0.8903333i,-0.05108266+0.05741213i,-0.4708115-0.01247138i,0.09767599+1.085373i,-1.024609+0.5571585i,0.2043842+0.2936886i,-0.6317921+1.272539i,-0.5664629-0.05761609i,-0.9814305+0.1920006i,-1.162481+0.6761085i,-0.9837433+1.198947i,-0.478187+1.501622i,-0.8816539-0.1258291i,-1.2906+0.3894374i,0.5035766+0.1924278i,-0.005733851-0.3013677i,-0.01312543+1.588033i,-1.285248+0.162421i,0.620278+0.3715404i,-0.9301494+1.484478i,-0.5207213-0.3568885i,-1.122645+0.004422677i,-1.324472+0.6530381i,-1.059148+1.250034i},
    {-0.1518664-0.6467802i,-0.3766672+0.05950377i,1.417207-0.7093002i,0.7596416-1.016456i,1.267314+0.8408687i,1.65723+0.2455878i,-0.2281603+0.4762412i,1.040202-0.9215139i,0.9947292+0.9533969i,-0.1899277-0.4837181i,-0.29529+0.199238i,0.07268376+0.7774308i,0.7233743+0.9660633i,1.326469+0.6813631i,1.584553+0.08110664i,-0.0495893+0.5456536i,0.4825797+0.8589308i,0.2684091-0.7264724i,-0.08596838-0.277294i,1.398428-0.2477279i,0.2937862+0.6506809i,0.550302-0.6871907i,1.179327+0.4512693i,1.31008+0.02598481i,1.150458-0.3628241i,0.8024911-0.5522224i,0.2050601-0.2240386i,1.151372-0.08027904i,0.9822624-0.3341274i,0.6223046+0.4532145i,0.8812782+0.381587i,0.2902225-0.1635357i,1.07281-0.06314395i,0.3791146+0.3056978i,0.7327902-0.4045149i,0.8666394+0.3946968i,1.070181+0.2052993i,1.120472-0.08249416i,0.9766317-0.352119i,0.6855575-0.4777627i,0.9645886+0.4122383i,1.157251+0.14287i,0.1971137+0.2122196i,0.4180278+0.4638306i,0.5892415-0.5070482i,1.051399+0.3819823i,0.1239319-0.05623148i,1.161484-0.2748406i,0.438583+0.5642768i,0.8367231+0.623631i,1.216318+0.4098932i,1.391845-0.02982711i},
    {-0.3643786-0.8342879i,-0.9130799-0.6402385i,0.5714652+0.05611762i,0.4388659-0.5776969i,-0.5364836+0.9349077i,0.1737652+0.8714491i,-1.323783-0.3764706i,0.691001-0.4432282i,-0.8098851+0.9898608i,-0.6424631-1.130115i,-1.315675-0.645833i,-1.493869+0.1764458i,-1.072832+0.9155317i,-0.259657+1.189161i,0.5362925+0.8515981i,-1.555955-0.1147083i,-1.315744+0.7310435i,-0.07553504-1.260346i,-0.9636533-1.122257i,0.8977298+0.3702566i,-1.500615+0.4999422i,0.2022308-1.208486i,0.08739655+1.202838i,0.8024022+0.6005026i,0.9138258-0.3220176i,0.3717022-1.060848i,-1.238696-0.754994i,0.7981221-0.1003832i,0.4188384-0.7919046i,-0.360988+0.9804343i,0.2722538+0.7075759i,-1.188357-0.1808932i,0.390059-0.4336546i,-0.5922232+0.693455i,-0.5488134-0.7088985i,0.2507367+0.3472695i,0.327477-0.08802055i,0.1273454-0.4637105i,-0.2533096-0.6280656i,-0.6432454-0.5156723i,0.2184966+0.1363486i,0.1674578-0.2431157i,-0.5338441+0.4297006i,-0.1955585+0.4169622i,-0.6641976-0.2499366i,0.02959345-0.06477792i,-0.5304179+0.1815151i,-0.2790898-0.2527264i,-0.2689841+0.1455377i,-0.238113+0.09691364i,-0.2047126+0.08151534i,-0.1308151+0.04412268i},
    {-0.4265173+1.183002i,0.7247646+1.307126i,-0.8857824-1.251835i,-1.161195-0.1966969i,1.459431-1.338462i,0.5142964-1.745588i,1.20308+0.863165i,-0.9521677-0.6217573i,1.567383-0.8915036i,-0.1066428+0.892603i,0.7695829+0.87501i,1.389614+0.3095363i,1.477972-0.4833352i,1.047661-1.099763i,0.3672369-1.268061i,0.9705173+0.3906428i,1.192922-0.1512496i,-0.2711737+0.06599391i,0.1117193+0.3180442i,0.2579458-0.8733502i,0.7641868+0.07823836i,-0.09300172-0.3938854i,0.8180785-0.4342987i,0.6882755-0.6293038i,0.478811-0.7559923i,0.2056389-0.769058i,-0.2208255-0.2973507i,0.9101803-0.6753954i,0.5845101-0.9651974i,0.6507634+0.410721i,1.067446+0.1205544i,-0.4600258-0.1858705i,1.011005-0.9315605i,0.2802622+0.6524617i,-0.1580669-1.140765i,1.392247+0.05185815i,1.445804-0.6852174i,0.9906846-1.334058i,0.1699241-1.55872i,-0.6590459-1.175533i,1.829439-0.2972662i,1.534426-1.298647i,0.1675699+1.305707i,1.323493+1.110672i,-1.325383-0.7288174i,2.001982-1.138211i,-0.2738782+1.477458i,-0.3399591-2.089135i,2.161306+0.5706867i,2.308359-0.8610098i,1.434144-2.028647i,-0.01152933-2.296825i},
    {-0.1380176+1.121861i,0.4146935+0.773506i,-1.256494+0.05483592i,-1.081157+0.6293963i,-0.01724304-0.7323098i,-0.5928988-0.727691i,0.4221017+0.6231616i,-1.203612+0.1739356i,0.3594044-0.4704186i,-0.4771197+1.007789i,0.1116002+0.9220873i,0.5215214+0.483987i,0.5670531-0.1169676i,0.2261329-0.6141592i,-0.3487263-0.7889727i,0.2778735+0.8126062i,0.5785385+0.2999839i,-1.129171+0.5303294i,-0.7098845+0.9512115i,-0.5116128-0.7896956i,0.4167707+0.7303851i,-1.288182+0.09170786i,0.4926641-0.4782301i,-0.05129374-0.8827884i,-0.7578093-0.8554117i,-1.3093-0.3662681i,-1.009201+1.068591i,-0.3957739-1.079384i,-1.170121-0.7573287i,0.927152+0.2365656i,0.7170401-0.6033062i,-0.6313679+1.349838i,-0.8675187-1.026273i,0.8523297+0.6420101i,-1.541511+0.4722389i,0.4041072-0.9350328i,-0.4367706-1.149849i,-1.22006-0.780333i,-1.590264+0.002806402i,-1.379167+0.8457314i,0.05018138-1.124444i,-0.8317181-1.08123i,0.8658346+0.7220391i,0.992112-0.1759573i,-1.132706+1.200821i,-0.383792-1.248154i,0.6363224+1.131161i,-1.704279-0.03219442i,0.8509107-0.6730331i,0.05233448-1.246693i,-0.9321622-1.154944i,-1.614465-0.4368984i},
    {0.5358472+0.9559655i,1.027006+0.5737891i,-0.7109696+0.1064767i,-0.4654734+0.672775i,0.3950975-0.8858676i,-0.2095591-0.7833294i,1.090367+0.4122033i,-0.6643585+0.2738725i,0.7999636-0.6955884i,0.2407519+0.9684254i,0.8100079+0.7734975i,1.14548+0.27049i,1.10651-0.3393365i,0.6982762-0.8077487i,0.07539093-0.9328516i,0.9794351+0.7229893i,1.268935+0.1158809i,-0.6439383+0.6420688i,-0.08218216+1.089365i,-0.1897869-1.004234i,1.252992+0.5975259i,-0.9374929+0.2605845i,1.02133-0.9008769i,0.2399233-1.218894i,-0.5880331-0.9549822i,-1.066006-0.1995575i,-0.2394509+1.337153i,-0.2514288-1.278599i,-1.00957-0.6579301i,1.652148-0.2411008i,1.136545-1.104899i,0.295563+1.504637i,-0.7644668-1.036187i,1.694016+0.2110929i,-0.9842395+0.8524064i,0.6408709-1.361491i,-0.3538677-1.287595i,-1.063345-0.5972155i,-1.166204+0.3811932i,-0.6232117+1.197274i,0.1554522-1.399594i,-0.7510874-1.018282i,1.678363+0.2202887i,1.462741-0.756023i,-0.1890161+1.450086i,-0.360179-1.314042i,1.573126+0.6812093i,-1.19501+0.4301832i,1.055651-1.185558i,0.05119522-1.408605i,-0.8383148-0.9170759i,-1.173417+0.02164201i},
    {-0.8526365-2.598839i,-1.951813-2.109174i,0.8851141-0.5778602i,0.6209937-1.676829i,-1.325636+0.7009568i,-0.2565013+0.6664729i,-2.115036-1.62321i,0.7212929-1.026498i,-1.818445+0.2755576i,-0.6812446-2.298618i,-1.625746-2.02085i,-2.176925-1.2207i,-2.101668-0.265747i,-1.45203+0.4179376i,-0.5326659+0.5392861i,-1.824916-1.705726i,-2.131741-0.8649549i,0.2742681-1.609339i,-0.4504645-2.083564i,-0.2777811+0.3688143i,-1.916355-1.430811i,0.4634213-1.034206i,-1.636964+0.1151449i,-0.8808797+0.430703i,-0.09729622+0.2178501i,0.3889791-0.4240062i,-0.09846632-1.858554i,-0.7098743+0.4376949i,0.04913883+0.1497452i,-2.076422-1.088718i,-2.012778-0.2287914i,-0.1648948-2.087075i,-0.4774929+0.6223283i,-1.992393-1.787761i,0.8250508-0.8385502i,-2.067814+0.276855i,-1.063152+0.9079625i,0.1599955+0.717516i,0.9807232-0.2663097i,0.942009-1.580455i,-1.60381+0.9140481i,-0.260138+1.034006i,-2.406075-1.873077i,-2.693896-0.5621777i,0.4804856-2.243086i,-0.8378519+1.069299i,-1.955632-2.283946i,1.028351-0.4429949i,-2.422259+0.04292776i,-1.50056+0.8813393i,-0.2558587+0.9498434i,0.758516+0.2108471i},
    {-0.2661371+1.440353i,0.8130367+1.094768i,-1.760563-0.5245864i,-1.576166+0.5602779i,0.3872074-1.636881i,-0.6511301-1.635552i,1.059781+0.6083125i,-1.625275-0.04559806i,0.8370118-1.192312i,-0.364693+1.20761i,0.5407799+1.015952i,1.140844+0.3066539i,1.175079-0.6326778i,0.6070431-1.400472i,-0.3332344-1.643154i,0.8596643+0.8384327i,1.285931-0.06012247i,-1.404049+0.6378361i,-0.5959661+1.221166i,-0.7584257-1.545543i,1.107628+0.4871694i,-1.609053+0.08316966i,0.7537118-1.299084i,-0.1378504-1.64355i,-1.053675-1.363663i,-1.606418-0.5708027i,-0.8768487+1.153893i,-0.5024697-1.703424i,-1.406878-1.173552i,1.405122-0.2203742i,1.035183-1.240671i,-0.4528355+1.40071i,-0.9998345-1.599794i,1.345194+0.3669298i,-1.720724+0.3458804i,0.6618032-1.589417i,-0.4133992-1.812478i,-1.390314-1.306584i,-1.833162-0.2919542i,-1.533214+0.7864887i,0.2370262-1.829671i,-0.9159327-1.738513i,1.388499+0.5235564i,1.49462-0.6675518i,-1.157134+1.261506i,-0.3919226-1.933674i,1.100094+0.9820393i,-1.903166-0.2529007i,1.14087-1.246531i,0.1441765-1.816169i,-0.9488168-1.61469i,-1.637015-0.7927099i},
    {-0.2423181-0.4853085i,-0.3443819-0.4690656i,-0.0335736-0.3007389i,-0.03274823-0.4575523i,-0.3046225-0.08306553i,-0.0935771-0.07869638i,-0.5379791-0.4298818i,0.06727209-0.4998926i,-0.3293263+0.006760343i,-0.4172671-0.654634i,-0.5926485-0.4251943i,-0.5428907-0.1408473i,-0.3053434+0.01209129i,-0.04347946-0.05524619i,0.07735877-0.2769249i,-0.4711918-0.1793381i,-0.2902316-0.09121152i,-0.3348368-0.5278633i,-0.3983802-0.4084574i,-0.08535041-0.3645104i,-0.334318-0.2563815i,-0.1734994-0.4519309i,-0.2314048-0.1906461i,-0.1348141-0.1915207i,-0.03422349-0.2726368i,-0.01032662-0.431828i,-0.3346486-0.6168333i,0.05606603-0.2016018i,0.08123673-0.4514641i,-0.3745559-0.02503897i,-0.1075174-0.01433963i,-0.5482553-0.4720103i,0.07725052-0.4662019i,-0.351272-0.03727645i,-0.356879-0.6159146i,0.03434812-0.2383676i,0.003276095-0.4480822i,-0.1547779-0.5580024i,-0.3225304-0.5222913i,-0.399433-0.3941292i,-0.1011526-0.4017608i,-0.1949719-0.446594i,-0.1953389-0.2605077i,-0.1808666-0.3183129i,-0.2558268-0.3277069i,-0.2309813-0.3329435i,-0.2491672-0.3633403i,-0.1772342-0.3229408i,-0.3024101-0.2968053i,-0.2594693-0.2384664i,-0.1728143-0.2317735i,-0.1009186-0.300227i},
    {-0.1130846+0.3472861i,0.06323309-0.02927976i,-0.8867342+0.2554953i,-0.5457334+0.4224843i,-0.7526437-0.4664265i,-0.9200464-0.1796694i,-0.09549914-0.2740052i,-0.6401377+0.3091825i,-0.5957344-0.4677608i,-0.1384281+0.156329i,-0.05790881-0.1164382i,-0.1743817-0.3950948i,-0.4663201-0.5400951i,-0.8052696-0.44113i,-0.9925116-0.1097616i,-0.07807273-0.4308967i,-0.4584909-0.6276848i,-0.08100241+0.3245886i,0.08943574-0.09998006i,-0.8388859+0.3635935i,-0.5688271-0.627339i,-0.01538166+0.2122378i,-0.9809921+0.08325152i,-0.6747196+0.3879638i,-0.2638524+0.3491105i,-0.04450779+0.02639389i,-0.4579315-0.4585524i,-0.2223614+0.1671651i,-0.1576958-0.1095381i,-0.6484029+0.1667577i,-0.4178495+0.1878048i,-0.6941689-0.1986069i,-0.2576506-0.1383517i,-0.5866036+0.1140486i,-0.52896-0.2802462i,-0.303429+0.04222154i,-0.2634183-0.1081466i,-0.3353865-0.2562582i,-0.5015349-0.3232813i,-0.6850447-0.2507185i,-0.1857334-0.09883424i,-0.2749445-0.3199267i,-0.4429137+0.2657762i,-0.1905678+0.1496508i,-0.8619235-0.02070116i,-0.2407569-0.403043i,-0.408298+0.3402835i,-0.8355791-0.3244227i,-0.03942607-0.1531144i,-0.2152655-0.4475656i,-0.5513908-0.5348806i,-0.8571029-0.3615509i},
    {1.166006+0.4798073i,1.279084-0.0590078i,-0.1578626+0.6977599i,0.3679443+0.9600648i,-0.09236898-0.7004215i,-0.492713-0.1912843i,1.344918-0.3582635i,0.0165754+1.004031i,0.1325546-0.9450855i,1.350882+0.630993i,1.509222-0.1148469i,1.126974-0.7810653i,0.3984748-1.023778i,-0.3031-0.7243791i,-0.6290177-0.04427864i,1.309383-0.5434513i,0.7015134-0.9514186i,0.892689+0.9970291i,1.378053+0.4764518i,-0.5331561+0.3556027i,0.9847586-0.7782288i,0.5692775+1.048719i,-0.2906092-0.5895709i,-0.5248794+0.04392205i,-0.2901901+0.6649805i,0.2814136+0.9718078i,1.253695+0.3431992i,-0.3315153+0.3635758i,0.05505848+0.755115i,0.3053437-0.6773916i,-0.1039234-0.4075171i,1.126402+0.09684768i,-0.1016513+0.4462701i,0.62731-0.5474909i,0.6565921+0.6490725i,-0.07921178-0.2595389i,-0.1591493+0.1233075i,0.008512582+0.4707252i,0.3487138+0.640092i,0.7142786+0.56675i,-0.07555817-0.1633384i,-0.1001832+0.1897035i,0.7939025-0.3517867i,0.4811754-0.4800938i,0.7265334+0.5371081i,-0.08625829-0.1564982i,1.018543-0.07452013i,0.03805356+0.5518642i,0.4558444-0.6074407i,0.003007066-0.5041475i,-0.303079-0.1038739i,-0.2718412+0.4365875i},
    {-0.7403074-1.373214i,-1.218397-0.732651i,1.151327-0.9403678i,0.5781737-1.60633i,0.2847631+0.9252843i,1.109238+0.441653i,-1.477096-0.3435461i,1.063906-1.437259i,-0.190854+1.086747i,-0.876504-1.689586i,-1.508898-0.8390674i,-1.438795+0.2233643i,-0.6980842+0.9913993i,0.3644713+1.104637i,1.256125+0.5108166i,-1.608924-0.3149931i,-1.187878+0.6863614i,0.1703-2.031328i,-0.9224089-1.795862i,1.578012+0.06147531i,-1.570785+0.2620866i,0.7215363-1.959812i,0.4277884+1.249481i,1.417586+0.5511805i,1.69972-0.6331909i,1.126391-1.70539i,-1.110433-1.692561i,1.599401-0.1733345i,1.328626-1.265253i,-0.4847992+1.054497i,0.5504941+0.9578599i,-1.29123-1.08667i,1.334249-0.6920174i,-0.8753718+0.6089223i,0.008704351-1.711841i,0.7346411+0.5927185i,1.173456-0.09200004i,1.108213-0.8887893i,0.5766523-1.478192i,-0.2050392-1.621619i,0.8730513+0.4168963i,1.206899-0.3216364i,-1.047321+0.2827239i,-0.380499+0.7824196i,-0.5054521-1.583258i,1.098978+0.1796128i,-1.270445-0.1648528i,0.7810751-1.409978i,-0.006030693+0.8564967i,0.8000127+0.549152i,1.21849-0.1985598i,1.062525-1.03153i},
    {-0.8610316-2.558452i,-1.765085-1.809848i,1.201281-1.282376i,0.5840127-2.21028i,-0.270398+0.5285894i,0.6597468+0.06740506i,-1.775863-1.104994i,0.7602272-1.767126i,-0.7113787+0.30881i,-0.9033847-2.160396i,-1.506609-1.535769i,-1.579551-0.688255i,-1.107756+0.005879395i,-0.3088434+0.2421836i,0.4546139-0.08436989i,-1.556889-1.13307i,-1.362642-0.3297575i,-0.03311045-2.105593i,-0.8406219-2.028183i,0.6569683-0.5087862i,-1.408972-0.6754737i,0.2053893-1.854261i,-0.2336729+0.007493826i,0.3313329-0.3473413i,0.5149689-0.9406003i,0.292874-1.46735i,-0.6312192-1.62759i,0.1927801-0.6403904i,0.2447847-1.021981i,-0.8181822-0.6164705i,-0.5332645-0.4409936i,-0.5217201-1.514464i,0.07149334-0.6196926i,-0.9408425-1.027153i,0.1523505-1.28262i,-0.6139751-0.4065986i,-0.219138-0.3430345i,0.1560202-0.5379416i,0.3482785-0.9407014i,0.2518454-1.401422i,-0.603121-0.2326843i,-0.0797208-0.2072815i,-1.100728-1.429964i,-1.266319-0.867414i,0.3029559-1.665244i,-0.4532631+0.02624811i,-0.9635908-1.85625i,0.7119274-0.6707799i,-1.439186-0.4990436i,-0.8996382+0.1354237i,-0.03146146+0.2729945i,0.7538478-0.2159763i},
    {0.8366995-0.9772391i,0.2306834-1.149915i,0.7781329+0.3945408i,1.030367-0.1121498i,-0.4438283+0.1251668i,-0.03066365+0.4397001i,-0.004944939-0.9302053i,0.8219853+0.08723178i,-0.4068856-0.1394749i,0.6144589-0.7355931i,0.2057724-0.8266261i,-0.1310854-0.6314549i,-0.2327465-0.2920149i,-0.08948131-0.01328516i,0.1637195+0.06975262i,0.1109409-0.4843535i,0.07163602-0.332708i,0.3313802-0.2559395i,0.2925705-0.2318208i,0.114129-0.3111539i,0.4515769-0.2817679i,0.008630082-0.03287951i,0.260615-0.6681252i,-0.07991823-0.6556661i,-0.3571152-0.3549546i,-0.3395143+0.1188079i,0.6414431+0.4779012i,-0.6337203-0.5376983i,-0.6503747+0.1524194i,0.6233519-1.208128i,-0.1417816-1.267683i,1.2291+0.2549156i,-0.8849718+0.04699205i,0.8719971-1.259553i,0.4338945+0.9430246i,-0.7382734-1.029154i,-1.026572-0.1846398i,-0.6731282+0.646952i,0.1533692+1.037007i,1.040178+0.7775214i,-1.07399-0.5006956i,-0.9226577+0.4324623i,0.6469564-1.55334i,-0.3222277-1.518034i,1.49808+0.3260987i,-1.115798+0.1532102i,0.9715332-1.472088i,0.4950296+1.152478i,-0.9125906-1.132821i,-1.207977-0.1384081i,-0.7535807+0.7976133i,0.2130818+1.179149i},
    {-0.1559236-0.8173972i,-0.8690953-0.5165492i,1.142231+0.4281781i,0.9604771-0.3876967i,-0.3673798+1.528511i,0.5173705+1.457741i,-1.243948-0.1808389i,1.17672-0.1071622i,-0.6914752+1.434052i,-0.3057616-0.9406216i,-1.050074-0.4498234i,-1.276642+0.389774i,-0.9065556+1.146292i,-0.1611997+1.465475i,0.5818943+1.237321i,-1.089657+0.009370963i,-1.01712+0.7173858i,0.4392357-0.5812415i,-0.2150824-0.6691179i,0.6723493+0.9727324i,-1.016511+0.2361882i,0.7569336-0.2205935i,-0.3575954+1.233147i,0.2823431+1.233514i,0.7944103+0.8312178i,0.9464571+0.1842072i,0.02162993-0.7160544i,0.5578446+1.156976i,0.9637463+0.5713149i,-0.9932414+0.7670346i,-0.4761218+1.263296i,-0.333707-0.6786102i,0.7897234+0.8795293i,-1.035316+0.4113029i,0.6286719-0.3700755i,-0.145648+1.23939i,0.4338904+1.072396i,0.7712427+0.6079594i,0.7625745+0.05970557i,0.4453818-0.3645913i,-0.0494262+1.151636i,0.455585+0.9998937i,-0.892518+0.05507991i,-0.9120148+0.6322371i,0.454605-0.5108624i,0.08118102+1.319443i,-0.8303472-0.4131463i,1.060583+0.3638132i,-0.956655+1.022704i,-0.2730857+1.474234i,0.5589458+1.351479i,1.103405+0.694577i},
    {0.2037791-0.5969573i,0.09708253-0.8265427i,-0.3518664-0.03213642i,-0.04973352-0.01317914i,-0.7212837-0.8275709i,-0.8728564-0.468462i,0.2822196-0.9720488i,-0.3591465+0.2420589i,-0.6573412-1.215816i,0.5981725-0.2212354i,0.6359482-0.8601792i,0.2113392-1.397046i,-0.5031232-1.518356i,-1.143232-1.108918i,-1.347614-0.3465504i,0.4970591-1.39046i,-0.2816762-1.674662i,0.5812704+0.3389859i,0.9405613-0.422373i,-1.172444+0.2087533i,-0.01393412-1.654121i,0.3411022+0.4888027i,-1.311156-0.8757047i,-1.272839-0.09537923i,-0.749599+0.4583766i,-0.01101212+0.5417188i,0.8042734-0.540607i,-1.011817+0.1747043i,-0.3974597+0.5039482i,-0.7587547-1.384599i,-1.195973-0.8475185i,0.7124675-0.86109i,-0.7376295+0.3708174i,-0.4209327-1.498239i,0.5358229+0.1272622i,-1.231285-0.4949407i,-0.98206+0.1355506i,-0.392267+0.4524658i,0.2537861+0.317746i,0.6573371-0.1917937i,-1.119034-0.1839089i,-0.7061125+0.2952736i,-0.3871065-1.418773i,-0.9293973-1.111978i,0.6768287-0.4844955i,-0.95424+0.05835286i,-0.05370691-1.400587i,0.196152+0.2898731i,-1.080735-0.832227i,-1.080429-0.208874i,-0.6746075+0.2565539i,-0.07272194+0.3376606i},
    {-0.6551324-0.8145296i,-0.9414601-0.06831832i,1.210849-0.9047881i,0.4765967-1.359556i,0.9406149+1.043557i,1.54668+0.3462352i,-1.01789+0.4177936i,0.9170591-1.33498i,0.586638+1.289159i,-0.8852175-0.9353001i,-1.159296+0.01784432i,-0.744272+0.9154454i,0.1490706+1.323113i,1.084085+1.057029i,1.620852+0.2602146i,-0.9912512+0.4993583i,-0.3213232+1.156529i,-0.07304877-1.422383i,-0.8364275-0.902499i,1.63046-0.1642337i,-0.7449656+0.8291896i,0.4636966-1.449682i,0.9781762+1.087401i,1.573359+0.3677754i,1.575461-0.5740575i,0.971158-1.308163i,-0.8209984-1.01723i,1.70344-0.08346485i,1.376889-1.019193i,0.01771322+1.340911i,1.010124+1.163146i,-1.117649-0.5607948i,1.616655-0.6394137i,-0.393426+1.197371i,-0.07747167-1.483308i,1.418604+0.7197934i,1.638504-0.231158i,1.18738-1.067405i,0.3274023-1.387452i,-0.4952678-1.078286i,1.428651+0.1618474i,1.27313-0.6098829i,-0.1688592+0.8910209i,0.5206277+0.8965123i,-0.5020301-0.6904631i,1.200842-0.07769398i,-0.4716471+0.4374116i,0.5413342-0.9418463i,0.5472023+0.752014i,1.000961+0.4208714i,1.175413-0.126287i,0.9804589-0.6845723i},
    {0.03126153-0.1752973i,-0.05064739-0.1397777i,0.1442131+0.1538476i,0.202593+0.09563147i,-0.2108639+0.0650857i,-0.1845998+0.2142665i,0.07869322-0.2881311i,0.1879405+0.3569093i,-0.3664125-0.1352496i,0.458598-0.1088647i,0.2839625-0.3987104i,-0.06766204-0.5059439i,-0.4241113-0.3396035i,-0.5872075+0.0427743i,-0.4483355+0.4549946i,0.09180689-0.6237248i,-0.3654703-0.5317513i,0.6936439+0.2078332i,0.6665624-0.2848145i,-0.2807644+0.7076058i,-0.2038445-0.703882i,0.6822751+0.4532856i,-0.7893432+0.1425657i,-0.5361648+0.6628411i,0.01634411+0.898627i,0.6091422+0.7048246i,0.8040398-0.5086336i,-0.215168+0.9752725i,0.4882936+0.9044408i,-0.933815-0.3101427i,-0.9231211+0.4215805i,0.4500569-0.9000666i,0.3223506+1.00438i,-0.8586648-0.4854881i,0.9994206-0.1772741i,-0.5633835+0.8242875i,0.114525+0.9868374i,0.7086804+0.6623492i,0.9271761+0.04561908i,0.6909199-0.5382947i,-0.1159494+0.8670676i,0.4464467+0.7263432i,-0.733938-0.2174841i,-0.6905848+0.3143306i,0.3654069-0.6242464i,0.1636529+0.7305693i,-0.5289101-0.4060722i,0.6978241+0.01220125i,-0.4818499+0.4661708i,-0.08045613+0.669315i,0.348427+0.5673242i,0.6026304+0.2189083i},
    {0.8548055+0.1891309i,1.178464-0.6553376i,-1.095011+0.3279554i,-0.237059+0.7576759i,-0.9512361-1.698312i,-1.468218-0.8794981i,1.055061-1.266771i,-0.5811571+0.6565134i,-0.5877357-1.830022i,0.9922224+0.03249051i,1.115176-0.8211703i,0.683015-1.541372i,-0.08855178-1.826934i,-0.860246-1.574073i,-1.306119-0.9001237i,0.9812793-1.108854i,0.4181246-1.699525i,0.1450589+0.604297i,0.8547213+0.1654718i,-1.382523-0.5694181i,0.8278793-1.429766i,-0.3374767+0.654287i,-0.7690946-1.709067i,-1.335317-1.048225i,-1.350421-0.1719875i,-0.7985861+0.5179255i,0.8681315+0.2705045i,-1.458054-0.6266121i,-1.16351+0.2429042i,0.1148492-1.91684i,-0.7962324-1.755518i,1.122346-0.1623067i,-1.346854-0.1280357i,0.4832229-1.731885i,0.1311523+0.6287446i,-1.089586-1.35777i,-1.316855-0.5718661i,-1.005541+0.1514079i,-0.3349806+0.5063837i,0.3878857+0.374352i,-1.121483-1.041354i,-1.173387-0.3333665i,0.5261705-1.460374i,-0.1545305-1.685381i,0.581883+0.2293596i,-1.208847-0.7928058i,0.8285157-1.146609i,-0.5075482+0.4270722i,-0.4937072-1.620701i,-1.044465-1.136607i,-1.146201-0.4329831i,-0.7881571+0.1459699i},
    {-0.09185138-1.11693i,-0.2811143-0.9009954i,0.3622171-0.8884859i,0.1691566-1.050319i,0.1660425-0.4938739i,0.3018922-0.6647586i,-0.1740693-0.6546313i,0.1237408-0.9788048i,0.1524726-0.57174i,-0.1436096-0.810361i,-0.1078677-0.6558325i,0.02445776-0.5799645i,0.1661436-0.6249963i,0.2275049-0.7586392i,0.1693528-0.8943918i,0.07465511-0.577489i,0.210811-0.6523873i,-0.1474315-0.7106856i,-0.05289285-0.5683448i,-0.02407183-0.9823229i,0.2796465-0.6545206i,-0.2022404-0.6618962i,0.1652001-1.029406i,-0.06873465-1.050977i,-0.2605799-0.8893265i,-0.2823988-0.6226915i,0.2033954-0.3813364i,-0.3459289-0.9326254i,-0.3746484-0.5963265i,0.2485547-1.196226i,-0.1208604-1.229919i,0.5200287-0.5370069i,-0.4573052-0.58571i,0.2986849-1.254275i,0.2224488-0.2218003i,-0.4565196-1.031047i,-0.5083314-0.5993748i,-0.2413659-0.252678i,0.1922121-0.1907976i,0.5452247-0.4469189i,-0.5200015-0.6482764i,-0.2848708-0.2918471i,-0.02279136-1.325447i,-0.3818441-1.120217i,0.6057903-0.7882848i,-0.3350468-0.3697634i,0.07254034-1.303296i,0.3973592-0.3478207i,-0.4797761-0.8313698i,-0.3865984-0.4560227i,-0.06463168-0.2419719i,0.3177648-0.3030697i},
    {1.621222-0.6006756i,0.7724175-0.9971893i,1.405967+1.671147i,2.018575+0.9388545i,-0.7983861+0.912875i,-0.2149402+1.724952i,0.4818542-1.130607i,1.759372+1.596879i,-1.019276+0.2533557i,2.051314-0.4869452i,1.141735-1.213894i,-0.04606621-1.184264i,-0.947911-0.3846107i,-1.124501+0.8182839i,-0.4854393+1.858163i,0.5871018-1.372408i,-0.5559303-0.9426132i,2.431996+0.7658859i,2.251628-0.4502205i,-0.08261003+2.17572i,0.07704762-1.391455i,2.251714+1.531689i,-1.367823+0.6350154i,-0.8154434+1.908576i,0.4716018+2.547749i,1.910483+2.18344i,2.600607-0.6204472i,-0.1612335+2.553285i,1.432661+2.553136i,-1.360794-0.6139398i,-1.538718+0.9520585i,1.907222-1.341482i,0.8202794+2.577481i,-0.8676274-1.027354i,2.665318+0.5915344i,-0.990135+1.595183i,0.1268564+2.315001i,1.410041+2.172822i,2.299721+1.278227i,2.432466+0.04386515i,-0.5116528+1.870645i,0.6497431+2.259055i,-0.5360624-0.9485658i,-1.145097+0.112184i,2.194198-0.4368275i,-0.00782865+2.099951i,0.06184982-1.225173i,2.107865+1.342498i,-1.05573+0.6829613i,-0.4937399+1.673617i,0.5428666+2.070425i,1.568958+1.732517i},
    {-0.9058441-0.3946907i,-0.8307291-0.08956795i,-0.3717864-0.8246616i,-0.7098903-0.7836729i,0.006897543-0.2099481i,-0.00375642-0.5724533i,-0.6705421+0.1091547i,-0.6369159-0.8521407i,-0.01286647-0.1187253i,-0.9618005-0.2398405i,-0.7456012+0.05236557i,-0.3991207+0.1197961i,-0.1076906-0.05525994i,-0.009126738-0.3654649i,-0.1306681-0.6515588i,-0.5383545+0.06010414i,-0.2578804+0.000311094i,-0.8531805-0.5107876i,-0.856919-0.2335118i,-0.2486258-0.7131832i,-0.4084339+0.04781338i,-0.782197-0.6402524i,-0.04412681-0.3633007i,-0.1508431-0.6458542i,-0.4233233-0.7826574i,-0.7149646-0.695842i,-0.7919452-0.1541318i,-0.3779766-0.7178075i,-0.6309909-0.6606691i,-0.172836-0.2657888i,-0.2130249-0.4755472i,-0.5689577-0.1425634i,-0.5223852-0.5649546i,-0.3251431-0.2598106i,-0.6122842-0.3645504i,-0.3644799-0.4269957i,-0.4149539-0.4530811i,-0.4589122-0.4596004i,-0.5024055-0.455427i,-0.5486435-0.432363i,-0.3498526-0.3465303i,-0.3491632-0.4203947i,-0.5360276-0.2377591i,-0.4465637-0.2083051i,-0.585733-0.4853199i,-0.2840902-0.3366378i,-0.6415215-0.2647594i,-0.3850561-0.5653069i,-0.3981217-0.1378882i,-0.2544679-0.2231947i,-0.1954461-0.3952132i,-0.2688275-0.5772428i},
    {0.7507085-0.522027i,0.1447242-0.7224587i,0.8057988+0.9864666i,1.129538+0.4326463i,-0.6882372+0.689146i,-0.2325864+1.123693i,-0.03745751-0.6983052i,0.9199775+0.8721436i,-0.8103418+0.195339i,1.009982-0.3206041i,0.5068628-0.7415889i,-0.1784662-0.779081i,-0.7778034-0.3709327i,-1.011432+0.3632972i,-0.7151896+1.128276i,0.3044566-1.063735i,-0.6035844-0.8911434i,1.561731+0.6220786i,1.519772-0.3975118i,-0.4371038+1.657138i,-0.3052366-1.256716i,1.552977+1.074192i,-1.427453+0.5375419i,-0.8432453+1.531296i,0.2562101+1.885283i,1.308505+1.423129i,1.478507-0.6809022i,-0.2137904+1.773085i,0.8474733+1.643849i,-1.214371-0.3922313i,-1.287212+0.6282292i,1.06268-0.9645303i,0.245719+1.744651i,-0.8291612-0.8816975i,1.684492+0.4901411i,-1.170577+1.029644i,-0.3692378+1.740863i,0.7368426+1.773377i,1.627493+1.056854i,1.834402-0.1026254i,-0.854526+1.624723i,0.3244898+1.975208i,-1.093853-0.9429822i,-1.552997+0.2134582i,1.459305-0.8726331i,-0.02331393+1.897814i,-0.7521672-1.070717i,1.678995+0.5953745i,-1.116403+0.9429794i,-0.3129346+1.539662i,0.6112824+1.463266i,1.209918+0.85899i},
    {-1.170887-0.9044979i,-1.09896+0.01074376i,0.492706-1.60766i,-0.3694828-1.573235i,0.9972025-0.01959511i,0.9919845-0.782922i,-0.440812+0.28287i,-0.1237849-1.306917i,0.6030641-0.05513552i,-0.5957409-0.4770633i,-0.3750004-0.1528164i,-0.07247353-0.06163703i,0.1613514-0.1416579i,0.2862321-0.2869284i,0.3317177-0.4370931i,-0.2595012-0.4157658i,-0.1859669-0.2742115i,0.09904973-0.8242346i,-0.09859306-0.8238842i,0.3351093-0.2985729i,-0.3471228-0.4935793i,0.352071-0.7278307i,-0.1142695-0.1153075i,0.1301468-0.0730101i,0.3807939-0.1752177i,0.5555916-0.4263226i,0.3097887-1.11136i,0.2168259+0.233649i,0.7171679-0.0001996347i,-0.9093885-0.4267606i,-0.6941038+0.2439905i,0.08051843-1.63301i,0.8138415+0.4415986i,-1.266584-0.6778416i,1.17012-1.296058i,-0.2759553+0.9272516i,0.8127389+0.8066329i,1.545633-0.065344i,1.471479-1.237759i,0.588235-2.053019i,0.6949274+1.032178i,1.571337+0.1694181i,-1.549709+0.05927912i,-0.7406323+0.9741823i,-0.3951619-2.085267i,1.389107+0.3629034i,-1.514214-0.2344536i,0.9757645-1.69352i,0.111798+0.9682572i,1.020067+0.5169113i,1.393405-0.3754326i,1.115595-1.255684i},
    {-0.9785615+0.3813811i,-0.5129086+0.9778572i,-0.0268144-0.9821492i,-0.6478499-0.6529545i,1.090681+0.1758604i,0.9247333-0.4552044i,-0.2476305+0.9904251i,-0.2045057-0.8600823i,0.8946673+0.6389151i,-0.9162473+0.1165227i,-0.6971192+0.7429562i,-0.1171122+1.118838i,0.6026134+1.049861i,1.142583+0.5191412i,1.224429-0.2682668i,-0.5862863+1.095682i,0.2390592+1.326112i,-0.8661002-0.8078282i,-1.239859+0.02431648i,1.145846-0.7760383i,-0.1611735+1.427858i,-0.6223009-1.131351i,1.42692+0.517563i,1.398443-0.4757445i,0.7167154-1.206196i,-0.2791314-1.303157i,-1.305922+0.2477424i,1.012477-0.9635128i,0.1070907-1.294462i,0.9505368+1.098268i,1.382399+0.2827337i,-1.005519+0.7365483i,0.4799303-1.110938i,0.5391648+1.196295i,-0.9500803-0.4825288i,1.206265-0.1611435i,0.7776671-0.7955656i,0.06666635-1.002343i,-0.5899495-0.7176465i,-0.9032475-0.1020405i,0.9348973-0.4033537i,0.4329351-0.7968664i,0.3517506+0.929425i,0.7956622+0.5591123i,-0.7327314+0.1190029i,0.6871921-0.4396234i,-0.08303053+0.8117133i,-0.1990467-0.6098749i,0.7101252+0.4574398i,0.8246903+0.02721012i,0.6773455-0.4056202i,0.2901478-0.6937801i},
    {0.2508637+0.6693743i,0.5496841+0.4801865i,-0.4379301+0.2975011i,-0.2628025+0.6525584i,0.09542802-0.3937517i,-0.3050186-0.2575486i,0.7385073+0.2995245i,-0.4525649+0.5512131i,0.3231667-0.432136i,0.3539272+0.8581798i,0.7328645+0.5642324i,0.8447034+0.07813806i,0.6118357-0.3891343i,0.1091575-0.6099482i,-0.4457377-0.4453841i,0.9890053+0.3469831i,0.8955644-0.287873i,-0.1682724+1.135151i,0.5316424+1.11302i,-0.8406415-0.1953392i,1.102255-0.1339148i,-0.4138975+1.142825i,-0.1356026-0.8480481i,-0.7845097-0.4196434i,-0.9771807+0.3349252i,-0.6158521+1.021733i,0.8167384+1.014012i,-0.950367+0.06956176i,-0.7730983+0.7927192i,0.3844843-0.8032409i,-0.3421624-0.7317308i,1.054966+0.6203719i,-0.8755139+0.5161829i,0.6407128-0.6671876i,0.2809733+1.21194i,-0.6845168-0.4260938i,-0.8967843+0.2593451i,-0.5976078+0.9069242i,0.05271683+1.182229i,0.708059+0.9495789i,-0.812129+0.0671173i,-0.6400506+0.7054378i,0.3122635-0.6278682i,-0.2848962-0.5102611i,0.8340371+0.4574301i,-0.5514514+0.4913918i,0.3796521-0.3931856i,0.2864981+0.7786872i,-0.3530432-0.06779224i,-0.355965+0.2903827i,-0.1498555+0.5181186i,0.1036569+0.5431929i},
    {0.4520392+0.5315362i,1.165941-0.1279564i,-1.250201-0.3758359i,-0.6695877+0.3517891i,-0.243545-1.942646i,-0.9820602-1.446461i,1.171903-0.8529333i,-0.7709723+0.1445164i,-0.03578241-1.857401i,0.7636744+0.06199296i,1.063527-0.6776503i,0.7806293-1.402036i,0.09667768-1.721047i,-0.5925686-1.484858i,-0.9090326-0.8615745i,0.6954117-1.226625i,0.1392732-1.521459i,0.4118396-0.1026659i,0.6709448-0.5862749i,-0.5369914-0.3829195i,0.1135056-1.284953i,0.2726085-0.2977493i,-0.4527701-0.8140844i,-0.3328616-0.4940589i,-0.04794957-0.3779978i,0.2019355-0.5005702i,0.1231193-0.9391961i,0.0935481-0.5081021i,0.2382329-0.6886894i,-0.193607-0.5298427i,0.04412901-0.4236391i,-0.313243-0.9000821i,0.3728611-0.8620656i,-0.1817413-0.3035878i,-0.2195723-1.19395i,0.5303869-0.5383824i,0.5514656-1.003351i,0.2061764-1.366314i,-0.3276137-1.373199i,-0.729553-0.9783082i,0.7234045-1.064256i,0.3012973-1.50782i,0.3164428+0.08323649i,0.8082356-0.3411973i,-0.8947518-0.4497617i,0.4774875-1.553744i,0.1950895+0.2409994i,-0.8301906-1.32901i,1.042572-0.8328862i,0.7263093-1.535772i,-0.006585496-1.85784i,-0.7959459-1.592941i},
    {0.3857677-1.055235i,-0.1607763-1.082261i,0.6378059+0.2458664i,0.8078463-0.2257957i,-0.6292301+0.153391i,-0.2474862+0.4601734i,-0.2046344-1.030503i,0.6781976+0.2014807i,-0.8060647-0.2408784i,0.6668348-0.8273962i,0.1766668-1.127432i,-0.4074212-1.043538i,-0.8078586-0.5967996i,-0.8272341+0.006511306i,-0.4566469+0.4800833i,-0.07811613-1.15258i,-0.6004152-0.891638i,0.8893567-0.1717027i,0.7675107-0.7231192i,-0.2950325+0.5435564i,-0.224884-1.126034i,0.7576238+0.2663194i,-0.9182452-0.2447247i,-0.7257025+0.3567196i,-0.1730147+0.7261506i,0.5234088+0.659835i,1.099856-0.6223975i,-0.5897686+0.7166739i,0.1992501+0.9031014i,-0.8874473-1.067666i,-1.201675-0.2918531i,0.9816703-1.054331i,-0.2119096+0.9544213i,-0.5890431-1.374845i,1.211162+0.1886845i,-1.201463+0.1388989i,-0.6642452+0.8445926i,0.2173712+1.04727i,1.041193+0.6261401i,1.404989-0.2485516i,-1.058405+0.6251646i,-0.2096722+1.132698i,-0.7330865-1.49544i,-1.358844-0.6957767i,1.33971-0.8665267i,-0.5702904+1.036714i,-0.3912544-1.632646i,1.211715+0.4672665i,-1.33289-0.05378579i,-0.8397995+0.7557784i,0.03736136+1.03596i,0.8593999+0.6879948i},
    {1.2437-2.00335i,0.3955854-2.199463i,1.533706-0.1617596i,1.847887-0.9946818i,-0.3758929-0.1046785i,0.4368647+0.3287015i,-0.1956084-2.054791i,1.893329-0.6804407i,-0.6087481-0.2991515i,1.003076-2.280939i,0.004444944-2.229405i,-0.6938927-1.507309i,-0.7090781-0.5048368i,-0.03894874+0.2286734i,0.9355572+0.3012485i,-0.521853-1.646588i,-0.6462734-0.7310213i,1.286934-1.940152i,0.4560066-2.113996i,1.391163-0.2448071i,-0.4583597-0.9722289i,1.308465-1.624039i,0.4661161-0.05638339i,1.067629-0.2549592i,1.368784-0.7677724i,1.263881-1.316242i,0.3600703-1.606601i,1.115777-0.6659141i,1.133576-1.08967i,0.2714653-0.5596624i,0.6192873-0.5181302i,0.2872455-1.243153i,0.9096893-0.9650822i,0.3724447-0.8030108i,0.6130102-1.168029i,0.634757-0.856486i,0.6279908-0.9304352i,0.5894412-0.9311031i,0.6058559-0.8818181i,0.6990693-0.8701299i,0.3539369-0.9808222i,0.3519877-0.7970645i,0.6452881-1.31292i,0.3765487-1.325738i,1.015191-0.820191i,0.09364899-0.7781305i,0.8377953-1.489995i,0.738258-0.3573076i,0.0002947622-1.359398i,-0.1678068-0.8697656i,0.05437496-0.3551142i,0.604459-0.1079808i},
    {0.03678468+0.9843725i,0.5592363+0.6623699i,-1.003505+0.1411441i,-0.7689209+0.6958621i,-0.02336871-0.7377785i,-0.5941005-0.5953664i,0.671873+0.3467204i,-0.881918+0.4474253i,0.2211912-0.6195898i,0.0728607+0.8840737i,0.5128015+0.5616619i,0.6361743+0.04082586i,0.3972315-0.4257336i,-0.07606011-0.6211756i,-0.5503781-0.4671877i,0.5448501+0.279066i,0.4744922-0.183388i,-0.3951364+0.7038165i,0.03608555+0.7131971i,-0.6177377-0.2335469i,0.4411818+0.07549239i,-0.534541+0.4791387i,-0.04183677-0.4028889i,-0.3640539-0.3297231i,-0.5655897-0.0902702i,-0.5843849+0.2072398i,-0.1737562+0.5551366i,-0.3532613-0.2700276i,-0.53679-0.06593038i,0.3094677+0.01365078i,0.171145-0.2352525i,-0.1635854+0.5826032i,-0.3949449-0.2963631i,0.3453921+0.2803744i,-0.626205+0.2760016i,0.1708544-0.3404629i,-0.1771041-0.4505138i,-0.5335394-0.3134862i,-0.7337039+0.03194432i,-0.6680248+0.4436091i,0.08329482-0.5078398i,-0.3686631-0.5227963i,0.4795594+0.4580188i,0.5810411-0.01760535i,-0.6035619+0.6846578i,-0.1373515-0.6511818i,0.3817064+0.7033154i,-0.9194809-0.01017223i,0.5643743-0.3155865i,0.1252516-0.6777127i,-0.4539827-0.6662065i,-0.892558-0.2738486i},
    {-0.5348166+0.4657802i,-0.2510582-0.0175875i,-1.68407+0.1346028i,-1.302477+0.4495251i,-1.191018-0.8554872i,-1.535517-0.589913i,-0.386573-0.2116761i,-1.498222+0.1824633i,-0.8679712-0.7957813i,-0.764738+0.3600569i,-0.4645494+0.08454566i,-0.4010437-0.3282451i,-0.6200766-0.6949217i,-1.030397-0.8349033i,-1.434104-0.6721381i,-0.400649-0.1146267i,-0.5027179-0.5238284i,-1.19587+0.3561933i,-0.8099245+0.3228919i,-1.482349-0.4700003i,-0.5041672-0.2728936i,-1.366151+0.1514112i,-0.9456297-0.6807057i,-1.240306-0.6237821i,-1.448057-0.4084769i,-1.492542-0.1070592i,-1.047825+0.3052597i,-1.309727-0.6269578i,-1.518491-0.3523014i,-0.5238919-0.3997099i,-0.7542024-0.6645125i,-0.9330244+0.3241884i,-1.402952-0.5650063i,-0.4845645-0.1482171i,-1.475538+0.0802922i,-0.8130114-0.7143184i,-1.169338-0.750721i,-1.493399-0.5582815i,-1.643575-0.1855088i,-1.521766+0.2283011i,-0.8916184-0.8915277i,-1.384034-0.8407246i,-0.2866135+0.05600173i,-0.2675756-0.4957543i,-1.396506+0.5361104i,-1.22037-1.027507i,-0.3024561+0.2938046i,-1.889888-0.1021805i,-0.4157826-0.857588i,-0.9934418-1.096476i,-1.588263-0.8964131i,-1.908288-0.3537613i},
    {0.4036108+0.4071255i,0.7367772+0.04584036i,-0.570168-0.1750241i,-0.3345043+0.181103i,0.1599355-0.9002739i,-0.1968014-0.792913i,0.6127777-0.07109129i,-0.4296569-0.180745i,0.4622087-0.6826709i,0.02772975+0.2297105i,0.3418341+0.1791746i,0.5771759-0.04151079i,0.6493745-0.3652585i,0.5197824-0.6852769i,0.2146991-0.8826834i,0.3718155+0.278373i,0.6942687+0.01888557i,-0.6040906-0.1728126i,-0.4135414+0.2713418i,0.1536248-1.107727i,0.605418+0.4177626i,-0.7976611-0.5330578i,0.993627-0.7130018i,0.529454-1.243911i,-0.2125969-1.34379i,-0.8680057-0.9043708i,-0.6775244+0.6540687i,0.05234531-1.548243i,-0.7848226-1.216428i,1.391094-0.1885297i,1.144014-1.075372i,-0.1668167+0.9867506i,-0.5408587-1.430806i,1.325647+0.1426064i,-1.104527+0.1750669i,0.7057894-1.425264i,-0.1715431-1.538939i,-0.9068825-1.062656i,-1.159925-0.2307247i,-0.8197877+0.5651301i,0.249426-1.541271i,-0.5921721-1.342556i,1.308698+0.05908152i,1.24996-0.8094214i,-0.4377793+0.8472247i,-0.2345449-1.508117i,1.144843+0.4063765i,-1.141273-0.1397568i,0.9318553-1.215388i,0.1237702-1.521772i,-0.6766769-1.223752i,-1.076654-0.4838285i},
    {0.3632638+0.4860744i,0.5800744+0.2582878i,-0.4511821-0.002429951i,-0.3743387+0.313187i,0.3263303-0.609148i,-0.08032285-0.6807979i,0.706028+0.4244898i,-0.7044597+0.01642295i,0.7435897-0.6083435i,-0.002625468+0.8928203i,0.6476701+0.7735333i,1.067693+0.2259211i,1.009637-0.4812077i,0.4855283-0.9738169i,-0.2342891-0.9913788i,0.9897128+0.4920875i,1.100124-0.1988669i,-0.5375183+0.7424056i,0.08931483+0.963056i,-0.4918751-0.7896816i,1.046477+0.212853i,-0.7852951+0.3788525i,0.5666385-0.8967283i,-0.07956589-1.018866i,-0.6873993-0.7070574i,-0.9820706-0.05500524i,-0.1413711+1.126263i,-0.4730746-1.087742i,-1.065411-0.4615149i,1.304665-0.4701087i,0.7182537-1.172149i,0.4130171+1.263587i,-0.9838741-0.7798526i,1.421649-0.1746996i,-0.772757+0.9608821i,0.1146028-1.319993i,-0.7286382-0.9876942i,-1.131346-0.2010221i,-0.9247119+0.63147i,-0.2483091+1.112148i,-0.3407826-1.085276i,-0.891812-0.5411698i,1.179489-0.2455565i,0.781476-0.8573628i,0.1071218+1.03961i,-0.5580848-0.8335096i,1.126368+0.1907229i,-0.8176158+0.4626967i,0.5083719-0.9806967i,-0.2011055-1.017346i,-0.7718219-0.5851079i,-0.9255499+0.1179284i},
    {0.8450588-1.35416i,0.3610465-1.200093i,1.591503-0.3486635i,1.580497-0.8634692i,0.403965+0.1448723i,0.9369641+0.2834992i,0.1907148-1.189954i,1.752929-0.4812412i,0.02820524-0.02671219i,1.108838-1.532088i,0.4069458-1.519127i,-0.1396043-1.034158i,-0.2401835-0.2842033i,0.1880575+0.3672479i,0.9579692+0.5821795i,-0.03620711-1.365263i,-0.3629938-0.6030969i,1.760585-1.330308i,1.032346-1.762066i,1.461311+0.4699213i,-0.328449-0.935173i,1.939018-1.04701i,0.3078217+0.5133439i,1.137468+0.578341i,1.795918+0.09104063i,1.972522-0.6925851i,0.8949313-1.672294i,1.472538+0.3056846i,1.86204-0.3096197i,-0.1178394-0.1184734i,0.3861182+0.367432i,0.5823972-1.562911i,1.645752+0.04314541i,-0.1875056-0.5202805i,1.580487-1.25211i,0.6914372+0.4386598i,1.370938+0.2878948i,1.789773-0.2683218i,1.743708-0.9593814i,1.261928-1.444659i,1.063295+0.3580455i,1.582746-0.03046441i,-0.05970572-0.4970209i,0.2159649+0.02653142i,0.9267779-1.376298i,1.23375+0.0956188i,0.1343457-0.83442i,1.519785-0.7645703i,0.3999569-0.01116503i,0.8127712+0.1296722i,1.233484+0.006849348i,1.510393-0.3474738i},
    {0.6697415-0.3538899i,0.6688225-0.7549102i,0.0480029+0.001891149i,0.4790313-0.01549338i,-0.3671871-0.6947919i,-0.3526618-0.2315875i,0.4226663-1.143868i,0.4938138+0.1120332i,-0.4673144-0.797043i,0.9255282-0.7923458i,0.5626505-1.247301i,-0.04579871-1.334726i,-0.5759321-0.9595805i,-0.7066645-0.2871031i,-0.3147028+0.3171782i,-0.005597448-1.523592i,-0.6735264-1.11313i,1.282524-0.7122182i,0.8581048-1.426166i,0.3742361+0.6005965i,-0.6990519-1.21364i,1.34329-0.6491053i,-0.5201932+0.3561097i,0.282665+0.6056297i,1.022552+0.2373918i,1.301585-0.5220992i,0.2935424-1.571705i,0.840162+0.3036145i,1.214458-0.3356709i,-0.6542634+0.01268435i,-0.07280802+0.4455373i,-0.2322806-1.417618i,1.134968-0.1556047i,-0.7179099-0.1575595i,0.6335948-1.412342i,0.5093993+0.4155682i,1.062961-0.05762148i,1.129342-0.7778062i,0.6776062-1.330673i,-0.01864268-1.403597i,0.9630116-0.06427693i,1.030872-0.7195539i,-0.2159673+0.1698679i,0.38415+0.2273621i,-0.4086422-0.9007329i,0.8695962-0.6753687i,-0.127086+0.02236282i,0.06794592-1.097426i,0.6824253-0.2342379i,0.7069079-0.6516165i,0.4408816-0.9419122i,0.06831022-0.9499581i},
    {0.399955-0.1848953i,0.6214761-0.1629397i,0.1218739-0.5487888i,0.1011327-0.2570629i,0.6261398-0.8680615i,0.2717853-0.8965001i,0.9640129-0.2282917i,-0.06958278-0.2419536i,0.7430367-0.9844686i,0.6529027+0.1752833i,1.049774-0.1014875i,1.150338-0.5956542i,0.8727933-1.038436i,0.3512121-1.171868i,-0.1300657-0.9028348i,1.236484-0.5125681i,0.9857293-1.021925i,0.4890484+0.3413107i,1.014299+0.119529i,-0.3046225-0.481678i,1.062961-0.9266577i,0.3603127+0.3083402i,0.05779402-1.057422i,-0.2345731-0.6216769i,-0.163922-0.1154429i,0.214308+0.2080122i,1.051832-0.1139511i,-0.1696594-0.3061932i,0.08301572+0.0705418i,0.4271064-1.065713i,0.03525003-0.8734112i,1.068111-0.4009418i,0.007606517-0.08416682i,0.5792617-0.9940014i,0.7425596+0.03159006i,-0.02395718-0.6087915i,0.007937899-0.2539597i,0.2504539-0.02070378i,0.5659298-0.001849507i,0.8042049-0.1774461i,0.0658878-0.433338i,0.1715751-0.1935221i,0.5479676-0.8051993i,0.3077195-0.7664438i,0.7959923-0.2889061i,0.1252586-0.3505941i,0.6750299-0.7274319i,0.5020114-0.09159986i,0.219913-0.6749478i,0.1369753-0.4462344i,0.2321761-0.2287288i,0.4428913-0.1437159i},
    {-0.5305681-1.558678i,-1.144751-0.7814909i,1.45952-1.014698i,0.7201604-1.708659i,0.6823443+0.926625i,1.43114+0.2550698i,-1.142384-0.06209511i,0.9573142-1.512224i,0.354972+0.9149382i,-0.7633136-1.25733i,-1.059196-0.4221701i,-0.7499372+0.3774697i,-0.01984524+0.7744078i,0.771817+0.6126004i,1.262684-0.004787446i,-0.8539737-0.01537637i,-0.3502784+0.5525985i,0.000263131-1.451041i,-0.6184083-1.058832i,1.215299-0.4191037i,-0.5437419+0.262138i,0.3252734-1.339287i,0.6795697+0.3732881i,1.015568-0.1291902i,0.9542343-0.6907653i,0.5814468-1.057693i,-0.2792224-0.8869383i,0.8370467-0.2816077i,0.7697578-0.6673954i,-0.1173155+0.1536922i,0.2617762+0.2402991i,-0.2479574-0.8824107i,0.8623338-0.2711792i,-0.4311647-0.07391468i,0.4919698-1.059241i,0.3858392+0.3246055i,0.8112897+0.04804654i,0.9618963-0.4463573i,0.7575835-0.9252708i,0.294772-1.161353i,0.5962902+0.2571835i,0.9112445-0.140217i,-0.5209537-0.1536509i,-0.2167865+0.232439i,0.1337328-1.144271i,0.7014022+0.1612223i,-0.5553085-0.5303775i,0.8812714-0.7536349i,-0.1374753+0.3222027i,0.3787088+0.3953563i,0.8475498+0.1288477i,1.06137-0.3888299i},
    {-0.1066949+1.061564i,0.7795052+1.073287i,-0.6075678-0.7321551i,-0.7235627+0.07924061i,1.117923-0.9529312i,0.4000863-1.16411i,1.070749+0.6583363i,-0.5459439-0.2617824i,1.207295-0.5810197i,0.1125296+0.7302472i,0.7038299+0.6931809i,1.117789+0.3032795i,1.183134-0.2390896i,0.8961257-0.677564i,0.4160807-0.8191844i,0.8363267+0.4098207i,1.023651+0.007520894i,-0.09153464+0.1700675i,0.2156694+0.3715962i,0.2856953-0.5474546i,0.7210397+0.1379987i,0.07178665-0.1393i,0.6817185-0.224366i,0.5961038-0.3122986i,0.5027102-0.3833036i,0.3599458-0.4392555i,-0.0489962-0.2236702i,0.9142008-0.327843i,0.6952498-0.6647736i,0.5678887+0.5724021i,1.026966+0.3441372i,-0.4123078-0.0385792i,1.021825-0.7389504i,0.3614652+0.8186119i,-0.1878612-0.8718882i,1.400468+0.08616886i,1.317932-0.6257236i,0.7726786-1.125004i,0.01108001-1.148434i,-0.6008333-0.6557204i,1.569659-0.3564941i,1.149918-1.081994i,0.4888606+1.151813i,1.3218+0.8191668i,-0.9237031-0.2088126i,1.50727-0.932655i,0.1267754+1.269087i,-0.3057889-1.350213i,1.79356+0.3526399i,1.766243-0.6927248i,1.037302-1.460033i,-0.02618686-1.542107i},
    {0.131241-0.2001854i,0.2498148+0.0466326i,0.5160643-0.6150501i,0.273909-0.519532i,0.8565035-0.1693341i,0.8093919-0.3895116i,0.3638051+0.05353643i,0.4655427-0.5506435i,0.7241881+0.006079749i,0.1772528-0.3206813i,0.1597437-0.1018876i,0.2891155+0.1164269i,0.5631925+0.2232596i,0.8820422+0.1142824i,1.068919-0.2158667i,0.04442337+0.152813i,0.4232496+0.405557i,0.1159978-0.793512i,-0.186916-0.3809585i,1.134962-0.6169631i,0.3094562+0.4840332i,0.160303-0.9044397i,1.220727+0.01628649i,1.197785-0.5314637i,0.8125648-0.9092511i,0.2857811-0.9239535i,-0.161222-0.09959162i,0.9104752-0.7620776i,0.4703874-0.8736355i,0.9368617+0.2087758i,1.101936-0.1723906i,0.02773789+0.08337504i,0.6749256-0.773141i,0.7152339+0.2749681i,0.03438247-0.499397i,1.040675-0.3293855i,0.8619884-0.6444356i,0.5213498-0.778758i,0.166658-0.6640011i,-0.03512889-0.3408432i,0.9940398-0.5155846i,0.6887998-0.7693877i,0.7315381+0.2813238i,1.017094-0.00450529i,-0.01128595-0.06575641i,0.767496-0.6994579i,0.6301829+0.2567389i,0.1109168-0.4974682i,0.9427449-0.3075277i,0.7549981-0.5465729i,0.4902863-0.5834818i,0.3059531-0.4526077i},
    {0.1588852-0.804858i,-0.489873-1.074164i,0.1035238+0.6817714i,0.4344571+0.08226012i,-1.335442+0.4073417i,-0.8215096+0.7923903i,-0.8371739-0.918744i,0.2278547+0.3609678i,-1.363333+0.03530095i,0.06249807-0.6778457i,-0.4221502-0.9065086i,-0.9482917-0.8033131i,-1.317435-0.3992837i,-1.370739+0.1663916i,-1.050438+0.6698759i,-0.5902365-1.033562i,-1.212484-0.796717i,0.5059334+0.02152444i,0.3504933-0.6955587i,-0.7799403+0.9857128i,-1.045666-1.069736i,0.5408731+0.3153571i,-1.584055+0.3355121i,-1.034519+0.935959i,-0.2288562+1.008058i,0.4051841+0.5258779i,0.1538369-0.8792745i,-0.5076525+0.9259752i,0.1151377+0.6405158i,-1.427413-0.2134437i,-1.263787+0.3694031i,-0.2433714-0.8531407i,-0.2757702+0.6591849i,-1.138652-0.4965422i,0.1938334-0.1177102i,-1.060843+0.3657138i,-0.6875066+0.5918456i,-0.2516678+0.5590848i,0.08784045+0.2703804i,0.1888547-0.1781866i,-1.030132+0.4488282i,-0.5868301+0.6660237i,-0.9520207-0.7096314i,-1.262864-0.2933737i,0.1869119-0.3920304i,-0.866636+0.611016i,-0.6960477-0.8259088i,0.07652929+0.379145i,-1.263098-0.06197901i,-1.080735+0.386182i,-0.6737032+0.6203738i,-0.2186136+0.5628332i},
    {0.01702191-0.9231167i,-0.2595996-0.6684116i,0.5933918-0.6674405i,0.31556-0.913636i,0.3835955-0.08797301i,0.5900108-0.3760304i,-0.1806726-0.2511187i,0.2363022-0.8731099i,0.3940404-0.178449i,-0.1820231-0.5249376i,-0.09042554-0.2775879i,0.1286304-0.1784947i,0.3330379-0.2519883i,0.4239546-0.4250847i,0.3845244-0.597747i,0.08085962-0.260816i,0.2389516-0.2569741i,-0.03211093-0.6105403i,-0.07944479-0.4477577i,0.3419629-0.681363i,0.1794712-0.197423i,-0.04977968-0.6885761i,0.4879345-0.4886386i,0.3958794-0.727189i,0.1453728-0.8286412i,-0.1095617-0.7080128i,-0.04175523-0.1763652i,0.08631305-0.8406376i,-0.1497129-0.6610253i,0.5103965-0.5910468i,0.3147211-0.7983618i,0.2978493-0.167718i,-0.1355401-0.5952838i,0.4484354-0.6152884i,0.07541949-0.1995746i,0.04095962-0.7310959i,-0.08551591-0.5647759i,-0.06220035-0.3699194i,0.07974863-0.2506154i,0.2567984-0.2574321i,-0.04391831-0.584339i,-0.05880069-0.4146924i,0.2943753-0.6847745i,0.1219931-0.722118i,0.374016-0.3300008i,-0.09425207-0.4476572i,0.3431406-0.6945431i,0.1931049-0.1928751i,-0.0597755-0.677082i,-0.1451761-0.4590437i,-0.04755277-0.2340105i,0.1910806-0.1400118i},
    {-1.837632+0.5750627i,-1.374976+0.7814303i,-1.772031-0.4913921i,-2.017693-0.06476278i,-0.746538-0.2678084i,-1.105714-0.5457474i,-1.133935+0.6642831i,-1.84392-0.2678273i,-0.7411309+0.0256286i,-1.78276+0.4509152i,-1.46851+0.6494383i,-1.084741+0.6319899i,-0.7648123+0.3773388i,-0.6574844-0.05220838i,-0.8612319-0.4886415i,-1.333374+0.8386044i,-0.798763+0.6746225i,-2.171099-0.03159365i,-2.038232+0.5707192i,-1.154631-0.7931314i,-0.8831763+0.8227271i,-2.169832-0.1814857i,-0.5680788-0.3044614i,-1.024497-0.6953304i,-1.59497-0.6755181i,-1.981099-0.3053315i,-1.772533+0.5668263i,-1.297476-0.5640846i,-1.672035-0.4402939i,-0.7716447+0.2693896i,-0.7603781-0.1067542i,-1.694772+0.5614155i,-1.35532-0.5641105i,-0.9078817+0.5623183i,-2.00174-0.04581493i,-0.7367812-0.2898126i,-1.111912-0.6076691i,-1.614851-0.5938964i,-1.981867-0.2429932i,-2.017401+0.2611769i,-0.9584553-0.5179331i,-1.432527-0.6003708i,-0.8446617+0.4913886i,-0.7156993+0.07407273i,-1.791627+0.4362859i,-1.217866-0.4774142i,-1.102961+0.540291i,-1.783049-0.1572879i,-0.8614877-0.01759704i,-1.01169-0.2695206i,-1.269352-0.3876852i,-1.54604-0.3413533i},
    {-0.2716382-0.2124307i,-0.4860411+0.2763092i,0.9426358-0.3201158i,0.4165053-0.6357788i,0.8464995+1.018869i,1.251025+0.4825147i,-0.5615728+0.7123364i,0.6746829-0.6888213i,0.66962+1.21083i,-0.5909263-0.239971i,-0.6982944+0.4748161i,-0.3104636+1.085136i,0.38118+1.294576i,1.042852+1.004788i,1.359918+0.3551573i,-0.5529333+0.8529633i,0.03886271+1.276577i,-0.1396142-0.7120618i,-0.6622416-0.1916777i,1.353098-0.04356793i,-0.2866766+1.158072i,0.1815924-0.8318162i,1.126112+0.9922204i,1.415899+0.2826064i,1.168233-0.4472626i,0.4990487-0.8359869i,-0.7334983-0.07074068i,1.306062-0.1944898i,0.7539394-0.7273616i,0.6325538+1.259077i,1.200657+0.7787971i,-0.6658601+0.4454339i,0.8942724-0.5135511i,0.3873174+1.165925i,-0.3073977-0.3478531i,1.121275+0.2942839i,0.9066815-0.2025296i,0.4653799-0.4146679i,0.04251877-0.3073537i,-0.1905067-0.002451872i,0.826357+0.1723424i,0.6669126-0.07863902i,0.2069458+0.7062178i,0.474019+0.6897352i,-0.0742081-0.02601127i,0.8154456+0.252554i,-0.1056988+0.5713152i,0.4528769-0.2823477i,0.5547354+0.7739974i,0.8456223+0.5056856i,0.8900176+0.1032046i,0.6584342-0.2301517i},
    {0.4277028-0.5665051i,0.03185156-0.5991157i,0.6232712+0.310742i,0.7245461-0.04716685i,-0.2486359+0.3099734i,0.04735524+0.4821046i,-0.03751428-0.514285i,0.621904+0.2328073i,-0.3628158+0.01926184i,0.5812915-0.4049705i,0.2797313-0.6054633i,-0.1100094-0.5835058i,-0.4276639-0.3038789i,-0.5019632+0.1480622i,-0.2488351+0.5703993i,0.08956465-0.7996858i,-0.4168922-0.5797079i,0.9959221-0.009508784i,0.8192539-0.5741214i,0.03846927+0.8136481i,-0.294254-0.7608488i,0.9977111+0.2094339i,-0.6119149+0.3232498i,-0.1893972+0.7399241i,0.3933605+0.7817761i,0.8594443+0.4440864i,0.7629987-0.6199273i,0.08621963+0.799888i,0.6418651+0.6660962i,-0.6503561-0.2687478i,-0.6176826+0.3209376i,0.541586-0.8234749i,0.4072826+0.8151551i,-0.5712917-0.5187985i,1.04649-0.1581215i,-0.4014629+0.6365061i,0.1857429+0.8354893i,0.745631+0.5943065i,0.9942718+0.0547415i,0.8261427-0.4939529i,-0.0181014+0.7141457i,0.4970518+0.6267929i,-0.4736049-0.3143699i,-0.4719663+0.1494879i,0.5345126-0.5519542i,0.2040304+0.5697182i,-0.2109464-0.4688585i,0.7161625+0.07678009i,-0.318792+0.2021539i,-0.07430419+0.4398591i,0.2586514+0.486812i,0.5544428+0.3277308i},
    {0.1583568-0.8476669i,0.2700714-0.7502819i,0.2941136-1.074188i,0.2183912-0.9865817i,0.4739646-0.9476434i,0.4165058-1.009324i,0.3509846-0.8140319i,0.2868486-0.9928456i,0.440916-0.8963498i,0.2620728-0.8734828i,0.3131051-0.8239416i,0.3909464-0.823139i,0.4496845-0.8838302i,0.4421928-0.9738964i,0.3636832-1.028144i,0.4276848-0.8365878i,0.4622838-0.9341596i,0.2944307-0.8123848i,0.4052961-0.8100919i,0.2224628-0.9325629i,0.4368425-1.0158i,0.3772523-0.7815176i,0.2153112-0.9778979i,0.2137329-0.8455465i,0.3205724-0.761735i,0.4548362-0.7946179i,0.454513-1.046834i,0.374526-0.7520922i,0.4868533-0.8263397i,0.1891708-0.8797474i,0.2657174-0.7804583i,0.311517-1.069292i,0.4762895-0.8344032i,0.1998957-0.8924066i,0.441223-1.034153i,0.35526-0.7677082i,0.4537315-0.8078182i,0.5034608-0.9045293i,0.4764292-1.013537i,0.3803726-1.079092i,0.4346433-0.7725745i,0.5124564-0.8675897i,0.1913305-0.8432654i,0.2811055-0.7571384i,0.2920514-1.081134i,0.4965478-0.831491i,0.1805761-0.8870958i,0.4572746-1.047722i,0.3461254-0.7459853i,0.4575313-0.780199i,0.5264795-0.8798337i,0.5167316-1.008133i},
    {-0.967433-1.041755i,-1.253879-0.7334374i,-0.1467806-0.7891887i,-0.4634472-1.113489i,-0.4699672+0.04069567i,-0.1275441-0.2806785i,-1.286378-0.3340787i,-0.4261064-1.090246i,-0.5194445+0.02457685i,-1.198965-0.815893i,-1.22212-0.4043426i,-0.9702157-0.1124093i,-0.6161005-0.07652585i,-0.3563653-0.2711626i,-0.2977188-0.5583258i,-0.9726395-0.2951582i,-0.7534975-0.2054156i,-0.8516181-0.8221347i,-0.9759931-0.665082i,-0.4131612-0.6104648i,-0.8790331-0.3174476i,-0.6966201-0.8275265i,-0.5211784-0.3205136i,-0.422532-0.4856064i,-0.4545748-0.6758578i,-0.6026655-0.7974801i,-0.9230331-0.6646155i,-0.4598183-0.5946947i,-0.5605236-0.7285964i,-0.6812436-0.3240499i,-0.5522327-0.3991456i,-0.8879839-0.5520617i,-0.562839-0.6503065i,-0.7241791-0.3880706i,-0.7732435-0.6563694i,-0.5874711-0.5152923i,-0.6221093-0.5877063i,-0.6851775-0.6011462i,-0.7177966-0.5641114i,-0.6952057-0.5302128i,-0.7452467-0.5343593i,-0.7429066-0.466485i,-0.7359756-0.666364i,-0.8525146-0.6204623i,-0.4949181-0.6120122i,-0.8082475-0.3099949i,-0.8012615-0.8193085i,-0.3964738-0.4060157i,-1.037552-0.4119996i,-0.8574425-0.1857097i,-0.5532066-0.1561851i,-0.3093799-0.3600597i},
    {-1.602387-0.934469i,-2.048726-0.04410458i,0.4829069-0.8599864i,-0.4126661-1.404536i,0.1690004+1.274285i,0.7894033+0.4070677i,-1.939736+0.7284549i,-0.1459481-1.321443i,-0.1117566+1.362104i,-1.885763-0.5799344i,-1.950335+0.3852626i,-1.383055+1.125756i,-0.5036595+1.308484i,0.2563581+0.8939904i,0.5623842+0.1146853i,-1.591423+0.7407088i,-0.9173177+1.164613i,-1.143383-0.9799869i,-1.667276-0.4102843i,0.4150869-0.2724245i,-1.231146+0.9490001i,-0.7832033-1.006727i,0.125873+0.7222748i,0.3464821+0.0557272i,0.08387762-0.5620801i,-0.4866239-0.8381309i,-1.36905-0.2419099i,0.05143033-0.168196i,-0.24383-0.5023426i,-0.6460835+0.6738177i,-0.2989138+0.5392064i,-1.194805-0.1706501i,-0.06468406-0.0992138i,-1.041216+0.5001109i,-0.5898438-0.5871935i,-0.288969+0.5945236i,0.001670086+0.2669137i,0.02259585-0.1936509i,-0.2661702-0.5762823i,-0.7456101-0.6867049i,-0.09430984+0.5418148i,0.1008715+0.08124445i,-1.24225+0.4775806i,-0.8354604+0.7536861i,-0.9316919-0.6334537i,-0.0001366624+0.3920913i,-1.364464+0.1572744i,-0.137334-0.4947965i,-0.7170276+0.7827163i,-0.2425219+0.6873523i,0.08700521+0.3163172i,0.1262474-0.1949233i},
    {0.1928271-0.9776544i,0.07013074-0.8313076i,0.4674544-0.8013265i,0.3419616-0.8926358i,0.3501985-0.6002495i,0.4049976-0.7133802i,0.203555-0.6445695i,0.2447819-0.8347327i,0.3899214-0.7022408i,0.1797124-0.6466041i,0.2816753-0.5806892i,0.4105179-0.6161106i,0.4813996-0.7476968i,0.4331353-0.9097846i,0.2650218-1.004497i,0.5059805-0.5110494i,0.6410676-0.726211i,-0.02538828-0.449942i,0.2490612-0.2640951i,-0.06073854-1.129281i,0.8557685-0.6758934i,-0.2156181-0.3299611i,0.3542146-1.415672i,-0.1808629-1.309262i,-0.4990358-0.8226576i,-0.3675739-0.2249333i,0.8085412-0.03768383i,-0.599533-0.8562045i,-0.444423-0.2051547i,0.4357015-1.61015i,-0.2095069-1.473005i,1.1329-0.5226372i,-0.4826624-0.3104439i,0.5573933-1.543412i,0.608981+0.0550206i,-0.487585-1.098142i,-0.541526-0.4987046i,-0.1863473-0.007050057i,0.4150465+0.1311515i,0.9696695-0.1725112i,-0.6259577-0.6739148i,-0.3568285-0.06091295i,0.2803405-1.667715i,-0.374927-1.416146i,1.228259-0.6920125i,-0.4259191-0.09655944i,0.3354149-1.665432i,0.8819299-0.03913904i,-0.6107338-0.7959612i,-0.3746784-0.174064i,0.2069928+0.0846243i,0.7695587-0.1328629i},
    {1.087977+1.009344i,0.9730068+0.5045902i,-0.00411528+1.807803i,0.5849247+1.841812i,-0.5438518+0.4755214i,-0.7105499+1.119196i,0.9585879+0.2077443i,0.2527462+2.023686i,-0.3930398+0.1526908i,1.322533+1.170109i,1.19833+0.4521267i,0.6465233-0.007945311i,-0.05769315-0.007930456i,-0.591453+0.4272575i,-0.7347732+1.086607i,0.9987568+0.2651895i,0.4074501-0.03194318i,0.7991384+1.858322i,1.248675+1.352347i,-0.7409135+1.290946i,0.8874013+0.07207373i,0.3718559+2.089445i,-0.5211827+0.1532833i,-0.8880531+0.8435594i,-0.7264947+1.62847i,-0.08697245+2.140194i,1.392892+1.569557i,-0.9847808+1.236322i,-0.541401+2.001645i,0.2454285-0.3621651i,-0.6256686-0.04939725i,1.654335+1.179686i,-0.9279228+1.728354i,0.7065681-0.4040566i,0.8621843+2.319492i,-1.06232+0.3400633i,-1.158213+1.38116i,-0.5354156+2.227663i,0.4911112+2.445784i,1.395932+1.931044i,-1.174828+0.9909518i,-0.7905614+1.920176i,0.4651386-0.4066289i,-0.4595682-0.1717956i,1.548392+1.367008i,-0.9216226+1.481544i,0.858874-0.1557383i,0.5466768+2.1932i,-0.6924528+0.2260682i,-0.9265985+1.019254i,-0.6026917+1.766477i,0.1144955+2.123564i},
    {-1.299788-0.01428999i,-0.7426786+0.8850011i,0.1078778-1.815335i,-0.8462638-1.393902i,1.660154-0.1572853i,1.396625-1.138488i,-0.2029617+1.088368i,-0.4088535-1.619248i,1.470018+0.3090583i,-1.189839+0.03320843i,-0.6488016+0.8297628i,0.2755877+1.097687i,1.159488+0.710439i,1.588431-0.1587749i,1.351079-1.10289i,-0.1826823+1.044542i,0.7859623+0.9464356i,-1.0734-0.8608969i,-1.100522+0.08902472i,0.8789017-1.421836i,0.3755141+0.9395889i,-0.7265394-1.106287i,1.33622-0.2828538i,1.047071-0.9757856i,0.4362997-1.306847i,-0.1961289-1.205391i,-0.716265-0.2339235i,0.8748792-0.8887815i,0.4167811-1.195809i,0.5317545+0.5724324i,1.032431+0.210248i,-0.8546185-0.1926986i,0.9582267-1.094501i,0.08866441+0.836876i,-0.5081471-1.282565i,1.377734-0.01881753i,1.295385-0.8819777i,0.6495596-1.478453i,-0.2300328-1.492365i,-0.8886161-0.9248958i,1.376651-0.5369385i,0.9298909-1.22595i,0.1952027+0.8328293i,0.888301+0.5432261i,-0.8611642-0.5366217i,1.12658-0.7597073i,-0.2834551+0.6003667i,0.01467213-1.313869i,0.9288901+0.3947284i,1.222533-0.1928218i,1.106583-0.8620887i,0.5877481-1.347366i},
    {0.1898023+0.5740155i,0.4659918+0.5429186i,0.02053395+0.2270755i,0.110049+0.4734589i,0.2733078-0.008771029i,0.06392766+0.1398564i,0.5732218+0.1440656i,0.2604323+0.5630951i,0.1078885+0.04180177i,0.6360021+0.2495813i,0.5079473-0.002766966i,0.2250134-0.06408451i,-0.006722611+0.1174242i,-0.01808552+0.4139746i,0.1983914+0.6159944i,0.140537-0.04546554i,-0.0282008+0.1828942i,0.6066523+0.09190561i,0.3905996-0.04726105i,0.4720004+0.5374409i,0.03693579+0.1874187i,0.562026+0.1588045i,0.202579+0.5012749i,0.3667394+0.5113299i,0.499405+0.4285266i,0.5616111+0.2845504i,0.3887254+0.006510948i,0.4390252+0.5366087i,0.6014964+0.3929533i,0.006054181+0.3821945i,0.1613346+0.5757376i,0.2115236-0.06292673i,0.6242024+0.4408374i,-0.02373298+0.3638232i,0.4909249-0.02390212i,0.3865508+0.5947762i,0.5738122+0.4515435i,0.6102791+0.236081i,0.5049663+0.06670034i,0.3338856+0.008694088i,0.4524007+0.4822543i,0.5474917+0.3587116i,0.06963069+0.3391959i,0.1512623+0.4843817i,0.3096556-0.01875027i,0.5219955+0.5087842i,-0.02513833+0.2272563i,0.6159946+0.05676794i,0.240516+0.6589419i,0.5457741+0.6181545i,0.741362+0.3562217i,0.685687+0.01867415i},
    {-0.1328817+2.561676i,0.9277278+2.447116i,-1.076039+0.5421146i,-1.08976+1.560005i,1.001829-0.1035986i,0.04708165-0.2617222i,1.318938+1.993181i,-1.078925+1.100529i,1.312124+0.2470832i,0.03624414+2.431505i,0.9495994+2.276223i,1.553574+1.561641i,1.547931+0.613977i,0.9136721-0.1071923i,-0.05016126-0.2295183i,1.40728+1.888197i,1.630758+0.9327432i,-0.600656+2.133352i,0.3168314+2.429523i,-0.6201612+0.184429i,1.513364+1.182994i,-0.6473157+1.849506i,0.4522769+0.001366573i,-0.2924521+0.2260282i,-0.6597152+0.8447155i,-0.5296103+1.488347i,0.4654894+1.80955i,-0.2467966+0.7211805i,-0.3032074+1.113596i,0.6935346+0.8016471i,0.4340384+0.6657852i,0.3742645+1.53119i,-0.01948092+0.814779i,0.6753056+1.196555i,-0.1120324+1.250393i,0.525153+0.7652595i,0.2879053+0.6704096i,0.02587113+0.730161i,-0.1617444+0.9395515i,-0.1940728+1.23045i,0.5973787+0.7185987i,0.3110164+0.58127i,0.5701537+1.578357i,0.8234447+1.327353i,-0.3366866+1.267601i,0.6989595+0.5703731i,0.2697027+1.849901i,-0.2221095+0.471166i,1.132613+1.301511i,1.124091+0.6733415i,0.6689062+0.156316i,-0.07473817+0.05913704i},
    {1.405864-0.07532559i,1.599027-0.649938i,0.0962064-0.09761628i,0.6142085+0.1544131i,0.3216937-1.302575i,0.03883753-0.8674626i,1.360867-0.9043345i,0.432113-0.1017823i,0.6457791-1.210562i,1.100085-0.2816354i,1.201357-0.5605265i,1.148165-0.8163947i,0.9918709-1.000441i,0.7685439-1.091796i,0.5108895-1.061182i,1.181641-0.4168705i,1.272598-0.7304578i,0.323849-0.2253833i,0.6676251-0.02094509i,0.3712302-1.211788i,1.404279-0.4268679i,0.04238262-0.383216i,1.116126-1.317747i,0.6004342-1.438696i,0.1067272-1.195735i,-0.130075-0.6753378i,0.5270933+0.2615361i,0.2926657-1.511954i,-0.1950497-1.0408i,1.732085-0.9603355i,1.30927-1.566201i,0.90178+0.4584587i,-0.1435457-1.394694i,1.913842-0.6614491i,-0.1651977+0.1555002i,0.8826045-1.865095i,0.03420427-1.675754i,-0.482499-0.9638992i,-0.3986872-0.0805224i,0.2518341+0.5312799i,0.318236-1.857942i,-0.3782124-1.287732i,1.992651-0.898201i,1.515943-1.664973i,0.814629+0.6293424i,-0.1656928-1.550197i,1.994218-0.5640334i,-0.2582174+0.1123013i,0.9735953-1.855253i,0.1307034-1.694641i,-0.3825967-1.032373i,-0.3331631-0.2198272i},
    {-0.3883755+0.9414244i,-0.05982846+1.363185i,0.1627034-0.07566589i,-0.3075487+0.2184291i,1.101628+0.6338736i,0.863925+0.1456409i,0.2649806+1.441443i,-0.1033647+0.09835535i,1.004482+0.8776175i,-0.3110547+0.9641967i,-0.004071336+1.283588i,0.4228211+1.354355i,0.8076836+1.158726i,1.003879+0.7647714i,0.9182372+0.3167658i,0.08496577+1.379453i,0.5838208+1.394132i,-0.3484953+0.3124331i,-0.4506429+0.8394129i,0.8188301+0.06973326i,0.3486825+1.492714i,-0.2185568+0.1011157i,1.11029+0.7935088i,0.9854308+0.2677635i,0.5611131-0.0506467i,0.0397937-0.0298795i,-0.4458208+0.8159481i,0.8456643+0.1056883i,0.3562888-0.1075478i,0.8155163+1.342416i,1.135279+0.873948i,-0.4282496+1.090759i,0.6296388-0.1112165i,0.6213681+1.503803i,-0.4390014+0.2825148i,1.153292+0.4976396i,0.8080599+0.01032733i,0.2427304-0.1185587i,-0.2462811+0.1479821i,-0.4324822+0.6444021i,0.9076058+0.2665753i,0.5022184+0.02054804i,0.5872128+1.307911i,0.8940061+1.004777i,-0.3109996+0.7941548i,0.7538+0.2272038i,0.2683957+1.322953i,-0.0299205+0.1643486i,0.9264395+0.8831752i,0.910666+0.4598676i,0.629998+0.1437182i,0.2170266+0.07909251i},
    {0.7840416+0.6179599i,1.014937-0.369792i,-1.295461+0.9162418i,-0.3399541+1.235438i,-1.347609-1.175195i,-1.753693-0.2853259i,0.6970433-0.9696018i,-0.6753986+1.124113i,-1.005978-1.315198i,0.8080715+0.2884438i,0.7995729-0.5945374i,0.2277689-1.250478i,-0.6230729-1.375117i,-1.341829-0.9189453i,-1.583364-0.1113239i,0.4613126-0.9853311i,-0.288665-1.320051i,0.2805278+0.7387587i,0.6814755+0.06420794i,-1.312091+0.3424248i,-0.04395406-1.121967i,-0.03996615+0.7312707i,-1.194702-0.6008211i,-1.231153+0.01392591i,-0.88377+0.4720955i,-0.3621371+0.5898794i,0.2663588-0.0560472i,-0.930975+0.1298706i,-0.6112828+0.3633524i,-0.5301415-0.6858767i,-0.7832144-0.4655359i,0.06329578-0.1715503i,-0.716255+0.07314809i,-0.268667-0.5152209i,-0.3132772+0.1510389i,-0.5923206-0.393178i,-0.6656618-0.2739453i,-0.7010286-0.134616i,-0.6771533+0.03912919i,-0.539266+0.2171573i,-0.5083184-0.637639i,-0.828847-0.5092674i,0.2419093-0.1888276i,0.1314261-0.6397885i,-0.4790666+0.5919234i,-0.8561241-0.8497313i,0.4643504+0.04278105i,-1.206807+0.257915i,-0.04273539-1.067422i,-0.7323019-1.103363i,-1.286988-0.6616221i,-1.416836+0.05209009i},
    {1.367412+1.384793i,1.853929+0.4457925i,-0.8464503+0.9959589i,-0.03536766+1.566262i,-0.1531111-1.028695i,-0.79065-0.37191i,1.616363-0.05732904i,-0.3699409+1.188005i,0.3551643-0.9581892i,1.116032+1.097248i,1.466967+0.4403379i,1.339402-0.2676053i,0.8187377-0.7307974i,0.1430762-0.7745141i,-0.403261-0.40479i,1.366607+0.2380438i,1.159333-0.3588933i,0.119751+1.148239i,0.733682+1.110617i,-0.4380786-0.2680553i,1.332645+0.1151693i,-0.316328+0.8930856i,0.5256354-0.7471616i,-0.1077849-0.6482114i,-0.5601823-0.1707765i,-0.6245589+0.5029106i,0.4355428+1.316122i,-0.3675912-0.6121236i,-0.7518745+0.04411262i,1.390556-0.3694103i,0.7917616-0.8981198i,0.7849736+1.368691i,-0.6796057-0.4111685i,1.618513+0.02878221i,-0.456273+1.176657i,0.41069-1.059685i,-0.4267603-0.7884972i,-0.8960416-0.03521641i,-0.7682774+0.8479048i,-0.09963618+1.442119i,-0.0330863-1.020895i,-0.7310491-0.4668715i,1.67221+0.0445629i,1.260629-0.7328935i,0.305605+1.515296i,-0.3763986-0.8251026i,1.629323+0.5604349i,-0.8086351+0.7468532i,0.9819901-0.9423983i,0.1119093-1.078767i,-0.6672822-0.6325276i,-1.000711+0.2256538i},
    {0.8795471+0.7864943i,0.8252137+0.5518957i,0.4924296+1.035756i,0.7173842+0.9921262i,0.273501+0.6485137i,0.301972+0.8610373i,0.6588318+0.4669351i,0.6599092+0.9841719i,0.3221083+0.6097926i,0.8127429+0.6639411i,0.7047021+0.5161806i,0.52795+0.4745304i,0.3657024+0.5584582i,0.2968068+0.731558i,0.3620581+0.9124317i,0.5807797+0.4539711i,0.3788099+0.5094581i,0.8525704+0.7613446i,0.7952523+0.538738i,0.5329019+1.040341i,0.3479833+0.4914347i,0.8853633+0.7365147i,0.3327665+0.9703955i,0.5886622+1.063603i,0.8321345+0.9301503i,0.8914179+0.6546682i,0.4324407+0.4131093i,0.8840541+0.83675i,0.8495674+0.551133i,0.5105367+1.065181i,0.7828545+0.9821232i,0.2265012+0.7368728i,0.7686307+0.4750349i,0.6157764+1.049447i,0.2878161+0.5651732i,0.8565757+0.6375839i,0.6860716+0.4553759i,0.4463913+0.4602462i,0.2950952+0.6321897i,0.3158643+0.8488944i,0.6426684+0.4827536i,0.4493649+0.505357i,0.7866033+0.8119609i,0.7745298+0.6378997i,0.4656992+0.9378654i,0.492009+0.5145859i,0.7541587+0.8462149i,0.3339506+0.7724516i,0.7040284+0.5428022i,0.540726+0.4860476i,0.3735851+0.5563357i,0.2942928+0.729892i},
    {-0.5812176+0.7126133i,-0.1155121+0.8305012i,-0.6613594-0.3650454i,-0.863947+0.05656593i,0.4076433-0.2473709i,0.03610864-0.5362402i,0.09241508+0.7892335i,-0.8113812-0.2056014i,0.5405726-0.02505969i,-0.6216593+0.7260296i,-0.1215915+0.8825215i,0.3646341+0.6650523i,0.5844705+0.1739124i,0.4185546-0.3397624i,-0.0472101-0.6081066i,0.2168889+0.759087i,0.5198689+0.3348002i,-0.8108575+0.4337153i,-0.4416037+0.7586211i,-0.3810663-0.4901229i,0.366127+0.4493299i,-0.7612926+0.2421138i,0.177121-0.3096306i,-0.1929187-0.3985327i,-0.5068778-0.2357716i,-0.6290508+0.06567053i,-0.3159343+0.4909866i,-0.2667281-0.2074158i,-0.42196-0.07425144i,0.1232018+0.1662957i,0.08661912+0.008635187i,-0.3348522+0.3752189i,-0.1687693-0.1745301i,0.005287413+0.4111074i,-0.5144309-0.0005546145i,0.2091307+0.01966845i,0.07322168-0.2256535i,-0.2171104-0.3338471i,-0.5300976-0.2138065i,-0.6921115+0.1026045i,0.2469351-0.1961145i,-0.07055528-0.4018794i,0.09736784+0.6070105i,0.3393309+0.3163398i,-0.6828378+0.3189397i,0.09658449-0.3294828i,-0.09871446+0.6565061i,-0.5572512-0.232227i,0.3538947+0.1854941i,0.2842817-0.1542336i,0.01684446-0.3909932i,-0.3560377-0.4173078i},
    {-1.357296-0.3603225i,-1.3754+0.5246103i,0.4950376-0.8572085i,-0.3039183-1.000369i,0.6366372+0.9441123i,0.9061266+0.2641788i,-1.046301+0.7264649i,0.1666005-0.7959324i,0.1447364+1.105769i,-0.9862388-0.3867641i,-1.146152+0.2312277i,-0.8927441+0.8206204i,-0.3238308+1.128062i,0.3158665+1.00956i,0.7361487+0.5126812i,-1.08294+0.455979i,-0.6861107+0.9511577i,-0.2564499-0.7577383i,-0.7906331-0.4907934i,0.6999202+0.2952227i,-0.9279318+0.5705425i,0.1921235-0.6102248i,-0.003602269+0.9978074i,0.4677271+0.7458979i,0.7133769+0.2546113i,0.6198224-0.3117568i,-0.4562383-0.7998951i,0.6924816+0.7591733i,0.921302+0.07953011i,-0.991807+0.9463149i,-0.3083535+1.331477i,-0.8309528-0.8604978i,1.029774+0.5343709i,-1.362927+0.6586764i,0.4435683-1.01986i,0.1313238+1.497394i,0.9544497+1.01053i,1.27583+0.0766146i,0.8993203-0.8708026i,-0.03354177-1.353915i,0.7429442+1.4185i,1.370394+0.5104522i,-1.570633+0.9265522i,-0.7156712+1.671579i,-0.7599932-1.331513i,1.252897+0.8859658i,-1.697957+0.5505191i,0.7134889-1.114489i,-0.007896991+1.673261i,0.9092851+1.184289i,1.280722+0.2478649i,0.9761488-0.6806796i},
    {0.9101084+1.32462i,1.376935+1.077322i,-0.004794985+0.5112551i,0.1503242+1.036767i,0.9648877-0.2488441i,0.4003098-0.1739545i,1.561311+0.8356119i,0.02663681+0.8361539i,1.171735-0.1644363i,0.9702518+1.318352i,1.415043+0.9999831i,1.534711+0.4857992i,1.298623+0.03813293i,0.8501012-0.1409078i,0.4132168+0.002422435i,1.404446+0.7230979i,1.356385+0.3080527i,0.5109445+1.068514i,0.8928394+1.110206i,0.376991+0.1814315i,1.326157+0.5786529i,0.3639992+0.8417627i,0.9469478+0.06846303i,0.631054+0.08375643i,0.3936282+0.2760254i,0.3136035+0.5637199i,0.6589351+1.022127i,0.6061485+0.07143856i,0.3333865+0.2717572i,1.348319+0.4739839i,1.193106+0.117021i,0.7618328+1.160185i,0.401491+0.04943423i,1.425089+0.6673022i,0.2344376+0.878914i,0.9882229-0.06359081i,0.543668-0.02786512i,0.2503247+0.2822482i,0.2346952+0.6819848i,0.4589056+0.9734193i,0.801446+0.03736407i,0.5172149+0.1428077i,1.239241+0.7273797i,1.275952+0.4461634i,0.4281233+0.9285834i,0.8668257-0.02095977i,1.109627+1.091765i,0.143161+0.3081127i,1.495498+0.2860595i,1.170612-0.1634683i,0.5836754-0.2792915i,0.04852424+0.05885338i},
    {0.185103-0.2504344i,0.2492758-0.1942625i,0.3098304-0.5057738i,0.2042562-0.4812357i,0.5269828-0.2906919i,0.5283086-0.443535i,0.234538-0.1001396i,0.2194167-0.5870067i,0.5855565-0.2218671i,0.04485492-0.2305938i,0.1976368-0.05812415i,0.4337291-0.04779731i,0.606693-0.2129778i,0.6063728-0.452193i,0.4340819-0.6145843i,0.4439783-0.07301616i,0.5866246-0.2478088i,0.09159471-0.2100934i,0.2654733-0.09534863i,0.1898036-0.5250334i,0.5355797-0.3185001i,0.1882558-0.1948525i,0.2937846-0.5138987i,0.1725418-0.4087068i,0.1868853-0.2538448i,0.3209221-0.1779422i,0.4870017-0.4074518i,0.2822959-0.1441978i,0.4652839-0.1714983i,0.08325101-0.3289241i,0.1604395-0.131252i,0.2728058-0.6144774i,0.578213-0.17749i,0.01816783-0.2547739i,0.4809703-0.6240157i,0.4203464-0.01400315i,0.6248972-0.17335i,0.6571298-0.4305597i,0.5022082-0.6365672i,0.2501908-0.6802127i,0.6104062-0.129905i,0.6789808-0.3747411i,0.07855135-0.06708557i,0.319273+0.03593498i,0.07063872-0.6248973i,0.7162519-0.2909424i,-0.00756647-0.0964193i,0.403184-0.7502365i,0.5560437+0.02763334i,0.7515413-0.2340594i,0.7051666-0.5645967i,0.4353279-0.7669442i},
    {-0.5938502-0.2624351i,-0.4929019+0.06971438i,-0.1919223-0.4900552i,-0.4417698-0.3297144i,0.07153763-0.2549629i,-0.1362667-0.418813i,-0.002378295+0.0380685i,-0.4655303-0.1038989i,-0.06538814-0.4150304i,-0.05832544+0.1223608i,0.1212662-0.0757536i,0.08576062-0.3461801i,-0.1435256-0.5013431i,-0.4153022-0.4377387i,-0.5578862-0.1975821i,0.1041921-0.378368i,-0.128646-0.5226935i,0.00812705+0.1644307i,0.1694573-0.04576641i,-0.5413473+1.913395e-05i,-0.01927272-0.5004018i,-0.1047129+0.2354152i,-0.5190786-0.4100338i,-0.6298949-0.1449523i,-0.5448146+0.1503428i,-0.2706264+0.3382169i,0.3563963+0.01221933i,-0.7477162+0.1074787i,-0.4406342+0.4506595i,-0.4357307-0.8004557i,-0.8443679-0.4731237i,0.5292203-0.380337i,-0.5691262+0.5316654i,-0.401369-0.9270232i,0.5055533+0.2646078i,-0.9907664+0.0313787i,-0.6387513+0.531962i,-0.04233532+0.6421663i,0.4527735+0.311545i,0.5768494-0.2541155i,-0.673254+0.4253602i,-0.1583701+0.5723476i,-0.6843207-0.6523563i,-0.8665783-0.2009596i,0.330843-0.5463381i,-0.3313677+0.4692605i,-0.4854754-0.7090215i,0.3871953+0.07789695i,-0.7848595+0.0499671i,-0.5071433+0.3955593i,-0.05847624+0.4743112i,0.3388311+0.2238496i},
    {0.0007386065+0.2085324i,0.2473905+0.460947i,0.3643423-0.4802453i,0.0725368-0.2844313i,0.9804553-0.04121576i,0.818033-0.3659874i,0.4864151+0.5152023i,0.1283908-0.352872i,0.9790114+0.02723052i,0.1148512+0.338601i,0.4501308+0.4881101i,0.7848917+0.3600725i,0.9262844+0.04316807i,0.8070443-0.2684587i,0.5158495-0.3993219i,0.728889+0.311051i,0.851959+0.04706769i,0.2001514+0.2351221i,0.4429907+0.3546906i,0.2648179-0.2528435i,0.8123453+0.03662828i,0.2321979+0.2313561i,0.4837162-0.3256178i,0.228582-0.2213825i,0.1310838+0.04730445i,0.2738166+0.3095805i,0.8445892+0.178093i,0.09349847+0.1896241i,0.3606003+0.4462592i,0.2086778-0.3891682i,-0.02878061-0.05026664i,0.8824812-0.3539792i,0.4827724+0.5818017i,0.03136409-0.3922754i,1.10606-0.05151378i,0.08063535+0.5287341i,0.585532+0.6795493i,1.053617+0.4102435i,1.186938-0.1250015i,0.8916707-0.6032348i,0.6247011+0.7503935i,1.117926+0.4426657i,-0.2948785+0.1508866i,0.01666799+0.6649225i,0.3501478-0.7978444i,1.147115+0.504318i,-0.3557835+0.1233388i,1.002643-0.6645176i,0.5790156+0.8629236i,1.151104+0.5497878i,1.335178-0.07660747i,1.02408-0.6465607i},
    {1.018639+0.1898529i,1.14861-0.3841495i,-0.2278344+0.5017618i,0.3839397+0.7008304i,-0.3656236-0.8507304i,-0.6239065-0.2428839i,1.024869-0.7995722i,0.1529418+0.6919834i,-0.1526668-0.9866666i,1.143796+0.08289047i,1.128133-0.5101575i,0.7531191-0.9527617i,0.1911646-1.067118i,-0.3233585-0.8106794i,-0.5739607-0.2825132i,1.052269-0.7258163i,0.5580966-1.106273i,0.7053428+0.6570639i,1.197945+0.1980397i,-0.6525602+0.0718457i,0.8485068-1.073297i,0.4796683+0.8016013i,-0.4987433-0.8518686i,-0.7149138-0.1477499i,-0.3999119+0.5113708i,0.2664194+0.7784201i,1.224552-0.07012887i,-0.4381236+0.2682314i,0.07471502+0.5965359i,-0.02201974-0.9299782i,-0.3598777-0.5249913i,0.9697926-0.3799711i,-0.07257517+0.2898707i,0.3064443-0.7896829i,0.6221272+0.2205446i,-0.164232-0.3785328i,-0.1607745-0.09677213i,-0.02387742+0.138289i,0.2191512+0.2803834i,0.5274872+0.2741137i,-0.1947097-0.4948396i,-0.3124028-0.1198383i,0.765052-0.7119109i,0.334745-0.937158i,0.7912056+0.3862868i,-0.4840138-0.3417087i,1.002671-0.6575056i,0.09036463+0.5974203i,-0.07503498-0.9554231i,-0.4631389-0.502i,-0.438141+0.07668387i,-0.0478458+0.4666151i},
    {-0.3352298+0.1411905i,-0.621206+0.1757292i,0.05296391+0.6598874i,0.04717604+0.3245227i,-0.5785741+1.002698i,-0.2112812+1.027129i,-0.8594952+0.28077i,0.1447195+0.4082907i,-0.7061998+0.991561i,-0.4517228-0.02546859i,-0.8124756+0.1510247i,-0.9699516+0.5269251i,-0.8385958+0.9210234i,-0.4711039+1.135449i,-0.04214454+1.049362i,-1.001838+0.3834793i,-0.9536158+0.8453345i,-0.1818234-0.08684877i,-0.6683673-0.06390618i,0.2311112+0.7748096i,-0.994572+0.79185i,-0.1364039-0.06158835i,-0.1555145+1.120493i,0.1647111+0.7792211i,0.1462577+0.3332343i,-0.1649675+0.05298567i,-0.777448+0.3409885i,-0.02232429+0.4243312i,-0.2223906+0.2546707i,-0.3369621+0.8000535i,-0.2231661+0.6736019i,-0.5518215+0.5220317i,-0.2740569+0.4847441i,-0.4609296+0.6055536i,-0.3359971+0.446616i,-0.4025846+0.656928i,-0.3273444+0.6720897i,-0.2354809+0.6262991i,-0.1856182+0.5112001i,-0.2289369+0.3726253i,-0.4080686+0.7835813i,-0.2328322+0.7549945i,-0.6648353+0.4629248i,-0.6606997+0.6670512i,-0.2598747+0.2438762i,-0.2893594+0.8524233i,-0.6796797+0.3552614i,-0.0406828+0.4765059i,-0.6118751+0.8134591i,-0.3713173+0.8937219i,-0.1404102+0.7914119i,-0.0401436+0.5650467i},
    {-0.3629783+0.2999304i,-0.3257485+0.2474132i,-0.5094089+0.1808594i,-0.5067626+0.2255802i,-0.3405668+0.1022718i,-0.4011939+0.05572463i,-0.3265413+0.3227491i,-0.5882828+0.1405971i,-0.2321513+0.09851018i,-0.4869683+0.3983513i,-0.3147293+0.402639i,-0.185795+0.2744482i,-0.1900952+0.08765332i,-0.3290155-0.03782256i,-0.5113063-0.02342894i,-0.2059881+0.2684512i,-0.2266067+0.1089668i,-0.4846802+0.3571706i,-0.3625198+0.3383652i,-0.524726+0.1225436i,-0.3090205+0.1816193i,-0.482694+0.2370384i,-0.3717878+0.1293923i,-0.3940213+0.1136403i,-0.4348896+0.09641898i,-0.500301+0.109207i,-0.5467659+0.2875488i,-0.3752272+0.008443716i,-0.5177487+0.01567594i,-0.2038461+0.2501133i,-0.2095848+0.08484014i,-0.4920309+0.4144924i,-0.5121325-0.03213831i,-0.1865867+0.2857723i,-0.6448309+0.2750597i,-0.3019924-0.02801551i,-0.478073-0.04246395i,-0.6135225+0.06451107i,-0.6397161+0.2297861i,-0.5511894+0.3642844i,-0.4242371-0.02298147i,-0.5543376+0.04265779i,-0.2200617+0.2108712i,-0.2587524+0.08853495i,-0.4680911+0.3579691i,-0.4706508+0.03032041i,-0.274743+0.2807132i,-0.5775146+0.2004571i,-0.2864421+0.08191034i,-0.3772639+0.02179014i,-0.4929456+0.02880094i,-0.5855214+0.1123129i},
    {0.443528+0.2520979i,0.1536609+0.04771363i,0.2795947+0.8380502i,0.446604+0.5602411i,-0.2678263+0.688767i,-0.02556651+0.8243268i,-0.1181476+0.1983075i,0.3374629+0.5685i,-0.2090741+0.5887965i,0.1738847+0.2423669i,0.0007750078+0.2220944i,-0.1506209+0.3072431i,-0.2232049+0.4737344i,-0.1707307+0.6621365i,0.00722537+0.7784137i,-0.1348897+0.2186284i,-0.2782921+0.418841i,0.3329801+0.282474i,0.1093415+0.1310428i,0.2598074+0.7669692i,-0.3042787+0.4301272i,0.3270132+0.2592413i,0.01596572+0.8246173i,0.2697727+0.7365525i,0.3783287+0.4993082i,0.2863195+0.2641582i,-0.1584904+0.2589038i,0.3465705+0.4833259i,0.2575589+0.2705239i,0.05612784+0.7729877i,0.2706147+0.6773703i,-0.2519507+0.5070755i,0.2352341+0.2298079i,0.1142121+0.7922141i,-0.2386196+0.3155961i,0.3723245+0.3635443i,0.1767461+0.1477511i,-0.1244098+0.1568728i,-0.3177325+0.3991575i,-0.256705+0.7098677i,0.07584637+0.090652i,-0.2263399+0.2016658i,0.4381272+0.4565999i,0.2902678+0.1798761i,0.1043168+0.8490866i,-0.2466828+0.2709444i,0.3901206+0.4150738i,-0.1392429+0.7492998i,0.003782745+0.1683045i,-0.1813734+0.2870845i,-0.2415523+0.4838689i,-0.1688645+0.6678978i},
    {0.02528567+1.703492i,0.6909701+1.34142i,-1.223812+0.4762998i,-1.02896+1.175973i,0.2034636-0.4641532i,-0.5104828-0.4382908i,0.8076592+1.10998i,-1.188272+0.7299517i,0.6030385-0.2288081i,-0.1837949+1.643367i,0.507243+1.437851i,0.9097484+0.8435587i,0.8459629+0.1346202i,0.3553772-0.3697506i,-0.3336979-0.4543741i,0.6719944+1.232537i,0.9081303+0.5970961i,-0.9516103+1.181488i,-0.3977086+1.566078i,-0.5270433-0.3952721i,0.8027241+1.080508i,-1.183796+0.7453188i,0.6069875-0.2482881i,-0.06689077-0.5462894i,-0.7947443-0.3482627i,-1.241917+0.2795755i,-0.6353988+1.641625i,-0.4156939-0.6007028i,-1.104912-0.1542487i,1.10752+0.4967679i,0.7885125-0.282225i,-0.2816514+1.818473i,-0.8106843-0.5055379i,1.106954+0.9524125i,-1.322957+1.071837i,0.4712867-0.6017272i,-0.4304104-0.715037i,-1.192425-0.209724i,-1.439047+0.6720501i,-1.050182+1.496922i,-0.02124633-0.7275181i,-0.8726575-0.4715197i,1.098784+0.8756861i,0.9917051+0.03287596i,-0.6339418+1.668245i,-0.4159798-0.5877678i,0.8169217+1.274517i,-1.288561+0.6027086i,0.7646719-0.1842391i,0.1019454-0.5786646i,-0.6716636-0.4766256i,-1.222314+0.09687729i},
    {-0.9521632+0.7736267i,-0.1908837+0.6511545i,-1.869594-0.6906931i,-1.861757+0.1232559i,-0.2390748-1.385738i,-1.075566-1.481045i,0.2199152+0.3475119i,-1.952594-0.1682407i,-8.720358e-05-1.204154i,-0.7742574+0.8271762i,-0.04092504+0.5243673i,0.2994459-0.1605742i,0.1193472-0.8711448i,-0.4490218-1.279883i,-1.115955-1.236961i,0.04196718+0.1610694i,0.1424409-0.4480563i,-1.4022+0.3328596i,-0.8600095+0.5723633i,-1.25917-1.073281i,0.07583243-0.0393759i,-1.612518-0.006812313i,-0.3225537-1.098526i,-0.9198318-1.206662i,-1.447539-0.9057834i,-1.655641-0.3391446i,-0.947503+0.5101841i,-1.155261-1.057176i,-1.510691-0.6443795i,-0.01836758-0.5225785i,-0.3155591-0.9272884i,-0.7668886+0.4181247i,-1.217411-0.8969412i,-0.07967029-0.1315339i,-1.441691-0.05862005i,-0.3939267-0.939164i,-0.8444475-1.054711i,-1.286414-0.8728679i,-1.536585-0.4465516i,-1.471216+0.06246475i,-0.4558615-1.080511i,-1.008113-1.137523i,-0.05469594+0.1785921i,0.1266795-0.3922946i,-1.440898+0.3238112i,-0.6708689-1.270528i,-0.2289616+0.4897945i,-1.732683-0.5971386i,0.1528006-0.7399016i,-0.3324592-1.253025i,-1.043891-1.326424i,-1.635336-0.9149671i},
    {-1.803934-0.4805442i,-1.485867+0.5590321i,0.2342602-1.856124i,-0.7999837-1.754676i,1.155375+0.3272695i,1.259335-0.6685195i,-1.087128+0.7815439i,-0.2014887-1.779386i,0.7111886+0.7189263i,-1.527158-0.6201934i,-1.371865+0.2671052i,-0.7135372+0.8472323i,0.1404766+0.8923191i,0.8249374+0.4128074i,1.067974-0.3709844i,-1.153514+0.4223354i,-0.4694019+0.8507282i,-0.7028607-1.479852i,-1.291276-0.9185323i,1.038268-0.6016697i,-0.9870982+0.6028153i,-0.1541101-1.603457i,0.569459+0.6370804i,1.015295-0.0478376i,0.9399411-0.8503109i,0.3965077-1.427335i,-1.061835-1.202629i,1.044748-0.1995822i,0.9208258-0.9839506i,-0.7035389+0.8598258i,0.1631486+0.9863865i,-1.348339-1.236687i,1.359231-0.4056796i,-1.401839+0.7277613i,0.05627688-2.049656i,0.7828578+1.149715i,1.596932+0.1601436i,1.539991-1.168483i,0.5822131-2.141907i,-0.8033756-2.222527i,1.525313+0.6394596i,1.75249-0.7357153i,-1.384209+1.194473i,-0.0812259+1.581216i,-1.501953-1.741597i,1.693154-0.1484395i,-1.736979+0.6800312i,0.3443721-2.126639i,0.5355664+1.337995i,1.446628+0.4887677i,1.611482-0.7480372i,0.9455962-1.812163i},
    {0.02204381+1.0809i,0.548151+0.6146353i,-1.548316+0.1863184i,-1.255696+0.8548549i,-0.2451562-1.11826i,-1.017897-1.007087i,0.7323094+0.5301584i,-1.65394+0.4063371i,0.3399556-1.017129i,-0.3470396+1.398235i,0.5003894+1.082421i,0.9793144+0.2851587i,0.8524516-0.6660125i,0.1335464-1.352816i,-0.8973745-1.438368i,0.9426834+0.9326847i,1.248946-0.1536717i,-1.605618+1.33408i,-0.4919403+1.853281i,-1.577557-1.395538i,1.443999+0.3958343i,-2.081199+1.041729i,0.18002-1.805825i,-1.200882-1.751132i,-2.196853-0.7900704i,-2.303248+0.5821701i,-0.1771535+1.945359i,-1.813782-1.206052i,-2.265308-0.007987414i,1.004009-1.064816i,-0.04873415-1.689335i,0.3907595+1.609426i,-2.018884-0.6190383i,1.218379-0.4397469i,-1.36246+1.463916i,-0.5953189-1.616418i,-1.608752-1.109755i,-2.059527-0.08305116i,-1.753373+0.9811884i,-0.851541+1.595235i,-1.06049-1.38916i,-1.809238-0.6484554i,1.076583-0.2733526i,0.5264925-1.130165i,-0.4169136+1.557978i,-1.366919-1.109778i,1.043772+0.3630461i,-1.758134+0.7404409i,0.177535-1.331998i,-0.8464325-1.402887i,-1.685995-0.7938462i,-1.93412+0.2208203i},
    {-0.1573622+1.522322i,0.6136518+1.595559i,-0.6445042-0.2375987i,-0.8835592+0.5264755i,1.204699-0.3549622i,0.4815009-0.7432674i,0.9546622+1.501029i,-0.8440886+0.07126353i,1.450548+0.02599421i,-0.2830535+1.51601i,0.5194517+1.645481i,1.212327+1.241645i,1.491114+0.5026019i,1.24959-0.2369765i,0.6092731-0.660978i,0.7761013+1.524072i,1.336532+1.01153i,-0.8397932+0.6645317i,-0.4763454+1.346916i,0.3819863-0.7429075i,1.027709+1.465375i,-0.9000334+0.1242961i,1.492041-0.05622609i,0.904647-0.7124012i,0.01130658-0.8429163i,-0.7720175-0.3574015i,-0.700184+1.407324i,0.4822638-0.9191271i,-0.4439696-0.7066737i,1.640883+0.8749081i,1.595805-0.06493143i,-0.3408967+1.68012i,0.04899354-0.8930275i,1.37432+1.346549i,-1.073384+0.4442478i,1.4084-0.4051672i,0.617215-0.9167467i,-0.3346699-0.8137476i,-1.018889-0.1172427i,-1.102835+0.8766844i,1.142125-0.7857018i,0.1356775-1.045387i,1.439221+1.502949i,1.855912+0.5173957i,-0.8933765+1.430533i,0.5910007-1.056525i,1.091512+1.782155i,-1.121394-0.02212202i,1.692865-0.09779496i,0.9829856-0.8327957i,-0.006557556-0.9234786i,-0.7922933-0.3685589i},
    {-0.2690332+1.363811i,0.4016393+0.7747987i,-2.082561+0.4971572i,-1.582432+1.298224i,-0.8895918-1.222712i,-1.800912-0.8227183i,0.6868344+0.2652568i,-1.941061+1.092756i,-0.4932316-1.287033i,-0.008278735+1.476424i,0.6579607+0.6497867i,0.6075875-0.4088463i,-0.1269198-1.163812i,-1.166825-1.244701i,-1.992683-0.6288976i,0.6641549+0.0002940273i,0.18673-0.8803615i,-0.8085446+1.596768i,0.1113769+1.26759i,-2.136515-0.06346116i,0.4088951-0.5146295i,-1.206012+1.467553i,-1.282549-1.05639i,-1.952459-0.4051134i,-2.020242+0.5128694i,-1.470352+1.227064i,0.1078654+0.9424341i,-1.876598+0.1915274i,-1.548392+0.8692882i,-0.6414886-0.7711149i,-1.242547-0.5657036i,-0.01319582+0.4400525i,-1.455881+0.4186768i,-0.4037505-0.3536327i,-0.7729048+0.7716674i,-1.068586-0.277558i,-1.246439-0.04484653i,-1.296481+0.2365257i,-1.201716+0.5221596i,-0.9489515+0.7369241i,-0.9646565-0.4126447i,-1.319867-0.205396i,-0.05773551+0.1508984i,-0.1998934-0.3151827i,-0.9130167+0.9675122i,-1.17779-0.54693i,0.03314858+0.5007792i,-1.626092+0.4568939i,-0.2738196-0.5963808i,-0.88633-0.7621788i,-1.479964-0.4912148i,-1.771426+0.1121654i},
    {0.7247111+0.1110184i,0.4076196+0.05271508i,0.800522+0.9130445i,0.9591067+0.640137i,-0.005169441+0.7849174i,0.2284727+1.044945i,0.3252274-0.01150943i,0.9493005+0.9102594i,-0.1713481+0.5920563i,0.9295194+0.0844247i,0.508693-0.1282516i,0.04050497-0.001616131i,-0.227566+0.4126882i,-0.1504502+0.9041244i,0.2337357+1.220886i,0.194163-0.107577i,-0.1682945+0.2271873i,1.148262+0.383208i,0.8747271-0.02253049i,0.5204809+1.251019i,-0.03996338+0.05562699i,1.162596+0.5935054i,-0.09262779+0.9733099i,0.3256396+1.226413i,0.8006997+1.137764i,1.089027+0.7625403i,0.7389622+0.001562022i,0.5979272+1.115943i,0.9024484+0.8792776i,-0.05653328+0.5665354i,0.08508691+0.8627371i,0.5693116+0.0932651i,0.6403143+0.9672497i,0.07431337+0.3193316i,0.9141825+0.5013966i,0.1245431+0.8689052i,0.3947265+1.021865i,0.716004+0.9673305i,0.933412+0.7078295i,0.9252519+0.3618471i,0.2359871+0.9891446i,0.5751079+1.017731i,0.08798178+0.2764133i,0.02465578+0.5752887i,0.7683629+0.2753105i,0.3853336+0.9266189i,0.3152129+0.2135256i,0.7637954+0.7421236i,0.09694359+0.5544624i,0.1465709+0.7713532i,0.3271227+0.9442418i,0.6099629+0.9797378i},
    {0.2883762+0.1240514i,0.2809052-0.131681i,-0.1354911+0.3168752i,0.1207026+0.3020154i,-0.3297784-0.09712503i,-0.3043447+0.1528306i,0.06644209-0.292379i,0.1261503+0.2679005i,-0.3021528-0.06857479i,0.2169401-0.1361082i,0.04291245-0.2507459i,-0.1490743-0.2105327i,-0.2508196-0.05764319i,-0.2209528+0.1112941i,-0.09315154+0.2087046i,-0.1019781-0.1861805i,-0.2055311-0.08277333i,0.174268-0.05003629i,0.08936409-0.1697872i,0.01567068+0.2173803i,-0.2024817-0.1294036i,0.2145946-0.02484209i,-0.1763532+0.2055262i,0.01561756+0.271041i,0.2090243+0.1708583i,0.2721194-0.05309555i,-0.1137146-0.3114906i,0.2874427+0.1568261i,0.3099591-0.1271503i,-0.1498749+0.3518696i,0.1538839+0.3422866i,-0.3979394-0.09303733i,0.3109617-0.2098391i,-0.08923019+0.4021896i,-0.269642-0.3166572i,0.3855018+0.04447594i,0.2864897-0.2649717i,-0.005574167-0.4038101i,-0.3047583-0.2882464i,-0.4267676+0.004443546i,0.2593666-0.2803945i,-0.02786224-0.3906574i,0.2595161+0.2770285i,0.3632227-0.0006857762i,-0.2867448+0.2764135i,-0.02256438-0.3668985i,0.2343863+0.266973i,-0.3811544-0.003513297i,0.2384894-0.23298i,0.0005515595-0.3405542i,-0.2407707-0.2557903i,-0.3552015-0.03259223i},
    {-0.9007156+0.3969627i,-0.7259062+1.234232i,0.9263283-0.57806i,0.09747446-0.6390887i,1.434588+1.391317i,1.716008+0.589756i,-0.6031247+1.438419i,0.6814541-0.7023839i,1.046609+1.791572i,-0.8354496+0.09188807i,-0.8707871+1.013029i,-0.3027276+1.734332i,0.5852966+1.913652i,1.362446+1.48796i,1.678604+0.6878494i,-0.5964082+1.311524i,0.06905908+1.758259i,-0.01153268-0.4978015i,-0.5802831-0.001509628i,1.567788+0.4819804i,-0.4308169+1.401419i,0.6045997-0.5577483i,0.9860534+1.657173i,1.538543+1.092603i,1.628189+0.2823066i,1.179827-0.4293214i,-0.4728555-0.4034892i,1.766155+0.8289989i,1.627497-0.08725948i,-0.09742079+1.928945i,0.8635255+1.980682i,-0.8272079-0.1957369i,1.915196+0.4315742i,-0.6583436+1.714301i,0.5376822-0.9739763i,1.35367+1.925716i,2.021564+1.022735i,1.945844-0.1294923i,1.119377-0.9774275i,-0.08579823-1.083241i,1.914132+1.56964i,2.198625+0.3561334i,-0.7822737+1.962751i,0.3930112+2.420524i,-0.7510802-0.790641i,2.205308+0.9045023i,-1.137268+1.533657i,0.9929593-1.104636i,1.078629+2.272678i,1.994585+1.44276i,2.153915+0.2220144i,1.485788-0.8061748i},
    {-1.669383-0.1156185i,-1.856094+0.4925826i,-0.1175044-0.1451289i,-0.6522021-0.4980769i,-0.4488835+1.397692i,0.06571192+0.9406649i,-1.947048+0.7144479i,-0.1906015-0.4310305i,-0.8193212+1.645081i,-1.716824-0.4042167i,-2.11628+0.3592847i,-1.900318+1.217973i,-1.151643+1.721212i,-0.2498127+1.591166i,0.3322196+0.8883635i,-2.05216+0.9598988i,-1.425557+1.596438i,-1.206014-0.7080653i,-1.873871-0.1845136i,0.2638472+0.3220589i,-1.624362+1.297634i,-0.8453132-0.5971201i,-0.2497113+1.280215i,0.07849913+0.6883214i,-0.03354546+0.05664145i,-0.4898166-0.3469262i,-1.534715-0.0746222i,-0.04387449+0.5057536i,-0.2018783-0.004319038i,-1.127297+1.260127i,-0.5908787+1.25043i,-1.594955+0.03241799i,-0.03671567+0.3685428i,-1.47872+1.087788i,-0.8044457-0.3929811i,-0.3863596+1.190704i,-0.04115722+0.7116908i,-0.08480757+0.1244299i,-0.4907289-0.2927473i,-1.057911-0.3530774i,-0.2373429+0.9921149i,-0.06955325+0.4817655i,-1.515518+0.9508041i,-1.093163+1.229728i,-1.164769-0.2630128i,-0.2028268+0.8937947i,-1.695582+0.5436638i,-0.2537568-0.1033972i,-1.023556+1.348083i,-0.4206249+1.281917i,0.03176714+0.8201057i,0.08198326+0.1363498i},
    {-0.4855757+0.3340717i,-0.1752462+0.829186i,0.4260505-0.7296823i,-0.1262365-0.552423i,1.242594+0.3675876i,1.184817-0.2132103i,0.0234385+0.9223319i,0.1990766-0.6689669i,1.053101+0.6461567i,-0.3989117+0.1764056i,-0.1881631+0.6472514i,0.2446018+0.8733325i,0.6990808+0.7966822i,1.006342+0.4849789i,1.079554+0.0685749i,-0.1149762+0.615546i,0.2485123+0.844301i,0.09515188-0.5239719i,-0.282511-0.2243028i,1.205704+0.0229238i,-0.1857399+0.7857695i,0.4517874-0.7538694i,0.9543954+0.9157354i,1.35179+0.3914186i,1.314928-0.2925423i,0.8281094-0.8076609i,-0.5203831-0.4699063i,1.52584+0.02981485i,1.200069-0.6901847i,0.3277862+1.337591i,1.131327+1.119431i,-0.8152428-0.1118246i,1.505116-0.4547964i,-0.04804838+1.349989i,-0.060179-1.057455i,1.541083+0.7606462i,1.658005-0.1423719i,1.150144-0.8907968i,0.2866085-1.113623i,-0.4943097-0.7222888i,1.617291+0.2377344i,1.369045-0.5506455i,0.09947926+1.28724i,0.8774056+1.203267i,-0.6282174-0.3616592i,1.513859-0.09434973i,-0.3198974+1.046531i,0.3859845-1.008994i,1.154714+1.048534i,1.571629+0.3546898i,1.437371-0.4627381i,0.7887236-1.003139i},
    {-0.8584888+0.5646828i,-1.032553+1.043683i,0.3013698+0.7433582i,-0.06508572+0.4966834i,-0.1054199+1.716044i,0.1893384+1.466517i,-0.8557656+1.122451i,0.1449445+0.8002353i,-0.4591514+1.611654i,-0.4288721+0.6281403i,-0.6784036+0.7909467i,-0.8041204+1.063093i,-0.7628639+1.372701i,-0.5426153+1.62525i,-0.1873682+1.712703i,-0.7651154+0.6804069i,-0.9781767+1.064373i,0.3117343+0.7044421i,-0.0789085+0.3781039i,0.03381338+1.853694i,-1.037471+0.7521794i,0.5366738+0.9146921i,-0.806161+1.818057i,-0.2423643+1.998i,0.3096981+1.777127i,0.6017098+1.256217i,0.05751501+0.243895i,-0.01122689+2.04881i,0.5404355+1.690596i,-1.342222+1.202947i,-1.083052+1.888312i,-0.1764617-0.03246153i,0.4003516+2.109647i,-1.510725+0.8129706i,0.8640497+0.5221928i,-0.7716863+2.3646i,0.1897317+2.392856i,0.932214+1.755497i,1.053298+0.7761849i,0.4851791-0.03103325i,-0.1117638+2.486812i,0.7372997+2.020096i,-1.643736+1.114133i,-1.305496+1.988742i,-0.090077-0.1874585i,0.3968618+2.231859i,-1.528043+0.7198858i,0.902834+0.6218864i,-0.8737236+2.268786i,0.01724499+2.367342i,0.75695+1.857525i,0.9777657+0.9859079i},
    {-0.8012776+1.09347i,-0.3464241+1.437431i,-0.4580248-0.2100793i,-0.9170621+0.183897i,0.8078144+0.4099475i,0.4864893-0.1546548i,-0.07250923+1.598357i,-0.8011306-0.1452709i,0.9290736+0.7227627i,-0.9846017+1.211413i,-0.368396+1.652128i,0.3943801+1.56604i,0.9035892+0.9875217i,0.8908936+0.2216929i,0.3752111-0.3267467i,0.1351314+1.596246i,0.6941321+1.171987i,-1.045178+0.6906608i,-0.741734+1.236152i,-0.01761411-0.2371515i,0.3144461+1.291132i,-0.8307342+0.3240533i,0.6207157+0.4094926i,0.3641695+0.0197714i,-0.07320365-0.1598172i,-0.555043-0.04977196i,-0.92023+0.9158671i,0.3352254-0.1873676i,-0.2932968-0.3217808i,0.661909+1.200961i,0.8830975+0.5392903i,-0.8126675+1.321744i,-0.0626957-0.396124i,0.5149181+1.373683i,-1.063966+0.4478025i,0.6865783+0.1109299i,0.1600801-0.2534657i,-0.4414048-0.1875423i,-0.8333132+0.2232529i,-0.8755444+0.7527473i,0.3823028+0.04194712i,-0.06259444-0.116104i,0.2795572+1.196242i,0.5510942+0.8417109i,-0.780665+0.8161139i,0.2999328+0.02212227i,-0.0724828+1.32929i,-0.5974498+0.05020338i,0.6327769+0.734079i,0.5584772+0.2310482i,0.1739745-0.1164865i,-0.3507027-0.139096i},
    {1.297809+0.3569392i,1.468814+0.008238931i,0.4719631+0.1534227i,0.7383605+0.3689127i,0.7888895-0.5658883i,0.5248852-0.365124i,1.412945-0.1527011i,0.6054917+0.2671517i,0.9259313-0.5802622i,1.261225+0.2508411i,1.396826-0.07710922i,1.260412-0.3980754i,0.9457151-0.5166329i,0.6614899-0.3750957i,0.5826334-0.09297025i,1.133308-0.3181545i,0.9044803-0.3456491i,1.094776+0.01736208i,1.070348-0.142139i,0.9097643+0.003664994i,0.8667789-0.1254284i,0.9649732-0.1600065i,0.9980652-0.01776875i,1.068164-0.1122852i,1.025654-0.2407814i,0.882703-0.2957453i,0.6743309-0.04393367i,1.099113-0.3256168i,0.9009478-0.4042202i,1.174253+0.1352658i,1.292883-0.0809058i,0.6247479+0.1508301i,1.001835-0.512114i,1.170132+0.2905396i,0.4636354-0.2305528i,1.393294-0.3215906i,1.129794-0.6001309i,0.7280077-0.6250092i,0.405375-0.3588493i,0.3489856+0.0676712i,1.258551-0.616881i,0.8249765-0.7129028i,1.425086+0.3024692i,1.572947-0.1229955i,0.4560655+0.3540734i,0.995759-0.7575856i,1.3228+0.4612604i,0.2499316-0.2620655i,1.570638-0.4292383i,1.194741-0.7929198i,0.6498042-0.8124352i,0.2188281-0.4436833i},
    {-0.5325127+1.072911i,0.01003456+1.893218i,0.6345554-0.5981138i,-0.2305139-0.1366132i,2.16085+0.7581316i,1.802206-0.1332956i,0.645852+2.091169i,0.05137986-0.3135056i,2.057346+1.082757i,-0.3361215+1.350721i,0.3376523+1.934904i,1.214066+1.927445i,1.852694+1.352549i,1.946329+0.5185122i,1.475462-0.1473855i,0.8910885+1.860748i,1.553758+1.499765i,-0.1991373+0.7098927i,0.04523955+1.339775i,0.9973606-0.1012453i,1.174431+1.515021i,0.08754748+0.4418992i,1.514955+0.5963526i,1.238264+0.2286056i,0.8258333+0.1050375i,0.4385392+0.2385411i,0.2092996+0.9551584i,1.155774+0.2645314i,0.7757939+0.1528428i,1.195017+1.237846i,1.397953+0.8939061i,0.2553756+1.03525i,1.061586+0.2281801i,0.920851+1.347578i,0.3567876+0.3847899i,1.379767+0.8067524i,1.287748+0.4519049i,1.004336+0.2180108i,0.6312637+0.194544i,0.3069121+0.4026849i,1.432424+0.7570729i,1.308718+0.3567942i,0.6507272+1.427046i,1.103973+1.394188i,0.1533271+0.4624811i,1.510511+0.5963381i,0.3438382+1.358137i,0.7875177+0.007699165i,1.291345+1.368072i,1.57607+0.9391867i,1.53807+0.4121705i,1.173135+0.003341913i},
    {-0.02868453+0.7485386i,0.134479+0.6775607i,-0.3759901+0.4572972i,-0.3454483+0.6540281i,0.04268165+0.1686455i,-0.1806677+0.1414722i,0.2380819+0.7050561i,-0.4857304+0.5078313i,0.2514608+0.1894709i,-0.1463487+0.951383i,0.1853709+0.9165258i,0.4335431+0.6570966i,0.4542173+0.2732472i,0.202979-0.05002676i,-0.2229918-0.1326946i,0.4667766+0.870486i,0.6162499+0.4131783i,-0.5658055+1.017633i,-0.0878661+1.235579i,-0.5835159-0.1016754i,0.7157523+0.5832615i,-0.7434551+0.9527778i,0.1070909-0.3241962i,-0.4890748-0.2438005i,-0.8741465+0.223574i,-0.8388105+0.8268241i,0.1762196+1.254891i,-0.7563479+0.08510664i,-0.8272362+0.6251871i,0.3891677-0.08918132i,-0.08451895-0.2285621i,0.3669156+1.016746i,-0.7390952+0.3459358i,0.5276891+0.186678i,-0.3690905+1.096216i,-0.2293757-0.1920311i,-0.6403583+0.0417374i,-0.822041+0.5082644i,-0.6481679+1.011138i,-0.1570823+1.287938i,-0.5712733-0.1842598i,-0.9119141+0.3292337i,0.646319+0.01776391i,0.1222215-0.3507657i,0.3567118+1.211988i,-0.869729+0.2709134i,0.6117553+0.1003153i,-0.287106+1.196139i,-0.3935004-0.1253237i,-0.6683591+0.2842367i,-0.5825597+0.7172631i,-0.263471+0.9330438i},
    {-1.39036+1.025161i,-0.814605+1.448644i,-1.173162-0.6102836i,-1.743596-0.02301891i,0.5649286-0.059173i,0.006450693-0.7571096i,-0.3197124+1.693464i,-1.705644-0.4286053i,0.7780112+0.2937144i,-1.619816+1.376092i,-0.7426951+1.814174i,0.2198085+1.578913i,0.8113688+0.7695406i,0.7432724-0.2447216i,0.02747405-0.990256i,-0.2000786+1.878884i,0.6904432+1.275226i,-2.203166+0.5614998i,-1.724106+1.577584i,-0.5439218-1.263864i,0.4360628+1.694238i,-2.270501+0.08997872i,0.8419134-0.4842708i,-0.09343215-1.224451i,-1.280982-1.157685i,-2.118524-0.327365i,-1.502261+1.738832i,-0.8097582-1.184518i,-1.756029-0.6547391i,0.9015189+0.4440886i,0.5559247-0.5170894i,-0.9214912+1.796744i,-1.251724-0.8697182i,0.6606341+0.9445512i,-1.926807+0.7565636i,0.1681581-0.7180491i,-0.7087011-0.9508584i,-1.533289-0.5781487i,-1.933575+0.2341318i,-1.721475+1.116673i,-0.2307009-0.8798621i,-1.138429-0.8167039i,0.563367+0.9558222i,0.6321811+0.05868063i,-1.321405+1.428771i,-0.7480892-0.8316975i,0.2618303+1.194673i,-1.748649+0.3467528i,0.2398032-0.2838884i,-0.405139-0.6120905i,-1.057366-0.4538633i,-1.421468+0.04015561i},
    {-0.5478051-1.255469i,-1.016215-0.7829605i,1.014662-0.6320795i,0.6436564-1.269712i,-0.01189701+0.826465i,0.76552+0.5663188i,-1.307498-0.5575133i,1.071059-1.042832i,-0.4675852+0.9088248i,-0.5593895-1.618992i,-1.263314-0.9934058i,-1.389342-0.05671004i,-0.8785523+0.7359146i,0.01710477+1.01089i,0.87433+0.6524729i,-1.401769-0.560738i,-1.22523+0.3395945i,0.4279988-1.653737i,-0.4954409-1.677214i,1.144983+0.3879071i,-1.469091-0.1844488i,0.956099-1.420991i,-0.1450961+1.124145i,0.8486713+0.8630379i,1.453014+0.001660235i,1.350786-1.067584i,-0.5402257-1.879137i,1.319437+0.4709264i,1.530025-0.6214809i,-1.070482+0.8579397i,-0.03177455+1.216881i,-1.072425-1.538514i,1.474124-0.1301978i,-1.339399+0.4313265i,0.4236347-1.774917i,0.4868865+1.001551i,1.211683+0.3330389i,1.340914-0.6237097i,0.842954-1.428123i,-0.03510488-1.72941i,0.7957175+0.6910053i,1.254322-0.08198449i,-1.221171+0.2372791i,-0.5753144+0.832646i,-0.3901016-1.611053i,1.001174+0.3859572i,-1.326286-0.2759147i,0.8815917-1.234592i,-0.2085969+0.8969082i,0.6259379+0.703621i,1.140298+0.02471123i,1.099288-0.8182817i},
    {-0.1518804+1.381514i,0.4278551+1.181022i,-1.1475+0.2912593i,-1.067308+0.9544483i,0.1846541-0.4993434i,-0.5327089-0.5373916i,0.7410352+1.019186i,-1.271171+0.6497058i,0.5229034-0.3853839i,-0.1778821+1.581083i,0.5430799+1.310058i,0.9136331+0.6373456i,0.7614166-0.1104888i,0.168206-0.5800757i,-0.580657-0.5600291i,0.7615519+1.002864i,0.8806109+0.2778341i,-0.8935751+1.285153i,-0.216402+1.543695i,-0.8473399-0.3874047i,0.8627908+0.712316i,-1.1639+0.9396971i,0.2715847-0.52432i,-0.4607227-0.6017453i,-1.085703-0.1944192i,-1.314821+0.5279284i,-0.3343077+1.615392i,-0.8261779-0.5194435i,-1.324248+0.1244867i,0.9041278-0.01729394i,0.3257729-0.6168893i,0.1303164+1.618888i,-1.177472-0.1917311i,0.9733013+0.3168174i,-0.9547559+1.32038i,-0.1641624-0.6516965i,-0.8705665-0.3741179i,-1.211659+0.2669523i,-1.06889+0.9423039i,-0.5598204+1.352269i,-0.4362168-0.4260766i,-0.9070816-0.07140246i,0.6896505+0.4576745i,0.5003168-0.06585682i,-0.4160234+1.308082i,-0.5261927-0.3512697i,0.596518+0.9094265i,-1.099432+0.6124941i,0.4388003-0.2389884i,-0.1541187-0.4950669i,-0.7871095-0.3029437i,-1.147904+0.2629953i},
    {0.7762923+0.6184487i,1.113563-0.2338941i,-1.192879+0.4319082i,-0.4648585+0.8624502i,-0.7016969-1.366135i,-1.210539-0.7822236i,0.8672531-0.5934429i,-0.8087324+0.5249765i,-0.2168077-1.332169i,0.4494761+0.4369592i,0.7546338-0.1160314i,0.6643161-0.7224388i,0.2366941-1.141962i,-0.3480538-1.219877i,-0.859832-0.9343322i,0.7320582-0.23742i,0.6002286-0.8170746i,-0.5036387+0.5716819i,0.1178241+0.5990891i,-1.008086-0.8630648i,0.8261289-0.4081652i,-0.9317963+0.4056759i,-0.05806594-1.377331i,-0.7737121-1.237447i,-1.247675-0.6567422i,-1.238138+0.1112284i,0.06254447+0.8293757i,-1.121367-1.044075i,-1.378519-0.2677433i,0.701474-1.131114i,-0.03227178-1.513478i,0.4720899+0.6933673i,-1.33348-0.6661018i,0.9131994-0.789061i,-0.7155246+0.7391048i,-0.4506533-1.455284i,-1.102259-1.011087i,-1.313336-0.2688708i,-1.01134+0.4202254i,-0.3604859+0.7544934i,-0.7037139-1.248177i,-1.15182-0.7211539i,0.8172107-0.5897508i,0.4413708-1.14079i,-0.1794138+0.7216449i,-0.8297538-1.152025i,0.8629085-0.04658984i,-1.206711+0.1290927i,0.3567965-1.342144i,-0.4198286-1.499502i,-1.157398-1.108063i,-1.485917-0.2938801i},
    {-1.136046-0.3166796i,-1.29605+0.4675784i,0.5364128-0.5328818i,-0.1839384-0.7666057i,0.488119+1.093155i,0.7974374+0.4789312i,-1.018387+0.765101i,0.1790765-0.5425161i,0.04249608+1.171399i,-0.8702542-0.2419145i,-1.05747+0.2810047i,-0.9029112+0.8179685i,-0.4497372+1.168973i,0.1465607+1.177516i,0.6457989+0.8011989i,-1.170629+0.445078i,-0.8780179+1.067924i,-0.1362527-0.7584987i,-0.8513535-0.5562666i,0.9081336+0.5279011i,-1.164959+0.8534933i,0.2074955-0.7592992i,0.218969+1.36433i,0.8057915+0.8436458i,0.9047456+0.07652108i,0.4876699-0.554751i,-0.8674595-0.4728425i,0.8142121+0.4745832i,0.6831706-0.1683194i,-0.5664063+1.192434i,0.05017903+1.234886i,-0.930123-0.2968525i,0.7938678+0.3306317i,-0.9914511+0.895746i,0.1008595-0.6959973i,0.2438472+1.302751i,0.8245177+0.8259425i,0.9698007+0.04270067i,0.5444607-0.6812587i,-0.2903262-0.9514018i,0.754888+1.188935i,1.120232+0.3369204i,-1.169304+1.154224i,-0.3432593+1.584199i,-0.9011454-0.7316951i,1.00657+0.5901895i,-1.216515+0.8507942i,0.2256447-0.7284161i,0.1492467+1.298169i,0.646684+0.8357043i,0.7414719+0.221421i,0.4748806-0.2842881i},
    {-0.1349462+0.2011225i,-0.2003325-0.06586521i,-0.5566587+0.4858062i,-0.3002332+0.4277466i,-0.8274965+0.06695144i,-0.7824077+0.3167071i,-0.4058809-0.1866887i,-0.3312059+0.4365605i,-0.8169549+0.03564851i,-0.183804-0.01073967i,-0.3731039-0.1879087i,-0.6378989-0.1841712i,-0.8293433+0.007777595i,-0.8308036+0.2854837i,-0.6309882+0.4877008i,-0.6456069-0.208778i,-0.8534448+0.002221973i,-0.1387304-0.0238995i,-0.3621227-0.2317984i,-0.3160143+0.4945473i,-0.8730884+0.02009031i,-0.1424282-0.05175044i,-0.5978971+0.5254822i,-0.2872044+0.4821215i,-0.1040572+0.2275664i,-0.1617421-0.08016623i,-0.7262509-0.1780297i,-0.1044206+0.1895253i,-0.1912253-0.1058445i,-0.5227426+0.5243388i,-0.2372299+0.4233058i,-0.8702837+0.1297749i,-0.2295863-0.1229408i,-0.4850596+0.5052882i,-0.7572694-0.1025904i,-0.1433893+0.1179014i,-0.2710926-0.1196124i,-0.5222064-0.1906008i,-0.7403762-0.06543811i,-0.8026546+0.1680148i,-0.2984647-0.08965527i,-0.5116546-0.1510721i,-0.2853786+0.332294i,-0.2160144+0.1387679i,-0.6933039+0.3255128i,-0.4708108-0.1315854i,-0.3253118+0.3564322i,-0.7679064+0.09267823i,-0.253482-0.01691723i,-0.4238443-0.1477029i,-0.6472759-0.1250907i,-0.7994089+0.05445655i},
    {-0.3156605-0.3636729i,-0.3965612-0.1361048i,0.2740316-0.3753546i,0.06500679-0.511851i,0.1419043+0.2104696i,0.325905+0.03488141i,-0.4061915-0.05963641i,0.2327212-0.4415452i,-0.03600831+0.2603944i,-0.2610897-0.4660539i,-0.4182063-0.250203i,-0.4089151+0.02168888i,-0.2298854+0.2344009i,0.04897191+0.2918675i,0.3096609+0.1604229i,-0.4794099-0.1664593i,-0.4057686+0.1324195i,0.110296-0.603548i,-0.2161365-0.5971589i,0.4310181+0.1026141i,-0.5441225-0.03704089i,0.3296641-0.5645511i,-0.02197266+0.4352661i,0.3619092+0.3195647i,0.5918991-0.03308957i,0.5346228-0.471234i,-0.2942434-0.7794701i,0.6243486+0.168783i,0.6814582-0.3444094i,-0.4157263+0.4943434i,0.1102245+0.6030027i,-0.6195418-0.6040283i,0.7310989-0.1923933i,-0.5434272+0.3983347i,0.009637147-0.8764225i,0.432901+0.4239173i,0.6746513-0.01737282i,0.5692201-0.4934361i,0.1913227-0.7753921i,-0.2636377-0.7464348i,0.5388998+0.1634568i,0.5886328-0.2631367i,-0.4050555+0.3372761i,-0.01225779+0.461617i,-0.4084457-0.5871657i,0.5528666-0.04497449i,-0.5146801+0.154336i,0.1610543-0.6708895i,0.1770934+0.3731678i,0.4475538+0.1157573i,0.4838079-0.2436627i,0.2861999-0.5284704i},
    {-2.495663+0.08207419i,-2.026699+1.085372i,-0.5453364-1.666442i,-1.596548-1.467491i,0.6967379+0.5818546i,0.7651474-0.4843001i,-1.761299+1.283701i,-0.8872377-1.691098i,0.3047324+1.192565i,-2.452784-0.3074394i,-2.25415+0.7975145i,-1.396338+1.528765i,-0.2686259+1.550357i,0.616492+0.8549941i,0.8641552-0.2388754i,-1.978196+1.153457i,-0.9686928+1.627483i,-1.723635-1.45716i,-2.415899-0.5739545i,0.8009496-0.6476652i,-1.683167+1.450743i,-1.065684-1.783952i,0.5202892+1.154811i,1.007709+0.04286386i,0.6687651-1.146791i,-0.370295-1.85614i,-2.543371-0.8079445i,1.033899-0.579884i,0.2664356-1.642608i,-0.5963117+1.874223i,0.5894955+1.296954i,-2.73366-0.1802325i,0.7655731-1.17749i,-1.281155+1.82922i,-1.634554-1.786361i,0.946066+0.7597095i,1.048813-0.5435313i,0.2968175-1.604362i,-0.9511527-1.936049i,-2.113209-1.398868i,1.055064+0.1674617i,0.7567415-1.050359i,-1.372926+1.709029i,-0.1445727+1.667415i,-2.387046-0.959244i,1.004949-0.3266833i,-2.037977+1.31637i,-0.6986519-1.892654i,0.2938632+1.470892i,1.028363+0.4376306i,0.9378402-0.8507545i,0.02693756-1.800561i},
    {-0.3767611-0.5635887i,-0.2486586-0.560739i,-0.3549342-0.6913027i,-0.306431-0.6024424i,-0.3392801-0.7392944i,-0.3934545-0.6393012i,-0.2094645-0.8214508i,-0.1855325-0.4944534i,-0.4924913-0.7441341i,-0.03391491-0.7916721i,-0.1714405-0.9532545i,-0.4023935-0.9751804i,-0.601419-0.8205629i,-0.6466726-0.5513972i,-0.4872642-0.3027442i,-0.3641616-1.126092i,-0.6733031-0.9703372i,0.2647453-0.7235777i,0.1171756-1.099766i,-0.2693359-0.05550469i,-0.7168737-1.151594i,0.4161477-0.6212364i,-0.8340439-0.2206181i,-0.3779662+0.06904426i,0.1699219-0.03963639i,0.4996101-0.5074079i,-0.04335534-1.446299i,0.08422603+0.05468261i,0.4793572-0.373509i,-1.026537-0.3937812i,-0.6486893+0.03380862i,-0.4544592-1.447578i,0.3750081-0.2105108i,-1.062485-0.5952477i,0.2760457-1.252285i,-0.3015911+0.1304796i,0.2415572-0.04449055i,0.5373319-0.543185i,0.4227707-1.121622i,-0.0586501-1.477899i,0.1183584+0.06811363i,0.5171732-0.39439i,-1.032964-0.3392942i,-0.5951261+0.08212678i,-0.5474231-1.42893i,0.4299315-0.3196036i,-1.000201-0.4554283i,0.09696263-1.304196i,-0.1160323+0.0101534i,0.2792674-0.2977622i,0.3522664-0.7666616i,0.1005789-1.136812i},
    {-0.5258028-0.6056491i,-0.128353-0.391324i,-0.279575-1.590156i,-0.538093-1.270173i,0.5484912-1.183099i,0.3155634-1.456521i,0.0225357-0.5495572i,-0.266674-1.382183i,0.3986518-0.9141639i,-0.3576393-0.927963i,-0.2400436-0.7636188i,-0.06850712-0.6715924i,0.1382854-0.6647725i,0.3472303-0.774444i,0.4798581-1.015807i,-0.4202992-0.7340899i,-0.1569181-0.4839085i,-0.2308602-1.607605i,-0.5834112-1.341133i,0.6971305-1.18878i,-0.4364491-0.4408138i,-0.0385203-1.801349i,0.5573981-0.4585868i,0.8207606-0.9446694i,0.7063255-1.498536i,0.2535825-1.858872i,-0.8042097-1.449719i,0.9279836-1.240161i,0.5986772-1.809319i,0.06168637-0.02529188i,0.7278917-0.2782077i,-1.062305-1.136078i,0.9061128-1.676178i,-0.2479987+0.066946i,-0.5367897-2.044782i,1.099382-0.6309601i,1.099818-1.45721i,0.5479863-2.0757i,-0.2736597-2.171245i,-0.9487719-1.702083i,1.162104-1.154787i,0.7962028-1.873892i,-0.0405161+0.1105006i,0.7117796-0.1391197i,-1.102454-1.25226i,0.9890926-1.588219i,-0.3710265+0.02372944i,-0.3952081-2.07547i,0.9904734-0.5145366i,1.079572-1.286816i,0.6385443-1.919239i,-0.1012806-2.096926i},
    {0.8575888+0.01275544i,0.697887-0.3062412i,0.2539948+0.4711367i,0.5339824+0.3866591i,-0.03273398-0.1329224i,-0.02889724+0.1032703i,0.5562949-0.2410036i,0.2878391+0.357323i,0.1630095-0.2789062i,0.6402885+0.1690483i,0.6781278-0.05207461i,0.5673624-0.2632496i,0.3361463-0.3633165i,0.08440778-0.2880381i,-0.06063082-0.0608747i,0.6723852-0.1679469i,0.4673131-0.3406587i,0.4449097+0.3760536i,0.630429+0.2129902i,-0.01529645+0.05447006i,0.5657077-0.2025291i,0.2647213+0.327193i,0.2042718-0.2615634i,0.06571504-0.1449422i,0.007445698+0.03224413i,0.05895245+0.2267454i,0.4776305+0.3804762i,-0.04497503-0.1766247i,-0.1104547+0.115803i,0.6072673-0.3582282i,0.2852355-0.4688664i,0.6920546+0.3669998i,-0.1862701+0.004372632i,0.7210888-0.3116725i,0.2507274+0.5272417i,0.05259407-0.4061329i,-0.149289-0.1216105i,-0.11742+0.2135175i,0.1126539+0.4406599i,0.4216824+0.4713053i,-0.02283899-0.2712823i,-0.1258909+0.003985871i,0.6970108-0.2461293i,0.4595009-0.427064i,0.5029135+0.4682413i,-0.1095508-0.2304254i,0.8455356-0.0661924i,-0.03393821+0.4382058i,0.328867-0.5586162i,-0.067632-0.4379844i,-0.2953331-0.06633415i,-0.2120726+0.3811325i},
    {0.2334313-0.163496i,-0.2709611-0.4756697i,-0.06091934+1.031905i,0.2797348+0.5967789i,-1.150422+0.5889223i,-0.8079307+0.9541855i,-0.5616279-0.3571331i,0.05446705+0.7823727i,-1.112688+0.2879823i,0.09443472-0.04693076i,-0.2576597-0.3063546i,-0.7036873-0.2927991i,-1.051919+0.007041891i,-1.128773+0.4751673i,-0.8735774+0.8911634i,-0.5008336-0.3762944i,-0.955079-0.1609926i,0.2449157+0.3561335i,0.06986092-0.1027922i,-0.5419347+0.9711864i,-0.7870007-0.1826122i,0.1039666+0.4811951i,-0.9267736+0.5549824i,-0.6531717+0.7656461i,-0.3484952+0.7532373i,-0.1466125+0.5806518i,-0.1604461+0.1664718i,-0.5954098+0.6102408i,-0.4203856+0.6409279i,-0.647137+0.08177632i,-0.7628483+0.2342445i,-0.1245613+0.2206701i,-0.6544453+0.6220141i,-0.4605436-0.04322854i,-0.2036823+0.6314893i,-0.8431343+0.2359549i,-0.8339366+0.5042076i,-0.6539184+0.7213227i,-0.3633026+0.7852259i,-0.07978702+0.647492i,-0.9609142+0.3144551i,-0.8745174+0.6593041i,-0.3277288-0.2216796i,-0.7238014-0.1919263i,0.1203805+0.5568733i,-1.048728+0.5344406i,-0.1182518-0.2324703i,-0.3303805+0.9868765i,-0.9771174-0.1007268i,-1.142172+0.3457179i,-0.9753007+0.7987201i,-0.5489845+1.039768i},
    {-0.7271429+1.599794i,0.5845314+1.419168i,-2.02056-0.8499284i,-1.975755+0.4384471i,0.5141971-1.779097i,-0.6945894-1.876449i,1.037593+0.7497851i,-1.87863-0.1046922i,0.8112586-1.271487i,-0.4866498+1.247043i,0.4465097+1.011596i,1.022113+0.2777688i,1.032694-0.6390901i,0.483589-1.371092i,-0.4088873-1.612968i,0.6811164+0.8031268i,1.120885-0.05180845i,-1.495687+0.5714629i,-0.7001891+1.162501i,-0.8827149-1.521661i,0.9810168+0.3815076i,-1.625315+0.1494179i,0.4562237-1.323374i,-0.424808-1.498202i,-1.169893-1.08553i,-1.464852-0.3402275i,-0.672734+0.7918491i,-0.5902199-1.219218i,-1.112604-0.8353798i,0.7219148-0.2064677i,0.5312482-0.820316i,-0.5957915+0.7756981i,-0.6709089-1.205319i,0.6254759+0.3397585i,-1.382905-0.08002628i,0.4789563-1.014729i,-0.1881598-1.336633i,-0.9162368-1.16682i,-1.380614-0.575768i,-1.376692+0.1789453i,0.3127415-1.208366i,-0.4325155-1.388285i,0.55107+0.6325849i,0.922891-0.07301468i,-1.36697+0.4458871i,0.1355507-1.440529i,0.1532133+1.041044i,-1.475762-0.9274372i,1.10573-0.4277802i,0.6734295-1.304434i,-0.2476156-1.710361i,-1.239748-1.420619i},
    {0.07886611-0.3075083i,0.1462566-0.3225847i,-0.06881294-0.5491757i,-0.1195657-0.4537181i,0.2475639-0.5945321i,0.1277351-0.6984802i,0.201426-0.2197948i,-0.19715-0.5594787i,0.3595921-0.5695691i,-0.06753366-0.1724589i,0.1639051-0.1428877i,0.3570029-0.2826177i,0.4030383-0.5186788i,0.2761936-0.7224527i,0.04750338-0.78517i,0.3076523-0.2367092i,0.3864156-0.4474045i,-0.1585611-0.2672859i,0.02467383-0.1739032i,-0.06422214-0.6949782i,0.3192812-0.3683783i,-0.1597374-0.3781528i,0.2028798-0.6551491i,0.05730486-0.6830664i,-0.07018526-0.6227539i,-0.1369375-0.5029479i,-0.02734005-0.2648097i,0.03501196-0.6760218i,-0.09523095-0.6056731i,0.3012456-0.450753i,0.2533945-0.5967932i,0.02606565-0.2400142i,-0.02344604-0.6510368i,0.2627622-0.3719977i,-0.1164886-0.414455i,0.1974505-0.5959054i,0.1004532-0.6336252i,0.00454099-0.6215023i,-0.07911494-0.567629i,-0.1360647-0.4677221i,0.2779782-0.5888311i,0.1667852-0.722058i,0.1884071-0.1576033i,0.3966265-0.2896666i,-0.3159801-0.3515658i,0.3032303-0.836869i,0.1825924+0.005958005i,-0.3522354-0.7263434i,0.5863742-0.5743651i,0.3596095-0.9146295i,-0.05102148-0.9870843i,-0.3877655-0.7390557i},
    {-0.5558728-0.06804482i,-0.233599-0.08340845i,-0.9319225-0.6144992i,-0.9217001-0.2448681i,-0.2834091-0.9765867i,-0.6779321-0.9759216i,0.03590246-0.2537473i,-0.9823177-0.3051647i,-0.1959265-0.9440636i,-0.36096+0.04108406i,-0.05999805-0.1565238i,0.03992189-0.4863701i,-0.08266486-0.7942258i,-0.3598078-0.960226i,-0.6805037-0.9285135i,-0.002594403-0.2465262i,0.06318397-0.587765i,-0.821737-0.03491006i,-0.4537608+0.12519i,-0.8887441-0.9521878i,0.2032136-0.397802i,-1.038697-0.06980171i,-0.3098462-1.192169i,-0.848808-1.125516i,-1.203595-0.692783i,-1.15975-0.1241258i,-0.1566349+0.2393098i,-1.169259-0.7864614i,-1.17802-0.2286131i,-0.1162793-1.126771i,-0.6405427-1.170211i,0.1120314-0.09443267i,-1.123405-0.3803314i,-0.05211651-0.9670517i,-0.4497853+0.1377363i,-0.8625736-0.9111944i,-1.025406-0.5403248i,-0.9102359-0.1709699i,-0.5959575+0.02344565i,-0.2477204-0.03275968i,-0.8963425-0.6630043i,-0.8906891-0.3435887i,-0.2398919-0.8348761i,-0.5226111-0.8700262i,-0.184185-0.2321054i,-0.8095131-0.4822549i,-0.2173744-0.6775811i,-0.5200872-0.1920194i,-0.5880301-0.7070808i,-0.6778621-0.5671067i,-0.6590757-0.4245023i,-0.5708683-0.3428781i},
    {0.2467467+0.4960762i,0.8215322+0.4573356i,-0.2586503-0.6563568i,-0.3065922-0.09825671i,0.9599198-0.9525312i,0.4403452-1.100665i,1.019683+0.2937586i,-0.3086618-0.4267488i,1.187266-0.7025985i,0.1867693+0.4677854i,0.7459945+0.4973513i,1.210047+0.1554508i,1.350464-0.4213969i,1.075872-0.9662449i,0.4987834-1.20426i,1.070105+0.4003837i,1.389797-0.1557135i,-0.2928907+0.1861721i,0.2197662+0.570963i,0.1156257-1.120076i,1.285383+0.07164924i,-0.3470748-0.06246317i,0.9468264-1.002548i,0.3830689-1.109539i,-0.09561487-0.8336135i,-0.2729104-0.3348792i,0.3202528+0.3729526i,0.2038747-0.8965536i,-0.07591254-0.5811749i,1.069667-0.4115473i,0.8700349-0.7208163i,0.4200788+0.2498783i,0.2210081-0.7781885i,0.9778936-0.05955698i,-0.07322252-0.2051085i,0.8942394-0.7253836i,0.5556259-0.9209074i,0.1336574-0.8636795i,-0.1822849-0.5256556i,-0.2052781-0.02769437i,0.8410664-0.9862828i,0.2912851-1.075977i,1.15834+0.1605163i,1.300792-0.4086564i,-0.05011617+0.3244953i,0.4671207-1.109007i,1.016772+0.2806413i,-0.2711287-0.3873713i,1.090136-0.7017172i,0.6889706-0.9623552i,0.2457583-0.9177487i,-0.05890517-0.6339263i},
    {0.8129632+0.7851765i,1.16446+0.2721425i,-0.3725209+0.6703727i,0.1907833+1.04756i,-0.2051223-0.6083373i,-0.5964104-0.01819151i,1.125554-0.3787629i,0.1295165+1.07902i,-0.1503272-0.6571243i,1.226016+0.4082315i,1.15062-0.2532462i,0.6652952-0.6779886i,0.04072809-0.6738772i,-0.4158991-0.2736876i,-0.5039151+0.3147691i,0.8652115-0.5166294i,0.3046916-0.7071027i,0.923919+0.7900014i,1.213965+0.2465173i,-0.4013902+0.6724033i,0.5350801-0.7448348i,0.7970354+0.9582983i,-0.5615611-0.1291344i,-0.5119845+0.5593446i,0.001304263+1.022738i,0.6866854+0.9996803i,1.15319-0.137994i,-0.04830583+0.8913577i,0.5493749+0.9153325i,-0.3067884-0.2426609i,-0.3619955+0.2844639i,0.735954-0.3809395i,0.3851196+0.7746366i,-0.09020962-0.2570148i,0.8885995+0.1749182i,-0.07408366+0.4802708i,0.2522646+0.6412909i,0.5877218+0.5485709i,0.7656012+0.2661706i,0.7050001-0.04780298i,0.2131182+0.524512i,0.4973641+0.4747924i,0.01972472+0.05057846i,0.0762278+0.2941553i,0.3913523-0.1017707i,0.4698874+0.3276648i,0.1445158+0.1528094i,0.4216088+0.01273607i,0.4059229+0.2815261i,0.4854678+0.1474949i,0.415967+0.002423239i,0.2449878-0.02718886i},
    {0.4294016+0.4130969i,0.3308818-0.1125033i,-0.8063515+1.073916i,-0.2568786+1.17802i,-1.137893-0.3417955i,-1.433228+0.2382978i,0.4296706-0.348318i,-0.6753193+1.387042i,-0.9841573-0.7444872i,0.7159542+0.7080271i,0.7309525-0.1712026i,0.1338297-0.8419386i,-0.7671857-0.9313159i,-1.489129-0.3901433i,-1.657121+0.4835854i,0.3565212-0.6487221i,-0.4481179-0.9030291i,0.3433954+1.159622i,0.6900085+0.4556883i,-1.364528+0.8585005i,-0.06970041-0.7169523i,-0.07805561+1.273543i,-1.295928-0.2477553i,-1.42505+0.410428i,-1.1243+0.9971581i,-0.5325798+1.2694i,0.4978407+0.6147623i,-1.35451+0.612045i,-0.9542532+1.126725i,-0.5404762-0.7030616i,-1.150437-0.4179883i,0.5973235+0.3785246i,-1.281246+0.8853487i,-0.1537622-0.7279174i,0.03114296+1.247705i,-1.398996-0.136014i,-1.432206+0.6046324i,-0.9679846+1.173123i,-0.2596833+1.283502i,0.3188777+0.9082832i,-1.346262+0.3004244i,-1.087043+0.8489416i,-0.2685615-0.502893i,-0.756499-0.3889267i,0.2004254+0.6284461i,-1.109951+0.3625195i,0.1005713-0.1499416i,-0.6210986+0.9730036i,-0.67853-0.4215642i,-1.105493-0.1584315i,-1.301798+0.3692549i,-1.092482+0.958043i},

};


const float train_sym[2*52] = {
  1.000000,1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,1.000000,-1.000000,1.000000,1.000000,
  1.000000,1.000000,1.000000,1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,1.000000,-1.000000,
  1.000000,1.000000,1.000000,1.000000,1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,1.000000,
  -1.000000,1.000000,-1.000000,-1.000000,-1.000000,-1.000000,-1.000000,1.000000,1.000000,-1.000000,-1.000000,
  1.000000,-1.000000,1.000000,-1.000000,1.000000,1.000000,1.000000,1.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,
  0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000,0.000000
};


const COMPLEXD actin[200][52] = {
  {0.384698+0.08925816i,0.367054-0.1267277i,0.2523469-0.3107313i,0.045581-0.4282613i,-0.2297287-0.4164406i,-0.4833909-0.2162997i,-0.5682356+0.1484513i,-0.3722974+0.5259789i,0.06942341+0.6940334i,0.5472205+0.5042329i,0.7825284+0.008893968i,0.6077561-0.5384221i,0.09059351-0.8269963i,-0.4935741-0.6832528i,-0.8262737-0.1800059i,-0.734311+0.4112566i,-0.2793574+0.7843065i,0.2953117+0.7654847i,0.7085012+0.3871717i,0.7801381-0.1541137i,0.4979292-0.6074724i,0.001283772-0.7790877i,-0.4889431-0.6030738i,-0.7604665-0.159506i,-0.693011+0.358449i,-0.3109744+0.720795i,0.6568255+0.4491538i,0.7971599-0.07295102i,0.5706323-0.5674657i,0.0783619-0.8050576i,-0.4550677-0.6741494i,-0.7855695-0.2312326i,-0.7590515+0.325606i,-0.3797233+0.7433237i,0.1876635+0.8238409i,0.6832378+0.515716i,0.8654237-0.05056565i,0.6301921-0.6088827i,0.07769663-0.8793952i,-0.5217021-0.7151514i,-0.8612976-0.1920403i,-0.7655227+0.4213655i,-0.2908224+0.8084157i,0.3071136+0.7803927i,0.7214462+0.375156i,0.7630974-0.1795771i,0.4472619-0.6053854i,-0.0423607-0.7200889i,-0.4692221-0.5084544i,-0.658915-0.09726209i,-0.5574983+0.3244193i,-0.2289102+0.5859557i},
    {0.4622502+1.395257i,1.242057+0.7880019i,1.45895-0.1770837i,1.013825-1.058762i,0.1133719-1.455161i,-0.8279659-1.191269i,-1.383605-0.3973956i,-1.312624+0.5580246i,-0.664288+1.245605i,0.2575409+1.372634i,1.044788+0.9053094i,1.369525+0.06448904i,1.113934-0.7879395i,0.3980391-1.305464i,-0.4855984-1.285377i,-1.186235-0.7312998i,-1.415629+0.1519877i,-1.050269+1.020149i,-0.1958931+1.500425i,0.8164943+1.339067i,1.534642+0.539941i,1.581127-0.5839902i,0.8630391-1.512462i,-0.3297272-1.76113i,-1.428425-1.151052i,-1.86724+0.05894313i,-0.2242917+1.893095i,1.065218+1.587479i,1.838949+0.5156989i,1.729906-0.7927408i,0.8091968-1.711627i,-0.4738566-1.823039i,-1.523206-1.095665i,-1.869038+0.1260672i,-1.36257+1.288774i,-0.2296703+1.869022i,1.023825+1.594723i,1.82222+0.571651i,1.776082-0.7419963i,0.8802884-1.726201i,-0.4537231-1.892198i,-1.578136-1.140442i,-1.932672+0.1660952i,-1.342675+1.376676i,-0.116189+1.89298i,1.123841+1.483219i,1.7752+0.3892055i,1.562833-0.8263012i,0.6481474-1.58748i,-0.4956276-1.585008i,-1.342486-0.8862261i,-1.554151+0.1474091i},
    {-1.186487+0.5186944i,-0.5692886+1.121852i,0.2581049+1.194301i,0.9225953+0.7497222i,1.161078+0.01532128i,0.9076277-0.691416i,0.2886443-1.092042i,-0.4419855-1.036967i,-0.9925064-0.5471801i,-1.130586+0.1885339i,-0.7757294+0.8669801i,-0.05566582+1.180713i,0.7186807+0.9601462i,1.179968+0.2796102i,1.08897-0.5496058i,0.4754073-1.122706i,-0.3611422-1.154802i,-1.006393-0.638495i,-1.15513+0.155043i,-0.7672343+0.8327009i,-0.06551433+1.092443i,0.6080106+0.8620311i,0.9736171+0.2951008i,0.9242488-0.3431894i,0.5256931-0.8087227i,-0.05264649-0.9552009i,-0.9554716-0.2471434i,-0.9469839+0.3880641i,-0.5393579+0.9246998i,0.1553337+1.11372i,0.8618353+0.8084642i,1.236147+0.07932131i,1.041504-0.7657582i,0.3084853-1.305635i,-0.6360731-1.228866i,-1.316836-0.5264422i,-1.364511+0.4738687i,-0.7286912+1.268154i,0.2822602+1.445753i,1.161738+0.9113967i,1.472748-0.06660721i,1.07095-1.003107i,0.165612-1.44789i,-0.8005332-1.203745i,-1.37526-0.4052068i,-1.306187+0.5643337i,-0.6418472+1.260193i,0.3061808+1.374864i,1.108968+0.8646852i,1.406787-0.03847393i,1.062945-0.9285491i,0.2262444-1.399597i},
    {-0.3374698-0.1746362i,-0.4041224+0.07693134i,-0.2865755+0.3423372i,0.003601841+0.482855i,0.3448224+0.3869168i,0.5471823+0.06010962i,0.4653141-0.3421048i,0.1107569-0.5875173i,-0.3286005-0.5141774i,-0.5953839-0.1489559i,-0.5302674+0.2975207i,-0.1788327+0.5655609i,0.2429886+0.5152689i,0.4976003+0.2064704i,0.475166-0.1621018i,0.2378077-0.3962632i,-0.05632093-0.4186001i,-0.2707338-0.2766148i,-0.3546854-0.06823931i,-0.3231493+0.1328245i,-0.2017165+0.2909128i,-0.00532444+0.3738759i,0.2317231+0.3323458i,0.4223063+0.133412i,0.4487127-0.1781048i,0.2444454-0.4606669i,-0.4818673-0.3351831i,-0.6061735+0.07891383i,-0.4055595+0.4811749i,0.0271379+0.6404141i,0.4571345+0.4574054i,0.6462345+0.02848913i,0.4929692-0.4115415i,0.08714949-0.6272582i,-0.3485906-0.5137516i,-0.5875908-0.1459972i,-0.5200045+0.2735732i,-0.201028+0.5307831i,0.1916056+0.5109823i,0.4594649+0.248251i,0.4857501-0.1068082i,0.2847119-0.3756641i,-0.02215508-0.4441645i,-0.2815733-0.3090015i,-0.3875953-0.06005715i,-0.3210984+0.1803581i,-0.1374075+0.3190697i,0.07659546+0.3216548i,0.2427498+0.2066295i,0.3110537+0.02392237i,0.263356-0.1629174i,0.1150363-0.2886617i},
    {-0.9062313-0.0279266i,-0.7247392+0.6045372i,-0.1446652+0.9649032i,0.5474547+0.8400533i,0.9887701+0.2715478i,0.9380117-0.4595402i,0.406814-0.9799414i,-0.3451329-1.018883i,-0.9425204-0.5463991i,-1.082243+0.2112062i,-0.6840129+0.881359i,0.06621947+1.12642i,0.8009843+0.8118663i,1.148574+0.08118345i,0.9218258-0.7050015i,0.22327-1.145364i,-0.5960881-1.006662i,-1.113964-0.3538513i,-1.061051+0.4764895i,-0.4683715+1.053076i,0.3487542+1.082098i,0.9636177+0.563565i,1.069311-0.2163782i,0.6369228-0.8488829i,-0.08407538-1.024135i,-0.7141269-0.6862537i,-0.7095559+0.565759i,-0.1572406+0.8481644i,0.4104104+0.7052734i,0.724513+0.2549087i,0.6728437-0.2541906i,0.3315597-0.5824809i,-0.1023514-0.6133142i,-0.4269287-0.3852026i,-0.5297517-0.04058439i,-0.4156809+0.2638127i,-0.1703541+0.4272224i,0.1003731+0.4240914i,0.3122544+0.2824111i,0.4119085+0.05508262i,0.3716105-0.1918757i,0.1938776-0.3801411i,-0.07247502-0.4323567i,-0.3288451-0.3080377i,-0.4592754-0.04117968i,-0.3914781+0.2572048i,-0.1464579+0.4482738i,0.1641963+0.4409598i,0.3976839+0.2427433i,0.4565125-0.04964454i,0.3306933-0.3091181i,0.08467424-0.4411586i},
    {-0.5421974-0.6534405i,-0.8260955-0.2147094i,-0.8148915+0.3193056i,-0.4835477+0.7733864i,0.09083392+0.9561287i,0.7026839+0.7333089i,1.065152+0.1313751i,0.9485705-0.6128173i,0.3390757-1.131024i,-0.5015341-1.117932i,-1.145787-0.5274173i,-1.23473+0.3670841i,-0.694005+1.105704i,0.2096109+1.296793i,1.011616+0.8376447i,1.3055-0.0319555i,0.9572319-0.8684352i,0.1602973-1.264549i,-0.6840708-1.051126i,-1.178885-0.3594479i,-1.117141+0.4681963i,-0.5566946+1.054058i,0.2312327+1.15303i,0.896108+0.7431555i,1.157194+0.01621999i,0.9105818-0.7118067i,-0.5089563-1.051617i,-1.070182-0.4998146i,-1.159672+0.2964158i,-0.714142+0.9820929i,0.08365596+1.228678i,0.8675245+0.8956621i,1.253028+0.1201473i,1.034565-0.7288364i,0.3072432-1.227953i,-0.5678657-1.123289i,-1.150396-0.4722835i,-1.157806+0.3861494i,-0.6127689+1.020203i,0.1857297+1.138542i,0.8412616+0.7287347i,1.070549+0.02967809i,0.8216942-0.6221519i,0.2535568-0.9627409i,-0.3759446-0.8931214i,-0.8262897-0.4759616i,-0.9429434+0.1190168i,-0.6837575+0.6725373i,-0.1309794+0.9685492i,0.5109539+0.8618486i,0.9647017+0.357582i,0.9952305-0.3476939i},
    {0.0809958-0.2918416i,-0.1347393-0.2589557i,-0.2623774-0.09421261i,-0.2434225+0.1012428i,-0.1072624+0.2224585i,0.0593903+0.2218138i,0.1732616+0.1237142i,0.1982957-0.008545407i,0.1464218-0.1184792i,0.04940158-0.1775751i,-0.06344193-0.1762708i,-0.1633764-0.1102077i,-0.2116069+0.01370037i,-0.1682483+0.1572739i,-0.0264503+0.2485403i,0.1582737+0.2179543i,0.2820217+0.05500716i,0.2552356-0.1632842i,0.07251374-0.3073281i,-0.1683099-0.2784149i,-0.321458-0.08145832i,-0.2883713+0.1699573i,-0.085038+0.3239681i,0.1667293+0.2878609i,0.3169692+0.08573038i,0.2802634-0.1596527i,-0.1520068-0.2682009i,-0.2900526-0.07883531i,-0.252521+0.1482276i,-0.06640351+0.2772737i,0.1523477+0.2320129i,0.2667718+0.04312583i,0.2039725-0.1665005i,0.006312385-0.2569732i,-0.1900075-0.1654377i,-0.2445694+0.04430708i,-0.1146706+0.219373i,0.105925+0.2258542i,0.2492127+0.05236763i,0.1982769-0.1729427i,-0.01784654-0.2738211i,-0.2381476-0.1616742i,-0.2888675+0.08985124i,-0.1187424+0.2944287i,0.1562924+0.2926649i,0.3364969+0.07456673i,0.286595-0.210298i,0.0353402-0.3620723i,-0.247113-0.2745576i,-0.3721716-0.006679937i,-0.2616324+0.2651413i,0.007915908+0.3704235i},
    {1.125831+0.3939207i,1.130072-0.4322829i,0.5857722-1.07634i,-0.2619028-1.209473i,-0.9968897-0.7454229i,-1.242479+0.0950326i,-0.8674721+0.8872015i,-0.06502941+1.226857i,0.7492818+0.9493427i,1.163977+0.2148441i,0.9904265-0.587975i,0.3499825-1.058233i,-0.4107681-0.9910294i,-0.9159417-0.4647339i,-0.9515578+0.2268842i,-0.5525383+0.7441168i,0.04593601+0.872272i,0.5495362+0.607054i,0.7537107+0.123448i,0.6235294-0.3383775i,0.2746137-0.5976231i,-0.1164812-0.6000319i,-0.4080341-0.4032142i,-0.5381085-0.10995i,-0.5068432+0.1919921i,-0.3335783+0.4426312i,0.3208436+0.5454897i,0.6339241+0.276641i,0.7353845-0.1808912i,0.5035849-0.6542152i,-0.03029061-0.8924821i,-0.6423836-0.7090126i,-1.006965-0.1251812i,-0.8834161+0.5955964i,-0.2818416+1.071581i,0.5119616+1.020986i,1.082943+0.4376185i,1.119714-0.3918169i,0.5909383-1.042112i,-0.2387336-1.18059i,-0.9542826-0.739408i,-1.206192+0.05984722i,-0.8787966+0.8276275i,-0.134677+1.199159i,0.6716332+1.002716i,1.161027+0.3329596i,1.103175-0.4954005i,0.5231689-1.091838i,-0.306392-1.171885i,-0.9906014-0.695249i,-1.20194+0.1099561i,-0.842137+0.856455i},
    {0.7436979+0.1128601i,0.6857473-0.4042181i,0.2851739-0.7935463i,-0.3123778-0.8353713i,-0.8241557-0.4517623i,-0.9620411+0.2125512i,-0.6035718+0.8301049i,0.1062353+1.056462i,0.8061798+0.7345298i,1.112263+0.006592244i,0.8416515-0.7489207i,0.1262397-1.126797i,-0.6578336-0.9243636i,-1.101087-0.2519827i,-0.9833502+0.5359175i,-0.3811074+1.039051i,0.3893794+1.019357i,0.9462794+0.5086342i,1.032374-0.2266528i,0.6278136-0.828816i,-0.05704068-1.021457i,-0.6922924-0.7312324i,-0.9852241-0.1106061i,-0.8121695+0.5416456i,-0.2688107+0.9228003i,0.3814028+0.8657742i,0.8897063-0.216308i,0.5351798-0.7241765i,-0.05193908-0.8840768i,-0.5959481-0.6354414i,-0.8507745-0.1050285i,-0.709222+0.45691i,-0.2471183+0.7924804i,0.3143502+0.7530802i,0.7117719+0.3668993i,0.7637217-0.174844i,0.4581473-0.6106737i,-0.04331305-0.7387326i,-0.4908283-0.5169494i,-0.6775655-0.0772975i,-0.5423647+0.3542123i,-0.1856259+0.5824019i,0.2041001+0.5363886i,0.458521+0.2809423i,0.5031897-0.04586044i,0.3620033-0.3139472i,0.1127976-0.4478342i,-0.15838-0.4261542i,-0.3748912-0.262337i,-0.4690517+0.00165655i,-0.3926186+0.2873664i,-0.1478368+0.485176i},
    {0.5742941-0.738087i,-0.00804302-0.9718841i,-0.6388289-0.7825475i,-1.027175-0.2119268i,-0.9613199+0.506471i,-0.4295415+1.036907i,0.3460883+1.10209i,0.9990782+0.6357356i,1.198003-0.1625693i,0.8231179-0.9131111i,0.03924738-1.244849i,-0.7806762-0.98629i,-1.241639-0.2540351i,-1.121587+0.6063532i,-0.4752992+1.190567i,0.3978239+1.226386i,1.096367+0.6948894i,1.298286-0.1654417i,0.9029907-0.9652566i,0.07879275-1.3345i,-0.8037799-1.088736i,-1.331752-0.3226222i,-1.241368+0.6179307i,-0.5549399+1.286781i,0.412802+1.351696i,1.197348+0.7668508i,0.9521236-1.063449i,0.03734356-1.424257i,-0.8883364-1.106962i,-1.385666-0.2721667i,-1.229234+0.6789888i,-0.5042209+1.302714i,0.4458147+1.317461i,1.182666+0.7241252i,1.369957-0.201603i,0.9209949-1.033601i,0.04004376-1.384415i,-0.8631486-1.083557i,-1.358121-0.2664i,-1.201644+0.6777305i,-0.4670133+1.288739i,0.4824607+1.267672i,1.175403+0.634483i,1.277731-0.2816515i,0.7644996-1.019772i,-0.07965747-1.231991i,-0.8266745-0.8552461i,-1.134371-0.1183037i,-0.9064518+0.6041183i,-0.3056968+0.991606i,0.3626188+0.9184684i,0.8120154+0.4747893i},
    {-0.5579348-0.6095486i,-0.835712-0.1241794i,-0.7387896+0.4414151i,-0.2943058+0.8217691i,0.2980682+0.8295819i,0.7614402+0.4544764i,0.8797307-0.1303857i,0.6016812-0.6562729i,0.05765011-0.8893297i,-0.5104668-0.7333842i,-0.8605791-0.2604819i,-0.847318+0.3307447i,-0.4709583+0.7974901i,0.1260825+0.941247i,0.7054619+0.68041i,1.012725+0.09273728i,0.8788813-0.5907338i,0.3137873-1.05891i,-0.4597505-1.055587i,-1.076519-0.5248709i,-1.199637+0.3185215i,-0.7145541+1.062008i,0.1720819+1.301007i,1.012011+0.8732332i,1.351667-0.02417299i,0.9940625-0.9240209i,-0.7972233-1.073557i,-1.285066-0.2672804i,-1.111716+0.6333091i,-0.4082506+1.170234i,0.4370806+1.111611i,1.009788+0.5441409i,1.07848-0.2166609i,0.6722522-0.8147485i,0.01681957-1.018534i,-0.5982444-0.7882546i,-0.9377161-0.2500776i,-0.8861533+0.3739306i,-0.468971+0.8407216i,0.1544301+0.9587656i,0.730493+0.6600212i,0.9986504+0.049909i,0.8118907-0.6082882i,0.2317237-0.9993092i,-0.4742723-0.9165475i,-0.9563977-0.3867342i,-0.9699172+0.328443i,-0.5132919+0.8686845i,0.171629+0.971943i,0.7385495+0.6115608i,0.9261005-0.006295876i,0.6825737-0.571934i},
    {-0.3584876-0.4735564i,-0.6042364-0.1198483i,-0.5456152+0.3220588i,-0.1964058+0.6159267i,0.2659807+0.5986258i,0.6001227+0.2748561i,0.635183-0.1888978i,0.3574426-0.5598909i,-0.09349801-0.6596727i,-0.501767-0.4439274i,-0.6760674-0.0135046i,-0.5305689+0.4337475i,-0.1226962+0.6860385i,0.3629496+0.6103973i,0.6880572+0.224183i,0.6747347-0.2937286i,0.309982-0.6778075i,-0.2268834-0.7154752i,-0.6497847-0.3757975i,-0.7273741+0.1602045i,-0.4216043+0.5995319i,0.09015589+0.7095754i,0.5257406+0.4508622i,0.6658605-0.01408956i,0.4686466-0.4314725i,0.06779864-0.6035209i,-0.5312222-0.1514812i,-0.4847678+0.2135909i,-0.2294646+0.4565631i,0.1106737+0.4831994i,0.3841331+0.2924346i,0.4699503-0.02380534i,0.3316725-0.3147048i,0.04243122-0.4390187i,-0.2458103-0.3414645i,-0.385443-0.08800562i,-0.3207204+0.1734846i,-0.1166515+0.3075057i,0.09456602+0.273272i,0.2080416+0.1339517i,0.206753-0.00875246i,0.1449557-0.09438934i,0.08030502-0.1304234i,0.02303407-0.1521387i,-0.05264577-0.1652704i,-0.1543895-0.1331003i,-0.2366974-0.02117528i,-0.2265373+0.1473645i,-0.08953974+0.2854193i,0.1250853+0.2978921i,0.3049881+0.1544114i,0.3462873-0.08223762i},
    {-1.204453-0.1189077i,-1.010615+0.6758569i,-0.3506469+1.169152i,0.4767522+1.126844i,1.086482+0.5630325i,1.192802-0.259215i,0.7506978-0.9547796i,-0.02580534-1.206031i,-0.7762401-0.9116712i,-1.169244-0.2196892i,-1.045953+0.5579988i,-0.4706295+1.089453i,0.3120382+1.153573i,0.976072+0.7166766i,1.232833-0.05382695i,0.9441459-0.8385807i,0.1999985-1.279403i,-0.6844811-1.137604i,-1.28664-0.4342854i,-1.282339+0.5181781i,-0.6376079+1.247119i,0.3411227+1.36704i,1.15494+0.8034848i,1.385913-0.1531331i,0.9302697-1.008095i,0.04557704-1.339649i,-1.234942-0.2523714i,-1.075485+0.5706582i,-0.4608743+1.082759i,0.3041665+1.099938i,0.8958589+0.6608533i,1.093832-0.02799293i,0.8393998-0.6863327i,0.2405343-1.05544i,-0.4638487-0.9830947i,-0.9815355-0.4866514i,-1.080529+0.2350648i,-0.6998414+0.8691239i,0.004250685+1.124437i,0.717436+0.8742439i,1.112836+0.225232i,1.007825-0.5294744i,0.449223-1.048884i,-0.312577-1.100739i,-0.9395801-0.6615137i,-1.153542+0.07778354i,-0.8535563+0.7938012i,-0.1618063+1.165935i,0.6203356+1.01528i,1.136467+0.3931622i,1.136763-0.4265558i,0.6052699-1.063283i},
    {0.4378343-0.2539498i,0.1509332-0.4788087i,-0.2078684-0.4505636i,-0.4492336-0.1918716i,-0.4534128+0.1541162i,-0.2309096+0.4065745i,0.09227002+0.4454883i,0.3508211+0.2682841i,0.4279161-0.02267675i,0.3045797-0.2841013i,0.05267916-0.4031663i,-0.2104308-0.3396592i,-0.373962-0.1299481i,-0.3719684+0.134799i,-0.2039474+0.3422094i,0.0619235+0.3985185i,0.3083709+0.2692921i,0.4155923+0.004875024i,0.3217403-0.2715331i,0.06427005-0.4199486i,-0.2301599-0.3592771i,-0.410096-0.1167753i,-0.3825368+0.1832649i,-0.1638841+0.3871612i,0.1315653+0.3943803i,0.3549919+0.2068005i,0.2452185-0.3193797i,-0.02844566-0.3990282i,-0.2865885-0.2766131i,-0.396826-0.01087784i,-0.2963531+0.2616178i,-0.03333734+0.3910059i,0.2467486+0.2986807i,0.3779314+0.03444652i,0.278309-0.2408512i,0.0130679-0.3525376i,-0.2397139-0.2321628i,-0.3100556+0.02804523i,-0.160708+0.2373287i,0.0827428+0.24784i,0.2277647+0.06842239i,0.1667181-0.1429013i,-0.03678836-0.2070629i,-0.2003765-0.07141349i,-0.1745703+0.1450962i,0.0301171+0.2489168i,0.2467543+0.1333046i,0.2854752-0.1282533i,0.08924253-0.3340198i,-0.2137268-0.3105523i,-0.4024476-0.04976083i,-0.327505+0.2794908i},
    {0.1134175+0.3372144i,0.3099386+0.1474259i,0.3029122-0.1176203i,0.1097071-0.2804963i,-0.1235873-0.2428557i,-0.2332093-0.05588961i,-0.1615354+0.1255762i,0.005981829+0.1690275i,0.1196943+0.0669218i,0.09273733-0.06766161i,-0.03097435-0.1051629i,-0.1225621-0.01232378i,-0.08470668+0.1220757i,0.06256174+0.1671167i,0.1982189+0.06392926i,0.2012683-0.1226281i,0.04984057-0.2546104i,-0.1609146-0.2279672i,-0.2903837-0.04896305i,-0.2518626+0.1741687i,-0.06556676+0.3081512i,0.1632741+0.2776063i,0.3127387+0.1005363i,0.3082855-0.1326554i,0.1511693-0.3095154i,-0.0888868-0.3444363i,-0.3838902+0.0389485i,-0.2757916+0.2949677i,-0.01134853+0.4224327i,0.285943+0.3359962i,0.4550077+0.05834265i,0.3872713-0.2739869i,0.1006977-0.477052i,-0.2565917-0.4266169i,-0.4855361-0.1388393i,-0.4532496+0.2316426i,-0.1739497+0.4794204i,0.1982614+0.4679305i,0.4594541+0.2069376i,0.4719954-0.1570948i,0.2377689-0.4274783i,-0.110005-0.4664909i,-0.3855565-0.2653797i,-0.4517488+0.05934333i,-0.2881539+0.3353011i,0.007140727+0.4275424i,0.2776706+0.3047294i,0.3937292+0.04542872i,0.314763-0.2133139i,0.09806861-0.3510883i,-0.1433171-0.3193034i,-0.3019685-0.1508324i},
    {-0.4533648-0.007894844i,-0.3060152+0.2737557i,-0.03781227+0.3620135i,0.1822076+0.2569004i,0.2564081+0.0676018i,0.1998003-0.08408089i,0.09504206-0.1444044i,0.01306271-0.1378799i,-0.03302657-0.1163462i,-0.07258233-0.1018438i,-0.1272087-0.07242012i,-0.1763177+0.004054012i,-0.1686101+0.1240341i,-0.06798404+0.2327612i,0.1049608+0.2538462i,0.2698197+0.1432571i,0.3273072-0.07037122i,0.2202119-0.2880519i,-0.02275598-0.3882183i,-0.2890936-0.2958068i,-0.4352738-0.03398988i,-0.3658902+0.274768i,-0.09557503+0.4665233i,0.2464592+0.4260303i,0.4797573+0.158273i,0.4725021-0.2049521i,-0.1507555-0.50308i,-0.4464334-0.2779474i,-0.51736+0.08474162i,-0.3329513+0.4006119i,0.008810513+0.5165021i,0.3387868+0.3838934i,0.502498+0.07372644i,0.4293919-0.2652496i,0.1582516-0.4772424i,-0.1846668-0.4669502i,-0.441763-0.239464i,-0.4931408+0.1010906i,-0.3123516+0.3959116i,0.01721679+0.5043292i,0.3386565+0.3732042i,0.4977198+0.06584298i,0.4203215-0.2689005i,0.1481798-0.4723723i,-0.1865534-0.4541576i,-0.4298241-0.2302115i,-0.4768251+0.09348064i,-0.311604+0.3740693i,-0.006026062+0.491097i,0.3108509+0.390369i,0.4992201+0.1054726i,0.4624738-0.2464444i},
    {-0.2354132+1.991417i,1.073913+1.647308i,1.839621+0.5735686i,1.751597-0.7080405i,0.8964877-1.624585i,-0.3181949-1.799265i,-1.358823-1.188221i,-1.787611-0.07538296i,-1.43274+1.054405i,-0.4536181+1.713976i,0.7224355+1.615778i,1.576856+0.7999571i,1.726392-0.3731984i,1.101003-1.377098i,-0.01671603-1.757931i,-1.118783-1.346506i,-1.708307-0.3366332i,-1.528966+0.8095549i,-0.6757798+1.579674i,0.4603224+1.643179i,1.377761+0.9891155i,1.686024-0.08445425i,1.265139-1.111171i,0.3032541-1.656599i,-0.7908503-1.493402i,-1.556639-0.6875533i,-1.053428+1.390976i,0.04313474+1.775429i,1.167724+1.386436i,1.820201+0.3524372i,1.672819-0.897946i,0.7387704-1.798944i,-0.5947309-1.899609i,-1.712473-1.097432i,-2.054997+0.2718405i,-1.411095+1.562611i,-0.0577489+2.129117i,1.35193+1.665192i,2.115197+0.3829934i,1.849426-1.084048i,0.6952874-2.010879i,-0.7644314-1.958738i,-1.819314-0.9881867i,-1.993447+0.4014435i,-1.256464+1.549654i,0.007218824+1.958486i,1.216663+1.494834i,1.861888+0.4020516i,1.696817-0.8393996i,0.8067089-1.71293i,-0.4391463-1.854167i,-1.520397-1.185131i},
    {-0.2050436+0.8897594i,0.4099407+0.83266i,0.8659168+0.390931i,0.9406384-0.2633353i,0.5608878-0.8343781i,-0.1266718-1.024839i,-0.789955-0.7002108i,-1.071802+0.003666519i,-0.7998316+0.7247716i,-0.1073452+1.071802i,0.6314278+0.8574652i,1.021291+0.2112372i,0.8768646-0.5061003i,0.3130661-0.9236736i,-0.3505968-0.8655359i,-0.7882434-0.4152253i,-0.8317412+0.1727316i,-0.5157185+0.6277065i,-0.01505577+0.7818049i,0.4551389+0.6080985i,0.718589+0.1983546i,0.6830457-0.2813561i,0.363835-0.6415681i,-0.113483-0.7310115i,-0.5483657-0.5017282i,-0.7450043-0.04493527i,-0.1924974+0.7225668i,0.3086371+0.6789358i,0.666292+0.3278571i,0.7194811-0.1678231i,0.4478712-0.5827453i,-0.02328222-0.7309783i,-0.4802247-0.5467684i,-0.7142955-0.1142796i,-0.6167319+0.3661937i,-0.2346469+0.6680478i,0.2453314+0.6497571i,0.5892574+0.3306635i,0.6401554-0.1189097i,0.3998815-0.4752323i,0.01427613-0.5868049i,-0.3259684-0.4446859i,-0.4942906-0.15577i,-0.4708144+0.1461482i,-0.3049094+0.3724325i,-0.05409607+0.4847515i,0.2342344+0.456846i,0.4908854+0.2600905i,0.6019455-0.09283119i,0.4550734-0.4894201i,0.0416237-0.7269236i,-0.4758069-0.6235307i},
    {-1.032858+0.4720359i,-0.5065436+1.019948i,0.2558264+1.117384i,0.9171436+0.702828i,1.162468-0.05105544i,0.8571813-0.7935072i,0.1363235-1.158845i,-0.6463456-0.9612681i,-1.100643-0.3041216i,-1.012105+0.4736058i,-0.4528563+0.9868905i,0.2756388+1.011853i,0.8221416+0.5841319i,0.9666843-0.05649973i,0.6989462-0.6160803i,0.1755895-0.885067i,-0.3822046-0.7964142i,-0.77594-0.4087586i,-0.8732598+0.1359356i,-0.6288635+0.6472479i,-0.1073885+0.924188i,0.5051467+0.8213656i,0.9429773+0.3341894i,0.9732508-0.3539599i,0.5336983-0.9239327i,-0.1967276-1.074555i,-1.119222+0.03602734i,-0.8232792+0.7599838i,-0.1252891+1.105232i,0.6162524+0.9063163i,1.034186+0.2837017i,0.946901-0.4370239i,0.4350581-0.9105951i,-0.2294014-0.9459926i,-0.7411965-0.57494i,-0.9059097+0.001882788i,-0.6991394+0.5344573i,-0.236214+0.8303741i,0.3003042+0.8040056i,0.7245222+0.4750443i,0.8865055-0.04995172i,0.7043055-0.5946984i,0.2043678-0.9439841i,-0.4479331-0.9132682i,-0.9737617-0.449951i,-1.091004+0.2911508i,-0.6745181+0.972802i,0.1302876+1.226984i,0.9376952+0.8673676i,1.312073+0.03041311i,1.020559-0.8651126i,0.1886693-1.339797i},
    {0.1942071-0.5852293i,-0.2116394-0.6448207i,-0.6170999-0.4163584i,-0.8076665+0.06815265i,-0.624611+0.6117709i,-0.08918888+0.9293453i,0.5658073+0.8086593i,1.001043+0.2563308i,0.9609023-0.4761731i,0.4307995-1.016907i,-0.341475-1.077283i,-0.9753448-0.6110591i,-1.15734+0.1633597i,-0.7953256+0.8796805i,-0.05239807+1.203427i,0.7378999+0.9802299i,1.219324+0.2955432i,1.159809-0.5614718i,0.551959-1.208654i,-0.3635008-1.325229i,-1.17358-0.8052242i,-1.465439+0.156662i,-1.038793+1.114188i,-0.04856665+1.568672i,1.028741+1.238297i,1.624443+0.2449444i,0.4285614-1.625544i,-0.7704118-1.49886i,-1.569519-0.5980394i,-1.554346+0.5963554i,-0.7531456+1.459228i,0.396557+1.563526i,1.302393+0.8932781i,1.532364-0.1787619i,1.016304-1.110262i,0.04610259-1.46737i,-0.8957647-1.1181i,-1.374222-0.2652419i,-1.192911+0.6716661i,-0.4657044+1.257094i,0.4491479+1.234401i,1.118787+0.63604i,1.237029-0.2371044i,0.767507-0.9614834i,-0.04218293-1.197336i,-0.7877614-0.8545921i,-1.114752-0.1306342i,-0.894843+0.6014499i,-0.2772607+0.9917451i,0.4080041+0.8882265i,0.8333322+0.3939232i,0.8363544-0.2142721i},
    {1.341624+1.105516i,1.724623-0.03041093i,1.281369-1.127051i,0.2506183-1.666621i,-0.8654448-1.420931i,-1.554642-0.5340648i,-1.523418+0.5721496i,-0.8065594+1.399482i,0.2653223+1.585788i,1.211208+1.051989i,1.602692+0.03687439i,1.253895-0.9976333i,0.3188252-1.567697i,-0.7640298-1.398233i,-1.475427-0.5690809i,-1.475727+0.5140743i,-0.7806844+1.323881i,0.2515778+1.483137i,1.116175+0.9502748i,1.423156+0.01771072i,1.076438-0.8610953i,0.2849568-1.303054i,-0.5722474-1.157993i,-1.132567-0.5382475i,-1.192885+0.2660355i,-0.7638404+0.9217743i,0.6796294+0.9483052i,1.110694+0.3340543i,1.080883-0.4135565i,0.6024238-0.9893481i,-0.1301178-1.15531i,-0.8161554-0.838745i,-1.17053-0.163649i,-1.038484+0.5976307i,-0.4588673+1.130096i,0.3446747+1.198214i,1.040521+0.7440907i,1.314058-0.07134328i,1.005633-0.9091613i,0.2072504-1.38087i,-0.7423863-1.229006i,-1.392539-0.4772781i,-1.401089+0.5446556i,-0.7280682+1.343387i,0.3187912+1.512402i,1.230214+0.9529452i,1.558739-0.0673187i,1.148811-1.054275i,0.2056446-1.541651i,-0.8224816-1.314665i,-1.467576-0.4926761i,-1.449616+0.5473329i},
    {0.5290853-0.3283713i,0.1821946-0.6004716i,-0.2580834-0.5791245i,-0.5817776-0.2755191i,-0.6343932+0.172496i,-0.3789806+0.5588539i,0.08182448+0.6916474i,0.5347531+0.4818528i,0.7435638+0.005300281i,0.5729995-0.5082156i,0.08392704-0.7805265i,-0.4742411-0.6435813i,-0.7932935-0.1535845i,-0.6890553+0.4260489i,-0.2175392+0.7757053i,0.3577965+0.7098517i,0.7265863+0.2807804i,0.7105563-0.2671665i,0.3474313-0.6502472i,-0.1569639-0.6979119i,-0.5554435-0.4184777i,-0.678336+0.03517843i,-0.4905999+0.4531339i,-0.08654118+0.6557862i,0.3537558+0.5565231i,0.6306725+0.1955408i,0.2811223-0.6001444i,-0.1898577-0.6324033i,-0.5596186-0.3368963i,-0.6274286+0.1281046i,-0.3618198+0.5049888i,0.07638521+0.590795i,0.434742+0.3596441i,0.5266306-0.03104784i,0.3370272-0.3512336i,0.009885292-0.4430913i,-0.2606647-0.3009937i,-0.3500654-0.04542462i,-0.2566216+0.1717433i,-0.07159164+0.256524i,0.09346213+0.205735i,0.1683847+0.0826743i,0.1470075-0.03272926i,0.0733081-0.08757017i,0.007353128-0.07738287i,-0.01252789-0.04063131i,0.005748262-0.02798096i,0.01427366-0.06002516i,-0.03374569-0.1024358i,-0.1327839-0.08619893i,-0.2089197+0.03064734i,-0.1669988+0.2058078i},
    {-0.0260992-0.8285428i,-0.5421019-0.5890648i,-0.7646757-0.09115093i,-0.6157871+0.407472i,-0.2011898+0.6771156i,0.2642657+0.6210902i,0.5710393+0.3001375i,0.6059488-0.1192984i,0.3836914-0.4521112i,0.0203399-0.5712779i,-0.3258536-0.4475531i,-0.5179244-0.1480257i,-0.488001+0.1972437i,-0.2581995+0.4468972i,0.0705997+0.5024436i,0.3597222+0.3466915i,0.4897949+0.05028368i,0.4107376-0.2587709i,0.1618679-0.4505732i,-0.1474194-0.4487531i,-0.3867175-0.2606308i,-0.4600009+0.02995975i,-0.3429925+0.3012073i,-0.08873016+0.4443195i,0.1976304+0.4054751i,0.4020313+0.203663i,0.3102226-0.3340732i,0.04816276-0.4596967i,-0.2422848-0.4045095i,-0.4486012-0.1822276i,-0.4834646+0.1297189i,-0.3178225+0.4125421i,0.0008108792+0.5447707i,0.3536963+0.4498971i,0.5866146+0.1387157i,0.5728692-0.2753015i,0.282245-0.607443i,-0.181145-0.68086i,-0.6058478-0.4229002i,-0.7681791+0.07506084i,-0.5542656+0.5806654i,-0.03941228+0.8299681i,0.5312953+0.6710139i,0.8628515+0.1591152i,0.7692854-0.4581513i,0.2810919-0.8654191i,-0.3631008-0.8467342i,-0.8384043-0.4022426i,-0.9022601+0.2497303i,-0.5189599+0.7844989i,0.1233101+0.9355385i,0.7078469+0.6269159i},
    {0.2858104+1.023198i,0.9098142+0.6093255i,1.11874-0.1388333i,0.7709405-0.8632778i,0.007951128-1.183615i,-0.7928252-0.9072005i,-1.210556-0.1535691i,-1.014714+0.6948782i,-0.2987327+1.197246i,0.5691923+1.094259i,1.146644+0.4436169i,1.148936-0.4200937i,0.5859327-1.06585i,-0.2563039-1.181887i,-0.9639196-0.7200145i,-1.194399+0.08938967i,-0.8372793+0.8493873i,-0.06866422+1.185075i,0.7283316+0.9279319i,1.150349+0.2079653i,0.983355-0.6035997i,0.3224933-1.086146i,-0.4754066-0.9983762i,-0.9900848-0.4105908i,-0.9726424+0.3430302i,-0.4740524+0.8634133i,0.7119438+0.5161821i,0.8202612-0.07054061i,0.5395471-0.5456026i,0.05917018-0.7106534i,-0.37667-0.5442559i,-0.5896589-0.1723357i,-0.52741+0.217243i,-0.258213+0.4621323i,0.0767269+0.483962i,0.3294434+0.3077697i,0.4087228+0.0398341i,0.3160676-0.190413i,0.1320521-0.2988425i,-0.04332694-0.2836358i,-0.1559053-0.2030376i,-0.2163589-0.1116885i,-0.2571972-0.01311938i,-0.2707907+0.1238864i,-0.1964638+0.2977491i,0.01705385+0.4257514i,0.3248194+0.3795838i,0.5648097+0.09486482i,0.5480393-0.3347904i,0.2062029-0.6748613i,-0.3211556-0.6903713i,-0.7443466-0.3156041i},
    {-0.3202146-0.2837838i,-0.4108452-0.02059434i,-0.3185346+0.2304441i,-0.0991716+0.3587434i,0.1350516+0.3207572i,0.2788751+0.1589758i,0.290801-0.03263303i,0.2025082-0.1723017i,0.07697867-0.2331745i,-0.04414741-0.2333673i,-0.1552531-0.1911734i,-0.2542113-0.09686626i,-0.3039974+0.06518108i,-0.2400416+0.2652035i,-0.03032843+0.4068269i,0.2635127+0.3749841i,0.4901185+0.1275522i,0.4938084-0.2440816i,0.2261425-0.5456942i,-0.201436-0.5925516i,-0.568821-0.3282055i,-0.671331+0.131938i,-0.4363908+0.5593966i,0.03571678+0.7332073i,0.5218354+0.5516595i,0.7821524+0.08240462i,0.2133487-0.8208245i,-0.3933777-0.7894057i,-0.8489301-0.3455065i,-0.8954155+0.317947i,-0.4672375+0.8627514i,0.2412809+0.9783375i,0.8560324+0.5693821i,1.028259-0.1636341i,0.647014-0.8219583i,-0.0824363-1.039012i,-0.7555922-0.6999117i,-1.009683-0.005865478i,-0.7316427+0.6559752i,-0.1035728+0.9447152i,0.5271971+0.7476091i,0.8526121+0.2098797i,0.7527319-0.3780738i,0.3200359-0.74366i,-0.2205124-0.7495537i,-0.6274122-0.4258361i,-0.7373856+0.06706224i,-0.5172991+0.5107176i,-0.07159846+0.7127586i,0.3968783+0.5850109i,0.6709941+0.1884863i,0.6223888-0.2861265i},
    {0.07630128+2.061529i,1.38022+1.502758i,1.996672+0.2421563i,1.643624-1.093392i,0.5265724-1.854484i,-0.7779057-1.702981i,-1.635314-0.7714477i,-1.680929+0.438667i,-0.974982+1.346233i,0.08384331+1.584492i,1.001567+1.136703i,1.425564+0.2735739i,1.254972-0.6216582i,0.6156902-1.217895i,-0.2300697-1.325313i,-0.9740499-0.9213679i,-1.340256-0.1500266i,-1.169299+0.7033208i,-0.4992833+1.290844i,0.4111995+1.341674i,1.169405+0.8044674i,1.427408-0.1005332i,1.059008-0.9727169i,0.2261097-1.423965i,-0.7045233-1.261753i,-1.337275-0.5637352i,-0.9028777+1.179777i,0.007577805+1.518879i,0.9672326+1.228993i,1.574566+0.3791443i,1.523609-0.7152751i,0.7595807-1.577956i,-0.4367311-1.766967i,-1.523207-1.112513i,-1.941425+0.1404448i,-1.422172+1.40439i,-0.1681774+2.034623i,1.21831+1.679219i,2.041505+0.4852612i,1.879975-0.9669976i,0.8059964-1.964656i,-0.6590089-2.024352i,-1.812945-1.122572i,-2.113321+0.309077i,-1.423313+1.598994i,-0.06381308+2.146865i,1.336331+1.693394i,2.123138+0.4393331i,1.916941-1.037143i,0.7988124-2.039112i,-0.7113001-2.079869i,-1.892414-1.127437i},
    {0.8986447+1.020297i,1.365981+0.2226519i,1.223226-0.7133604i,0.4974292-1.366955i,-0.5142398-1.406899i,-1.343463-0.7598642i,-1.557851+0.3110538i,-0.9949332+1.292101i,0.1104463+1.66403i,1.209052+1.191495i,1.716747+0.08365673i,1.342862-1.091817i,0.2689225-1.711882i,-0.9406545-1.446388i,-1.650109-0.4432405i,-1.502358+0.7593175i,-0.6036078+1.536201i,0.5549076+1.512672i,1.377753+0.7456411i,1.479765-0.3369579i,0.8638406-1.183763i,-0.1160852-1.406111i,-0.9635366-0.9524607i,-1.294377-0.09734267i,-1.006637+0.72615i,-0.2941361+1.148041i,0.9721028+0.4666077i,1.001833-0.2357798i,0.6083407-0.7734979i,-0.001744332-0.9434631i,-0.5609217-0.7136751i,-0.8509491-0.2111548i,-0.7772925+0.3440156i,-0.3924257+0.7274652i,0.1321298+0.7942402i,0.5759377+0.5326723i,0.7605481+0.06694319i,0.6250093-0.3988921i,0.2478176-0.674336i,-0.1989673-0.6662939i,-0.5370685-0.4076252i,-0.6577285-0.02005086i,-0.5453141+0.3544933i,-0.252062+0.6045535i,0.1368308+0.660353i,0.514829+0.4878392i,0.751285+0.1020143i,0.7149976-0.3975998i,0.3461606-0.8146635i,-0.2609534-0.9189496i,-0.8448051-0.5800181i,-1.084743+0.1105397i},
    {-0.1792174+0.393757i,0.1333046+0.4828984i,0.4702524+0.3114341i,0.6134028-0.08796141i,0.4274929-0.5115414i,-0.02582594-0.7040241i,-0.5089288-0.5282665i,-0.7524819-0.05972372i,-0.6184853+0.4590653i,-0.1727613+0.7627842i,0.3653437+0.704089i,0.7435026+0.3123346i,0.7891837-0.2375111i,0.4713599-0.7048386i,-0.08956074-0.8736172i,-0.6554092-0.6373169i,-0.9519979-0.06347658i,-0.7945949+0.5997745i,-0.2088755+1.014516i,0.5374854+0.9278132i,1.049345+0.3386877i,1.025128-0.4639301i,0.4506291-1.045877i,-0.3726691-1.080549i,-0.9978104-0.5471913i,-1.094614+0.2584707i,0.1200399+1.073299i,0.7742584+0.7137015i,1.025595+0.03844941i,0.7899621-0.616836i,0.2075074-0.9605833i,-0.446767-0.8597062i,-0.8849537-0.3741027i,-0.9166734+0.2772775i,-0.5244746+0.8017385i,0.1184077+0.9525329i,0.7105783+0.6470826i,0.9594681+0.02417056i,0.7347772-0.6093225i,0.1487824-0.9326934i,-0.4963126-0.7855618i,-0.8720602-0.2561002i,-0.8018001+0.3724785i,-0.3469207+0.7822223i,0.2424578+0.7882538i,0.6713371+0.4202465i,0.7497151-0.1143028i,0.4724182-0.5487746i,0.00215529-0.6891172i,-0.4226473-0.4976478i,-0.6068116-0.0977322i,-0.4897878+0.2980252i},
    {-0.8873228-1.363475i,-1.593973-0.5084862i,-1.59681+0.6412125i,-0.8364577+1.556918i,0.3733126+1.771946i,1.462389+1.131737i,1.878544-0.0918233i,1.382909-1.309655i,0.1962641-1.910128i,-1.100498-1.582437i,-1.865243-0.484534i,-1.726607+0.8404138i,-0.7660965+1.747844i,0.5393341+1.814698i,1.56675+1.032557i,1.847677-0.2115206i,1.273463-1.334251i,0.1255094-1.826883i,-1.064224-1.476564i,-1.753143-0.4528632i,-1.628949+0.7702491i,-0.7525517+1.626649i,0.4641972+1.718864i,1.44763+1.009621i,1.73773-0.1556318i,1.213624-1.217606i,-0.9407797-1.359107i,-1.55322-0.4400442i,-1.445079+0.6250837i,-0.7142501+1.359487i,0.2824818+1.473736i,1.11266+0.9630356i,1.448886+0.07163842i,1.177539-0.8273686i,0.4198732-1.374602i,-0.5188884-1.347971i,-1.254478-0.7446665i,-1.464712+0.2015233i,-1.030169+1.091641i,-0.1123272+1.519765i,0.8894116+1.26366i,1.508135+0.412327i,1.436257-0.6522692i,0.6897501-1.428736i,-0.3867089-1.542871i,-1.284598-0.9367582i,-1.581591+0.1016233i,-1.145807+1.082363i,-0.1919755+1.552839i,0.8312665+1.309492i,1.45865+0.4818459i,1.420956-0.5419855i},
    {0.9631015+0.1076477i,0.8328887-0.5118353i,0.346209-0.9312258i,-0.3116556-0.967393i,-0.8706648-0.5778711i,-1.072956+0.1010043i,-0.790437+0.7828994i,-0.1109647+1.142068i,0.6687744+0.9728675i,1.168096+0.3167788i,1.116544-0.5287623i,0.5110934-1.146454i,-0.3636948-1.216218i,-1.075731-0.6905419i,-1.270391+0.1757656i,-0.8530385+0.9584384i,-0.0305077+1.281003i,0.8011413+0.9967555i,1.252521+0.2476994i,1.11911-0.6138531i,0.4655228-1.190646i,-0.4087993-1.216102i,-1.101009-0.6715962i,-1.282254+0.1988051i,-0.8528138+0.9881852i,-0.004327685+1.311207i,1.296875+0.1910974i,1.094726-0.7041412i,0.354974-1.234831i,-0.5361322-1.140153i,-1.123595-0.4923784i,-1.131929+0.3531224i,-0.6020696+0.9654635i,0.158449+1.072795i,0.7666866+0.6841852i,0.9687711+0.04249864i,0.7392582-0.536944i,0.2422373-0.8279589i,-0.2882777-0.7674996i,-0.6592973-0.4317121i,-0.7685297+0.03374883i,-0.6012391+0.4715859i,-0.2138604+0.7415789i,0.272934+0.7416124i,0.6860257+0.4430417i,0.8450985-0.07064632i,0.6441193-0.6020387i,0.1285923-0.9061003i,-0.4910803-0.8093933i,-0.921405-0.3184514i,-0.9330204+0.3560998i,-0.4928216+0.89007i},
    {-1.72192-0.2441988i,-1.441712+0.8856202i,-0.5363755+1.554424i,0.5493045+1.499869i,1.330238+0.7990885i,1.495519-0.2003209i,1.021203-1.056716i,0.1485283-1.427071i,-0.742375-1.193716i,-1.295595-0.4853618i,-1.31047+0.3970897i,-0.7993744+1.105384i,0.03241802+1.368423i,0.8641925+1.080647i,1.367445+0.3381833i,1.3198-0.5829857i,0.6994947-1.309727i,-0.2751647-1.507758i,-1.198998-1.035173i,-1.635836-0.04461499i,-1.328894+1.039827i,-0.3617983+1.696286i,0.8372195+1.565832i,1.683245+0.6631681i,1.734186-0.5966197i,0.9377047-1.593871i,-1.429379-1.176913i,-1.839804+0.02782298i,-1.37462+1.195632i,-0.2832596+1.776513i,0.9030748+1.5264i,1.64266+0.5974395i,1.628885-0.5659622i,0.9014763-1.447176i,-0.2010041-1.679261i,-1.200463-1.181266i,-1.675134-0.1742663i,-1.423071+0.9133111i,-0.543051+1.61486i,0.5962753+1.614879i,1.498219+0.8904549i,1.747572-0.2595861i,1.204088-1.327196i,0.08654787-1.815672i,-1.106603-1.474102i,-1.817506-0.4314958i,-1.692827+0.8442886i,-0.7639078+1.75485i,0.5508245+1.854274i,1.632205+1.071787i,1.95377-0.238729i,1.342999-1.455965i},
    {-0.4678003-0.8252642i,-0.9035535-0.361889i,-0.9580715+0.2911805i,-0.580565+0.8543518i,0.09163728+1.064024i,0.7724445+0.7912438i,1.139085+0.1198061i,0.9830102-0.6625928i,0.3323411-1.178728i,-0.5288507-1.145441i,-1.178715-0.5365371i,-1.269935+0.3745847i,-0.7249806+1.136149i,0.2029925+1.350692i,1.050463+0.892294i,1.385121-0.01787686i,1.034638-0.9240204i,0.1756508-1.373597i,-0.7621475-1.148965i,-1.318743-0.3708369i,-1.232347+0.5725713i,-0.5594922+1.224494i,0.3644347+1.281682i,1.095295+0.7327257i,1.293903-0.1471889i,0.8820103-0.9356856i,-0.7503626-1.000269i,-1.199133-0.2803509i,-1.082664+0.5446354i,-0.4762347+1.092963i,0.3250091+1.126864i,0.9524652+0.6520161i,1.132766-0.09958103i,0.801937-0.7844794i,0.1220124-1.101802i,-0.5975638-0.9201161i,-1.036134-0.3292069i,-1.000636+0.4008562i,-0.5115841+0.938049i,0.2029248+1.03811i,0.8097786+0.660143i,1.02861-0.01094417i,0.7684162-0.6538169i,0.169581-0.9706843i,-0.4735939-0.833115i,-0.8661205-0.3345155i,-0.8541246+0.2742291i,-0.4803861+0.7201855i,0.0630332+0.8338724i,0.5411942+0.6035742i,0.7762858+0.1505105i,0.6997548-0.3394807i},
    {-0.9942222+0.08870821i,-0.6929901+0.7282033i,-0.04015535+1.007491i,0.6334162+0.7835135i,0.9883819+0.1726605i,0.8530765-0.5146708i,0.3055104-0.9385642i,-0.3764078-0.9007307i,-0.8611521-0.4343893i,-0.9256564+0.2245491i,-0.5541736+0.7601137i,0.06586439+0.9270539i,0.639851+0.6594324i,0.9043555+0.0926495i,0.745057-0.505051i,0.2442213-0.8576524i,-0.3607759-0.8068314i,-0.7881517-0.3825288i,-0.8417948+0.2126575i,-0.5017394+0.6984591i,0.06699593+0.8483341i,0.5925432+0.596495i,0.8260417+0.06939968i,0.6619885-0.475355i,0.1896993-0.7754617i,-0.3521977-0.6942315i,-0.6905205+0.2280447i,-0.3591413+0.5952103i,0.1070257+0.6500016i,0.4702269+0.4013562i,0.5741565+0.00775269i,0.4145182-0.3267431i,0.1139996-0.4670243i,-0.1699466-0.4009022i,-0.3350182-0.2097373i,-0.364287+0.006514481i,-0.2927027+0.1863067i,-0.155569+0.3089915i,0.02984987+0.3599007i,0.2389157+0.3075642i,0.4075149+0.1257154i,0.4408453-0.156859i,0.2730896-0.4312679i,-0.0643094-0.5479239i,-0.4271762-0.4069921i,-0.6233933-0.03824929i,-0.5243556+0.3925048i,-0.1506149+0.6645568i,0.3266505+0.6240112i,0.6715748+0.2719626i,0.7059759-0.2316873i,0.4000426-0.647091i},
    {0.7118689-0.08430398i,0.4951935-0.4968439i,0.08209694-0.6854162i,-0.352997-0.5859338i,-0.637359-0.2458608i,-0.6582123+0.1990547i,-0.400207+0.5709127i,0.04289745+0.709628i,0.4903314+0.537333i,0.7373737+0.1065688i,0.6486313-0.3996556i,0.2407598-0.7377627i,-0.3015233-0.7257003i,-0.7065058-0.3530506i,-0.7619493+0.1965455i,-0.4401476+0.6397929i,0.08356466+0.7543216i,0.5359074+0.5026769i,0.7045382+0.03919215i,0.5446889-0.3968515i,0.1723859-0.61935i,-0.2293766-0.5721264i,-0.5095626-0.3138252i,-0.5906529+0.04494562i,-0.4573382+0.3879691i,-0.1415543+0.6034827i,0.6099045+0.3141407i,0.7070659-0.1546464i,0.458563-0.6050163i,-0.05587244-0.7868603i,-0.5808401-0.56489i,-0.820951-0.03079793i,-0.6291525+0.5285645i,-0.1105919+0.8029754i,0.4413035+0.6535835i,0.7329424+0.190511i,0.6453948-0.3165782i,0.2765732-0.6173836i,-0.1577941-0.6144505i,-0.4680435-0.3713924i,-0.5705119-0.0257252i,-0.4727971+0.2994792i,-0.2201595+0.5208331i,0.1262416+0.5738646i,0.4687561+0.4096562i,0.6643167+0.03959462i,0.5791408-0.4136257i,0.1899353-0.7328241i,-0.3519323-0.7167141i,-0.7695212-0.320914i,-0.8150538+0.279227i,-0.4319955+0.7680207i},
    {0.3513953-0.3761597i,0.01516858-0.5419743i,-0.3627374-0.428342i,-0.566076-0.07684826i,-0.4731812+0.3213937i,-0.1386248+0.5468675i,0.2476574+0.4901157i,0.4872054+0.2063397i,0.4866824-0.1421259i,0.2833879-0.395402i,-0.0111359-0.4712224i,-0.2832862-0.3688948i,-0.4502997-0.1340778i,-0.457183+0.1634801i,-0.2795311+0.4268524i,0.04667875+0.5387207i,0.399628+0.4113426i,0.6022854+0.06029278i,0.5184788-0.3640358i,0.1551316-0.6376942i,-0.3141029-0.5946283i,-0.6382834-0.2393219i,-0.6387258+0.2448735i,-0.3163512+0.602415i,0.1544709+0.6540812i,0.5336079+0.3895316i,0.4601663-0.4393391i,0.07676848-0.6220515i,-0.328976-0.5266458i,-0.585284-0.2025335i,-0.5847142+0.2115449i,-0.3227005+0.5383281i,0.09404612+0.6287353i,0.4811797+0.4292535i,0.6534553+0.01921233i,0.5168959-0.4128782i,0.1261738-0.6556136i,-0.3330686-0.583339i,-0.6348342-0.2257912i,-0.6285717+0.2432998i,-0.3165627+0.5935105i,0.1475349+0.6534859i,0.5357675+0.3954778i,0.658453-0.05165612i,0.4578361-0.4659218i,0.03787485-0.6424451i,-0.3870422-0.4980628i,-0.6030875-0.1157172i,-0.5112644+0.3001795i,-0.1790802+0.5376769i,0.2045942+0.4949722i,0.4448259+0.2283267i},
    {0.4337017+0.2518297i,0.4997565-0.1336311i,0.268977-0.4651083i,-0.1443184-0.5420659i,-0.5082957-0.2948378i,-0.5956227+0.1587657i,-0.3227104+0.5600318i,0.1778584+0.6525612i,0.6139101+0.3473724i,0.7048151-0.1990179i,0.3665562-0.6617261i,-0.2166829-0.7460983i,-0.6954564-0.3815067i,-0.7733727+0.223766i,-0.3964351+0.7092596i,0.2136647+0.7873607i,0.7009103+0.4170305i,0.7919647-0.1822245i,0.4484937-0.6722505i,-0.1290648-0.7927967i,-0.6285514-0.4937056i,-0.7952983+0.05787951i,-0.5520945+0.5770116i,-0.02435776+0.8030432i,0.5248769+0.6195363i,0.8167372+0.1090133i,0.187731-0.8341821i,-0.4386035-0.7536244i,-0.8511543-0.2541071i,-0.8056747+0.40764i,-0.3046416+0.8628571i,0.3830867+0.8408563i,0.865443+0.3387595i,0.8575474-0.3624364i,0.3580083-0.8571096i,-0.3437487-0.8568419i,-0.8384427-0.3647954i,-0.8415702+0.3265268i,-0.3611514+0.8119499i,0.3118886+0.8149897i,0.7810033+0.3479638i,0.7796358-0.3020154i,0.3249277-0.7486079i,-0.2991188-0.736737i,-0.7164555-0.2911865i,-0.6863784+0.3043454i,-0.2463738+0.6846125i,0.3170573+0.6283115i,0.6519538+0.1916151i,0.5630649-0.3347972i,0.1300524-0.6171758i,-0.3539923-0.4928892i},
    {0.7608542+0.3700238i,0.8090928-0.2671292i,0.3964541-0.7566094i,-0.2394014-0.8185202i,-0.735751-0.4220598i,-0.8158529+0.20241i,-0.4442261+0.7011648i,0.1600764+0.8007528i,0.6549105+0.4598047i,0.7721831-0.1156171i,0.4661974-0.5980457i,-0.07089546-0.7292435i,-0.5310408-0.4622726i,-0.6721201+0.0263841i,-0.4487812+0.4545808i,-0.01828627+0.6027682i,0.3704109+0.4281194i,0.5250391+0.06342419i,0.4035177-0.2818642i,0.1083834-0.4441578i,-0.1938208-0.3779398i,-0.3656941-0.1510378i,-0.3530873+0.1120523i,-0.1878597+0.2943548i,0.04212976+0.328876i,0.233007+0.2146206i,0.2275102-0.182271i,0.04768988-0.274709i,-0.1408413-0.2243067i,-0.2400858-0.06626748i,-0.2051963+0.106441i,-0.07016923+0.1991659i,0.07709902+0.172937i,0.1537246+0.06309016i,0.1322733-0.05231381i,0.04842488-0.1078905i,-0.03369568-0.08875422i,-0.06738096-0.02811441i,-0.04730986+0.02484162i,-0.002042772+0.03815718i,0.03044602+0.01102982i,0.02489979-0.03180586i,-0.01947057-0.05490262i,-0.07646444-0.02977289i,-0.1008245+0.04589652i,-0.05185813+0.1346481i,0.07138557+0.1679436i,0.2073918+0.08743078i,0.2527377-0.09917501i,0.1309851-0.293101i,-0.1312568-0.3489088i,-0.3873283-0.1766846i},
    {0.2124162+0.3316894i,0.3215833+0.126641i,0.3005078-0.06033519i,0.2131928-0.1870623i,0.09685244-0.2648874i,-0.05176301-0.2964713i,-0.2269545-0.2453405i,-0.3669276-0.07464948i,-0.3724441+0.1848314i,-0.1868215+0.414136i,0.1336202+0.4690573i,0.4293512+0.2840669i,0.5311668-0.06740542i,0.3693573-0.4077371i,0.0183503-0.5600085i,-0.3496118-0.4473013i,-0.5608698-0.1247663i,-0.5217756+0.2603575i,-0.2484866+0.5409577i,0.1490596+0.5939651i,0.5070283+0.3819179i,0.6614248-0.02633055i,0.5146668-0.4635249i,0.09799392-0.7184326i,-0.411779-0.6357065i,-0.7574808-0.2165907i,-0.3253454+0.7713878i,0.276999+0.8080845i,0.7553248+0.4229092i,0.8506844-0.1895114i,0.5094069-0.7081096i,-0.0883607-0.8641359i,-0.6323919-0.5848631i,-0.8510941-0.0230511i,-0.6479782+0.5337486i,-0.1386204+0.8145893i,0.4190765+0.6957293i,0.7568667+0.2508326i,0.7239432-0.2948969i,0.3525319-0.6790299i,-0.166177-0.7286255i,-0.5815889-0.4385339i,-0.7075372+0.03606027i,-0.5065104+0.4656566i,-0.09346203+0.6614152i,0.3342802+0.5568484i,0.5943412+0.2202611i,0.5915565-0.1933174i,0.3407296-0.5130602i,-0.05141284-0.6126351i,-0.4254113-0.4489882i,-0.6205301-0.08106197i},
    {0.1349829-0.3270885i,-0.09206692-0.3666684i,-0.3190099-0.2531395i,-0.4397824+0.0001469784i,-0.3663748+0.3005634i,-0.09289164+0.499294i,0.2713306+0.4671471i,0.5396355+0.1829154i,0.5495316-0.2298804i,0.2676753-0.5562645i,-0.174655-0.6099582i,-0.5466745-0.3464097i,-0.6473229+0.1049875i,-0.4190286+0.5109239i,0.02190421+0.6625009i,0.4515435+0.485193i,0.6574746+0.07155562i,0.543627-0.3728869i,0.1706084-0.6344006i,-0.2801566-0.5919089i,-0.5949414-0.2694916i,-0.6268107+0.1784343i,-0.362474+0.5400756i,0.0720181+0.6450648i,0.470417+0.4447849i,0.6442834+0.03575465i,0.1422051-0.6237036i,-0.2914338-0.5659782i,-0.5844936-0.2447169i,-0.6026598+0.1875273i,-0.3401377+0.5295125i,0.0801328+0.6231514i,0.4626099+0.424471i,0.6271799+0.02481442i,0.4930382-0.3877144i,0.121337-0.6139278i,-0.3080325-0.5411173i,-0.5821643-0.2044427i,-0.5648791+0.2256384i,-0.2709227+0.5308288i,0.1415921+0.5623223i,0.4598694+0.3196602i,0.5338877-0.05653315i,0.35135-0.3710307i,0.02847627-0.4825223i,-0.2682795-0.3677263i,-0.4131364-0.1111849i,-0.3705628+0.1576639i,-0.1877707+0.3315895i,0.04657839+0.360787i,0.2434981+0.2530352i,0.3380175+0.05739867i},
    {-0.817054-0.3732255i,-0.9121407+0.2374997i,-0.5801106+0.8047887i,0.0794405+1.041818i,0.7770078+0.7763192i,1.147416+0.07699204i,0.9473692-0.7319465i,0.2251901-1.217094i,-0.66438-1.082392i,-1.240769-0.3637659i,-1.176405+0.5679736i,-0.4955392+1.213191i,0.4384677+1.230833i,1.135869+0.6249411i,1.252073-0.2765976i,0.7547297-1.017144i,-0.089695-1.248578i,-0.87032-0.8831804i,-1.22745-0.1086674i,-1.002787+0.7104146i,-0.3009993+1.191692i,0.5505378+1.101026i,1.139108+0.4695407i,1.163067-0.3990555i,0.6001475-1.063234i,-0.2584279-1.175619i,-1.130759+0.1260613i,-0.7248375+0.8116521i,-0.003150854+1.028494i,0.629426+0.7256365i,0.8772544+0.1334806i,0.6980712-0.416067i,0.2653603-0.6921402i,-0.1853066-0.6527396i,-0.491455-0.3937478i,-0.5971147-0.04436456i,-0.5084342+0.2926082i,-0.2534013+0.5336717i,0.1086262+0.5962259i,0.4599723+0.4252096i,0.6443109+0.05370883i,0.5492586-0.3705969i,0.1936364-0.643736i,-0.260202-0.6224134i,-0.5918871-0.3143453i,-0.6481885+0.1266122i,-0.4198785+0.4931968i,-0.02713375+0.6342897i,0.35789+0.5121508i,0.5893502+0.1924927i,0.5891262-0.1992178i,0.3569851-0.519986i},
    {1.794754+0.9762984i,1.948212-0.451396i,1.133175-1.581587i,-0.1769053-1.874854i,-1.306367-1.260709i,-1.742025-0.1151604i,-1.357897+0.9850648i,-0.4112124+1.560662i,0.635857+1.422055i,1.341498+0.6958023i,1.449437-0.2771538i,0.9535031-1.094493i,0.07381842-1.436366i,-0.8289348-1.170516i,-1.380406-0.4017282i,-1.335676+0.5538982i,-0.6932679+1.281171i,0.2786534+1.440795i,1.140548+0.9370098i,1.480487-0.01270525i,1.123347-0.9623342i,0.2346714-1.451844i,-0.7515476-1.244778i,-1.354265-0.4552836i,-1.296578+0.5137819i,-0.6429415+1.189691i,0.9631926+0.7940519i,1.19136+0.0184876i,0.9075643-0.6836984i,0.2986576-1.045419i,-0.3644182-0.984175i,-0.8514418-0.5755137i,-1.024977+0.02257679i,-0.8362495+0.6232663i,-0.3217947+1.029998i,0.3748613+1.065569i,0.9971731+0.6479516i,1.246954-0.1181827i,0.9370399-0.9222196i,0.1383939-1.364829i,-0.7996205-1.174608i,-1.407194-0.3905786i,-1.352371+0.6245587i,-0.6374226+1.36805i,0.395313+1.468743i,1.248949+0.879516i,1.527956-0.1154234i,1.116653-1.059191i,0.2050512-1.538014i,-0.814521-1.345669i,-1.50802-0.5496445i,-1.55914+0.5346164i},
    {0.642308-1.572227i,-0.5698954-1.609525i,-1.501046-0.8209665i,-1.662393+0.3912298i,-0.9679562+1.394369i,0.2122546+1.665589i,1.252673+1.077547i,1.616828-0.0365699i,1.147279-1.077595i,0.1334613-1.517465i,-0.8730327-1.178127i,-1.373093-0.2957782i,-1.173858+0.646102i,-0.4473987+1.193348i,0.40753+1.13973i,0.9908297+0.5833665i,1.080893-0.1711764i,0.6963168-0.7793166i,0.04736972-1.00098i,-0.5716991-0.7769396i,-0.9013352-0.2328752i,-0.8153425+0.3781476i,-0.3727536+0.7811603i,0.2049996+0.8030179i,0.6385375+0.4589895i,0.7349093-0.05464403i,0.07360365-0.6110048i,-0.2825466-0.4665501i,-0.437-0.1819244i,-0.3986051+0.07438673i,-0.2722014+0.2238205i,-0.1440211+0.29538i,-0.01389611+0.3445452i,0.1671923+0.3607956i,0.3965672+0.2599811i,0.562027-0.02283895i,0.4990368-0.4235982i,0.1314471-0.7337773i,-0.4197656-0.7183158i,-0.8641282-0.2920772i,-0.9087802+0.3795901i,-0.4573297+0.9447786i,0.2996202+1.065205i,0.9718457+0.6260722i,1.185467-0.1796341i,0.7964578-0.9457667i,-0.02309156-1.269386i,-0.8704628-0.9650403i,-1.317557-0.1632331i,-1.126573+0.7521185i,-0.3702511+1.330587i,0.597999+1.274503i},
    {-0.8157436+0.5794698i,-0.2383361+1.007296i,0.5045101+0.9351931i,1.017816+0.3656941i,1.009805-0.4129593i,0.4739428-0.9824345i,-0.3006471-1.038707i,-0.9003925-0.5663403i,-1.025953+0.1665162i,-0.6462984+0.7765854i,0.0138899+0.978694i,0.6205267+0.7154105i,0.904931+0.149515i,0.772355-0.4443617i,0.3128048-0.8115693i,-0.2605512-0.8129862i,-0.7033256-0.4639571i,-0.8315253+0.07990536i,-0.5920655+0.5827338i,-0.08952406+0.8224044i,0.4510997+0.6891176i,0.782118+0.2424992i,0.750833-0.3099397i,0.3757782-0.7104552i,-0.162287-0.7764249i,-0.6107216-0.4868869i,-0.5730541+0.4889246i,-0.129906+0.7267051i,0.3522581+0.6307865i,0.6564061+0.2597025i,0.6562834-0.2074692i,0.3692681-0.5583684i,-0.05970597-0.6465503i,-0.4340894-0.4541767i,-0.6007724-0.08774243i,-0.513119+0.2858916i,-0.232753+0.5213827i,0.1181889+0.5476504i,0.4143334+0.3730326i,0.5609999+0.06164828i,0.5047057-0.2883495i,0.2433065-0.5563449i,-0.153297-0.6214502i,-0.5351719-0.4145983i,-0.7146307+0.01813018i,-0.5633895+0.4963368i,-0.1109426+0.7745396i,0.4362239+0.6798597i,0.7924606+0.2314675i,0.7584144-0.3500381i,0.3445666-0.7629622i,-0.2338762-0.7986361i},
    {0.6435097-0.9498988i,-0.1791919-1.107161i,-0.8587005-0.664448i,-1.037354+0.09057496i,-0.6724387+0.7269594i,-0.01866131+0.9351865i,0.5625154+0.6765438i,0.8142552+0.1465259i,0.6833724-0.3791097i,0.2849671-0.6888458i,-0.1937725-0.6947166i,-0.5705119-0.4209959i,-0.7068041+0.02324647i,-0.5394199+0.4656174i,-0.1195001+0.7114236i,0.3745776+0.6263829i,0.6985717+0.2276388i,0.6726385-0.2929848i,0.3010503-0.6597748i,-0.2142031-0.6755694i,-0.5910264-0.344992i,-0.63936+0.1325536i,-0.3673631+0.4944077i,0.04603213+0.5733258i,0.3778951+0.3754947i,0.4889791+0.04231668i,0.1247968-0.3968019i,-0.1339963-0.3611593i,-0.3037497-0.1910608i,-0.3342399+0.03037186i,-0.231024+0.212238i,-0.05096026+0.2867292i,0.1208391+0.2377176i,0.213494+0.1085957i,0.2091504-0.02633447i,0.1452559-0.1128249i,0.07367992-0.1486074i,0.01216229-0.1656339i,-0.06335244-0.178606i,-0.1738563-0.1537201i,-0.2838715-0.03775358i,-0.3011774+0.1715003i,-0.1468518+0.3815318i,0.1568803+0.4435548i,0.4622389+0.2589833i,0.572176-0.1258555i,0.3726352-0.5178896i,-0.07385388-0.6823762i,-0.5440172-0.4887793i,-0.773734-0.001635211i,-0.6087964+0.5410752i,-0.09903334+0.8487784i},
    {-0.969987-0.9629523i,-1.328511-0.1423317i,-1.10706+0.7007608i,-0.4282795+1.216768i,0.4106307+1.20781i,1.061849+0.6920355i,1.25983-0.1115768i,0.9221619-0.8687683i,0.1851676-1.259631i,-0.6436068-1.109405i,-1.206348-0.469093i,-1.246915+0.3940207i,-0.7301062+1.101979i,0.1294537+1.329988i,0.9510885+0.9582512i,1.355578+0.1391398i,1.14375-0.7600795i,0.4000848-1.32189i,-0.5363092-1.277527i,-1.228329-0.6421189i,-1.352171+0.2873667i,-0.8555621+1.075897i,0.0207457+1.363109i,0.8679351+1.033186i,1.309624+0.2560045i,1.170525-0.6109477i,-0.315124-1.265554i,-1.028043-0.8062464i,-1.317859-0.005753109i,-1.059627+0.8185109i,-0.3351752+1.327604i,0.579082+1.282742i,1.294685+0.6554773i,1.462919-0.3218538i,0.9498066-1.218398i,-0.05728524-1.588408i,-1.097793-1.204039i,-1.650069-0.206531i,-1.408185+0.9326388i,-0.4637493+1.642921i,0.7247213+1.556945i,1.567119+0.7099149i,1.649332-0.4790226i,0.9407123-1.428069i,-0.2043729-1.687514i,-1.235614-1.15079i,-1.675283-0.08672125i,-1.333098+1.002509i,-0.3791132+1.616601i,0.7425578+1.479008i,1.514678+0.6567049i,1.579234-0.46888i},
    {-0.2643656-0.4835204i,-0.4970837-0.1735394i,-0.463557+0.1898819i,-0.2149442+0.424796i,0.1052351+0.4413233i,0.348276+0.2612341i,0.4217234-0.01858378i,0.3082915-0.2767105i,0.05987728-0.4066783i,-0.2175034-0.3487718i,-0.3942857-0.1200902i,-0.3736058+0.1744193i,-0.1545362+0.3792017i,0.1467064+0.3742997i,0.3542088+0.160149i,0.3453708-0.1295162i,0.139135-0.3125392i,-0.1155356-0.2861816i,-0.2502608-0.09841727i,-0.2015824+0.09736004i,-0.04782926+0.1679866i,0.0699006+0.1011273i,0.07136372-0.00242708i,-0.002945679-0.03209959i,-0.04432723+0.02983542i,0.01255613+0.09840399i,0.1756187-0.05686306i,0.09155641-0.1991393i,-0.0917999-0.2293534i,-0.2476038-0.101902i,-0.2592894+0.1089118i,-0.1114127+0.2653396i,0.1024694+0.269227i,0.2533572+0.1264752i,0.2653021-0.07079122i,0.1513424-0.2165848i,-0.01640231-0.2538334i,-0.1620958-0.1869687i,-0.2394821-0.05492415i,-0.2309545+0.09709038i,-0.1358539+0.22426i,0.02727059+0.2785169i,0.2076034+0.2193187i,0.3240734+0.04393461i,0.2998936-0.1873623i,0.1151547-0.3628543i,-0.1612559-0.3743352i,-0.3919896-0.1860873i,-0.4412072+0.1282095i,-0.2562079+0.4107409i,0.08906846+0.4998584i,0.4198776+0.3237396i},
    {0.04056894+0.2242462i,0.1214137+0.1283515i,0.1261244+0.05149843i,0.1219485+0.01720521i,0.1445851-0.02160632i,0.1549521-0.1121885i,0.08066434-0.2300769i,-0.09740671-0.2799824i,-0.2980191-0.175218i,-0.3828359+0.07323898i,-0.2603023+0.3393993i,0.03428036+0.4580178i,0.3482751+0.337251i,0.5044704+0.02383368i,0.4089482-0.3231237i,0.1025942-0.5248693i,-0.2670374-0.4779356i,-0.5240405-0.1996172i,-0.5448064+0.1867508i,-0.308784+0.5070539i,0.09084173+0.607415i,0.4776165+0.4214639i,0.6611412+0.01230825i,0.5284142-0.4372608i,0.1161623-0.7000902i,-0.3855299-0.6217453i,-0.6963376+0.3210144i,-0.3127386+0.7138391i,0.2428096+0.7503038i,0.6848232+0.4037308i,0.7844217-0.1518223i,0.4894593-0.6344082i,-0.05142892-0.8008255i,-0.5674069-0.5682665i,-0.8014839-0.05277514i,-0.6366705+0.4893005i,-0.1540613+0.7870575i,0.4047185+0.6897907i,0.7565675+0.24611i,0.7225592-0.3164325i,0.3244604-0.7080054i,-0.2252274-0.7312844i,-0.6396536-0.3873429i,-0.7149884+0.1306867i,-0.435587+0.5516207i,0.03259774+0.6760045i,0.4469951+0.4716213i,0.6195725+0.06755833i,0.4979136-0.3321342i,0.1656162-0.5525135i,-0.215899-0.5154096i,-0.481399-0.2546678i},
    {0.8803592-0.7271015i,0.1752373-1.089717i,-0.5603731-0.8992981i,-0.9649306-0.3011683i,-0.8827413+0.3747415i,-0.4131238+0.806017i,0.1799046+0.8335242i,0.6220427+0.5056022i,0.7537794+0.0135934i,0.5724697-0.4216226i,0.195769-0.6449727i,-0.2122476-0.6081236i,-0.5085165-0.3583013i,-0.6086581+0.0002631608i,-0.495066+0.3466892i,-0.2086185+0.5726792i,0.1634985+0.6020449i,0.5015472+0.408573i,0.6767671+0.03485732i,0.5930587-0.3990173i,0.2401309-0.7175903i,-0.2704429-0.7546673i,-0.7231619-0.4427722i,-0.8855751+0.1218369i,-0.6330757+0.6923117i,-0.04089013+0.9785156i,1.027992+0.2122846i,0.9440581-0.5203155i,0.3872289-1.031342i,-0.3828287-1.053748i,-0.989292-0.5604691i,-1.12925+0.2176058i,-0.7260553+0.9057953i,0.03293954+1.169739i,0.7871773+0.8770146i,1.174918+0.1609144i,1.005504-0.6408481i,0.3530072-1.144363i,-0.473983-1.103529i,-1.077379-0.5332114i,-1.164105+0.2925873i,-0.693565+0.9734589i,0.1012238+1.18255i,0.8332143+0.8290667i,1.157537+0.09654332i,0.9377063-0.6594504i,0.2971909-1.091536i,-0.4579781-1.019748i,-0.9904859-0.4961431i,-1.076521+0.2378092i,-0.6869796+0.8627323i,0.01056874+1.109117i},
    {-0.2480655-1.059183i,-0.8237342-0.6768855i,-1.050257-0.04115737i,-0.8575749+0.5951709i,-0.3278092+0.9927872i,0.3404027+0.9998138i,0.8927269+0.5991555i,1.098352-0.0736284i,0.8406894-0.7563336i,0.1905371-1.146767i,-0.5886277-1.037653i,-1.137971-0.439266i,-1.177229+0.3926554i,-0.6632919+1.065708i,0.1698634+1.2508i,0.9266467+0.8576941i,1.255604+0.07849216i,1.021438-0.7224327i,0.3493621-1.195218i,-0.4609769-1.155813i,-1.078693-0.6360402i,-1.26229+0.1564718i,-0.9271318+0.9185109i,-0.1720339+1.340509i,0.7279407+1.206836i,1.387102+0.5032288i,0.8166642-1.395781i,-0.298521-1.657988i,-1.358731-1.095609i,-1.795469+0.07236057i,-1.328907+1.268908i,-0.1582255+1.859311i,1.122574+1.511408i,1.846882+0.392418i,1.642984-0.9212807i,0.6281498-1.762621i,-0.6727132-1.726548i,-1.616565-0.8604304i,-1.765773+0.3901203i,-1.080704+1.421948i,0.09049617+1.76325i,1.192621+1.277462i,1.719634+0.207968i,1.437933-0.9409835i,0.4884542-1.633965i,-0.6769539-1.550329i,-1.504966-0.7374403i,-1.605971+0.4080897i,-0.9455527+1.332764i,0.1405982+1.600686i,1.12041+1.107292i,1.535119+0.1193016i},
    {0.7524114+1.00456i,1.187408+0.2648554i,1.040789-0.5435196i,0.4382127-1.042445i,-0.3051797-1.046242i,-0.8615405-0.6081482i,-1.026445+0.05133325i,-0.7667455+0.6590737i,-0.2009858+0.9845966i,0.4486177+0.9026262i,0.9204878+0.4342422i,1.002634-0.2406332i,0.6332575-0.8307546i,-0.04122726-1.054405i,-0.7104394-0.7875543i,-1.049122-0.147681i,-0.8925499+0.5553985i,-0.3268927+0.9836696i,0.3648076+0.949311i,0.8615553+0.497677i,0.9630177-0.1429693i,0.659499-0.6923604i,0.1001722-0.9406717i,-0.4898776-0.8084908i,-0.8887863-0.3500058i,-0.9371737+0.2694981i,0.04559491+1.035529i,0.711383+0.8018373i,1.093073+0.1704008i,0.9734225-0.5875049i,0.3707885-1.101292i,-0.4395642-1.095286i,-1.055682-0.5512009i,-1.163777+0.2683509i,-0.7093434+0.9568133i,0.07737762+1.179796i,0.8101641+0.8434455i,1.147236+0.1266266i,0.9510425-0.6248553i,0.3342665-1.0712i,-0.4117762-1.028541i,-0.9566572-0.5348789i,-1.071706+0.181729i,-0.7183036+0.8079165i,-0.05583024+1.076853i,0.6290286+0.8764352i,1.042268+0.2931306i,1.004057-0.4248042i,0.5235345-0.9692742i,-0.2019357-1.09872i,-0.862495-0.7404597i,-1.159788-0.03035687i},
    {-0.2770382+0.5499897i,0.1115565+0.6112103i,0.4664038+0.428606i,0.6497101+0.06028676i,0.5726415-0.3630376i,0.2357397-0.6684284i,-0.2462799-0.7010432i,-0.66558-0.4044428i,-0.8049821+0.1216058i,-0.5568898+0.6382769i,-0.007235455+0.8761104i,0.5831326+0.6857781i,0.9080278+0.1384136i,0.7869173-0.4974012i,0.2715063-0.8976067i,-0.3803397-0.8594283i,-0.845788-0.4064297i,-0.90517+0.2343736i,-0.5421496+0.7575819i,0.06567106+0.9275612i,0.6412333+0.6755999i,0.9301509+0.1161144i,0.8011834-0.5067452i,0.29894-0.9153599i,-0.3641354-0.9110653i,-0.8837631-0.4700712i,-0.6179705+0.8341104i,0.08587996+1.048027i,0.7640625+0.7339163i,1.059856+0.04069458i,0.8129714-0.6714026i,0.1569377-1.028464i,-0.5553513-0.8541111i,-0.9546142-0.2631115i,-0.8595621+0.4175888i,-0.3594345+0.8429314i,0.2626847+0.8336126i,0.7010275+0.4451011i,0.7812819-0.09781779i,0.5178304-0.5381857i,0.06811929-0.70724i,-0.3639801-0.5740547i,-0.6152468-0.2257593i,-0.60964+0.1871874i,-0.3664899+0.5081849i,0.01521698+0.6208691i,0.3885545+0.4833523i,0.6053442+0.1459081i,0.5714235-0.2591474i,0.2911788-0.5625216i,-0.1235803-0.6276891i,-0.4937393-0.416115i},
    {1.345374-0.06174972i,0.9644752-0.8988024i,0.1565594-1.280271i,-0.6840008-1.061839i,-1.18109-0.3766903i,-1.134411+0.4507237i,-0.5857151+1.054504i,0.2126738+1.17694i,0.9056264+0.7702314i,1.183264+0.01805695i,0.9183058-0.737783i,0.2321756-1.147786i,-0.5531119-1.021172i,-1.067123-0.4235276i,-1.074258+0.3537265i,-0.5886018+0.941442i,0.1430194+1.077326i,0.7750843+0.7254726i,1.033765+0.07337302i,0.8326066-0.5762917i,0.2872975-0.9493199i,-0.3561262-0.907977i,-0.8306906-0.4886308i,-0.9487916+0.1268985i,-0.6665027+0.6844231i,-0.09944485+0.9519082i,0.9147658+0.312553i,0.9137453-0.3317914i,0.5042543-0.8364739i,-0.1358961-0.9704354i,-0.7186596-0.6684653i,-0.9793508-0.0654663i,-0.8006265+0.5657588i,-0.265364+0.9416775i,0.3846434+0.8970133i,0.8604318+0.4558259i,0.9542822-0.1837036i,0.6284413-0.7395288i,0.02830883-0.9694915i,-0.5831819-0.7753628i,-0.9406283-0.2432983i,-0.8903967+0.395833i,-0.4543864+0.8674561i,0.182592+0.9698179i,0.7523459+0.6558727i,1.012624+0.05005137i,0.8426756-0.6007276i,0.2936074-1.020131i,-0.4209014-1.009529i,-0.9950333-0.5374163i,-1.150316+0.2231568i,-0.7691538+0.9402551i},
    {0.5359957+0.2467981i,0.5897101-0.1306245i,0.3987992-0.4799587i,0.0141404-0.6476843i,-0.4134609-0.5309159i,-0.6808056-0.1486328i,-0.6338282+0.3363267i,-0.2679389+0.6827152i,0.2469418+0.7012266i,0.6489454+0.3702657i,0.7306826-0.1434902i,0.4562872-0.5782189i,-0.02537002-0.7236642i,-0.4730987-0.5279012i,-0.6847199-0.1056528i,-0.5868007+0.3397982i,-0.2449171+0.6200978i,0.1872087+0.6333115i,0.5362222+0.3851378i,0.6658508-0.02542763i,0.5174038-0.438473i,0.1357965-0.6811603i,-0.3305941-0.6326147i,-0.675213-0.2882833i,-0.7229429+0.2148368i,-0.4260226+0.6444795i,0.5871336+0.5450935i,0.8099272+0.03412253i,0.6430686-0.5038141i,0.1628266-0.8039279i,-0.3977268-0.718224i,-0.7668295-0.2892139i,-0.7689118+0.2741014i,-0.4079004+0.7015864i,0.1392359+0.7933561i,0.611508+0.5130879i,0.7899415+0.0005206577i,0.5995626-0.499965i,0.1395053-0.7578645i,-0.3705477-0.6635703i,-0.6978635-0.2729908i,-0.7032678+0.2275298i,-0.396942+0.6127068i,0.07636069+0.7186081i,0.5071961+0.5074699i,0.7107301+0.07611888i,0.6002911-0.3876115i,0.2219471-0.6810995i,-0.2607245-0.6705055i,-0.6307445-0.3528346i,-0.7128868+0.1326673i,-0.4613189+0.5598969i},
    {-0.2316827+0.05768696i,-0.1882811+0.2014279i,-0.03771516+0.3210853i,0.2016034+0.3175169i,0.4121112+0.1223292i,0.4332112-0.2097184i,0.1886803-0.492971i,-0.2201435-0.5231717i,-0.5511377-0.2351931i,-0.5802726+0.2236833i,-0.2660882+0.5769166i,0.2107367+0.6040561i,0.5663263+0.2893758i,0.6003159-0.1747537i,0.3136189-0.5223326i,-0.1148295-0.5788016i,-0.4540153-0.3445528i,-0.5498064+0.03655125i,-0.3827013+0.3739197i,-0.04921382+0.5207621i,0.2944433+0.4227942i,0.4939583+0.1292217i,0.4551966-0.2244193i,0.19152-0.4661244i,-0.166987-0.4688847i,-0.4299897-0.2287046i,-0.2397287+0.3772789i,0.07485659+0.4097913i,0.3021285+0.2297057i,0.3360562-0.02549911i,0.2078141-0.2037752i,0.03411391-0.2425052i,-0.08761323-0.184027i,-0.1413854-0.1045695i,-0.1657681-0.0357335i,-0.1808091+0.04508455i,-0.1530216+0.1556008i,-0.03714667+0.2533113i,0.1506947+0.2518209i,0.3108318+0.1012976i,0.3236458-0.1442093i,0.1488754-0.3437723i,-0.1280832-0.3657717i,-0.3470476-0.1853284i,-0.3811784+0.09624881i,-0.2172116+0.3214961i,0.04715376+0.3766956i,0.2733793+0.2491148i,0.3600379+0.01528411i,0.2814424-0.2121691i,0.08262268-0.336784i,-0.1474013-0.309833i},
    {0.2096732+0.2216078i,0.2948909+0.06133083i,0.2799651-0.117094i,0.1691986-0.2632096i,-0.01431048-0.3290754i,-0.2200663-0.2743719i,-0.3670153-0.09070972i,-0.3695267+0.1690363i,-0.1908484+0.390576i,0.1120479+0.4477348i,0.3961678+0.2808882i,0.5037451-0.04960673i,0.3579159-0.3809479i,0.01846675-0.5347888i,-0.3437806-0.4210337i,-0.5406979-0.09209817i,-0.4705552+0.2857105i,-0.1701779+0.5233546i,0.2098079+0.5070195i,0.4857096+0.2502187i,0.5303929-0.1204671i,0.3285639-0.4307436i,-0.02242863-0.5397447i,-0.3607474-0.4010584i,-0.5335004-0.08011788i,-0.4639258+0.2771696i,0.1810623+0.5145302i,0.4692072+0.2871463i,0.5517417-0.07392899i,0.3877127-0.4118185i,0.04138572-0.5757731i,-0.3411244-0.4835486i,-0.5875536-0.1601513i,-0.5713175+0.2618319i,-0.2758318+0.5878772i,0.1793285+0.6462397i,0.5766658+0.3808537i,0.7024451-0.09853972i,0.467878-0.5526538i,-0.02292636-0.7339388i,-0.5136699-0.5312042i,-0.735933-0.04602874i,-0.5678706+0.457477i,-0.1086549+0.7061518i,0.3829285+0.5780972i,0.6456937+0.1662921i,0.5649232-0.2910637i,0.22012-0.5591541i,-0.1857543-0.533146i,-0.453928-0.2700213i,-0.4878902+0.07363508i,-0.3138843+0.3388549i},
    {0.6480816+0.06632747i,0.4794256-0.3607353i,0.1009255-0.5377918i,-0.2569982-0.4224698i,-0.4232669-0.131679i,-0.3617643+0.1576723i,-0.1541879+0.31346i,0.07208738+0.29911i,0.214858+0.1625842i,0.2337551-0.007948028i,0.1512272-0.1307443i,0.03009197-0.1634673i,-0.06143495-0.1164009i,-0.08607309-0.04100716i,-0.0574953+0.005325791i,-0.02702506+0.0009354349i,-0.0396581-0.0226681i,-0.09011995-0.007505308i,-0.1184287+0.07473112i,-0.05757857+0.1827234i,0.09948187+0.2225618i,0.2707264+0.1188333i,0.3278011-0.1119039i,0.188284-0.3475341i,-0.1091633-0.4281213i,-0.4075483-0.2643081i,-0.345987+0.447247i,0.04981292+0.5993924i,0.4655749+0.4321285i,0.6669385+0.006514618i,0.5204005-0.4635679i,0.07677753-0.7211047i,-0.4434103-0.6069523i,-0.7603276-0.1561172i,-0.6867132+0.4073105i,-0.2394189+0.7821313i,0.3566397+0.7543051i,0.7834998+0.3225226i,0.8052729-0.291669i,0.4030267-0.7618163i,-0.2120177-0.8372072i,-0.7160437-0.4803916i,-0.8503491+0.1176584i,-0.5552926+0.6477073i,0.01010344+0.8474271i,0.5612773+0.628443i,0.8327318+0.1066902i,0.6993033-0.4637329i,0.2260961-0.8106957i,-0.3633564-0.7651598i,-0.78443-0.3394565i,-0.8209507+0.2680732i},
    {-0.5274798+0.08031563i,-0.3663248+0.4072772i,-0.02430953+0.5609471i,0.3465276+0.458625i,0.5723633+0.1356042i,0.539718-0.2668886i,0.2506847-0.563691i,-0.172908-0.6088454i,-0.538049-0.3648714i,-0.6643655+0.07083601i,-0.4717985+0.4985424i,-0.03250938+0.7032649i,0.4472418+0.5641981i,0.7213441+0.1310578i,0.6351639-0.3846839i,0.2205615-0.714081i,-0.3100904-0.6795231i,-0.6779326-0.2990849i,-0.6948956+0.2222527i,-0.3667538+0.611669i,0.1207917+0.6821063i,0.5173004+0.4248609i,0.6448137-0.007357711i,0.4746372-0.4002651i,0.1136623-0.5884678i,-0.2687722-0.5161158i,-0.5474832+0.132449i,-0.3484963+0.4410688i,0.0006629905+0.5651565i,0.3580649+0.4444181i,0.5645898+0.119016i,0.515336-0.2711052i,0.2217895-0.5415717i,-0.180039-0.5564362i,-0.4936173-0.305797i,-0.5664629+0.08443736i,-0.3714875+0.421019i,-0.0152129+0.5475774i,0.3272238+0.420452i,0.5044346+0.1166168i,0.4541358-0.2184119i,0.2153968-0.4427904i,-0.1023963-0.4728697i,-0.3680848-0.3055497i,-0.4755354-0.01282535i,-0.3805034+0.2844307i,-0.1204384+0.4599529i,0.1942803+0.4344425i,0.4238284+0.215708i,0.4634865-0.09880715i,0.2961796-0.3659086i,0.001204858-0.4663542i},
    {-0.2586657-0.7923351i,-0.7789087-0.4565473i,-0.9477558+0.1974376i,-0.5985422+0.8344878i,0.1356411+1.068966i,0.8604904+0.7145661i,1.146929-0.06871107i,0.8038324-0.8482932i,0.009368464-1.177679i,-0.792918-0.8697401i,-1.16295-0.1038376i,-0.9182378+0.6946786i,-0.216914+1.109557i,0.5597385+0.9555478i,1.027662+0.3461887i,0.9859055-0.3993705i,0.4841712-0.9284104i,-0.2280758-1.009979i,-0.8215721-0.6191692i,-1.024433+0.06103039i,-0.7373123+0.7138127i,-0.08849388+1.02277i,0.6080253+0.8251975i,0.9971766+0.211099i,0.8724681-0.5038084i,0.3021872-0.9408336i,-0.8500163-0.3617195i,-0.8289484+0.290693i,-0.393016+0.7254016i,0.178399+0.7435384i,0.5722694+0.4010517i,0.6262531-0.06348687i,0.3907938-0.3996276i,0.04993614-0.4875433i,-0.2186001-0.3660463i,-0.3376698-0.155883i,-0.3290465+0.04060042i,-0.2476962+0.1854634i,-0.1241895+0.2807833i,0.03787864+0.3193254i,0.2217636+0.2676781i,0.3662603+0.09974775i,0.3839737-0.1528279i,0.2230572-0.3858719i,-0.07564338-0.4689277i,-0.3771538-0.3280702i,-0.5194824-0.007330505i,-0.4109773+0.3400876i,-0.09336963+0.533223i,0.2749963+0.4684666i,0.5084182+0.1802492i,0.4984735-0.1822446i},
    {0.2239813-0.03962663i,0.09983803-0.1256345i,-0.0003804502-0.08911188i,0.0003399829-0.02007713i,0.06488919-0.02662858i,0.07750675-0.1291287i,-0.04422432-0.2282881i,-0.2543642-0.1839373i,-0.3895416+0.05306398i,-0.2913391+0.3672776i,0.05124101+0.5371352i,0.4580757+0.3942353i,0.6614015-0.0347917i,0.4900478-0.5177402i,0.001044044-0.7558489i,-0.5397643-0.5787047i,-0.8176836-0.06019031i,-0.6615409+0.5213629i,-0.1442255+0.8474627i,0.4638594+0.7398872i,0.8480693+0.2514467i,0.8138275-0.3721946i,0.3767764-0.8233938i,-0.2537619-0.8815227i,-0.7771552-0.5125155i,-0.9393018+0.1169483i,-0.03018599+0.9824523i,0.6305006+0.7795784i,1.006414+0.1807489i,0.8949576-0.5335611i,0.329228-1.007966i,-0.4232998-0.9907749i,-0.9860041-0.4711549i,-1.064116+0.3027067i,-0.6024857+0.9416907i,0.1761665+1.113631i,0.8779638+0.7190475i,1.138723-0.04922262i,0.816346-0.7986339i,0.07215193-1.138902i,-0.7074245-0.889869i,-1.113557-0.1825324i,-0.9358139+0.6073221i,-0.2779231+1.062287i,0.5004699+0.9519788i,0.9856241+0.3562186i,0.9384677-0.3886318i,0.4170643-0.8858678i,-0.2740282-0.8979022i,-0.7676432-0.4611489i,-0.8349858+0.1601897i,-0.4891715+0.6378785i},
    {-0.3953157+0.2572744i,-0.102872+0.4060753i,0.1669635+0.3313842i,0.3027493+0.1368675i,0.2987148-0.06784115i,0.1935809-0.2232738i,0.02105571-0.298212i,-0.1776912-0.2575825i,-0.3218117-0.08396686i,-0.3118861+0.1666597i,-0.1124592+0.3555059i,0.1821657+0.3428803i,0.3839622+0.1071247i,0.3439828-0.2107511i,0.07649096-0.3952391i,-0.2381419-0.3169325i,-0.3841164-0.03361681i,-0.2704329+0.2537503i,0.008422396+0.3530616i,0.2536166+0.2167373i,0.3106628-0.0406284i,0.1674217-0.2409211i,-0.060418-0.2682018i,-0.2240372-0.1298134i,-0.2356368+0.07151219i,-0.1052618+0.212927i,0.2152259+0.08974761i,0.2161555-0.09839233i,0.07648747-0.2334214i,-0.1265121-0.2236728i,-0.2641084-0.05948178i,-0.2337084+0.1648201i,-0.0366349+0.2995354i,0.2067199+0.2404433i,0.3308232+0.01124624i,0.2423368-0.2423826i,-0.008729953-0.3516338i,-0.262419-0.2432119i,-0.3609028+0.01344486i,-0.2511103+0.2616111i,-0.005018285+0.3635754i,0.2413229+0.2752517i,0.3689977+0.04911929i,0.3221387-0.2096501i,0.1139475-0.3874508i,-0.1791439-0.3922006i,-0.4260012-0.1877148i,-0.4782399+0.1627851i,-0.2546484+0.4851225i,0.1695161+0.5663766i,0.5573376+0.2994577i,0.6393571-0.2008322i},
    {-1.287647-0.6984696i,-1.432329+0.3219248i,-0.8663709+1.18323i,0.1236887+1.45542i,1.041336+1.01071i,1.436462+0.08108877i,1.128322-0.8688456i,0.2843513-1.378742i,-0.6746096-1.215546i,-1.286077-0.4766964i,-1.268225+0.4681392i,-0.6485249+1.16212i,0.2584117+1.282328i,1.010266+0.791354i,1.254976-0.05314337i,0.8988971-0.8341417i,0.1413102-1.18553i,-0.6384232-0.9675992i,-1.076331-0.3194985i,-0.9965035+0.4296061i,-0.476145+0.9328056i,0.2163359+0.9865544i,0.7628522+0.6055225i,0.9396342-0.009055635i,0.7012865-0.5756604i,0.1810459-0.8577158i,-0.7424687-0.3435437i,-0.7669337+0.1845891i,-0.4703233+0.5954818i,-0.005630258+0.7279297i,0.4190336+0.5567i,0.640095+0.1862505i,0.6017637-0.2171208i,0.3541733-0.5076976i,0.003671115-0.6078418i,-0.3389098-0.5061918i,-0.5792595-0.2338478i,-0.6380081+0.1447427i,-0.461473+0.5208035i,-0.06262694+0.7437908i,0.4363906+0.6734058i,0.8165117+0.2716906i,0.8570356-0.328366i,0.4731035-0.8490284i,-0.1976393-1.002072i,-0.835624-0.6604519i,-1.101904+0.04458607i,-0.830133+0.7735437i,-0.1296179+1.154181i,0.6640533+0.9804664i,1.160476+0.3217015i,1.110389-0.5126827i},
    {-0.184544+0.003375458i,-0.1583123+0.1097445i,-0.06320611+0.1897771i,0.0709876+0.1890052i,0.1706004+0.09575448i,0.1770802-0.03402268i,0.1009575-0.1195215i,0.01067324-0.1259268i,-0.03583747-0.08949669i,-0.0457047-0.06883572i,-0.07215923-0.07359235i,-0.1398932-0.04973207i,-0.1958746+0.05614717i,-0.1468327+0.2165606i,0.04279983+0.315424i,0.2866891+0.2359724i,0.4180431-0.02746264i,0.3135486-0.3367676i,-0.001512549-0.49444i,-0.3559327-0.3819258i,-0.5420859-0.04417499i,-0.4473349+0.3391772i,-0.1155136+0.5648808i,0.2887249+0.5165168i,0.570828+0.2125194i,0.5933129-0.2131569i,-0.1246256-0.6764014i,-0.5640663-0.4518427i,-0.7589698+0.03512583i,-0.5684879+0.5583825i,-0.0469082+0.830435i,0.5476185+0.6663901i,0.8796163+0.1185487i,0.7383242-0.5246729i,0.1822495-0.8982617i,-0.4823656-0.7834197i,-0.8837116-0.2437631i,-0.8064904+0.4167279i,-0.3088867+0.839776i,0.3292832+0.8155042i,0.7755163+0.3802294i,0.8181038-0.2274758i,0.455178-0.7023363i,-0.1230456-0.8184115i,-0.6303694-0.5258224i,-0.8152457+0.02885822i,-0.5809188+0.5653931i,-0.04476027+0.8023955i,0.5073307+0.6092612i,0.7708861+0.09294529i,0.6033301-0.4508668i,0.1174704-0.7124841i},
    {-0.3688629-0.01545956i,-0.2637538+0.2037363i,-0.07257001+0.2864375i,0.09339671+0.2429149i,0.1860237+0.1415281i,0.2204485+0.03322802i,0.2184796-0.07809375i,0.1652458-0.1994867i,0.02836692-0.2966304i,-0.1800794-0.2917029i,-0.3677787-0.1269431i,-0.4032171+0.1599169i,-0.2139929+0.4239892i,0.1355809+0.4929399i,0.4589479+0.2880993i,0.5567433-0.1038693i,0.349114-0.4686982i,-0.06277533-0.5927891i,-0.4516979-0.3972254i,-0.6008192+0.01187409i,-0.43241+0.4083714i,-0.04789122+0.5815443i,0.3404817+0.4544292i,0.5364075+0.1148038i,0.4632869-0.2506573i,0.187001-0.4677857i,-0.3794619-0.2628018i,-0.4462815+0.01982589i,-0.3405524+0.2770395i,-0.1108097+0.4259002i,0.1679414+0.4180441i,0.402506+0.2419035i,0.4917763-0.06077355i,0.3641791-0.3792062i,0.0359326-0.5564631i,-0.3572124-0.4676774i,-0.6051415-0.1153189i,-0.543235+0.3350551i,-0.1736765+0.6300526i,0.3085976+0.5842317i,0.624189+0.2113074i,0.5881185-0.2719885i,0.2324199-0.5831344i,-0.2193762-0.5572334i,-0.5066617-0.2439818i,-0.4985726+0.1469383i,-0.2537731+0.3995658i,0.05463254+0.4224706i,0.2713904+0.268137i,0.3404592+0.05287869i,0.2900488-0.1350127i,0.1664692-0.2628271i},
    {0.4649915-0.799987i,-0.1874744-0.965921i,-0.8226229-0.6310112i,-1.079322+0.08100659i,-0.7745373+0.808561i,-0.03535505+1.147514i,0.753714+0.891247i,1.166146+0.1616404i,0.9793321-0.6561703i,0.2977937-1.134393i,-0.51691-1.039252i,-1.055104-0.4429478i,-1.073181+0.3402919i,-0.5947191+0.9345532i,0.1341758+1.084235i,0.7817808+0.7486935i,1.075635+0.09041534i,0.898258-0.6076066i,0.3201128-1.049945i,-0.4234374-1.034878i,-1.008574-0.5404312i,-1.148827+0.2400464i,-0.7372525+0.9516011i,0.06650516+1.230286i,0.8779862+0.8983448i,1.270637+0.09056795i,0.2273273-1.263735i,-0.6745558-1.081306i,-1.206938-0.34254i,-1.097694+0.5429624i,-0.4369846+1.101706i,0.3928266+1.067392i,0.9536568+0.5125338i,0.9971637-0.2280429i,0.5711173-0.772051i,-0.05507242-0.8957263i,-0.5687931-0.6137972i,-0.7723553-0.1173419i,-0.6401669+0.3571056i,-0.2788975+0.6356203i,0.1501051+0.6482092i,0.4924778+0.4187869i,0.6346352+0.040495i,0.5269072-0.3478419i,0.2053662-0.5956143i,-0.2046434-0.5950187i,-0.5277144-0.3381231i,-0.6176666+0.06427708i,-0.4354421+0.4288475i,-0.07272059+0.5927423i,0.2990358+0.4968027i,0.5216383+0.2059416i},
    {-0.1536636+1.025948i,0.5789108+0.8963233i,1.048132+0.2951789i,0.9950215-0.4772505i,0.437429-1.022414i,-0.3421767-1.062174i,-0.95395-0.58098i,-1.102385+0.1794908i,-0.723241+0.851778i,-0.0004672032+1.119616i,0.7264391+0.8577796i,1.115389+0.1846019i,0.9749953-0.587496i,0.3595672-1.088135i,-0.4417246-1.063968i,-1.033898-0.5142341i,-1.114917+0.2925142i,-0.6413894+0.9481444i,0.1405957+1.121507i,0.8280567+0.7382014i,1.082297+0.01423101i,0.8054042-0.6745327i,0.1710414-1.000906i,-0.4931875-0.8455787i,-0.8848886-0.326178i,-0.8611976+0.2940034i,0.08971528+0.8531587i,0.5867509+0.6011612i,0.8203287+0.1065567i,0.7014046-0.4212832i,0.2836716-0.7602463i,-0.2522282-0.7649212i,-0.670703-0.4340931i,-0.7868542+0.08249903i,-0.554309+0.5516006i,-0.08558025+0.7670627i,0.4063765+0.6440054i,0.7098778+0.2486468i,0.7043883-0.2424282i,0.4011138-0.6226553i,-0.07031364-0.7363261i,-0.5136304-0.5349572i,-0.7390357-0.09808068i,-0.6406529+0.3898059i,-0.2518514+0.7098213i,0.2555784+0.7090315i,0.6449904+0.3831469i,0.7334714-0.1125456i,0.4883378-0.5416433i,0.03947263-0.7117118i,-0.3997083-0.5679221i,-0.6466573-0.2005852i},
    {-1.388685-0.631823i,-1.460167+0.4262936i,-0.8255543+1.26765i,0.1950214+1.488488i,1.102967+0.9976438i,1.470963+0.04803098i,1.143483-0.9010455i,0.2945815-1.410089i,-0.6706806-1.259386i,-1.310436-0.5352386i,-1.342094+0.4226721i,-0.7595758+1.17788i,0.1690294+1.38835i,1.018705+0.9566013i,1.394772+0.07811683i,1.115627-0.8388399i,0.3076733-1.358142i,-0.6434473-1.227403i,-1.276117-0.5105549i,-1.285291+0.4369721i,-0.6802493+1.14819i,0.2236257+1.286185i,0.976644+0.8128674i,1.230955-0.008119036i,0.9067078-0.7671881i,0.2036258-1.124277i,-0.9738788-0.4040682i,-0.9775836+0.2743446i,-0.5841509+0.789359i,0.01698912+0.9552733i,0.5808901+0.7339712i,0.894635+0.2289288i,0.8439103-0.3580927i,0.4506607-0.7957211i,-0.1293419-0.9059653i,-0.6591966-0.6380372i,-0.9149601-0.09838776i,-0.7841271+0.4871408i,-0.3192024+0.869337i,0.2837477+0.8852503i,0.7713484+0.5277011i,0.9404546-0.05567594i,0.7184011-0.6266401i,0.1880957-0.9507081i,-0.4433772-0.8854259i,-0.9181041-0.4368974i,-1.022599+0.231175i,-0.6793293+0.845323i,0.0001140824+1.123926i,0.7354683+0.9043108i,1.184311+0.2399545i,1.10197-0.5922334i},
    {0.4669266+0.9881173i,0.9760011+0.4543627i,1.022955-0.2655293i,0.6118611-0.8348624i,-0.04622886-1.011975i,-0.6524967-0.7483086i,-0.9593201-0.1829698i,-0.8606257+0.4392149i,-0.4111961+0.8706812i,0.2077192+0.9444159i,0.7517467+0.6254371i,0.9937856+0.02874218i,0.8121122-0.6070158i,0.258292-1.002079i,-0.4393838-0.9591231i,-0.9633809-0.4718711i,-1.05783+0.2506315i,-0.6638227+0.8743672i,0.04263895+1.104389i,0.7359127+0.8314946i,1.100068+0.1811191i,0.974052-0.5539284i,0.4143445-1.050452i,-0.3390986-1.090934i,-0.963782-0.6474308i,-1.180493+0.105521i,-0.1314202+1.239284i,0.7134909+1.0622i,1.262259+0.3573945i,1.217016-0.5628384i,0.561066-1.243825i,-0.399854-1.32206i,-1.179458-0.7351526i,-1.371287+0.2258483i,-0.8763939+1.06737i,0.04199364+1.363641i,0.9097167+0.9845504i,1.30267+0.1491499i,1.060842-0.712948i,0.3425756-1.195277i,-0.4871889-1.106387i,-1.050016-0.5306207i,-1.121165+0.2448227i,-0.7036945+0.8754617i,-0.001299102+1.103825i,0.6791332+0.8517216i,1.052363+0.2394959i,0.9658372-0.4672343i,0.4602994-0.9653688i,-0.2451595-1.039799i,-0.843359-0.6566734i,-1.070702+0.01846074i},
    {1.169137-0.05601429i,0.8369135-0.7617223i,0.162396-1.089402i,-0.5496936-0.9309013i,-1.003594-0.372494i,-1.010322+0.3469018i,-0.5574173+0.9153576i,0.1660313+1.064949i,0.8246233+0.7022195i,1.084305-0.01521317i,0.7959798-0.7284629i,0.1023407-1.059796i,-0.6226317-0.8331329i,-0.9865247-0.187708i,-0.8137943+0.5033693i,-0.2448891+0.8644007i,0.3689903+0.7431096i,0.6983423+0.2791166i,0.6298876-0.2208962i,0.2952886-0.4976125i,-0.06382283-0.4849208i,-0.2745388-0.2968774i,-0.3194071-0.09463956i,-0.2854827+0.04297682i,-0.2450376+0.1437774i,-0.1831367+0.2609886i,0.2221195+0.390905i,0.4816105+0.2033646i,0.5692015-0.1671293i,0.3615773-0.5497585i,-0.09439283-0.709088i,-0.5752253-0.5031091i,-0.8040754+0.002790728i,-0.6248543+0.5537977i,-0.108088+0.8503665i,0.4838092+0.7251551i,0.847125+0.2378055i,0.8038722-0.3664416i,0.3848608-0.7967023i,-0.2060326-0.8622903i,-0.7046654-0.5463291i,-0.9027185+0.01027734i,-0.7174011+0.5794531i,-0.2098553+0.9277619i,0.4315564+0.8909824i,0.9393716+0.4406689i,1.057585-0.272252i,0.6668383-0.9379203i,-0.1120688-1.205726i,-0.9215972-0.873004i,-1.322935-0.0407i,-1.04564+0.8863921i},
    {0.926676-1.268339i,-0.1441288-1.57491i,-1.149352-1.094496i,-1.588297-0.07357678i,-1.25352+0.9823313i,-0.3142047+1.565832i,0.7812401+1.402156i,1.516092+0.564202i,1.534791-0.5626897i,0.8062425-1.445526i,-0.3429373-1.64186i,-1.356931-1.021895i,-1.711352+0.135166i,-1.194726+1.24932i,-0.0522201+1.731361i,1.119201+1.313016i,1.69298+0.2158734i,1.37138-0.9628379i,0.3563815-1.592696i,-0.7787599-1.370914i,-1.433611-0.476205i,-1.317927+0.5697045i,-0.5774034+1.225159i,0.3433746+1.221751i,0.9814425+0.6599056i,1.092331-0.1117782i,0.1106273-0.9383346i,-0.4528574-0.7552172i,-0.7662652-0.3093942i,-0.7572518+0.1972444i,-0.4724004+0.5806919i,-0.03800228+0.7224751i,0.3853214+0.5913721i,0.6492326+0.245866i,0.6622705-0.1843567i,0.4213928-0.539474i,0.01646506-0.6846061i,-0.3984737-0.5604388i,-0.6600952-0.2096118i,-0.6587877+0.2336658i,-0.3864085+0.5912651i,0.05305431+0.7120467i,0.480573+0.53839i,0.7163898+0.1362081i,0.6588677-0.3303697i,0.3285652-0.6698693i,-0.1436855-0.7441322i,-0.5737683-0.5198835i,-0.7938306-0.07452269i,-0.7064676+0.4334103i,-0.3162344+0.8103434i,0.2580052+0.8836917i},
    {0.5910724-1.359937i,-0.3639559-1.423401i,-1.161327-0.8979281i,-1.476446+0.01324922i,-1.156596+0.9406461i,-0.3096767+1.47422i,0.7018203+1.347061i,1.405444+0.5915119i,1.45548-0.4442937i,0.8267664-1.262043i,-0.1658464-1.476962i,-1.042823-1.016582i,-1.416165-0.1336486i,-1.165649+0.755673i,-0.4488485+1.285508i,0.4174997+1.278316i,1.101589+0.7671676i,1.355242-0.05180422i,1.06933-0.8809389i,0.3154288-1.391757i,-0.6364631-1.332213i,-1.378543-0.6603449i,-1.533216+0.3756418i,-0.9650026+1.304444i,0.1009744+1.654857i,1.160493+1.219279i,1.420474-0.9438496i,0.4893679-1.634491i,-0.6603342-1.570936i,-1.503466-0.7994622i,-1.674641+0.324706i,-1.107259+1.310806i,-0.0414368+1.733971i,1.073768+1.396576i,1.747816+0.4134994i,1.648047-0.8075221i,0.7682997-1.711619i,-0.5229298-1.842817i,-1.619311-1.087721i,-1.966432+0.2263945i,-1.360576+1.466411i,-0.07837511+2.011688i,1.253146+1.582269i,1.979578+0.3875049i,1.752599-0.9864554i,0.6941834-1.878089i,-0.6800923-1.872632i,-1.719332-0.9871142i,-1.941878+0.3527048i,-1.250876+1.516009i,0.02446946+1.956849i,1.278432+1.468187i},
    {-0.4054192-1.188098i,-1.036615-0.7326792i,-1.302495+0.02362734i,-1.065305+0.8310283i,-0.3504486+1.364793i,0.5967998+1.34437i,1.362959+0.6984222i,1.550831-0.3366343i,1.008125-1.286803i,-0.05126312-1.672693i,-1.131349-1.273462i,-1.706389-0.2577097i,-1.492608+0.8991961i,-0.5850328+1.656212i,0.6011531+1.665329i,1.532124+0.9201147i,1.790425-0.2549178i,1.24707-1.346705i,0.1178005-1.864242i,-1.112285-1.54658i,-1.880785-0.4948587i,-1.799054+0.8390943i,-0.8569095+1.833387i,0.5349475+1.988124i,1.71732+1.189397i,2.103414-0.2063512i,0.1395446-2.141768i,-1.284726-1.731738i,-2.106626-0.4930432i,-1.932175+0.9865707i,-0.8409041+2.005881i,0.6549205+2.080009i,1.849027+1.16678i,2.169597-0.3085578i,1.453087-1.644633i,0.03505563-2.194098i,-1.399015-1.683787i,-2.147157-0.3622201i,-1.847186+1.116514i,-0.6640007+2.025387i,0.8011845+1.937854i,1.830729+0.9355503i,1.956991-0.4591819i,1.174096-1.571789i,-0.1008479-1.911131i,-1.263526-1.376401i,-1.809586-0.2584068i,-1.536696+0.9252641i,-0.5989393+1.661501i,0.5775212+1.645924i,1.473501+0.8993548i,1.692705-0.2386026i},
    {-0.1801025-0.2022751i,-0.2846674-0.03274855i,-0.2383501+0.175854i,-0.05110531+0.2938776i,0.1640798+0.2416961i,0.2718323+0.05707819i,0.2179205-0.1341139i,0.06286777-0.2190534i,-0.08091955-0.1786063i,-0.1439547-0.07868086i,-0.1373846+0.007232216i,-0.1089825+0.0603915i,-0.07682791+0.1054679i,-0.01646452+0.1507214i,0.08812405+0.1565555i,0.1941207+0.07457303i,0.2169608-0.08324649i,0.1083471-0.2257756i,-0.08247082-0.2471697i,-0.2330267-0.1197898i,-0.2434962+0.07443213i,-0.1171233+0.2081591i,0.04904059+0.2102102i,0.151034+0.1114241i,0.1577902-0.001316522i,0.1124423-0.06928807i,0.02394834-0.1250387i,-0.04606613-0.1453958i,-0.1474474-0.1140357i,-0.2220878+0.00430461i,-0.1891658+0.1719408i,-0.02648806+0.2832908i,0.1876435+0.2436084i,0.3197382+0.05257065i,0.2787961-0.1845091i,0.082987-0.3289411i,-0.1570738-0.30193i,-0.3156423-0.1255968i,-0.3226346+0.1066796i,-0.1835286+0.2898493i,0.04138117+0.3488567i,0.2631349+0.2533176i,0.3834557+0.02645132i,0.325409-0.244484i,0.08403589-0.4226852i,-0.2371176-0.3868877i,-0.4571143-0.1222653i,-0.4255254+0.2373908i,-0.138583+0.4746927i,0.2361548+0.4337699i,0.4649251+0.1376568i,0.4113073-0.2221338i},
    {-1.346223+0.6604339i,-0.6196527+1.3634i,0.3852762+1.445809i,1.21371+0.8740993i,1.493134-0.09205335i,1.098379-1.017036i,0.2071975-1.484048i,-0.7791989-1.282243i,-1.416721-0.501852i,-1.418485+0.5069978i,-0.7826401+1.292586i,0.208939+1.503198i,1.116717+1.041107i,1.535322+0.1042943i,1.268949-0.8974683i,0.4199353-1.51573i,-0.6454617-1.457609i,-1.446247-0.7238984i,-1.598419+0.372219i,-1.00209+1.328984i,0.08884459+1.683361i,1.166254+1.241938i,1.706282+0.1948565i,1.433723-0.9611071i,0.4706022-1.66421i,-0.7182594-1.571349i,-1.652347+0.4450486i,-0.9697636+1.394331i,0.1519773+1.677169i,1.181779+1.178791i,1.648042+0.1474739i,1.349817-0.9329053i,0.4378664-1.567777i,-0.6608548-1.47362i,-1.438988-0.7034847i,-1.541217+0.3780271i,-0.9302869+1.263955i,0.09490555+1.545375i,1.045219+1.107623i,1.482239+0.1803307i,1.229272-0.7866583i,0.4413817-1.352587i,-0.4946738-1.293552i,-1.162316-0.6828274i,-1.302527+0.1789928i,-0.8989838+0.9219675i,-0.1472579+1.260613i,0.6453862+1.083084i,1.173042+0.4683659i,1.227139-0.3478526i,0.7675978-1.044674i,-0.04418534-1.322608i},
    {0.3069004-0.4167283i,-0.04571784-0.4829616i,-0.3284456-0.3099581i,-0.4176686-0.01981896i,-0.3073972+0.2332675i,-0.08411645+0.345897i,0.1376559+0.2992465i,0.2718486+0.1421786i,0.2843741-0.04791893i,0.1886937-0.1985313i,0.03069358-0.2607767i,-0.1275229-0.2189535i,-0.226225-0.09466691i,-0.2297433+0.05916286i,-0.1425029+0.1790954i,-0.006894708+0.2199726i,0.1191495+0.1745505i,0.1908791+0.07094494i,0.1924553-0.04803384i,0.1325427-0.1457557i,0.03065578-0.1984i,-0.08927538-0.1900732i,-0.1943597-0.1117763i,-0.240714+0.0265992i,-0.1894039+0.1815741i,-0.0375036+0.2807981i,0.3064706+0.09930886i,0.3121077-0.1303073i,0.1564316-0.3144481i,-0.09068938-0.349269i,-0.3026734-0.2077401i,-0.3678986+0.04105425i,-0.2529795+0.270701i,-0.01831431+0.3682744i,0.2197387+0.2922698i,0.3518665+0.08612975i,0.3256579-0.1523786i,0.1601173-0.3208089i,-0.07213702-0.3528656i,-0.2774573-0.2372735i,-0.3732832-0.01703775i,-0.3142606+0.2241469i,-0.1111431+0.3861705i,0.1631765+0.3877939i,0.3909456+0.2063057i,0.4548986-0.09694716i,0.298777-0.3874217i,-0.0281283-0.5129776i,-0.3758808-0.3848283i,-0.5597165-0.04028574i,-0.4606759+0.3569485i,-0.1051148+0.5929257i},
    {-0.5776233+0.09212594i,-0.3830248+0.4749066i,0.0333775+0.6278226i,0.4514015+0.4553304i,0.6468401+0.04353686i,0.5190532-0.3934357i,0.13843-0.6368104i,-0.3042034-0.5757087i,-0.6020448-0.24895i,-0.6262876+0.1898181i,-0.3701707+0.5479741i,0.0585549+0.67032i,0.4798947+0.4947786i,0.7053701+0.08037143i,0.6138829-0.4018684i,0.2182002-0.7271594i,-0.3160921-0.7182903i,-0.7303362-0.3478388i,-0.79995+0.2229221i,-0.4645977+0.7097164i,0.121536+0.8532153i,0.6616718+0.5662851i,0.8756179-0.01102794i,0.6526894-0.5852935i,0.1084027-0.8679847i,-0.4830115-0.7246478i,-0.7830066+0.3605042i,-0.362739+0.7787292i,0.2259249+0.8277894i,0.7083766+0.486302i,0.8578078-0.08865454i,0.5972719-0.6282883i,0.04209175-0.870801i,-0.5427503-0.6876897i,-0.864026-0.1584635i,-0.7508163+0.4547171i,-0.2547202+0.8350911i,0.3660834+0.7820678i,0.7827619+0.3274196i,0.7794561-0.2782274i,0.3751225-0.7074969i,-0.1925809-0.7435i,-0.6115723-0.3978196i,-0.6767282+0.1109998i,-0.3963419+0.4987988i,0.03580997+0.5830064i,0.3739646+0.3719766i,0.4669357+0.03046038i,0.326386-0.2422208i,0.08552256-0.3335016i,-0.1086207-0.2617881i,-0.1880217-0.1277375i},
    {-0.2187121+0.2631476i,-0.0231865+0.3203847i,0.1575229+0.2638727i,0.2736903+0.1238281i,0.294161-0.05613013i,0.2079633-0.2200788i,0.03626168-0.3062259i,-0.1601391-0.2704589i,-0.2971562-0.1164407i,-0.3079613+0.09378596i,-0.1830119+0.2651793i,0.02071669+0.3194356i,0.210318+0.2362439i,0.3063053+0.05894258i,0.2775266-0.1347981i,0.1439905-0.2721189i,-0.04305613-0.3085749i,-0.2217975-0.2317089i,-0.3305945-0.05870576i,-0.3177828+0.1606349i,-0.1633414+0.3436466i,0.09330155+0.3966448i,0.3463964+0.2637795i,0.4621896-0.02310354i,0.3540027-0.3363333i,0.04831849-0.5087055i,-0.5318068-0.1207902i,-0.4888737+0.2659662i,-0.1949842+0.5291491i,0.2016075+0.5310655i,0.5007659+0.2715777i,0.5574508-0.1179373i,0.3504418-0.4489669i,-0.01781406-0.5698139i,-0.377848-0.4300984i,-0.5699187-0.09384472i,-0.5075893+0.292566i,-0.210672+0.5590281i,0.1985744+0.5787776i,0.5377429+0.3256951i,0.6389706-0.101005i,0.4321912-0.5061554i,-0.004311031-0.6836716i,-0.4642191-0.5243595i,-0.7092512-0.08781229i,-0.5976971+0.4121732i,-0.172309+0.7133799i,0.3508631+0.6490796i,0.6951615+0.2465778i,0.67664-0.281853i,0.3083553-0.6550096i,-0.2073127-0.6795875i},
    {0.9967242+0.2891975i,0.9290417-0.4688729i,0.3571551-0.9704311i,-0.3942001-0.9386374i,-0.9047327-0.4093921i,-0.9112366+0.3017798i,-0.4501435+0.8022115i,0.1921927+0.8531381i,0.6697509+0.4828509i,0.7721558-0.06969148i,0.5088976-0.5170873i,0.05844286-0.6757964i,-0.3549123-0.5272554i,-0.5700073-0.1833426i,-0.5350695+0.1931011i,-0.2963043+0.458786i,0.03955252+0.5288946i,0.344633+0.3902965i,0.5060978+0.1001216i,0.4607943-0.2295386i,0.222125-0.4659144i,-0.1160299-0.505768i,-0.4097973-0.323561i,-0.5249615+0.007811851i,-0.4015428+0.34097i,-0.09028729+0.518841i,0.4876967+0.1730769i,0.4737516-0.1805832i,0.236197-0.4313042i,-0.09473184-0.4617786i,-0.3493193-0.2772849i,-0.41605+0.006558112i,-0.2966405+0.2422785i,-0.08407414+0.3387356i,0.1128112+0.2970763i,0.2353493+0.1769435i,0.2829276+0.03345277i,0.2701339-0.1142198i,0.187738-0.2585101i,0.01490351-0.3591169i,-0.2265363-0.3389585i,-0.4366921-0.1427538i,-0.4754181+0.1870548i,-0.2623959+0.4939505i,0.1373314+0.5869495i,0.52208+0.3704382i,0.6668817-0.07279366i,0.4672008-0.5145291i,0.01119132-0.7132404i,-0.4688904-0.5557554i,-0.7287951-0.117229i,-0.6401098+0.3879129i},
    {0.12006+0.03103945i,0.1286524-0.1161943i,-0.01446443-0.2276884i,-0.2267731-0.172601i,-0.3360496+0.06204784i,-0.2140383+0.3340788i,0.1059072+0.43612i,0.4279613+0.2523184i,0.5218807-0.1388609i,0.2894612-0.500307i,-0.1542211-0.5906998i,-0.5462355-0.3287846i,-0.6427534+0.1474158i,-0.3732994+0.5643536i,0.1169088+0.6798039i,0.5561284+0.4244076i,0.7038246-0.06422375i,0.481298-0.5247129i,0.006825279-0.7159724i,-0.4737025-0.5411801i,-0.7162386-0.09134127i,-0.6001918+0.4062748i,-0.1845193+0.7038426i,0.3249784+0.6545916i,0.6781394+0.2823694i,0.7017573-0.2321682i,-0.1308119-0.7406057i,-0.5905378-0.4799228i,-0.7712806+0.02523836i,-0.5734946+0.5348505i,-0.07859942+0.7942535i,0.4774043+0.6579471i,0.8092265+0.1735931i,0.7274094-0.4226277i,0.2526445-0.8143301i,-0.3731886-0.7753275i,-0.8060195-0.3102031i,-0.7957823+0.3291371i,-0.3436693+0.7798302i,0.2879095+0.7851014i,0.7318272+0.3541507i,0.7432283-0.2452846i,0.3462424-0.660309i,-0.1970484-0.6743413i,-0.5671867-0.326804i,-0.5864202+0.1408605i,-0.3030438+0.4585259i,0.07771508+0.4897832i,0.3439735+0.2804563i,0.3949478-0.01248525i,0.2612361-0.2351362i,0.04668922-0.3103951i},
    {-0.1016055-0.4419785i,-0.2718715-0.2473771i,-0.29075-0.06008364i,-0.2417395+0.05954498i,-0.1873799+0.1340721i,-0.1278746+0.2037742i,-0.02848202+0.2693965i,0.1265011+0.2859407i,0.3012905+0.1994154i,0.415414-0.007177339i,0.3804256-0.2850641i,0.1507209-0.5200755i,-0.2284908-0.5696604i,-0.6037588-0.337231i,-0.7601029+0.1425312i,-0.5375013+0.6676465i,0.03809066+0.9397128i,0.7087875+0.7347963i,1.093369+0.07682496i,0.9139974-0.720368i,0.1986485-1.206057i,-0.6936771-1.064527i,-1.266325-0.328029i,-1.181829+0.6211222i,-0.4679916+1.268929i,0.4992885+1.267005i,1.324836-0.3310118i,0.7870855-1.115444i,-0.1257545-1.360908i,-0.9798753-0.9605066i,-1.378872-0.1018717i,-1.131385+0.8219665i,-0.3349834+1.378763i,0.6522127+1.286541i,1.356949+0.5578048i,1.412499-0.4770634i,0.7585009-1.307688i,-0.2988974-1.498606i,-1.225732-0.9306196i,-1.539405+0.1175926i,-1.072772+1.109056i,-0.06695669+1.535526i,0.9607233+1.18678i,1.492829+0.2523457i,1.275023-0.7892247i,0.432136-1.420133i,-0.6071133-1.337973i,-1.326317-0.5959135i,-1.372833+0.4283564i,-0.7309802+1.217785i,0.2652594+1.373773i,1.097165+0.825166i},
    {-0.9385473+0.5876681i,-0.3202432+1.049887i,0.4357813+0.9879503i,0.9504236+0.4587937i,0.9950981-0.2521767i,0.589969-0.8025761i,-0.04327976-0.9661058i,-0.6170814-0.7126963i,-0.9081269-0.1807722i,-0.8237265+0.4072241i,-0.4070506+0.8278656i,0.1870221+0.9175826i,0.7304987+0.6213389i,0.9871924+0.03051157i,0.8098896-0.6192235i,0.2346795-1.025038i,-0.4954662-0.9610534i,-1.024521-0.417766i,-1.066457+0.3596092i,-0.5750263+0.9812129i,0.2119669+1.121553i,0.8937047+0.7041449i,1.125534-0.05371124i,0.8044258-0.7639334i,0.1124985-1.080783i,-0.5969904-0.8759972i,-0.9192464+0.4005607i,-0.4498299+0.8659193i,0.1841911+0.9345729i,0.7097486+0.608152i,0.922416+0.0414399i,0.7498587-0.5317318i,0.2651506-0.8834266i,-0.3403935-0.8675901i,-0.8186309-0.4757809i,-0.9544686+0.1443677i,-0.6626766+0.7294822i,-0.04796441+1.004438i,0.617783+0.8162172i,1.012582+0.2289646i,0.9284338-0.485547i,0.3922906-0.9755017i,-0.3349219-0.9936922i,-0.8917977-0.5333781i,-1.009336+0.1682891i,-0.649688+0.7626199i,-0.01140571+0.9761283i,0.5921688+0.7405922i,0.8983173+0.2001366i,0.8068601-0.3879716i,0.3922463-0.7832173i,-0.1607498-0.8498329i},
    {1.090032+1.047392i,1.496301+0.06193855i,1.147053-0.9260078i,0.2528327-1.421204i,-0.7159358-1.212564i,-1.294801-0.4506777i,-1.249297+0.4708524i,-0.6492918+1.129965i,0.2061727+1.26092i,0.9401889+0.8384504i,1.248243+0.06061231i,1.00525-0.7374071i,0.3124845-1.209236i,-0.5306953-1.136242i,-1.140129-0.5350524i,-1.21974+0.3260897i,-0.7178382+1.037187i,0.1273823+1.247709i,0.89857+0.8545322i,1.216789+0.0625395i,0.9423737-0.7256911i,0.2403773-1.128323i,-0.5236925-0.9810678i,-0.9875416-0.4016411i,-0.9717355+0.3009476i,-0.5406762+0.8023079i,0.5818843+0.6514502i,0.8174762+0.1647628i,0.7287629-0.3361047i,0.3867192-0.6792626i,-0.07510646-0.7693835i,-0.5075749-0.589329i,-0.772657-0.1904897i,-0.7652609+0.3106181i,-0.4492716+0.7403303i,0.09864561+0.9080051i,0.6756591+0.6889952i,1.011223+0.1169981i,0.8971117-0.5821422i,0.3253758-1.068457i,-0.4623926-1.061933i,-1.073523-0.5175816i,-1.174228+0.3176226i,-0.6879745+1.021621i,0.1480159+1.228818i,0.9108968+0.8345858i,1.225639+0.04606572i,0.9585057-0.7439532i,0.2624086-1.16987i,-0.5287446-1.062373i,-1.07093-0.4953805i,-1.148401+0.2784151i},
    {1.117702-0.2551548i,0.6914527-0.8994219i,-0.03413427-1.122713i,-0.7278908-0.8442763i,-1.092451-0.2007401i,-0.9794189+0.5274958i,-0.4370261+1.031452i,0.3105062+1.090297i,0.9429888+0.6609555i,1.168918-0.08831703i,0.8593841-0.8285936i,0.1299729-1.207269i,-0.68849-1.021677i,-1.19909-0.3381239i,-1.141011+0.5227895i,-0.5323583+1.141494i,0.3330262+1.214756i,1.035953+0.7102185i,1.243893-0.1234871i,0.8691385-0.8883305i,0.09814825-1.231728i,-0.7079657-1.005279i,-1.182366-0.3211232i,-1.113071+0.5060917i,-0.5328354+1.099475i,0.2940557+1.18567i,1.216195-0.08185609i,0.8737581-0.8429884i,0.1226339-1.199365i,-0.6733389-0.9846283i,-1.133001-0.3136317i,-1.049573+0.4801065i,-0.4867553+1.018912i,0.2688839+1.06846i,0.8628919+0.6380452i,1.043704-0.04785941i,0.7631421-0.6738274i,0.1726333-0.9789727i,-0.4622223-0.8569863i,-0.8780771-0.3812768i,-0.9142035+0.2385913i,-0.5673193+0.7444258i,0.01220733+0.9300797i,0.5811832+0.722058i,0.9018079+0.2094608i,0.8398193-0.3920124i,0.420537-0.829567i,-0.1820521-0.9181668i,-0.7170327-0.6159387i,-0.957316-0.04132016i,-0.7903842+0.5710927i,-0.2683279+0.9590015i},
    {0.3577882+0.1034528i,0.3318312-0.1689593i,0.1236742-0.3497875i,-0.1523516-0.3347783i,-0.3378069-0.1312797i,-0.3255634+0.1406061i,-0.1278501+0.319811i,0.1311464+0.3049141i,0.2953332+0.1162733i,0.2754026-0.1219996i,0.09985922-0.2656725i,-0.1123933-0.2407658i,-0.2335895-0.08148596i,-0.2050127+0.1029143i,-0.06301758+0.2026192i,0.09521683+0.1715863i,0.1762243+0.04513025i,0.1428055-0.09141061i,0.02754494-0.15705i,-0.09335133-0.1197119i,-0.1464903-0.009534941i,-0.1023076+0.1020756i,0.009503131+0.1446652i,0.1175563+0.09004486i,0.1507622-0.02962992i,0.08235724-0.1388338i,-0.1644409-0.07902285i,-0.1820367+0.07026308i,-0.08023033+0.1929338i,0.08858028+0.205471i,0.223309+0.08633958i,0.2335828-0.1044827i,0.09745578-0.2551332i,-0.117955-0.2660926i,-0.2883298-0.1130151i,-0.3022515+0.1296526i,-0.1315846+0.3227059i,0.1405513+0.3404356i,0.3574139+0.1510013i,0.37803-0.1513821i,0.1688493-0.3905826i,-0.1620597-0.4117056i,-0.4193057-0.183134i,-0.4380518+0.1713369i,-0.192929+0.4400555i,0.1768501+0.4543851i,0.4494406+0.198754i,0.4594794-0.1756003i,0.2025237-0.4450944i,-0.164759-0.4539654i,-0.426424-0.2070376i,-0.4402465+0.1425737i},
    {1.426075+0.5908852i,1.452739-0.4453821i,0.8260033-1.248244i,-0.1516029-1.46804i,-1.034299-1.025851i,-1.432979-0.1368231i,-1.18249+0.7931561i,-0.407995+1.349136i,0.5348277+1.289289i,1.219632+0.6504108i,1.341077-0.2698135i,0.8535796-1.048802i,-0.008410526-1.334404i,-0.8419483-1.008731i,-1.26792-0.2399193i,-1.109506+0.6052441i,-0.4669892+1.14282i,0.3458224+1.152473i,0.9632202+0.6660511i,1.137348-0.07196455i,0.831681-0.7363162i,0.2067379-1.066834i,-0.4722037-0.95947i,-0.9461039-0.4794036i,-1.045675+0.1832977i,-0.7341872+0.7820396i,0.5824057+0.9589517i,1.080584+0.413443i,1.142226-0.3551466i,0.6940909-1.02442i,-0.1079609-1.274292i,-0.9178399-0.9472476i,-1.348185-0.1517879i,-1.164034+0.7622308i,-0.4168664+1.360399i,0.5615928+1.338125i,1.311159+0.6798124i,1.465513-0.3228191i,0.9326046-1.204209i,-0.05556589-1.54402i,-1.04619-1.166536i,-1.57278-0.2283067i,-1.372404+0.845775i,-0.5156326+1.55184i,0.6127606+1.541024i,1.482017+0.7930075i,1.663986-0.3572974i,1.047827-1.365011i,-0.08937234-1.734483i,-1.20371-1.269119i,-1.748045-0.1814345i,-1.448075+1.00253i},
    {-0.1812345+1.008777i,0.5348296+0.869346i,0.972454+0.2924777i,0.9164646-0.4240282i,0.4028516-0.9195186i,-0.3055544-0.9498224i,-0.8526014-0.5055538i,-0.9663038+0.1855111i,-0.5946112+0.7734257i,0.06867202+0.9632816i,0.6835174+0.6656454i,0.9395266+0.04125469i,0.7160059-0.5850543i,0.1409604-0.895627i,-0.4814591-0.7443334i,-0.8337892-0.2268473i,-0.7498298+0.377451i,-0.294695+0.7571334i,0.2784829+0.7316171i,0.6687875+0.3399124i,0.6885222-0.1897361i,0.3583699-0.5711604i,-0.1150225-0.6194509i,-0.4657037-0.3475604i,-0.5242695+0.05600119i,-0.3076804+0.3532929i,0.2351174+0.2421995i,0.2661494+0.01923683i,0.1576266-0.1137579i,0.04066177-0.1160242i,0.005974215-0.06242778i,0.03495433-0.05420828i,0.0346609-0.1168256i,-0.05979104-0.1751433i,-0.2097275-0.1264634i,-0.2937229+0.05481334i,-0.2087948+0.2752052i,0.03462103+0.3826376i,0.3052468+0.2810481i,0.4380004+0.006192541i,0.3457364-0.2951282i,0.07198217-0.460548i,-0.2446614-0.4071136i,-0.4550043-0.1642823i,-0.4692828+0.1584779i,-0.2806253+0.4285243i,0.0452277+0.5343672i,0.388667+0.4143348i,0.6013023+0.08410992i,0.5553958-0.3414736i,0.218347-0.6656135i,-0.2901908-0.6921783i},
    {-0.8774524+0.6426791i,-0.2528146+1.049679i,0.4789823+0.955187i,0.968457+0.4174788i,0.9956496-0.2958581i,0.568514-0.8491969i,-0.09835494-1.000933i,-0.6987253-0.703527i,-0.9748127-0.105509i,-0.8186851+0.5265316i,-0.3051313+0.921122i,0.343075+0.9082465i,0.8424574+0.4886192i,0.9650499-0.1579619i,0.6446467-0.7396777i,0.021433-0.9818804i,-0.61239-0.7643332i,-0.953316-0.1904857i,-0.8425832+0.460258i,-0.346861+0.8774732i,0.2846729+0.8784981i,0.7570797+0.4892887i,0.8747697-0.09017503i,0.6160579-0.5994979i,0.1149196-0.8362851i,-0.415645-0.7238068i,-0.8070818+0.218103i,-0.5086438+0.6755901i,0.01895657+0.8588809i,0.5604956+0.6708604i,0.8720605+0.172019i,0.7952349-0.424316i,0.3483247-0.8411875i,-0.2677105-0.8755931i,-0.7642643-0.5066398i,-0.910589+0.09226718i,-0.6457886+0.643773i,-0.09814602+0.9031405i,0.486694+0.7651991i,0.8589401+0.2966384i,0.8634377-0.3034661i,0.4934821-0.7845517i,-0.1061812-0.9373601i,-0.6857119-0.6772398i,-0.9821925-0.09345847i,-0.8365337+0.5663581i,-0.2858335+0.9925308i,0.4286416+0.9619379i,0.9639176+0.4642871i,1.047429-0.2738363i,0.6250058-0.8944556i,-0.1037511-1.090975i},
    {-0.1643235+0.3654574i,0.06766358+0.3194372i,0.1820045+0.1899343i,0.2064998+0.07588413i,0.2065861-0.006700359i,0.2001424-0.09647296i,0.1463284-0.2080279i,0.007898439-0.2911213i,-0.1853086-0.2681375i,-0.3383453-0.1090445i,-0.3564017+0.1300068i,-0.2124399+0.3375868i,0.03758362+0.4148048i,0.2918513+0.3233793i,0.4506273+0.09027612i,0.4437773-0.2102973i,0.2451425-0.471373i,-0.1054527-0.5701065i,-0.4815874-0.4133498i,-0.6932085-0.01035528i,-0.579077+0.4809547i,-0.1281867+0.8000878i,0.464316+0.7280263i,0.8771347+0.244269i,0.8505354-0.4236029i,0.3598287-0.9137447i,-0.9051682-0.4790981i,-1.008261+0.2424426i,-0.6062365+0.8536777i,0.09972444+1.051862i,0.767699+0.7422647i,1.080482+0.06864484i,0.8831056-0.6592205i,0.24902-1.09814i,-0.5403606-1.019438i,-1.104524-0.42561i,-1.138458+0.4202314i,-0.5841032+1.09496i,0.3031189+1.226996i,1.062192+0.7147376i,1.274967-0.1885349i,0.8138539-0.9993391i,-0.07305108-1.278039i,-0.90301-0.8834828i,-1.238622-0.04678895i,-0.9291854+0.7754698i,-0.1715478+1.164891i,0.6250816+0.9569468i,1.068162+0.2970364i,0.9702352-0.4648177i,0.4142247-0.95952i,-0.3092918-0.9682674i},
    {-0.01801055+0.2784735i,0.1639402+0.1557862i,0.1716753-0.02925291i,0.0453825-0.1190948i,-0.07419545-0.06099288i,-0.0722196+0.06272572i,0.04566184+0.1158438i,0.1633018+0.02842329i,0.1547264-0.1417873i,-0.007753063-0.2530131i,-0.2227734-0.1917333i,-0.3297024+0.03320935i,-0.2271059+0.2856593i,0.04647613+0.3914625i,0.3284267+0.2599452i,0.4359724-0.04726592i,0.2884072-0.3492449i,-0.03567204-0.4604256i,-0.346081-0.3104794i,-0.4621337+0.01142673i,-0.325002+0.3169267i,-0.02640123+0.4396029i,0.2606269+0.3324839i,0.3936628+0.07906691i,0.3353235-0.1780269i,0.1472285-0.3281525i,-0.2497838-0.2297633i,-0.3420581-0.04731835i,-0.3227926+0.1670658i,-0.1728104+0.3521216i,0.08851145+0.4193773i,0.3670544+0.2921615i,0.5101609-0.0206308i,0.3948419-0.3832042i,0.03365689-0.5849266i,-0.3941711-0.4732985i,-0.6347153-0.0756465i,-0.5245149+0.3923391i,-0.1102439+0.6539193i,0.3710228+0.5504675i,0.6417217+0.1442587i,0.5572932-0.3266002i,0.1840744-0.6024151i,-0.2599726-0.5533745i,-0.5444486-0.2333872i,-0.5468744+0.1768743i,-0.2916948+0.4784351i,0.08689639+0.543425i,0.4146581+0.3539926i,0.5446239-0.001474408i,0.4117687-0.3607663i,0.06860076-0.5477454i},
    {-0.3713476+0.1617523i,-0.2117626+0.3799365i,0.07853097+0.4630043i,0.3856935+0.3273566i,0.5409897-0.007554071i,0.4204851-0.38899i,0.04812972-0.5974749i,-0.385612-0.484771i,-0.6256672-0.08848676i,-0.5170918+0.37053i,-0.1160509+0.6211169i,0.339242+0.517831i,0.5825951+0.1348836i,0.4904115-0.2890526i,0.1492307-0.5123317i,-0.219957-0.4402609i,-0.4155815-0.1622473i,-0.3735171+0.1349126i,-0.1751318+0.2996677i,0.03945177+0.2958348i,0.1727835+0.1868818i,0.2115987+0.05922768i,0.1946919-0.0428654i,0.1534335-0.1236953i,0.08320993-0.1948277i,-0.03380854-0.2361059i,-0.3016512-0.05696103i,-0.3034119+0.1587022i,-0.1474308+0.346353i,0.1189394+0.390527i,0.3683769+0.2358778i,0.4591843-0.06515272i,0.31993-0.3675003i,0.0004852435-0.5078415i,-0.3447486-0.3967983i,-0.5355737-0.07488549i,-0.463715+0.3021005i,-0.1545302+0.5422445i,0.2423425+0.5183747i,0.5287165+0.2357837i,0.5591924-0.1690564i,0.3149665-0.4969509i,-0.08663426-0.58528i,-0.4498743-0.3882536i,-0.5961593+0.0001846274i,-0.4515486+0.3909773i,-0.08478269+0.5913466i,0.3237127+0.500509i,0.5700047+0.1629217i,0.530848-0.2508556i,0.2297843-0.5308548i,-0.1740315-0.5389338i},
    {0.6433805+0.01903156i,0.5113957-0.3734177i,0.169731-0.6007712i,-0.2357405-0.5680586i,-0.5282614-0.2929855i,-0.5826545+0.09677181i,-0.3867172+0.4250612i,-0.04237632+0.5551273i,0.2935632+0.451047i,0.4888565+0.1793739i,0.4870228-0.1393403i,0.310101-0.3894852i,0.02965582-0.4955375i,-0.2635477-0.4288374i,-0.4768052-0.204405i,-0.5291316+0.1173517i,-0.3762026+0.4305362i,-0.0435582+0.6050369i,0.3566891+0.5376876i,0.652283+0.2142656i,0.683241-0.2564639i,0.3898462-0.6689878i,-0.1331097-0.8087183i,-0.6556832-0.5645893i,-0.910731-0.007817077i,-0.7314935+0.6146768i,0.5490123+0.8823608i,1.030183+0.3120099i,1.008586-0.4614385i,0.4595675-1.039467i,-0.3538002-1.102477i,-1.009958-0.5958914i,-1.158715+0.227112i,-0.7177826+0.9396613i,0.08232381+1.175472i,0.829616+0.8243636i,1.154785+0.07848275i,0.9161314-0.6847171i,0.2509169-1.101988i,-0.5137022-0.9935569i,-1.024351-0.4276061i,-1.05573+0.3281856i,-0.5983774+0.9292851i,0.140922+1.099557i,0.8226823+0.7513744i,1.119839+0.03625786i,0.8748839-0.7078858i,0.1942758-1.110296i,-0.5856181-0.9593994i,-1.065259-0.327894i,-0.9993503+0.4548741i,-0.4357747+0.981541i},
    {0.4864021-0.9062545i,-0.2135551-1.03328i,-0.8507807-0.6710106i,-1.112569+0.03863365i,-0.843614+0.7717214i,-0.1402742+1.164442i,0.6717315+0.995209i,1.184495+0.3153578i,1.117778-0.5529329i,0.4802563-1.168986i,-0.416982-1.205287i,-1.115695-0.63051i,-1.254472+0.2655567i,-0.7635083+1.024796i,0.1011244+1.265165i,0.8994686+0.8779482i,1.240055+0.07226457i,0.9729766-0.7460225i,0.2484537-1.183924i,-0.5734225-1.047299i,-1.102545-0.419162i,-1.098565+0.3922703i,-0.5745728+1.00155i,0.2134583+1.123252i,0.8855698+0.7044485i,1.117138-0.04680306i,0.1000271-1.076244i,-0.6204997-0.8529213i,-0.9980016-0.2220628i,-0.8610387+0.4750059i,-0.3169821+0.8823154i,0.3232279+0.8240572i,0.732229+0.3845458i,0.7456297-0.1681306i,0.4257359-0.5539981i,-0.01426789-0.6320848i,-0.3565544-0.4418818i,-0.4913113-0.13223i,-0.434029+0.1504997i,-0.2641576+0.3316322i,-0.05311667+0.4027103i,0.160933+0.3740885i,0.3481356+0.2439474i,0.4553513+0.01380283i,0.4131875-0.2706806i,0.1865426-0.5028744i,-0.1714663-0.5539861i,-0.513705-0.3519638i,-0.66145+0.05280232i,-0.5051281+0.4871212i,-0.08166482+0.732385i,0.4243897+0.6412753i},
    {-1.108391+0.7135548i,-0.3802096+1.306301i,0.5855249+1.262828i,1.290178+0.5754074i,1.361799-0.4146436i,0.7619608-1.205517i,-0.2032039-1.408106i,-1.059059-0.9396052i,-1.407549-0.04111281i,-1.105608+0.8626505i,-0.3056298+1.366673i,0.6310065+1.253984i,1.290905+0.5742755i,1.375916-0.3792153i,0.829955-1.183585i,-0.120667-1.461248i,-1.04612-1.05705i,-1.500593-0.1341036i,-1.24339+0.87909i,-0.37749+1.487415i,0.6838405+1.381255i,1.419476+0.6039912i,1.46727-0.463945i,0.8089595-1.299262i,-0.2259998-1.50143i,-1.133332-0.9874889i,-1.133909+0.9309203i,-0.2644017+1.422979i,0.702277+1.242097i,1.316147+0.4941254i,1.306482-0.4573312i,0.6996089-1.168542i,-0.2050509-1.323352i,-0.9845208-0.8731875i,-1.291949-0.04640344i,-1.009863+0.7704082i,-0.2889644+1.214909i,0.5350918+1.106724i,1.097835+0.5138338i,1.161867-0.2899112i,0.7110582-0.9481003i,-0.04769403-1.173325i,-0.7732967-0.8698632i,-1.138519-0.1788784i,-0.9798223+0.5798303i,-0.37913+1.054527i,0.3721909+1.032608i,0.9192092+0.5459035i,1.02382-0.1531607i,0.6762326-0.7328528i,0.07507619-0.9542868i,-0.499785-0.7709281i},
    {0.06241953-0.3883345i,-0.1954973-0.3104159i,-0.3240864-0.09933574i,-0.2859968+0.1212858i,-0.1324149+0.2500694i,0.04528433+0.2530086i,0.1711363+0.1595503i,0.2130653+0.02747031i,0.1781693-0.09170005i,0.0923326-0.1672153i,-0.01535018-0.1859436i,-0.116313-0.1457056i,-0.1814699-0.05517434i,-0.1853594+0.06151516i,-0.1177387+0.1646935i,0.004675065+0.2103678i,0.1369334+0.1704628i,0.2207483+0.05155683i,0.2114629-0.1005073i,0.1040008-0.2169762i,-0.05808912-0.2388273i,-0.1995757-0.1495199i,-0.2508661+0.01202648i,-0.1857086+0.168947i,-0.03613797+0.2465579i,0.1254949+0.2114508i,0.2271295-0.06999961i,0.1368089-0.1908265i,-0.004073167-0.2343812i,-0.1439408-0.1891721i,-0.2354448-0.06950949i,-0.2420294+0.08933349i,-0.1467844+0.2323032i,0.03124158+0.2933299i,0.2259025+0.2229615i,0.3397358+0.02666244i,0.2931207-0.2157235i,0.08196414-0.3770615i,-0.1998726-0.3530593i,-0.4011145-0.1338359i,-0.4000326+0.1756923i,-0.1828815+0.4086924i,0.1407188+0.433152i,0.398424+0.2305269i,0.4532995-0.09369543i,0.2781349-0.3711866i,-0.03532653-0.4625745i,-0.3299604-0.3261151i,-0.4634397-0.03146654i,-0.3733091+0.27916i,-0.1018771+0.4578344i,0.2236455+0.4168541i},
    {-1.311758-0.6241279i,-1.390461+0.371271i,-0.8081189+1.168435i,0.1375504+1.390428i,0.9825138+0.953624i,1.333901+0.09566971i,1.05731-0.7606434i,0.32088-1.224462i,-0.5116726-1.116896i,-1.067653-0.5299835i,-1.131069+0.2458288i,-0.7149349+0.8704346i,-0.02606919+1.099688i,0.640916+0.8684519i,1.024159+0.2931811i,0.9845799-0.3883133i,0.5449306-0.9077461i,-0.122987-1.058958i,-0.7556438-0.7710801i,-1.088768-0.1436556i,-0.9617677+0.5746811i,-0.3995661+1.072457i,0.3726812+1.107706i,1.009445+0.6328329i,1.200684-0.1576326i,0.8327424-0.9000024i,-0.7454382-0.9908989i,-1.205339-0.2832i,-1.102105+0.5486152i,-0.4975274+1.113906i,0.3146369+1.164729i,0.964712+0.7015569i,1.180417-0.05145822i,0.8906735-0.7665834i,0.2298744-1.15319i,-0.5317106-1.059389i,-1.088166-0.5155793i,-1.200886+0.2742137i,-0.7901633+0.9902619i,0.00839333+1.307142i,0.8632774+1.037987i,1.369706+0.2529348i,1.245065-0.7096094i,0.4996358-1.381015i,-0.53069-1.400712i,-1.335925-0.7247226i,-1.498642+0.3279904i,-0.9240457+1.233052i,0.1042605+1.537291i,1.07556+1.095372i,1.519323+0.1354017i,1.237189-0.8711563i},
    {0.4596939+0.5755419i,0.7276229+0.217214i,0.7545238-0.2563975i,0.4853365-0.6937429i,-0.03500225-0.9046733i,-0.6270354-0.7395556i,-1.017762-0.1952717i,-0.968242+0.5282331i,-0.4262297+1.086872i,0.3985769+1.161832i,1.107363+0.6507423i,1.313298-0.2405201i,0.8624164-1.07751i,-0.05833315-1.418131i,-0.9986825-1.055111i,-1.473962-0.1416214i,-1.222553+0.8750281i,-0.3510756+1.480026i,0.712814+1.358276i,1.436721+0.5604957i,1.455963-0.5196162i,0.7600253-1.345426i,-0.3035961-1.510153i,-1.208655-0.940497i,-1.517112+0.07303115i,-1.094256+1.030431i,0.8167168+1.215608i,1.387277+0.3987321i,1.30083-0.5756372i,0.6231391-1.256617i,-0.3173221-1.34783i,-1.090316-0.8283012i,-1.355657+0.05329363i,-1.005443+0.896381i,-0.2045116+1.324103i,0.6831681+1.146345i,1.253586+0.4448668i,1.244158-0.4586511i,0.6582456-1.145376i,-0.2301042-1.294254i,-1.002082-0.8374323i,-1.294861+0.004227363i,-0.9776239+0.8281851i,-0.2124222+1.247288i,0.6303627+1.076058i,1.155627+0.4129451i,1.131346-0.4174i,0.5898333-1.026018i,-0.1996091-1.142789i,-0.8656586-0.735119i,-1.109932-0.01215798i,-0.840986+0.6818396i},
    {-1.391937-0.2257579i,-1.241305+0.6817197i,-0.5643709+1.316234i,0.3764154+1.408132i,1.197165+0.8889136i,1.529374-0.05811637i,1.181788-1.038262i,0.2593924-1.595312i,-0.8419084-1.427871i,-1.598149-0.5652561i,-1.616232+0.6103894i,-0.8515012+1.533859i,0.3473968+1.740886i,1.403424+1.112106i,1.800482-0.05943155i,1.341636-1.213067i,0.2434463-1.797122i,-0.973437-1.534027i,-1.734786-0.5478539i,-1.68202+0.6979698i,-0.8383231+1.617947i,0.4009452+1.777535i,1.450818+1.09923i,1.81291-0.09578225i,1.31688-1.237456i,0.2059777-1.782628i,-1.684964-0.4948187i,-1.586372+0.692816i,-0.7626623+1.522992i,0.3774835+1.630967i,1.304602+1.001929i,1.616596-0.04906996i,1.204744-1.0415i,0.2774689-1.546679i,-0.7474868-1.362704i,-1.425178-0.5861303i,-1.467413+0.4365388i,-0.8617716+1.255961i,0.1212594+1.511682i,1.042954+1.091957i,1.491044+0.1878917i,1.268224-0.7909716i,0.4824558-1.405078i,-0.5068448-1.386439i,-1.258074-0.7551112i,-1.446195+0.2003276i,-0.9985269+1.058768i,-0.1156672+1.449504i,0.8191372+1.204468i,1.399284+0.4257554i,1.363597-0.5525896i,0.7136269-1.298152i},
    {1.247997+0.06498372i,0.9505576-0.7067963i,0.2774976-1.083751i,-0.4277993-0.9646335i,-0.8757883-0.4778858i,-0.9407086+0.1324167i,-0.6597308+0.6353238i,-0.1657642+0.882885i,0.3759199+0.8158706i,0.7957911+0.4511625i,0.9379139-0.1121921i,0.7071599-0.6832941i,0.1419839-1.016342i,-0.5475183-0.9177861i,-1.041425-0.3753228i,-1.06984+0.3885877i,-0.5805148+1.00489i,0.2053+1.154944i,0.9019867+0.7547072i,1.170956+0.003370531i,0.8988838-0.7333926i,0.236338-1.122289i,-0.5063558-1.016272i,-1.018951-0.4886265i,-1.110205+0.2346338i,-0.7503467+0.8744777i,0.7032388+1.006853i,1.22983+0.3648453i,1.240189-0.517787i,0.6502514-1.24798i,-0.3269254-1.43158i,-1.228363-0.9017057i,-1.564397+0.1349672i,-1.107403+1.162302i,-0.05766719+1.626909i,1.043118+1.261993i,1.61415+0.2527541i,1.366006-0.8684596i,0.4520121-1.52847i,-0.6418071-1.424136i,-1.378715-0.654976i,-1.442947+0.3727494i,-0.8576199+1.178308i,0.07598013+1.428679i,0.9428039+1.0521i,1.385739+0.2306812i,1.227637-0.6875603i,0.5286983-1.316203i,-0.4260617-1.372223i,-1.220312-0.8010458i,-1.474617+0.169173i,-1.033771+1.097631i},
    {1.610467+0.3042084i,1.446916-0.76922i,0.6479102-1.511015i,-0.4484555-1.591592i,-1.361782-0.958633i,-1.673247+0.121432i,-1.223029+1.164655i,-0.2019549+1.685733i,0.9233554+1.431832i,1.627528+0.5130129i,1.579724-0.6445127i,0.8032948-1.501931i,-0.3381278-1.664467i,-1.316345-1.063794i,-1.685739+0.01720245i,-1.284703+1.080909i,-0.3034245+1.644137i,0.8069412+1.455908i,1.540749+0.6087227i,1.568154-0.5056679i,0.8851329-1.377422i,-0.1875793-1.6145i,-1.157587-1.121791i,-1.59165-0.1374963i,-1.311018+0.8872911i,-0.4597866+1.500682i,1.346963+0.7688198i,1.530173-0.2364848i,1.052963-1.139259i,0.1154639-1.555816i,-0.8883051-1.29959i,-1.523783-0.4629472i,-1.495999+0.6052905i,-0.7895979+1.433182i,0.300698+1.630906i,1.283993+1.081393i,1.696148+0.01617348i,1.327866-1.078149i,0.3369316-1.688097i,-0.8207296-1.522452i,-1.608341-0.6532532i,-1.661962+0.5208072i,-0.9558875+1.463418i,0.1915481+1.745411i,1.263626+1.233976i,1.772673+0.1506159i,1.475074-1.021246i,0.4876428-1.743462i,-0.7486696-1.666029i,-1.657014-0.8019956i,-1.794577+0.4569546i,-1.078692+1.512621i},
    {0.6622864-0.03389071i,0.4578651-0.4941601i,-0.02214288-0.6767578i,-0.4910404-0.4597111i,-0.6594357+0.02439495i,-0.4318745+0.4708249i,0.03033956+0.6093714i,0.4279087+0.3830917i,0.5316949-0.03072489i,0.3242309-0.3622015i,-0.01976926-0.4359566i,-0.2788663-0.2654449i,-0.3335825-0.003706037i,-0.2140012+0.1866991i,-0.03661855+0.2352706i,0.09577285+0.1733393i,0.1490892+0.07315744i,0.143458-0.01513306i,0.10687-0.07973123i,0.04876257-0.1222906i,-0.0289467-0.1325449i,-0.1074238-0.09249486i,-0.1472785-0.003234421i,-0.1150782+0.09745447i,-0.01711927+0.1504606i,0.09248214+0.1167319i,0.0976563-0.09360053i,-0.0116905-0.1251506i,-0.1016705-0.05740029i,-0.09703849+0.05594193i,0.00486325+0.1159544i,0.1194149+0.05669907i,0.1332707-0.08922773i,0.001600631-0.198396i,-0.1935555-0.1481531i,-0.2858501+0.06997995i,-0.1541245+0.3122536i,0.1571362+0.3720549i,0.4359536+0.1457632i,0.44638-0.2549635i,0.1208946-0.5524526i,-0.3542896-0.4997823i,-0.6488426-0.08211764i,-0.5272745+0.4428192i,-0.03703089+0.7143176i,0.5075396+0.5295526i,0.7428487-0.003095367i,0.513167-0.5377802i,-0.02595424-0.734884i,-0.5280491-0.4890426i,-0.6974671+0.02145479i,-0.4696678+0.4797688i},
    {0.736163+0.3268098i,0.7663395-0.2296572i,0.4255008-0.6650124i,-0.1085606-0.7659868i,-0.5646474-0.4977385i,-0.7272418-0.0142501i,-0.544847+0.4375224i,-0.1372642+0.6541286i,0.2889188+0.5688207i,0.5526606+0.2573038i,0.5715109-0.1263575i,0.3696103-0.4298369i,0.04129963-0.5541762i,-0.2927942-0.4683599i,-0.5174595-0.2048185i,-0.547435+0.1482758i,-0.3554226+0.4617167i,0.002445052+0.6012353i,0.3875173+0.4853569i,0.6253326+0.1390571i,0.5881806-0.2960995i,0.2709871-0.6168578i,-0.1896057-0.6588775i,-0.5746159-0.3884864i,-0.693925+0.0710256i,-0.4872821+0.4990195i,0.3919786+0.5640816i,0.6514184+0.1880356i,0.6170178-0.2568633i,0.3211501-0.5760579i,-0.09857874-0.6459414i,-0.4699087-0.4519027i,-0.6523767-0.07631154i,-0.5766169+0.3397814i,-0.2595594+0.6390689i,0.1942302+0.6910861i,0.6091978+0.4414694i,0.7902479-0.04263857i,0.6115105-0.5654769i,0.1059543-0.8681518i,-0.5094212-0.7592991i,-0.9183677-0.2440325i,-0.8758094+0.4410422i,-0.3664989+0.9348377i,0.3591073+0.9545634i,0.9130152+0.471049i,0.9925107-0.2619296i,0.5579167-0.8510085i,-0.1484886-0.9903585i,-0.7504122-0.6290473i,-0.9522397+0.01956813i,-0.6869149+0.616564i},
    {-0.8200555-0.6576058i,-1.044856+0.04867818i,-0.7490184+0.7201258i,-0.09145255+1.027281i,0.5991247+0.8300431i,0.9890408+0.2347622i,0.8963494-0.4654157i,0.3720126-0.9323395i,-0.3265401-0.9425712i,-0.8581167-0.4945437i,-0.9634791+0.1884124i,-0.5955053+0.7666051i,0.05518525+0.9552376i,0.6582796+0.6705375i,0.9163638+0.07028105i,0.7177784-0.5348281i,0.1856093-0.8481052i,-0.39978-0.737298i,-0.7541574-0.2881196i,-0.7302386+0.2585534i,-0.3744029+0.6398553i,0.1178871+0.6980163i,0.5111384+0.4404437i,0.6418908+0.01515922i,0.4822684-0.3736497i,0.134302-0.5630479i,-0.4631289-0.2348642i,-0.483183+0.09110463i,-0.3140734+0.344953i,-0.0458845+0.4423889i,0.2130891+0.3707614i,0.3779666+0.1743612i,0.4046208-0.07396954i,0.2890745-0.2948722i,0.06460118-0.4153405i,-0.1984503-0.3838713i,-0.4019918-0.1944737i,-0.4522826+0.09331975i,-0.3084426+0.3629445i,-0.01736845+0.4885883i,0.2963995+0.4014127i,0.4890622+0.1320444i,0.4710754-0.201394i,0.2501613-0.453005i,-0.07894757-0.5178738i,-0.38321-0.3711567i,-0.5442572-0.06705707i,-0.4932947+0.2856662i,-0.229606+0.5534512i,0.168534+0.6128054i,0.5481286+0.3990676i,0.7236557-0.0406527i},
    {-0.04249324-0.8096592i,-0.5911945-0.6156097i,-0.8933505-0.08074637i,-0.7607512+0.5530682i,-0.2145982+0.9595364i,0.4956505+0.8960778i,1.001898+0.3518418i,1.012886-0.4185995i,0.4879997-1.01449i,-0.3205778-1.105487i,-0.9937898-0.6212043i,-1.171984+0.2010746i,-0.7509462+0.9401604i,0.06222833+1.213789i,0.8581778+0.8762268i,1.23407+0.09007956i,0.9938591-0.7556722i,0.2463503-1.235718i,-0.641768-1.097628i,-1.219615-0.3948854i,-1.17873+0.5245709i,-0.5241162+1.183858i,0.4092819+1.227467i,1.124288+0.6251313i,1.235711-0.2973888i,0.6935876-1.036219i,-0.916811-0.7303652i,-1.120007+0.0757544i,-0.7407238+0.7672759i,-0.03910265+1.005063i,0.5941391+0.7322046i,0.8664713+0.1562645i,0.7119443-0.4090258i,0.2703378-0.7180838i,-0.226928-0.6842698i,-0.5726221-0.3718983i,-0.6493624+0.06339179i,-0.4492307+0.4390818i,-0.06857578+0.6034369i,0.3213601+0.4910435i,0.540382+0.1609773i,0.4893432-0.218487i,0.2119587-0.4543293i,-0.1263268-0.441591i,-0.3423123-0.2253078i,-0.3514788+0.04014916i,-0.2085325+0.2061439i,-0.04279554+0.2280976i,0.0529012+0.1701664i,0.08377234+0.1215424i,0.1171728+0.1061441i,0.1910702+0.06875144i},
    {-0.8080812+1.474768i,0.3432007+1.598893i,1.267346+0.9600686i,1.542759-0.09506946i,1.077868-1.046695i,0.1327326-1.453822i,-0.8215163-1.154931i,-1.333732-0.3299909i,-1.18582+0.5997372i,-0.4882066+1.184369i,0.3880191+1.166776i,1.008051+0.6013027i,1.096408-0.1915689i,0.6660975-0.8079963i,-0.01432695-0.9762946i,-0.5889534-0.6824092i,-0.8113578-0.1405168i,-0.6527375+0.3577603i,-0.2698445+0.6098106i,0.123618+0.5815839i,0.3826229+0.3700047i,0.4745656+0.102119i,0.4365146-0.1425323i,0.3067117-0.3375374i,0.09724715-0.4642259i,-0.175925-0.4772916i,-0.6023894-0.005584332i,-0.5286165+0.3836291i,-0.2029462+0.673431i,0.2691996+0.7024873i,0.6858826+0.4123208i,0.8415896-0.1058959i,0.6294414-0.6397941i,0.1013016-0.9442281i,-0.5396308-0.8489982i,-1.010683-0.3436245i,-1.06424+0.393451i,-0.6091208+1.042292i,0.2116398+1.266954i,1.04061+0.8837665i,1.447875-0.005499855i,1.152862-1.006881i,0.213994-1.597473i,-0.9419293-1.402439i,-1.706947-0.437051i,-1.620419+0.8464448i,-0.655442+1.769224i,0.7215229+1.797369i,1.779742+0.862453i,1.926795-0.5692434i,1.05258-1.73688i,-0.3930932-2.005059i},
    {0.175402+1.000541i,0.7281132+0.652186i,0.9430745+0.0664841i,0.7677373-0.5080763i,0.2961766-0.8536298i,-0.2794791-0.849011i,-0.7355214-0.5018415i,-0.8901923+0.05261555i,-0.672824+0.5917386i,-0.1637+0.8864692i,0.4250198+0.8007673i,0.834941+0.362667i,0.8804728-0.2382877i,0.5395525-0.7354792i,-0.03530663-0.9102927i,-0.5912932-0.6912862i,-0.8919582-0.1786639i,-0.8157512+0.4090094i,-0.3964649+0.8298915i,0.1981931+0.9110156i,0.7301904+0.6090651i,0.9747624+0.02961216i,0.8060837-0.5995501i,0.2621259-1.004108i,-0.4443897-0.9767317i,-0.9958799-0.4875881i,-0.6957814+0.9472714i,0.0823542+1.200704i,0.856701+0.8786487i,1.240572+0.1152455i,1.03046-0.7246262i,0.3179482-1.228518i,-0.5540991-1.147593i,-1.165749-0.5206901i,-1.228091+0.3509189i,-0.7175269+1.056353i,0.1233509+1.271169i,0.9066399+0.9016531i,1.276844+0.1185136i,1.065747-0.7244114i,0.363601-1.245764i,-0.5182984-1.20255i,-1.179254-0.6007191i,-1.305532+0.2972773i,-0.8192863+1.079501i,0.0703724+1.369474i,0.949742+1.009841i,1.390859+0.1535144i,1.16433-0.7943531i,0.3657541-1.368013i,-0.6187426-1.276264i,-1.301045-0.5582184i},
    {0.3006073+0.9156036i,0.7917663+0.5334273i,0.9462095-0.06611487i,0.7007133-0.6324132i,0.1598575-0.9262294i,-0.4447991-0.8236912i,-0.855127-0.3718415i,-0.8995985+0.2335107i,-0.5647236+0.7359502i,0.005511948+0.9280636i,0.574768+0.7331357i,0.9102398+0.2301282i,0.8712701-0.3796983i,0.4630363-0.8481106i,-0.159849-0.9732134i,-0.7441952-0.6826275i,-1.033695-0.07551909i,-0.8791782+0.601707i,-0.3174221+1.049004i,0.4250269+1.044596i,1.017752+0.5571641i,1.172733-0.2202227i,0.7860902-0.9412387i,0.004683364-1.259255i,-0.8232731-0.995344i,-1.301246-0.2399193i,-0.4746909+1.296791i,0.4866687+1.318961i,1.24481+0.698292i,1.416908-0.2814626i,0.9013055-1.145261i,-0.06032309-1.464276i,-0.9997067-1.076548i,-1.458777-0.1707311i,-1.219479+0.8120447i,-0.4056309+1.401853i,0.5891077+1.327957i,1.298585+0.6375773i,1.401444-0.3408314i,0.8584516-1.156912i,-0.07978772-1.439956i,-0.9863274-1.058643i,-1.443123-0.1799269i,-1.227501+0.7963848i,-0.4242561+1.409724i,0.5954189+1.354404i,1.337886+0.6408475i,1.43025-0.3898214i,0.8204114-1.22592i,-0.1840447-1.448967i,-1.073555-0.9574377i,-1.408657-0.01871979i},
    {-0.06310949-1.778997i,-1.162286-1.289333i,-1.674641-0.2419812i,-1.410521+0.8569872i,-0.5361094+1.520798i,0.5330256+1.486314i,1.325509+0.8033684i,1.51082-0.2066568i,1.028918-1.095399i,0.1082824-1.478777i,-0.8362194-1.201009i,-1.387398-0.4008583i,-1.312141+0.5540944i,-0.6625033+1.237779i,0.2568611+1.359128i,1.035389+0.8858842i,1.342214+0.04511352i,1.063795-0.7894977i,0.3390625-1.263722i,-0.5117458-1.188656i,-1.126829-0.6109695i,-1.252948+0.2143648i,-0.8474367+0.9349862i,-0.09135274+1.250544i,0.6922308+1.037691i,1.178506+0.3958352i,0.6910606-1.038713i,-0.07965261-1.257536i,-0.8386658-0.9695866i,-1.286895-0.2688768i,-1.223251+0.59105i,-0.6246322+1.267233i,0.312034+1.44217i,1.202866+0.9679195i,1.614578-0.01870875i,1.278287-1.096696i,0.2736246-1.727804i,-0.9495224-1.537357i,-1.77025-0.5535317i,-1.731536+0.7606133i,-0.8142829+1.733889i,0.529389+1.853848i,1.616548+1.053236i,1.904369-0.2576637i,1.270012-1.423244i,0.04832494-1.88914i,-1.166105-1.464105i,-1.817878-0.3768465i,-1.632732+0.8627691i,-0.711033+1.701181i,0.5336683+1.769685i,1.548043+1.030689i},
    {-0.08279401+1.635018i,0.9963799+1.289433i,1.57722+0.3299211i,1.392823-0.7549431i,0.5705505-1.442216i,-0.4677871-1.440887i,-1.243124-0.8029778i,-1.441931+0.1490672i,-1.020355+0.9976472i,-0.1813499+1.402275i,0.724123+1.210617i,1.324187+0.5013192i,1.358422-0.4380125i,0.7903863-1.205807i,-0.1498913-1.448488i,-1.043007-1.033098i,-1.469274-0.1345428i,-1.220706+0.8325014i,-0.412623+1.415831i,0.5750826+1.350878i,1.290971+0.6818348i,1.42571-0.277835i,0.9370549-1.104419i,0.04549269-1.448885i,-0.8703323-1.168998i,-1.423075-0.3761374i,-0.6935056+1.348558i,0.3191266+1.508759i,1.223535+0.9788864i,1.588465-0.02570887i,1.218526-1.046006i,0.2694924-1.595376i,-0.8164914-1.405128i,-1.528537-0.5615951i,-1.537381+0.5405457i,-0.8451463+1.394752i,0.2300561+1.617813i,1.206971+1.111918i,1.649819+0.09728885i,1.349871-0.981154i,0.4203693-1.635005i,-0.7325895-1.543848i,-1.571842-0.7182216i,-1.677963+0.4728865i,-0.973791+1.456171i,0.2085795+1.739008i,1.283437+1.176705i,1.719823+0.0582354i,1.324213-1.051866i,0.3275195-1.621504i,-0.7654737-1.420025i,-1.453672-0.5980446i},
    {-0.009937407-0.1481895i,-0.1120012-0.1319465i,-0.1988071-0.03638014i,-0.1996325+0.1204333i,-0.07224183+0.2540535i,0.1388036+0.2584226i,0.3055984+0.09276272i,0.2996528-0.1627736i,0.09694558-0.3438794i,-0.1848865-0.317515i,-0.3602678-0.08807527i,-0.31051+0.1962718i,-0.07296269+0.3492103i,0.1889012+0.2818728i,0.3097395+0.0601941i,0.2388111-0.1577809i,0.0578509-0.2459075i,-0.1024561-0.1907443i,-0.1659995-0.07133842i,-0.1470303+0.02739139i,-0.1019373+0.08073754i,-0.0588813+0.1148119i,0.0009759194+0.1464729i,0.09756656+0.1455984i,0.1981572+0.06448218i,0.2220541-0.09470899i,-0.1022679-0.2797142i,-0.2884467-0.1355173i,-0.3136174+0.1143451i,-0.1421753+0.3120801i,0.1248633+0.3227794i,0.3158746+0.1348912i,0.3096312-0.1290828i,0.1188913-0.2998426i,-0.1244983-0.2787956i,-0.2667288-0.09875146i,-0.2356568+0.1109632i,-0.0776028+0.2208834i,0.09014968+0.1851723i,0.1670524+0.05701023i,0.131228-0.0646418i,0.03740875-0.109475i,-0.03704181-0.07661137i,-0.0515141-0.01880615i,-0.02344615+0.00941213i,-0.001399427-0.00417557i,-0.0167865-0.0262213i,-0.05514653-0.01417821i,-0.07002943+0.04031374i,-0.0270886+0.09865265i,0.05956638+0.1053455i,0.1314621+0.03689199i},
    {0.3659732+0.4224359i,0.5422909+0.04587002i,0.4076764-0.330645i,0.06667557-0.4976341i,-0.2735859-0.3912767i,-0.4409886-0.1045196i,-0.3835587+0.1988554i,-0.1610799+0.3843323i,0.1166765+0.3926111i,0.3406298+0.2314788i,0.421149-0.04128841i,0.3046761-0.319945i,0.01273776-0.4649453i,-0.3262118-0.3659802i,-0.5134538-0.03461184i,-0.4009851+0.3557469i,-0.02056691+0.5525351i,0.3980554+0.3997383i,0.5684935-0.02483027i,0.3598281-0.4387433i,-0.08976926-0.5521892i,-0.4636762-0.2873876i,-0.5019343+0.1584013i,-0.1956617+0.4631136i,0.2152054+0.4242603i,0.43455+0.1015437i,0.0211263-0.3834026i,-0.2566965-0.2423149i,-0.321362+0.03438829i,-0.1693451+0.2419075i,0.06120837+0.2629546i,0.215111+0.1234571i,0.2214072-0.06320191i,0.1075458-0.1891983i,-0.04990222-0.2050964i,-0.1756288-0.1173713i,-0.2156395+0.03299678i,-0.1436713+0.1811085i,0.02247703+0.2481316i,0.2059869+0.1755687i,0.2933244-0.02368445i,0.2041134-0.2447769i,-0.03614411-0.340926i,-0.2884901-0.2248006i,-0.3828657+0.05444863i,-0.2383009+0.3278932i,0.07075989+0.4154333i,0.3565213+0.2492729i,0.4396318-0.07796466i,0.2637923-0.3724158i,-0.07233299-0.4597308i,-0.3780451-0.2864011i},
    {0.7271116+0.4152943i,0.8401895-0.1235209i,0.5967572-0.6332468i,0.07095031-0.8955518i,-0.5312636-0.7649345i,-0.9316077-0.2557973i,-0.9060235+0.4227765i,-0.4223192+0.9395176i,0.3063401+1.009599i,0.9119873+0.5664799i,1.070328-0.17936i,0.6880793-0.8455784i,-0.04041987-1.088291i,-0.7419946-0.7888922i,-1.067912-0.1087917i,-0.8704881+0.6079644i,-0.2626188+1.015932i,0.4537944+0.9325161i,0.9391583+0.4119388i,0.9720507-0.2910897i,0.5458639-0.8427418i,-0.1303828-0.9842058i,-0.7295038-0.654084i,-0.963774-0.02059101i,-0.7290847+0.6004674i,-0.157481+0.9072948i,0.8147998+0.2786861i,0.7704099-0.2990627i,0.3838362-0.690602i,-0.1335509-0.7419046i,-0.542818-0.4720302i,-0.6875072-0.03233463i,-0.5405459+0.381757i,-0.1884154+0.6120039i,0.2176975+0.5845595i,0.5181064+0.324052i,0.598044-0.05879448i,0.430382-0.4062121i,0.09018084-0.575579i,-0.275384-0.502237i,-0.5144528-0.2278515i,-0.5390779+0.1251905i,-0.3550079+0.4162998i,-0.04228073+0.5446069i,0.2876388+0.472595i,0.5251529+0.2210113i,0.5796484-0.1390332i,0.4008411-0.4873511i,0.01694977-0.6719537i,-0.4358876-0.5686606i,-0.7419737-0.1683869i,-0.7107359+0.3720745i},
    {-0.7189723-0.9555288i,-1.197062-0.3149655i,-1.172662+0.5226822i,-0.5995088+1.188645i,0.3060982+1.34297i,1.130573+0.8593385i,1.45576-0.07413942i,1.085241-1.019574i,0.1695189-1.504433i,-0.8551689-1.271901i,-1.487563-0.421382i,-1.41746+0.6410498i,-0.6767491+1.409085i,0.3858065+1.522322i,1.27746+0.928502i,1.587589-0.1026924i,1.166543-1.104047i,0.1916351-1.613643i,-0.9010738-1.378176i,-1.599347-0.4791608i,-1.54945+0.6797721i,-0.7428714+1.542127i,0.4491235+1.667166i,1.438922+0.9688661i,1.721055-0.2155055i,1.147726-1.287705i,-1.089098-1.274875i,-1.620737-0.2443509i,-1.349961+0.8475676i,-0.4634641+1.472183i,0.5718292+1.375545i,1.269895+0.6689842i,1.355584-0.274332i,0.8540367-1.026608i,0.03003947-1.294155i,-0.7559763-1.010404i,-1.194791-0.3256854i,-1.129549+0.4711038i,-0.5979874+1.060506i,0.1837041+1.203933i,0.8943865+0.8345818i,1.228234+0.09604912i,1.025985-0.7004094i,0.3591639-1.200105i,-0.484117-1.165572i,-1.120313-0.5972983i,-1.24911+0.2528327i,-0.8024102+0.9922927i,0.01530443+1.274182i,0.8213478+0.9668375i,1.239826+0.2191256i,1.08386-0.6138449i},
    {-0.496906-1.579889i,-1.40096-0.8312851i,-1.565407+0.3038129i,-0.9481384+1.231717i,0.09372769+1.507152i,1.023872+1.045968i,1.411737+0.1264315i,1.124353-0.7885631i,0.347253-1.287373i,-0.539259-1.181833i,-1.142484-0.5572061i,-1.215425+0.2903077i,-0.7436305+0.9844421i,0.0552823+1.220746i,0.8187395+0.8941928i,1.192764+0.154507i,0.9985161-0.6488052i,0.3310152-1.127031i,-0.4764963-1.04962i,-1.021094-0.4697765i,-1.044846+0.3030889i,-0.5695149+0.8756987i,0.1304528+0.9860565i,0.6954585+0.6312214i,0.8790945+0.03796235i,0.6569996-0.4887878i,-0.2670935-0.6490273i,-0.5569057-0.3381723i,-0.6089103+0.04341868i,-0.4540565+0.3620922i,-0.1691388+0.537569i,0.1575944+0.5359016i,0.435619+0.3588701i,0.5767168+0.04859084i,0.5164762-0.3040569i,0.2498494-0.5719641i,-0.1449877-0.6355282i,-0.5201458-0.4406211i,-0.7124041-0.03786131i,-0.615971+0.4228592i,-0.2389953+0.7458783i,0.2844049+0.7712812i,0.7366019+0.4514013i,0.9021932-0.1111487i,0.6670816-0.6866813i,0.08913741-1.004811i,-0.5994651-0.8776874i,-1.076053-0.3077828i,-1.07506+0.4795191i,-0.5355125+1.113986i,0.3326642+1.251557i,1.117974+0.7625864i},
    {0.6045712-0.7203885i,-0.001444989-0.8930644i,-0.5460045-0.6513914i,-0.7982385-0.1447008i,-0.6759567+0.3820174i,-0.262792+0.6965507i,0.2370733+0.6733547i,0.5898569+0.3440824i,0.6390139-0.1173757i,0.3823305-0.4787426i,-0.02635597-0.5697755i,-0.3632137-0.3746043i,-0.4648749-0.03516429i,-0.3216097+0.2435654i,-0.06840886+0.3266032i,0.1211874+0.2275029i,0.1604923+0.07585739i,0.09925181+0.0009110722i,0.06044217+0.02502975i,0.1179994+0.05430339i,0.2194485-0.02491732i,0.2234983-0.2239711i,0.02848659-0.4112746i,-0.3120466-0.3988155i,-0.5892436-0.09810404i,-0.5716427+0.3756585i,0.4093147+0.7347518i,0.8658487+0.2808477i,0.8825031-0.40927i,0.3912236-0.9512774i,-0.37391-1.010832i,-0.9969721-0.5117662i,-1.1171+0.3038426i,-0.6398687+1.002702i,0.2017661+1.199875i,0.9704018+0.7723033i,1.258701-0.07221082i,0.9052565-0.9038026i,0.07875918-1.293857i,-0.80805-1.034372i,-1.306118-0.243845i,-1.154786+0.6893128i,-0.414828+1.296489i,0.5543561+1.261183i,1.265951+0.5829492i,1.347926-0.4100607i,0.7394049-1.215238i,-0.2629012-1.409328i,-1.144719-0.8759706i,-1.440106+0.1184425i,-0.9857091+1.054464i,-0.01904654+1.436i},
    {-0.1058766-1.12977i,-0.8190483-0.8289219i,-1.192278-0.1158054i,-1.010524+0.7000694i,-0.3173328+1.216138i,0.5674176+1.145369i,1.193901+0.4932116i,1.226767-0.419535i,0.6414282-1.121679i,-0.2557146-1.252994i,-1.000027-0.7621962i,-1.226595+0.07740127i,-0.8565086+0.8339193i,-0.1111527+1.153103i,0.6319413+0.9249478i,1.03961+0.3030018i,0.9670735-0.405013i,0.4892827-0.8936143i,-0.1650354-0.9814906i,-0.7223963-0.6603596i,-0.9664639-0.07618459i,-0.8069806+0.5329663i,-0.3075484+0.9207743i,0.3323901+0.9211409i,0.8444573+0.5188451i,0.9965042-0.1281656i,0.07167694-1.028427i,-0.6078916-0.8446034i,-1.013793-0.2589421i,-0.9431944+0.4546619i,-0.4260748+0.9509232i,0.28366+0.9909829i,0.8397704+0.5671566i,0.9852691-0.09893017i,0.6787189-0.6824482i,0.09560101-0.9270168i,-0.4839374-0.7600234i,-0.8212897-0.2955866i,-0.8126215+0.2526672i,-0.4954288+0.6769641i,0.0006208023+0.8392635i,0.505632+0.6875209i,0.842471+0.2572928i,0.8619677-0.3198644i,0.504652-0.8232351i,-0.131228-1.00707i,-0.7803002-0.7255191i,-1.110631-0.05144043i,-0.906608+0.7103308i,-0.2230387+1.161861i,0.6089928+1.039106i,1.153453+0.3822042i},
    {0.4417227-0.08890107i,0.3350261-0.3184864i,0.1139228-0.4759198i,-0.1882101-0.4948771i,-0.4833401-0.3195147i,-0.6349128+0.0395942i,-0.5201632+0.4639925i,-0.1212029+0.7501151i,0.4193976+0.7077594i,0.8361161+0.2868208i,0.8738918-0.352123i,0.4492827-0.8889901i,-0.2651796-1.0103i,-0.905288-0.6008615i,-1.10967+0.1615058i,-0.7350027+0.8824034i,0.04373262+1.166606i,0.8192139+0.8470421i,1.178505+0.08568327i,0.9344999-0.7168096i,0.2240095-1.146064i,-0.5790458-0.9968589i,-1.073213-0.3676485i,-1.034895+0.412677i,-0.5116554+0.9664328i,0.2269315+1.049775i,1.042217-0.0325508i,0.7738729-0.6827605i,0.1595162-1.012004i,-0.5208111-0.8765429i,-0.958029-0.3394623i,-0.9504111+0.3530338i,-0.4996859+0.8788736i,0.1829891+0.9901831i,0.7737665+0.6353184i,0.9933416-0.01311557i,0.7441164-0.6436068i,0.1543234-0.960522i,-0.4917297-0.8258022i,-0.8952807-0.3162625i,-0.8810901+0.3241473i,-0.4681689+0.8033298i,0.1491629+0.9107164i,0.6914537+0.6039215i,0.9147723+0.02356071i,0.7162964-0.5664091i,0.1842367-0.8925305i,-0.4340955-0.7979293i,-0.8427911-0.3241708i,-0.8424855+0.2991822i,-0.436664+0.7646101i,0.1652216+0.8457168i},
    {-0.9210207-0.7222874i,-1.207348+0.02392386i,-0.9449611+0.812546i,-0.2107085+1.267314i,0.6747267+1.135799i,1.280792+0.4384774i,1.283778-0.5100358i,0.6511708-1.242738i,-0.3207498-1.381401i,-1.151106-0.8430579i,-1.425184+0.1100865i,-1.01016+1.007688i,-0.1168177+1.415356i,0.818197+1.149271i,1.354964+0.3524568i,1.257139-0.5916004i,0.5872115-1.248771i,-0.338937-1.330141i,-1.102316-0.8102568i,-1.364571+0.07199149i,-1.010854+0.9214318i,-0.1978083+1.35744i,0.712288+1.179644i,1.307471+0.4600176i,1.309573-0.4818153i,0.7052697-1.215921i,-1.086887-0.9249874i,-1.437551-0.008777332i,-1.111001+0.9269505i,-0.2481751+1.433153i,0.7442356+1.255388i,1.383537+0.4685526i,1.350766-0.5471715i,0.6593143-1.289613i,-0.3433599-1.391066i,-1.152716-0.8120356i,-1.372616+0.1389158i,-0.9214917+0.9751631i,-0.06151404+1.29521i,0.7611561+0.9860436i,1.162763+0.2540896i,1.007242-0.5176407i,0.4347474-0.9832631i,-0.2547395-0.9887545i,-0.7679183-0.5982209i,-0.9349542-0.0145482i,-0.7375354+0.5296538i,-0.275446+0.8496041i,0.281314+0.8442562i,0.7350725+0.5131136i,0.9095252-0.03404478i,0.7145706-0.5923301i},
    {0.01371275-0.2034453i,-0.06819618-0.1679257i,-0.1266643-0.1256996i,-0.1850442-0.06748346i,-0.2284127+0.0369377i,-0.2021486+0.1861185i,-0.06114444+0.3162791i,0.1703917+0.3287613i,0.3839612+0.1633977i,0.4410492-0.1370127i,0.2664137-0.4268584i,-0.08521082-0.5340919i,-0.4416601-0.3677515i,-0.6047562+0.0146263i,-0.4658843+0.4268465i,-0.0742581+0.6518728i,0.383019+0.5598994i,0.6760951+0.1796852i,0.6490136-0.3129625i,0.2983132-0.6794578i,-0.2213933-0.73203i,-0.6647263-0.4251376i,-0.806892+0.1144177i,-0.5537136+0.6346931i,-0.001204679+0.870479i,0.5915934+0.6766766i,0.786491-0.5367815i,0.2327168-0.9471245i,-0.4707448-0.8762928i,-0.9513638-0.3382907i,-0.9406699+0.3934325i,-0.4325081+0.9282146i,0.3048018+0.976232i,0.8762136+0.5136361i,0.9818718-0.2054221i,0.5809323-0.7961395i,-0.09697626-0.9586894i,-0.6911316-0.6342012i,-0.9096273-0.01747108i,-0.6733712+0.5664427i,-0.1334982+0.8389196i,0.4288979+0.6981952i,0.7514868+0.2456321i,0.7081336-0.2861826i,0.3478581-0.6523944i,-0.1461041-0.7024213i,-0.5464589-0.4342202i,-0.6802754+0.01594676i,-0.4993987+0.4380228i,-0.09800492+0.641167i,0.3308783+0.5391762i,0.5850816+0.1907603i},
    {0.9821422+0.79017i,1.305801-0.05429845i,0.9676746-0.9289945i,0.1097223-1.358715i,-0.8238994-1.097273i,-1.340881-0.2784589i,-1.182398+0.6657317i,-0.4538204+1.257553i,0.460399+1.228982i,1.119559+0.6335297i,1.242512-0.2201312i,0.8103517-0.9403328i,0.03878491-1.225895i,-0.7329093-0.9730337i,-1.178782-0.2990845i,-1.108616+0.5078145i,-0.5454613+1.098485i,0.2723956+1.205336i,0.982058+0.7665109i,1.255186-0.03162109i,0.955216-0.8287265i,0.21014-1.255326i,-0.641758-1.108028i,-1.20798-0.4471858i,-1.223084+0.4290517i,-0.6712494+1.118965i,0.9954681+0.8715436i,1.330718+0.02557297i,1.036173-0.8439434i,0.2421859-1.315801i,-0.6688957-1.154479i,-1.249683-0.4387325i,-1.219518+0.4730035i,-0.6105596+1.130846i,0.258489+1.229784i,0.9622495+0.7567312i,1.189518-0.02917308i,0.8782039-0.752447i,0.2076439-1.107423i,-0.5152224-0.9753911i,-0.9941468-0.4403145i,-1.046051+0.2676726i,-0.6535072+0.8593346i,0.02719378+1.084342i,0.7092196+0.8303987i,1.08151+0.1917667i,0.9558524-0.5455697i,0.3802115-1.028111i,-0.3663706-1.019662i,-0.9171281-0.5355678i,-1.018864+0.168056i,-0.6608204+0.747009i},
    {-0.1426821-0.3565617i,-0.331945-0.1406274i,-0.3113864+0.1281179i,-0.1183259+0.2899511i,0.1152118+0.2664941i,0.2510616+0.09560946i,0.2249-0.1057367i,0.0729101-0.2184368i,-0.1016419-0.188628i,-0.1944403-0.04999296i,-0.1586983+0.1045356i,-0.02637291+0.1804035i,0.1153129+0.1353717i,0.1766742+0.001728875i,0.1185221-0.1340238i,-0.02382443-0.182879i,-0.1599803-0.1079807i,-0.1982622+0.04968248i,-0.1037235+0.1920232i,0.0749025+0.2219549i,0.2288158+0.1058474i,0.2530711-0.09847183i,0.1143695-0.2690385i,-0.1195653-0.2906094i,-0.3114105-0.1289585i,-0.3332295+0.1376765i,0.1525647+0.3790317i,0.3967595+0.1722573i,0.425479-0.1640415i,0.197724-0.4358583i,-0.1716911-0.4695512i,-0.469198-0.2233611i,-0.5081359+0.174658i,-0.2478542+0.4939072i,0.1716181+0.5385677i,0.5073503+0.2706793i,0.559162-0.1609932i,0.2921966-0.50769i,-0.1413814-0.5695705i,-0.494394-0.3134491i,-0.5708322+0.1120916i,-0.3357014+0.468521i,0.07362203+0.5650794i,0.4326748+0.3598492i,0.5549596-0.02791678i,0.3858775-0.3906046i,0.02170967-0.542928i,-0.3465286-0.4125473i,-0.5306067-0.07100181i,-0.437429+0.3043453i,-0.1154623+0.5183961i,0.2669341+0.4572982i},
    {0.9920865-1.039919i,0.1432824-1.436433i,-0.7768318-1.231903i,-1.38944-0.4996107i,-1.427521+0.4736312i,-0.8440754+1.285708i,0.147281+1.56985i,1.130236+1.157636i,1.648412+0.185888i,1.422179-0.926189i,0.5126-1.653138i,-0.6752014-1.623508i,-1.577046-0.8238544i,-1.753636+0.3790402i,-1.114575+1.418919i,0.04203343+1.811651i,1.185066+1.381857i,1.802861+0.3266422i,1.622493-0.8894643i,0.7117453-1.736476i,-0.5520876-1.830699i,-1.622578-1.092445i,-1.996958+0.1957716i,-1.444579+1.469333i,-0.1575334+2.108505i,1.281348+1.744196i,1.971472-1.059691i,0.7903687-2.114042i,-0.8035261-2.113893i,-1.989929-1.053184i,-2.167853+0.5128147i,-1.278086+1.780726i,0.1911442+2.138237i,1.496763+1.466598i,2.036182+0.1522906i,1.61927-1.155939i,0.5022789-1.875758i,-0.7809054-1.733578i,-1.670586-0.838983i,-1.803331+0.3953786i,-1.140788+1.431401i,0.02060786+1.819811i,1.165198+1.38781i,1.774232+0.3270598i,1.565063-0.8760713i,0.6369638-1.660707i,-0.5672854-1.664417i,-1.478729-0.9032542i,-1.684865+0.2437176i,-1.122875+1.234374i,-0.08626854+1.631181i,0.9398231+1.293273i},
    {-0.4389506-0.03116399i,-0.3638356+0.2739587i,-0.09510706+0.4611348i,0.2429968+0.4201462i,0.473791+0.1535786i,0.4631371-0.2089266i,0.2036486-0.4726813i,-0.1700224-0.488614i,-0.454027-0.2448014i,-0.494907+0.1236862i,-0.2787077+0.4158923i,0.06777276+0.4833228i,0.3592029+0.3082668i,0.4577667-0.001938163i,0.3362254-0.2880321i,0.07146106-0.4236308i,-0.2090131-0.3638378i,-0.386287-0.1472609i,-0.3900255+0.1300149i,-0.2182677+0.3496566i,0.05845962+0.4113401i,0.3153035+0.2767257i,0.4227667+0.0002259517i,0.3160504-0.2823275i,0.04357022-0.4191307i,-0.2480711-0.3323153i,-0.3250517+0.2093949i,-0.08891692+0.3542808i,0.1640974+0.2971425i,0.2940575+0.09773793i,0.2538686-0.1120205i,0.1020642-0.2209633i,-0.05549175-0.201428i,-0.1417504-0.1037161i,-0.1453907-0.001023699i,-0.1024136+0.063469i,-0.05193954+0.0895544i,-0.007981311+0.09607377i,0.03551203+0.09190029i,0.08174998+0.06883629i,0.1170409+0.01699636i,0.1177302-0.05686804i,0.06913405-0.1257676i,-0.02032984-0.1552216i,-0.1188395-0.1217933i,-0.1828033-0.02688891i,-0.174628+0.0987673i,-0.0818374+0.2017802i,0.06877177+0.2256385i,0.2124256+0.140332i,0.2714474-0.03168653i,0.198066-0.2137161i},
    {0.5758303-0.767965i,-0.03015402-0.9683967i,-0.6309205-0.7405285i,-0.9546593-0.1867082i,-0.8631154+0.4432079i,-0.4074647+0.8777555i,0.2123358+0.9442433i,0.7450992+0.6262055i,0.98522+0.05059908i,0.8351042-0.5665421i,0.3319846-0.987527i,-0.3533445-1.025019i,-0.9526816-0.6168708i,-1.18631+0.1173592i,-0.8900678+0.8823379i,-0.1295783+1.309673i,0.7784626+1.137081i,1.386853+0.3761405i,1.344894-0.6434499i,0.611982-1.4112i,-0.4801149-1.502654i,-1.378099-0.8282536i,-1.602331+0.2916039i,-1.018124+1.285358i,0.08133187+1.639345i,1.133627+1.177191i,1.303629-0.9268402i,0.3886687-1.527147i,-0.672595-1.397911i,-1.389249-0.6381693i,-1.46209+0.3822912i,-0.8878019+1.210468i,0.07084081+1.498713i,1.00404+1.127636i,1.509614+0.244203i,1.345455-0.7837059i,0.5441161-1.494925i,-0.5619643-1.527439i,-1.452615-0.8109163i,-1.659523+0.3485634i,-1.029404+1.378785i,0.1496115+1.72927i,1.268732+1.18892i,1.727875+0.03247987i,1.284426-1.118571i,0.1981922-1.651876i,-0.9270454-1.316655i,-1.504117-0.3494365i,-1.291281+0.6970414i,-0.4878128+1.293723i,0.4364042+1.217327i,1.03504+0.613052i},
    {-1.202345-0.4041427i,-1.130418+0.5110989i,-0.4612482+1.107304i,0.4009406+1.072879i,0.9657446+0.48076i,0.9605266-0.2825669i,0.4722699-0.7832251i,-0.1552428-0.8065618i,-0.5716063-0.4452196i,-0.6271987+0.02329182i,-0.4064582+0.3475388i,-0.1039314+0.4387181i,0.1298936+0.3586972i,0.2547743+0.2134268i,0.3002598+0.06326202i,0.290959-0.08458932i,0.2174247-0.2261436i,0.0675919-0.3238795i,-0.1300509-0.323529i,-0.3036515-0.2017823i,-0.3785807+0.006775843i,-0.3206132+0.2274755i,-0.1457273+0.3850477i,0.09868897+0.4273451i,0.3493361+0.3251375i,0.5241338+0.07403252i,0.2783309-0.6110047i,-0.1853681-0.7340042i,-0.68571-0.5001555i,-0.9408463+0.07359453i,-0.7255617+0.7443457i,-0.04906059+1.132655i,0.7823836+0.9419538i,1.298042+0.1774865i,1.138662-0.7957028i,0.3074131-1.427607i,-0.7812811-1.306988i,-1.514175-0.4350111i,-1.440021+0.7374043i,-0.5567772+1.552664i,0.6634696+1.532533i,1.539879+0.6697732i,1.581167-0.5596343i,0.7720901-1.474537i,-0.4266197-1.584911i,-1.35765-0.8632585i,-1.545672+0.2659016i,-0.9443066+1.193165i,0.08034021+1.468612i,0.9886093+1.017266i,1.361947+0.1249226i,1.084137-0.7553288i},
    {-1.066533+0.3095026i,-0.6008799+0.9059787i,0.1147857+1.054028i,0.7358212+0.7248329i,1.00271+0.103982i,0.836762-0.5270829i,0.3356018-0.9185466i,-0.2924769-0.9319607i,-0.8066959-0.5670366i,-1.004219+0.04464424i,-0.7850904+0.6710777i,-0.2050835+1.04696i,0.5146421+0.977983i,1.054611+0.4472627i,1.136457-0.3401453i,0.6742576-1.023803i,-0.1510879-1.254233i,-0.9540715-0.8797066i,-1.32783-0.04756197i,-1.057875+0.8479167i,-0.2491448+1.35598i,0.7102722+1.20323i,1.338949+0.4456846i,1.310472-0.547623i,0.6287441-1.278074i,-0.3671027-1.375036i,-1.393893+0.1758639i,-0.9245057+1.035391i,-0.01911942+1.366341i,0.8625655+1.02639i,1.294428+0.2108553i,1.09349-0.6646699i,0.391959-1.182816i,-0.4511936-1.124417i,-1.038052-0.5544072i,-1.118294+0.233022i,-0.6896958+0.867444i,0.02130494+1.074222i,0.6779208+0.7895249i,0.9912188+0.1739189i,0.846926-0.4752321i,0.3449638-0.8687448i,-0.2637793-0.8575466i,-0.7076909-0.4872338i,-0.8207027+0.04712447i,-0.5992209+0.5115018i,-0.1710018+0.7398349i,0.287018+0.6817533i,0.6221539+0.3855613i,0.736719-0.04466833i,0.5893742-0.4774987i,0.2021765-0.7656585i},
    {0.1443923+0.4620939i,0.4432127+0.2729061i,0.5444015-0.09022066i,0.3692739-0.4452779i,-0.01104335-0.6010322i,-0.41149-0.4648291i,-0.632036-0.09224401i,-0.5590363+0.3439326i,-0.2166954+0.6394165i,0.2474558+0.6508994i,0.6263931+0.356952i,0.7382321-0.1291424i,0.5053643-0.5964148i,0.002686096-0.8172287i,-0.5522091-0.6526645i,-0.8825339-0.1397026i,-0.789093+0.4951534i,-0.2747438+0.9278708i,0.425171+0.9057398i,0.9471129+0.4026197i,0.9957833-0.3411953i,0.5203689-0.9355445i,-0.242074-1.055329i,-0.8909811-0.6269239i,-1.083652+0.1276448i,-0.7223234+0.8144526i,0.7102671+0.8067319i,1.056838+0.1377187i,0.8795696-0.5854387i,0.2780129-1.010521i,-0.4486337-0.9390113i,-0.9484947-0.4130915i,-0.9819852+0.3089024i,-0.5342414+0.8744681i,0.174502+1.00466i,0.7909882+0.6333742i,1.003256-0.05206465i,0.7040792-0.6996437i,0.05375455-0.9749481i,-0.6015875-0.7422985i,-0.9186004-0.1401632i,-0.746522+0.4981574i,-0.2057922+0.8351486i,0.3913676+0.7175416i,0.7275657+0.2501496i,0.6579227-0.2841113i,0.2731807-0.6004661i,-0.1800267-0.5714068i,-0.4595146-0.2750727i,-0.4624364+0.08310223i,-0.2563269+0.3108381i,-0.002814468+0.3359124i},
    {0.4588775+1.258045i,1.172779+0.5985523i,1.243363-0.3506728i,0.6627494-1.078298i,-0.2367067-1.216137i,-0.975222-0.7199525i,-1.178741+0.1264246i,-0.764134+0.8710251i,0.02894417+1.130892i,0.7705127+0.7885017i,1.070366+0.04885842i,0.7874675-0.6755275i,0.1035159-0.9945384i,-0.5857304-0.7583492i,-0.9021944-0.1350658i,-0.7022499+0.5001161i,-0.1461115+0.7949504i,0.4186779+0.6238428i,0.677783+0.1402338i,0.5301532-0.3435892i,0.1203438-0.5584439i,-0.2794467-0.4287593i,-0.4459319-0.08757565i,-0.3260234+0.2324498i,-0.04111133+0.3485109i,0.2087738+0.2259385i,0.1299576-0.2126874i,-0.1003863-0.2184066i,-0.2450711-0.03781931i,-0.1867688+0.1966659i,0.05096725+0.3028696i,0.3064048+0.1735734i,0.3796994-0.1355569i,0.174903-0.4229209i,-0.2127341-0.467441i,-0.5372252-0.1881264i,-0.5583039+0.2768424i,-0.2130146+0.639805i,0.3207755+0.64669i,0.7227148+0.2517995i,0.7302427-0.3377476i,0.3081356-0.7813117i,-0.3232811-0.8097452i,-0.8150738-0.3853114i,-0.8879136+0.276747i,-0.4843257+0.8272354i,0.2019277+0.9675081i,0.8233523+0.6025016i,1.04941-0.1063774i,0.7331476-0.8092632i,0.0002527463-1.131332i,-0.7891076-0.8664323i},
    {0.3630504-0.78294i,-0.1834936-0.8099654i,-0.6150886-0.5181617i,-0.785129-0.04649956i,-0.6519475+0.4256863i,-0.2702036+0.7324687i,0.2273517+0.7582077i,0.6554802+0.473776i,0.8287821-0.03141688i,0.6441175-0.5551008i,0.1539494-0.8551362i,-0.4301386-0.7712425i,-0.830576-0.3245043i,-0.8499514+0.2788066i,-0.4793643+0.7523786i,0.1008335+0.8802851i,0.6231326+0.6193427i,0.8666394+0.1005926i,0.7447934-0.4508239i,0.3177498-0.8158517i,-0.2476014-0.8537382i,-0.7349064-0.5386147i,-0.9409626+0.02757061i,-0.7484198+0.6290148i,-0.195732+0.9984459i,0.5006915+0.9321303i,1.077138-0.3501023i,0.612486-0.9889691i,-0.1765327-1.175397i,-0.9101647-0.7953708i,-1.224392-0.01955778i,-0.958953+0.7820359i,-0.234627+1.226717i,0.6117605+1.102549i,1.188445+0.4609798i,1.22418-0.4111942i,0.6869625-1.116888i,-0.1946538-1.319565i,-1.018476-0.8984354i,-1.382272-0.02374367i,-1.081122+0.8974599i,-0.2323896+1.404994i,0.7558039+1.223145i,1.381561+0.4234814i,1.316993-0.5942314i,0.5930077-1.30901i,-0.4139717-1.360351i,-1.188997-0.7395619i,-1.355607+0.2185095i,-0.8625169+1.028074i,0.01464402+1.308256i,0.8366826+0.9602902i},
    {0.6664541-1.030261i,-0.1816605-1.226374i,-0.9564597-0.8113299i,-1.270641+0.02159233i,-0.9531388+0.8684111i,-0.1403812+1.301791i,0.7728543+1.081702i,1.316083+0.2926488i,1.185994-0.673938i,0.4258298-1.307849i,-0.5728009-1.256315i,-1.271139-0.5342197i,-1.286324+0.4682527i,-0.6161946+1.201763i,0.3583113+1.274338i,1.099099+0.6734982i,1.223519-0.2420682i,0.7096884-0.9670622i,-0.1212393-1.140906i,-0.8139173-0.7282824i,-1.035606+0.0008605951i,-0.7312189+0.6509497i,-0.1111297+0.9167061i,0.4903832+0.7181304i,0.7915384+0.2053171i,0.6866349-0.3431529i,-0.2171756-0.6335118i,-0.5385309-0.3071754i,-0.55633+0.1165804i,-0.3057805+0.4134271i,0.04204138+0.4549593i,0.2900003+0.2700639i,0.3324434+0.008007326i,0.2048012-0.1700788i,0.03576433-0.1949399i,-0.05751115-0.1166036i,-0.05074499-0.04265425i,-0.01219534-0.04198638i,-0.02861006-0.09127142i,-0.1218235-0.1029596i,-0.2233089-0.007732693i,-0.2252582+0.176025i,-0.06804218+0.3398305i,0.2006972+0.3526483i,0.4379452+0.1528986i,0.4835969-0.1949591i,0.2605494-0.5169051i,-0.1610121-0.615782i,-0.5769511-0.3863086i,-0.7450527+0.103324i,-0.5228709+0.6179753i,0.02721321+0.8651087i},
    {0.1664766+0.8724213i,0.6889282+0.5504187i,0.873813-0.02919294i,0.639229-0.5839109i,0.1063232-0.8497297i,-0.4644085-0.7073176i,-0.801565-0.2347693i,-0.752226+0.3354741i,-0.3508831+0.731541i,0.2025526+0.7721226i,0.6424934+0.4497107i,0.7658662-0.07112532i,0.5269234-0.5376847i,0.05363183-0.7331268i,-0.4206862-0.5791389i,-0.674542-0.1671148i,-0.6041842+0.2953392i,-0.2654445+0.5918653i,0.1657775+0.6012459i,0.4880458+0.3454981i,0.5708738-0.03645879i,0.4048491-0.3671875i,0.08785518-0.5148401i,-0.234362-0.4416742i,-0.4358978-0.2022214i,-0.454693+0.0952886i,-0.04406421+0.4431854i,0.2235694+0.3819788i,0.407098+0.1778816i,0.4391597-0.0983004i,0.3008369-0.3472037i,0.03389346-0.470652i,-0.2652529-0.4083143i,-0.475084-0.1684233i,-0.4965131+0.1640504i,-0.3005464+0.4524141i,0.0474122+0.562465i,0.4038474+0.4254374i,0.604012+0.08000687i,0.5383329-0.3316579i,0.2129868-0.619791i,-0.2389711-0.6347476i,-0.6092513-0.3460677i,-0.7107331+0.1295565i,-0.4738699+0.5727066i,0.007659573+0.7631329i,0.5113983+0.5913641i,0.789789+0.1221234i,0.6940663-0.4275377i,0.2549436-0.7896639i,-0.3242907-0.7781577i,-0.7628661-0.3857998i},
    {0.480523+0.6669785i,0.7642813+0.1836108i,0.668731-0.3358011i,0.2871377-0.6507234i,-0.1756781-0.6542889i,-0.520178-0.3887147i,-0.6287665+0.01047779i,-0.4828821+0.3836616i,-0.1473683+0.5945829i,0.2506015+0.5612552i,0.5507901+0.285744i,0.6142958-0.1270468i,0.3952629-0.4937235i,-0.01505722-0.633705i,-0.4187647-0.4709398i,-0.6146906-0.08657163i,-0.5126216+0.3226301i,-0.1805308+0.5573916i,0.2054151+0.5240902i,0.4670099+0.268802i,0.5111723-0.07169532i,0.3508117-0.3526095i,0.06970979-0.4795074i,-0.224966-0.4225838i,-0.4327176-0.2072785i,-0.4772024+0.09413913i,-0.03248495+0.506458i,0.2943876+0.4257595i,0.5031518+0.1511032i,0.4914477-0.1985115i,0.2611372-0.4633142i,-0.08231509-0.5253868i,-0.3876123-0.363808i,-0.530775-0.05298116i,-0.4601987+0.2814905i,-0.2023281+0.5131201i,0.1539981+0.5495227i,0.4780596+0.3570832i,0.6282358-0.01568949i,0.5064265-0.4294994i,0.1237211-0.6903294i,-0.3686945-0.6395263i,-0.728726-0.2572i,-0.747764+0.294556i,-0.3811661+0.7373087i,0.2050306+0.8263085i,0.7128834+0.4950029i,0.8745487-0.0990178i,0.599557-0.6563897i,0.02189778-0.8952778i,-0.5729239-0.6952148i,-0.8929485-0.152563i},
    {0.3032542+0.7003195i,0.6364206+0.3390344i,0.6705245-0.1181699i,0.4348609-0.4742971i,0.05957888-0.6070799i,-0.2971581-0.4997189i,-0.5124211-0.2221028i,-0.5300135+0.112449i,-0.361852+0.3894769i,-0.07262687+0.5229046i,0.2414775+0.4723687i,0.4768192+0.2516833i,0.5490178-0.07206446i,0.4194258-0.3920828i,0.1143425-0.5894893i,-0.2714589-0.5715671i,-0.5939121-0.3120796i,-0.7044473+0.1203815i,-0.5138981+0.5645359i,-0.05326815+0.8145331i,0.5050613+0.7109567i,0.8980176+0.2398637i,0.8932704-0.4198078i,0.4290974-0.9507169i,-0.3129535-1.050596i,-0.9683623-0.6111768i,-0.7778811+0.9472628i,0.04801131+1.255049i,0.8851793+0.9232339i,1.290738+0.1046644i,1.043657-0.7821783i,0.2671733-1.279945i,-0.6412153-1.137612i,-1.22529-0.4358004i,-1.204884+0.4682609i,-0.6054329+1.13207i,0.2718997+1.245745i,1.007239+0.769462i,1.260282-0.06246935i,0.9201443-0.8583241i,0.1490694-1.248077i,-0.6925288-1.049362i,-1.208341-0.3522756i,-1.149603+0.5162273i,-0.5381359+1.140419i,0.3349015+1.214923i,1.044486+0.6995705i,1.24163-0.1534372i,0.8314986-0.9221937i,0.02341359-1.228578i,-0.7770334-0.9305575i,-1.177011-0.1906344i},
    {0.2584979+0.5064366i,0.4753085+0.27865i,0.555948-0.01793232i,0.4791046-0.3335493i,0.2215645-0.5887857i,-0.1850887-0.6604357i,-0.6012622-0.4448521i,-0.8092255+0.03678522i,-0.6388239+0.5879813i,-0.1073913+0.9131826i,0.5429043+0.7938957i,0.9629276+0.2462834i,0.9048714-0.4608454i,0.3807625-0.9534547i,-0.3390549-0.9710165i,-0.884947-0.5124498i,-0.995358+0.1785047i,-0.6422842+0.7627679i,-0.01545103+0.9834182i,0.5966409+0.7693193i,0.9417114+0.2332153i,0.8900609-0.3992147i,0.4618726-0.876366i,-0.1843317-0.9985035i,-0.7921651-0.6866951i,-1.086836-0.03464298i,-0.2461369+1.146625i,0.5778404+1.06738i,1.170177+0.4411526i,1.199899-0.4497465i,0.6134878-1.151787i,-0.3082512-1.283949i,-1.08864-0.7594903i,-1.316883+0.1543373i,-0.8775228+0.9812444i,-0.009836975+1.299631i,0.833404+0.9673319i,1.236112+0.1806598i,1.029478-0.6518323i,0.3530749-1.132511i,-0.4455485-1.064914i,-0.9965779-0.5208075i,-1.074723+0.2251942i,-0.6767101+0.8370005i,0.002355908+1.059972i,0.6628506+0.8131473i,1.021602+0.2110852i,0.9223817-0.4830589i,0.4036061-0.9603344i,-0.3058713-0.9969836i,-0.8765877-0.5647456i,-1.030316+0.1382906i},
    {0.01618307-0.7865484i,-0.4678292-0.6324815i,-0.7626269-0.2189477i,-0.7516215+0.2958579i,-0.4249108+0.7124835i,0.1080884+0.8511105i,0.6381609+0.6223423i,0.9240533+0.08637009i,0.8006705-0.5408991i,0.2799625-0.9644771i,-0.4219299-0.9515154i,-0.9684801-0.4665467i,-1.069059+0.2834079i,-0.6408182+0.9348592i,0.1290935+1.149791i,0.8650829+0.7976522i,1.19187+0.03548562i,0.9317097-0.7626963i,0.2034705-1.194455i,-0.632435-1.037533i,-1.157325-0.3675617i,-1.110143+0.4793988i,-0.521054+1.080955i,0.3085922+1.145952i,0.9670424+0.6586519i,1.143646-0.1249738i,0.06605557-1.104683i,-0.643662-0.8732958i,-1.033164-0.2579916i,-0.9467151+0.4491379i,-0.4427575+0.9350433i,0.2464786+0.9952999i,0.8168765+0.6107567i,1.016381-0.04733078i,0.7516108-0.684499i,0.1374386-1.006271i,-0.5420626-0.8555061i,-0.960897-0.2992894i,-0.9148323+0.3917701i,-0.4330519+0.8770475i,0.2344187+0.9256568i,0.7538698+0.5371469i,0.8885815-0.07059032i,0.6129108-0.5941427i,0.09790215-0.8086868i,-0.4048746-0.6632301i,-0.6945301-0.2668087i,-0.6909089+0.196959i,-0.4289189+0.5564463i,-0.01610456+0.6972835i,0.4046078+0.5744606i,0.6815168+0.2201375i},
    {0.4624534+0.1656601i,0.4615344-0.2353602i,0.1592852-0.5214411i,-0.2717432-0.5040566i,-0.5744751-0.1752419i,-0.5599499+0.2879625i,-0.2153783+0.6243178i,0.2865258+0.6315832i,0.6746024+0.277493i,0.7182402-0.2727958i,0.3553624-0.7277514i,-0.2530868-0.8151757i,-0.7832202-0.4400305i,-0.9139526+0.2324468i,-0.5219909+0.8367282i,0.2128855+1.004042i,0.8808145+0.5935803i,1.075236-0.1926682i,0.6508167-0.906616i,-0.166948-1.120147i,-0.90634-0.6940897i,-1.136002+0.1295554i,-0.7274813+0.8756597i,0.0753769+1.12518i,0.8152637+0.7569418i,1.094297-0.002549208i,0.08625438-1.052155i,-0.6328739-0.8231645i,-1.00717-0.1838791i,-0.8615515+0.5322343i,-0.2800961+0.9650873i,0.4395687+0.898068i,0.9276798+0.3639453i,0.925198-0.3619905i,0.4263068-0.8927917i,-0.3021112-0.9351181i,-0.8556728-0.4619285i,-0.9220542+0.2582562i,-0.4703182+0.8111229i,0.2259307+0.8840474i,0.7557235+0.455273i,0.8235836-0.2000039i,0.4232554-0.6894179i,-0.1768619-0.7469121i,-0.6159302-0.3811829i,-0.6623082+0.1558187i,-0.3343741+0.5419128i,0.1393421+0.5778758i,0.4751372+0.2853121i,0.4996198-0.1320665i,0.2335936-0.4223622i,-0.1389779-0.4304081i},
    {-0.06995848+0.2548351i,0.1515626+0.2767907i,0.3480396+0.1090584i,0.3687808-0.1826674i,0.1562264-0.4283311i,-0.1981282-0.4567697i,-0.4940994-0.2114387i,-0.5394962+0.1977767i,-0.2731233+0.5447382i,0.1829892+0.6150137i,0.5798603+0.3382429i,0.6804243-0.1559239i,0.4028798-0.5987054i,-0.1187014-0.7321379i,-0.5999792-0.4631045i,-0.7665709+0.07283774i,-0.5158159+0.5821943i,0.01913489+0.781041i,0.5443859+0.5592594i,0.774536+0.0419476i,0.5930471-0.4869274i,0.1096008-0.7480706i,-0.4121194-0.6176913i,-0.7044866-0.1819466i,-0.6338355+0.3242874i,-0.2556055+0.6477425i,0.5819188+0.3257793i,0.6395729-0.1335371i,0.3868977-0.5102721i,-0.04280709-0.6259822i,-0.4346634-0.4336809i,-0.5981976-0.0387886i,-0.4623069+0.3555636i,-0.1093482+0.554271i,0.2726461+0.4713204i,0.4938706+0.1690611i,0.4619756-0.1857707i,0.2194595-0.4190266i,-0.09601635-0.4378808i,-0.3342915-0.2622842i,-0.4040257+0.006392349i,-0.2983384+0.2462083i,-0.07805407+0.3654689i,0.162194+0.3267134i,0.3260789+0.1508243i,0.3446549-0.08913627i,0.2051164-0.2877015i,-0.03209792-0.3481305i,-0.2500005-0.2352175i,-0.3329381-0.00650403i,-0.2377374+0.2110015i,-0.02702218+0.2960145i},
    {-0.7249432-1.162327i,-1.339127-0.3851403i,-1.265145+0.618347i,-0.5257853+1.312309i,0.4879692+1.322976i,1.236765+0.6514204i,1.336759-0.3342555i,0.7629391-1.115873i,-0.1605969-1.311289i,-0.9576887-0.8609796i,-1.253571-0.02581958i,-0.9443123+0.7738203i,-0.2142203+1.170758i,0.5774419+1.008951i,1.068309+0.3915631i,1.048349-0.3809742i,0.5446535-0.948949i,-0.194112-1.05469i,-0.8127834-0.6624814i,-1.020924+0.02275314i,-0.738117+0.6584886i,-0.1308983+0.9429365i,0.4851947+0.7696386i,0.8211926+0.2671604i,0.7598592-0.2944147i,0.3870716-0.6613429i,-0.4735975-0.4905877i,-0.6426716-0.1147428i,-0.5753827+0.2710448i,-0.3116906+0.5500427i,0.06740113+0.6366497i,0.4423324+0.4860601i,0.6679587+0.1251714i,0.6255398-0.3224359i,0.2975947-0.6628902i,-0.1914641-0.7209561i,-0.6169146-0.4443971i,-0.7675212+0.05000672i,-0.5632084+0.5289202i,-0.1003969+0.7650025i,0.4019151+0.6535341i,0.7168694+0.2561336i,0.7153287-0.2426997i,0.4111616-0.6287895i,-0.06064234-0.7479209i,-0.5070271-0.5575729i,-0.7496836-0.134027i,-0.6868963+0.3572843i,-0.3318504+0.7185532i,0.1843338+0.7917069i,0.6531748+0.5251983i,0.8669953+0.007520712i},
    {-0.5166374+1.169089i,0.3695627+1.180812i,1.01751+0.6246303i,1.133505-0.1867655i,0.70798-0.8454063i,-0.0098562-1.056585i,-0.6608068-0.7658613i,-0.9558864-0.1542575i,-0.7973524+0.4734948i,-0.2974128+0.8377721i,0.2938874+0.8007057i,0.7078463+0.4108044i,0.7731915-0.1315647i,0.4861832-0.570039i,0.006138178-0.7116595i,-0.4263842-0.5173456i,-0.6137084-0.1150458i,-0.5014771+0.2775924i,-0.1942731+0.4791211i,0.1242471+0.4399297i,0.3110973+0.2455236i,0.3381558+0.03177512i,0.271776-0.1168411i,0.1861613-0.2047737i,0.09276771-0.2757787i,-0.04999666-0.3317306i,-0.4589387-0.1161453i,-0.5042583+0.2203181i,-0.2853073+0.5572487i,0.1579462+0.6799271i,0.6170235+0.4516621i,0.8222502-0.06894571i,0.6118829-0.6314255i,0.04847727-0.9261369i,-0.5978037-0.7643633i,-0.9905254-0.1936938i,-0.9079899+0.5181987i,-0.3627362+1.017479i,0.3988625+1.04091i,1.010776+0.5481955i,1.159717-0.2489692i,0.7399752-0.9744695i,-0.07891814-1.259338i,-0.9118571-0.9266917i,-1.333646-0.1012877i,-1.097327+0.8251302i,-0.2831671+1.376612i,0.7157313+1.242688i,1.383618+0.4601648i,1.3563-0.5852i,0.62736-1.352508i,-0.4361293-1.434583i},
    {-0.3779953+0.03557963i,-0.2594216+0.2823977i,-0.006828025+0.379285i,0.2353273+0.283767i,0.3472672+0.06643099i,0.3001556-0.1537465i,0.1454313-0.2893015i,-0.04369361-0.3148784i,-0.2149518-0.2418448i,-0.3319835-0.0849162i,-0.3494927+0.1338775i,-0.2201208+0.352192i,0.05395614+0.4590246i,0.3728058+0.3500475i,0.559683+0.01989837i,0.464813-0.388578i,0.08598673-0.6413221i,-0.3932385-0.557747i,-0.6961523-0.1451934i,-0.6257253+0.3811981i,-0.1997802+0.7197983i,0.3489333+0.6686746i,0.7114903+0.2520516i,0.6885484-0.2956986i,0.3033285-0.673486i,-0.2234553-0.6881884i,-0.6704583+0.1361734i,-0.4012388+0.5263125i,0.03884892+0.6378704i,0.4276254+0.4445409i,0.5926992+0.06337449i,0.4814985-0.3191401i,0.1656893-0.5373759i,-0.2059976-0.5107331i,-0.4748539-0.2636319i,-0.5314382+0.09362042i,-0.3527521+0.4086706i,-0.01211345+0.5429929i,0.3425783+0.428236i,0.5443652+0.1050782i,0.4848034-0.2798196i,0.1795634-0.5336227i,-0.2223018-0.5170888i,-0.5078577-0.2312598i,-0.5205223+0.1700087i,-0.2582597+0.4636929i,0.1209465+0.4925039i,0.3983195+0.2617031i,0.4335085-0.0717626i,0.2457618-0.3108078i,-0.01895002-0.3477168i,-0.2032833-0.2168427i},
    {0.6809061-0.724477i,0.03214792-0.993783i,-0.6255447-0.7621524i,-0.956478-0.1626411i,-0.8134208+0.4877228i,-0.2994887+0.8727713i,0.315153+0.838363i,0.7498756+0.4413489i,0.8413121-0.115682i,0.584519-0.5974646i,0.09987073-0.8261276i,-0.4262708-0.7229321i,-0.7954143-0.3189027i,-0.8487183+0.2467726i,-0.5284175+0.7502569i,0.06821563+0.9531808i,0.6904632+0.716336i,1.027954+0.1019055i,0.8725141-0.6151777i,0.2579194-1.066094i,-0.5236453-0.9893553i,-1.062894-0.3957382i,-1.062034+0.4158931i,-0.5124979+1.01634i,0.2931647+1.088439i,0.927205+0.6062589i,0.6758578-0.7988935i,-0.01436844-1.006356i,-0.6371586-0.7208968i,-0.9053921-0.1330627i,-0.7417658+0.4497841i,-0.2786495+0.7727596i,0.2462506+0.7395659i,0.6166314+0.4161612i,0.7158543-0.03732913i,0.5388225-0.4460948i,0.1654858-0.6722266i,-0.2703531-0.6394659i,-0.6098613-0.3507614i,-0.7108756+0.09780554i,-0.5081107+0.5292092i,-0.06480923+0.7464048i,0.4299998+0.6292503i,0.7408434+0.2129927i,0.7089328-0.3116494i,0.3446151-0.6913971i,-0.1740268-0.7455277i,-0.5985501-0.459526i,-0.7410769+0.01840202i,-0.5587139+0.466563i,-0.1516823+0.7007549i,0.3034073+0.6432142i},
    {-0.1515327-0.4427172i,-0.4281542-0.188012i,-0.4248373+0.1870409i,-0.1470054+0.4332364i,0.2150409+0.3924266i,0.4214562+0.1043692i,0.3492272-0.2292808i,0.06774763-0.3927103i,-0.2254858-0.3019506i,-0.3505777-0.04453804i,-0.2589801+0.2028117i,-0.03992421+0.3019049i,0.1644833+0.2284113i,0.2554+0.05531494i,0.2159698-0.1173475i,0.08769499-0.2195836i,-0.07039696-0.2234254i,-0.2006655-0.1301407i,-0.2479994+0.03264193i,-0.1734083+0.2009635i,0.01091664+0.2829766i,0.2183343+0.2081765i,0.3193799-0.008239009i,0.2273248-0.2467894i,-0.02318184-0.3482417i,-0.2781163-0.2276133i,-0.2103098+0.3040344i,0.08224155+0.360238i,0.3182675+0.1806258i,0.3418419-0.1106472i,0.1461665-0.3179622i,-0.1292947-0.3126816i,-0.3040947-0.1148842i,-0.2798808+0.1348888i,-0.09313512+0.280825i,0.127595+0.2506963i,0.2540705+0.08437628i,0.230755-0.1104802i,0.08880597-0.2297841i,-0.08824375-0.2229675i,-0.2124729-0.1039394i,-0.2273553+0.06570715i,-0.1258207+0.2043749i,0.04656147+0.2417184i,0.2054614+0.1503988i,0.2628067-0.03274244i,0.174586-0.2141435i,-0.02455033-0.2875245i,-0.2283301-0.1966824i,-0.3137307+0.0213559i,-0.2161074+0.2463891i,0.02252599+0.3403878i},
    {-0.5030409+0.508311i,-0.04038536+0.7146786i,0.4374401+0.5581439i,0.6831021+0.1315145i,0.5880529-0.3345601i,0.2288767-0.6124992i,-0.2006563-0.5975314i,-0.5093288-0.3345791i,-0.59346+0.04112313i,-0.4481694+0.3841635i,-0.1339193+0.5826865i,0.2498504+0.5652382i,0.5697786+0.3105871i,0.6771066-0.1189601i,0.473359-0.5553932i,-0.00121738-0.7718526i,-0.5358279-0.6078708i,-0.8365086-0.09834538i,-0.7036412+0.5039675i,-0.1799594+0.8598831i,0.4514146+0.7559754i,0.8352412+0.2482374i,0.766512-0.3712132i,0.3100939-0.7620821i,-0.2603788-0.7422698i,-0.6465083-0.3720832i,-0.4379417+0.5000746i,-0.0371145+0.6308363i,0.3374443+0.5070457i,0.5629462+0.2026378i,0.5742128-0.1735059i,0.3601815-0.4946638i,-0.02072961-0.6308622i,-0.4267092-0.4955665i,-0.6671492-0.1125667i,-0.5978097+0.3565643i,-0.2226791+0.6744208i,0.28026+0.6606482i,0.6472764+0.3097449i,0.6828101-0.1944251i,0.3761356-0.5846848i,-0.09793577-0.6671225i,-0.4899292-0.4246369i,-0.6188916-0.007320989i,-0.4570363+0.3695342i,-0.1167247+0.544166i,0.2316303+0.4735392i,0.4484581+0.2240396i,0.4731031-0.08434878i,0.3229008-0.3362723i,0.06523926-0.454437i,-0.2114493-0.4081051i},
    {-0.5861627-0.4652594i,-0.8005657+0.0234805i,-0.6281111+0.5729445i,-0.1019807+0.8886075i,0.5319749+0.76604i,0.9365001+0.229686i,0.8760974-0.4595078i,0.3601583-0.9416499i,-0.3550954-0.9580012i,-0.9054509-0.4927996i,-1.012819+0.2219874i,-0.6249883+0.8323076i,0.06665537+1.041747i,0.7283278+0.7519597i,1.045394+0.1023287i,0.8674579-0.6001346i,0.2756619-1.023749i,-0.4541388-0.9648904i,-0.9767662-0.4445064i,-1.038573+0.2963966i,-0.6012012+0.9052438i,0.1329322+1.084645i,0.8115873+0.7393917i,1.101374+0.02977772i,0.8537087-0.7000912i,0.1845241-1.088816i,-1.048023-0.3235693i,-0.9915372+0.4473184i,-0.4394148+0.9801902i,0.3180292+1.006248i,0.8861323+0.5259684i,0.9803846-0.1926053i,0.5797478-0.7663797i,-0.07279282-0.9130963i,-0.6219223-0.6006817i,-0.8067505-0.04145526i,-0.5921569+0.4553583i,-0.1508553+0.6674965i,0.2720058+0.5601824i,0.5050313+0.2552805i,0.5118324-0.08048626i,0.3523879-0.3314677i,0.1075788-0.4533892i,-0.1594944-0.4369065i,-0.3887327-0.2788399i,-0.500921+0.0002746214i,-0.4202234+0.3184865i,-0.1383523+0.5351763i,0.2402107+0.5211688i,0.5310977+0.252857i,0.575493-0.149624i,0.3439096-0.4829803i},
    {0.2580949-0.5331079i,-0.1377564-0.5657184i,-0.4536633-0.3441392i,-0.5549382+0.01376964i,-0.4182439+0.3433706i,-0.1222527+0.5155019i,0.2071222+0.4808878i,0.4522961+0.2662045i,0.5324237-0.05265905i,0.4116836-0.3715733i,0.1101234-0.5720661i,-0.2796173-0.5501086i,-0.5972718-0.2704817i,-0.6715711+0.1814594i,-0.418443+0.6037965i,0.08004326+0.7662886i,0.5865001+0.5463107i,0.8263142+0.02388843i,0.6496459-0.5407242i,0.1311386-0.8470454i,-0.4638619-0.7274516i,-0.8281031-0.2428312i,-0.7815228+0.356647i,-0.3590051+0.7733213i,0.2237526+0.8151734i,0.6898363+0.4774836i,0.5933908-0.5865301i,0.08338828-0.8332852i,-0.4722572-0.6994933i,-0.8199641-0.2353506i,-0.7872905+0.3543348i,-0.3719782+0.7900777i,0.2376746+0.8485523i,0.7408997+0.4854013i,0.8768823-0.1247243i,0.5710708-0.6699033i,-0.01613503-0.8688865i,-0.576023-0.6277037i,-0.8246638-0.08813871i,-0.6565348+0.4605557i,-0.1877093+0.7475429i,0.3274439+0.6601901i,0.6432129+0.2809727i,0.6415743-0.1828851i,0.3649047-0.518557i,-0.03442251-0.6031154i,-0.3805543-0.4354613i,-0.5465546-0.1101773i,-0.4884+0.2355511i,-0.2439121+0.4732563i,0.08904346+0.5202092i,0.3848349+0.3611281i},
    {-0.1897387+0.06981649i,-0.07802406+0.1672015i,0.05398187+0.1567044i,0.1297043+0.06909835i,0.1258692-0.03015999i,0.0684103-0.09184035i,-0.002889164-0.1034515i,-0.06124689-0.07536218i,-0.09282053-0.0211336i,-0.08602269+0.04400058i,-0.03499038+0.09354184i,0.04285092+0.09434446i,0.1015891+0.03365319i,0.09409731-0.05641299i,0.0155877-0.1106611i,-0.07958937-0.08089554i,-0.1141884+0.01667621i,-0.0536648+0.1050986i,0.05720067+0.1073915i,0.1256326+0.01507949i,0.08874704-0.09831665i,-0.02915686-0.1359658i,-0.1327842-0.06041446i,-0.1343625+0.07193694i,-0.02752306+0.1557484i,0.1067407+0.1228655i,0.1064176-0.1293501i,-0.02643052-0.1653912i,-0.1387579-0.09114366i,-0.1589247+0.03773604i,-0.08237804+0.137025i,0.03657849+0.1518087i,0.1281941+0.08308018i,0.1481998-0.02507683i,0.09312753-0.1166693i,-0.007164551-0.1497751i,-0.105636-0.1096652i,-0.1553653-0.01295405i,-0.1283337+0.09605332i,-0.03227714+0.1616086i,0.08654786+0.1449088i,0.1643609+0.04989376i,0.156765-0.07421803i,0.06698997-0.160345i,-0.05604401-0.1636505i,-0.1484524-0.0859924i,-0.1675193+0.03038756i,-0.1091791+0.1302387i,-0.001970097+0.1714981i,0.1094358+0.1372844i,0.178384+0.03764968i,0.1686361-0.09064991i},
    {-0.2688268-0.4996884i,-0.5552727-0.1913704i,-0.5518256+0.2471217i,-0.2351589+0.5714219i,0.228639+0.5827627i,0.571062+0.2613886i,0.5877718-0.2079883i,0.2724997-0.5481793i,-0.1791616-0.5666439i,-0.5003585-0.2738259i,-0.5235143+0.1377244i,-0.2716095+0.4296577i,0.08250556+0.4655412i,0.3422408+0.2709044i,0.4008873-0.01625879i,0.2740334-0.2469089i,0.05489138-0.3366515i,-0.1530119-0.2800677i,-0.277387-0.123015i,-0.2854449+0.06839769i,-0.1804269+0.2246194i,-0.001986018+0.2854594i,0.1774278+0.2215535i,0.2760741+0.05646062i,0.2440314-0.1337908i,0.09594058-0.2554131i,-0.2244269-0.1225485i,-0.2387878+0.05262766i,-0.1380825+0.1865294i,0.01736251+0.2180171i,0.1463734+0.1429214i,0.1893777+0.009994655i,0.1357671-0.1082395i,0.02557304-0.1539965i,-0.07463743-0.1143024i,-0.1111351-0.02677469i,-0.07649685+0.04563928i,-0.01342863+0.05907913i,0.01919045+0.02204434i,-0.003400416-0.01185425i,-0.04664056+0.007707783i,-0.04430046+0.07558209i,0.03736944+0.1242969i,0.1539084+0.07839526i,0.203688-0.06994516i,0.1096414-0.2320722i,-0.1026554-0.2772414i,-0.3021323-0.1360513i,-0.3389461+0.1300674i,-0.1588363+0.3563573i,0.1453996+0.385882i,0.3892263+0.1820074i},
    {-0.9604204-0.9756305i,-1.406759-0.08526614i,-1.124874+0.901148i,-0.2293009+1.445697i,0.8109674+1.233123i,1.43137+0.3659062i,1.297769-0.6872934i,0.4960188-1.362604i,-0.5302103-1.320942i,-1.243796-0.621096i,-1.308368+0.3441011i,-0.7410878+1.084594i,0.1383075+1.267322i,0.898325+0.8528289i,1.204351+0.07352374i,0.9494563-0.6995473i,0.2753508-1.123451i,-0.5014158-1.021148i,-1.025309-0.4514459i,-1.057054+0.3135861i,-0.589179+0.9078385i,0.1412364+1.047889i,0.76784+0.6811132i,0.988449+0.01456564i,0.7258446-0.6032416i,0.155343-0.8792924i,-0.7270834-0.2830715i,-0.6933973+0.2093576i,-0.3981369+0.5435042i,-0.004116542+0.6326562i,0.3430531+0.4980449i,0.5528377+0.2118116i,0.5772829-0.1403754i,0.3992493-0.4589493i,0.05212319-0.6283551i,-0.352998-0.5533621i,-0.643637-0.2257522i,-0.6645628+0.2348124i,-0.3757967+0.6174438i,0.1036432+0.7278665i,0.5476571+0.5006533i,0.7428384+0.04008289i,0.600283-0.4364191i,0.1934935-0.7125245i,-0.289725-0.6746152i,-0.6418303-0.3509298i,-0.7224972+0.1161128i,-0.5046329+0.5359581i,-0.07506067+0.7415547i,0.399445+0.6461908i,0.7289721+0.2751556i,0.7682143-0.2360849i},
    {-0.08544677-0.2471077i,-0.2081432-0.1007609i,-0.1891805+0.07077985i,-0.06368768+0.1620891i,0.07192462+0.1302972i,0.1267238+0.01716651i,0.07471886-0.08597716i,-0.03349203-0.104186i,-0.1116475-0.02830584i,-0.09856151+0.08394258i,0.00340139+0.1498575i,0.132244+0.114436i,0.2031257-0.01715015i,0.1548614-0.1792379i,-0.01325209-0.2739503i,-0.2277066-0.2194973i,-0.3627937-0.004335733i,-0.3036622+0.2806047i,-0.02921271+0.4664516i,0.3390124+0.3987342i,0.5774946+0.05465334i,0.493892-0.4005856i,0.07594073-0.685125i,-0.4591368-0.5787153i,-0.7773097-0.09211098i,-0.6458479+0.5056134i,0.5302673+0.6928629i,0.8778069+0.1256578i,0.7226969-0.525392i,0.1574276-0.8796032i,-0.4877808-0.7424582i,-0.8546259-0.2079095i,-0.7609363+0.4201027i,-0.2791193+0.8128652i,0.3307071+0.7855673i,0.7658589+0.367595i,0.8197998-0.2318421i,0.4646212-0.7234966i,-0.1367726-0.8616982i,-0.6913955-0.5580355i,-0.9042317+0.05663186i,-0.6351024+0.6696337i,-0.002066629+0.9371685i,0.6532009+0.6855996i,0.9499851+0.03853421i,0.7041931-0.6339872i,0.05714099-0.9348857i,-0.6036561-0.6914076i,-0.8890077-0.06541453i,-0.6529523+0.5564827i,-0.07128105+0.815171i,0.4912848+0.5976838i},
    {0.8116721+0.03384403i,0.6967019-0.4709098i,0.2804201-0.8323035i,-0.3086199-0.866312i,-0.8201566-0.4999785i,-0.9868547+0.1436961i,-0.6822831+0.7677556i,-0.02355863+1.048186i,0.6693445+0.8228091i,1.046228+0.1946088i,0.9220248-0.5233732i,0.3702185-0.9834452i,-0.333998-0.9834304i,-0.8677578-0.5482424i,-1.011078+0.1111074i,-0.7224519+0.7103105i,-0.1311453+1.007443i,0.5228336+0.8828225i,0.9723706+0.376847i,1.017218-0.3154465i,0.6110964-0.9034262i,-0.09555104-1.113945i,-0.7974875-0.8222166i,-1.164358-0.1319406i,-1.0028+0.6529698i,-0.3632773+1.164694i,1.116587+0.5940573i,1.261086-0.2608222i,0.8177059-1.026145i,-0.03087636-1.337665i,-0.9019734-1.024897i,-1.378031-0.2041858i,-1.204228+0.7528537i,-0.4302633+1.379557i,0.5858795+1.343992i,1.338625+0.6354366i,1.434517-0.4056597i,0.8117205-1.252163i,-0.2148064-1.470284i,-1.119627-0.9555441i,-1.451133+0.01545189i,-1.066866+0.9446757i,-0.1888337+1.382129i,0.735873+1.147296i,1.272087+0.3915078i,1.197927-0.5060437i,0.5825692-1.131238i,-0.270372-1.2177i,-0.9687577-0.7494317i,-1.202903+0.04375419i,-0.8789964+0.790977i,-0.1618093+1.148064i},
    {-1.485369+0.2960498i,-0.9282596+1.195341i,0.07770309+1.504996i,1.031845+1.083562i,1.474573+0.1530545i,1.211044-0.8281483i,0.3885426-1.398708i,-0.5944344-1.308908i,-1.284437-0.6193981i,-1.37542+0.3435482i,-0.8343825+1.140103i,0.0900068+1.408027i,0.9739069+1.020779i,1.40285+0.1515649i,1.165498-0.7925504i,0.3682632-1.354882i,-0.6003814-1.256775i,-1.258981-0.5505572i,-1.286103+0.3993645i,-0.6933209+1.111496i,0.1899333+1.249929i,0.9121203+0.795947i,1.150639+0.02748598i,0.8614896-0.6654458i,0.2507188-0.9965075i,-0.3817098-0.8950511i,-0.9018459+0.07641622i,-0.6892984+0.5784417i,-0.2312002+0.8854697i,0.3461736+0.8827721i,0.8468497+0.5205877i,1.040199-0.1176412i,0.7726458-0.7841614i,0.09691648-1.147216i,-0.693728-0.9722248i,-1.192153-0.2915222i,-1.109804+0.5716379i,-0.4639787+1.168114i,0.4156137+1.182025i,1.074197+0.614556i,1.19107-0.2265987i,0.74431-0.9156098i,-0.00962182-1.143169i,-0.7027201-0.8535658i,-1.046745-0.226282i,-0.9409994+0.4493676i,-0.469036+0.9107064i,0.1709088+1.003529i,0.7433092+0.7050681i,1.036952+0.117518i,0.921002-0.5517489i,0.4021672-1.037026i},
    {-0.124923+0.3029203i,0.1512666+0.2718234i,0.2941913+0.04401975i,0.2046762-0.2023636i,-0.04141744-0.2798662i,-0.2507976-0.1312388i,-0.2584966+0.1270296i,-0.05429296+0.2919999i,0.2068368+0.2292935i,0.3212768-0.02151394i,0.1932221-0.2738622i,-0.08971182-0.3351797i,-0.3214478-0.153671i,-0.3328108+0.1428794i,-0.1163338+0.3448991i,0.1741882+0.3165608i,0.342926+0.08820105i,0.2919271-0.1791896i,0.07587441-0.3183563i,-0.1572751-0.2663457i,-0.2777894-0.08367657i,-0.2473007+0.1122908i,-0.1121462+0.2301796i,0.05201418+0.2402347i,0.1846798+0.1574314i,0.2468858+0.01345518i,0.07400014-0.2645843i,-0.1243-0.2655134i,-0.2867711-0.121858i,-0.3086711+0.1110993i,-0.1533906+0.3046424i,0.1032016+0.334022i,0.3094772+0.1697422i,0.3384582-0.09272799i,0.1761996-0.2949973i,-0.07182553-0.323681i,-0.259087-0.1804483i,-0.2955538+0.03501421i,-0.1902411+0.2043949i,-0.01916034+0.2624011i,0.1376754+0.2111591i,0.2327664+0.08761638i,0.2450946-0.06810068i,0.163463-0.2132865i,-0.005069591-0.2898455i,-0.2072703-0.2376889i,-0.3398636-0.04383889i,-0.3012693+0.2143273i,-0.07420921+0.3878466i,0.2310489+0.3470593i,0.4266368+0.08512646i,0.3709618-0.2524211i},
    {-0.408563+1.454218i,0.6520464+1.339658i,1.35172+0.5653433i,1.365441-0.452547i,0.7261475-1.211056i,-0.2285997-1.36918i,-1.043257-0.8857228i,-1.354606-0.006929096i,-1.036443+0.8603747i,-0.2394372+1.324047i,0.6739181+1.168765i,1.277893+0.4541829i,1.27225-0.493481i,0.6379908-1.21465i,-0.3258426-1.336976i,-1.131599-0.7807388i,-1.355076+0.1747148i,-0.8763373+1.025894i,0.0411501+1.322065i,0.8958425+0.9230289i,1.237683+0.07553584i,0.9229971-0.7420478i,0.1765955-1.106091i,-0.5681335-0.8814297i,-0.9353965-0.2627424i,-0.8052917+0.3808889i,0.1898081+0.7020921i,0.5224779+0.3862774i,0.5788887-0.006138152i,0.4178533-0.3058108i,0.158357-0.4416728i,-0.09858316-0.4237317i,-0.2951622-0.2926789i,-0.3996243-0.08909748i,-0.3877138+0.1429353i,-0.2494717+0.3421984i,-0.01222399+0.4370483i,0.2498102+0.377297i,0.4374257+0.1679064i,0.4697541-0.1229919i,0.3216974-0.3888593i,0.0353351-0.526188i,-0.2944723-0.4708991i,-0.5477634-0.219895i,-0.6123679+0.1601431i,-0.4232781+0.5370848i,-0.005978664+0.7424427i,0.4977909+0.6362919i,0.8569317+0.1940531i,0.8484095-0.4341164i,0.3932249-0.9511419i,-0.3504195-1.048321i},
    {0.6725168+0.572711i,0.8656805-0.001901427i,0.6371406-0.5504203i,0.1191385-0.8024498i,-0.4116532-0.6545382i,-0.6945094-0.219426i,-0.6275204+0.2562979i,-0.3012339+0.5462543i,0.08756787+0.5625257i,0.366738+0.3664012i,0.4680099+0.08751009i,0.4148182-0.1683581i,0.2585239-0.3524048i,0.03519693-0.4437594i,-0.2224575-0.4131458i,-0.4482941-0.2311661i,-0.5392507+0.08242116i,-0.4094979+0.4226533i,-0.06572179+0.6270915i,0.3621168+0.5637516i,0.6709318+0.2211687i,0.6909643-0.2648206i,0.3827794-0.6697102i,-0.1329127-0.7906594i,-0.6266197-0.5476984i,-0.8634219-0.02730117i,-0.2062536+0.9095727i,0.4406812+0.8639176i,0.9283966+0.3927636i,0.9987384-0.3122989i,0.5759227-0.9181641i,-0.168433-1.106495i,-0.8768926-0.7466578i,-1.180495+0.01341252i,-0.8985447+0.8035368i,-0.1492575+1.217059i,0.6991427+1.027718i,1.215846+0.3158626i,1.132034-0.5675142i,0.4815129-1.179317i,-0.415111-1.209906i,-1.111559-0.639695i,-1.259304+0.2501644i,-0.7825956+1.016937i,0.08128205+1.277379i,0.8990397+0.9021602i,1.260871+0.08400321i,0.9915644-0.7603379i,0.2402483-1.207217i,-0.6026435-1.046604i,-1.115944-0.3843365i,-1.06651+0.4282094i},
    {-0.7098085+0.2494788i,-0.3812614+0.6712394i,0.1587296+0.7676115i,0.6289816+0.4735165i,0.7801952-0.05807197i,0.5424921-0.5463047i,0.05645229-0.7494974i,-0.4247976-0.5935903i,-0.6830487-0.185672i,-0.6324876+0.2722511i,-0.3255043+0.5916428i,0.1013882+0.662409i,0.4862507+0.4667807i,0.6824464+0.07282583i,0.5968043-0.3751797i,0.2364672-0.6875078i,-0.2623879-0.702186i,-0.6699282-0.3795125i,-0.7720758+0.1474673i,-0.4973972+0.6222124i,0.0272496+0.8007681i,0.5399897+0.5908299i,0.7888568+0.1015632i,0.6639978-0.4241821i,0.2396801-0.7425923i,-0.2816392-0.7218251i,-0.7672538+0.1240026i,-0.5242314+0.5862573i,-0.03485587+0.7994934i,0.4940833+0.6504701i,0.8138456+0.1820024i,0.7496825-0.3988131i,0.3082059-0.8031621i,-0.2999351-0.8118576i,-0.7604343-0.4094308i,-0.8318595+0.194306i,-0.486627+0.6816183i,0.07870249+0.8105043i,0.567714+0.5439635i,0.7539151+0.04754351i,0.5861728-0.4253702i,0.1807855-0.6713976i,-0.2657799-0.6159654i,-0.5725732-0.3128311i,-0.6324325+0.1022092i,-0.432367+0.4647418i,-0.05303727+0.6310073i,0.3513534+0.527597i,0.6050066+0.1912296i,0.589233-0.232078i,0.3085651-0.5482274i,-0.1044063-0.6128531i},
    {1.172024+0.7871948i,1.40292-0.2005572i,0.9074788-1.085477i,-0.04802843-1.404673i,-0.9596266-1.00596i,-1.365711-0.116091i,-1.085026+0.8003669i,-0.287416+1.293348i,0.6179959+1.145963i,1.196054+0.4576787i,1.187555-0.4253025i,0.6157514-1.081243i,-0.2350904-1.205882i,-0.9538466-0.7497104i,-1.195381+0.05791096i,-0.8492951+0.8160962i,-0.09931757+1.150816i,0.6685104+0.9079936i,1.069458+0.2334428i,0.924109-0.5116597i,0.3440285-0.9527318i,-0.3480164-0.9005055i,-0.8067195-0.4315862i,-0.8431706+0.1831608i,-0.4957875+0.6413304i,0.02584539+0.7591143i,0.6543413+0.1131877i,0.5429924-0.2991055i,0.2233002-0.5325873i,-0.142159-0.5166419i,-0.3952318-0.296301i,-0.4512783+0.002315392i,-0.3282725+0.242383i,-0.1193155+0.3459861i,0.07470536+0.3202738i,0.2043381+0.2239431i,0.2776793+0.1047104i,0.3130461-0.03461887i,0.2891707-0.2083641i,0.1512835-0.3863922i,-0.1203358-0.4684041i,-0.4408644-0.3400326i,-0.6298919+0.01959275i,-0.5194087+0.4705536i,-0.091084+0.7611583i,0.4681416+0.6804964i,0.8523329+0.2120159i,0.8188246-0.4271498i,0.3452471-0.8981875i,-0.3443194-0.9341284i,-0.8990058-0.4923872i,-1.028853+0.221325i},
    {0.9868985+1.162157i,1.473416+0.2231569i,1.226964-0.7733233i,0.415881-1.343626i,-0.5336244-1.25133i,-1.171163-0.5945455i,-1.235849+0.2799646i,-0.7504543+0.9653696i,0.02534906+1.180825i,0.7355191+0.8746122i,1.086453+0.2177024i,0.9588882-0.4902409i,0.4382243-0.9534329i,-0.2374371-0.9971497i,-0.7837743-0.6274255i,-0.9860939-0.01540827i,-0.7788201+0.5815288i,-0.2607623+0.9256034i,0.3531686+0.8879814i,0.818592+0.4906909i,0.9521315-0.1074663i,0.6968414-0.6704501i,0.145122-0.9697972i,-0.4882983-0.870847i,-0.9406956-0.3934121i,-1.005072+0.280275i,0.05502939+1.093486i,0.7481046+0.8347591i,1.132388+0.1785229i,1.010043-0.5920458i,0.4112482-1.120755i,-0.4044602-1.146055i,-1.060119-0.6338041i,-1.238+0.1938533i,-0.8367864+0.9540217i,-0.0301766+1.28232i,0.8072736+1.011133i,1.276555+0.257852i,1.148791-0.6252692i,0.4801495-1.219483i,-0.4135997-1.243531i,-1.111562-0.689507i,-1.291697+0.1780727i,-0.8801154+0.955529i,-0.07490838+1.29266i,0.756912+1.047738i,1.24881+0.3377994i,1.189148-0.5242176i,0.6014767-1.165034i,-0.2686041-1.301402i,-1.047796-0.8551632i,-1.381224+0.00301822i},
    {0.3196237+0.05654976i,0.2652904-0.1780488i,0.06749371-0.3058117i,-0.1574608-0.2621817i,-0.2864223-0.08143076i,-0.2579513+0.1310927i,-0.09890849+0.2630094i,0.09998588+0.2542274i,0.2378151+0.1201519i,0.2528196-0.06600339i,0.1447787-0.2137639i,-0.03197337-0.2554141i,-0.194221-0.1714863i,-0.2631165+0.001613435i,-0.1978653+0.1824872i,-0.02085632+0.2759734i,0.1811134+0.2204863i,0.2926471+0.03140004i,0.2353289-0.1912066i,0.02702145-0.3103966i,-0.2119401-0.2385098i,-0.32544-0.006570258i,-0.2271568+0.240451i,0.02873885+0.3336582i,0.2722111+0.2002058i,0.3314946-0.07527635i,-0.1274827-0.3168352i,-0.3241308-0.1068055i,-0.2896441+0.1788115i,-0.04938667+0.335236i,0.2229311+0.2521787i,0.3334222-0.006928272i,0.2087073-0.2549096i,-0.05585302-0.3195029i,-0.2721072-0.1647713i,-0.2966523+0.09236061i,-0.1261483+0.2745686i,0.113532+0.2696983i,0.2648281+0.09775478i,0.2440591-0.1189498i,0.08274502-0.2471909i,-0.1105585-0.2245875i,-0.22668-0.08201636i,-0.2146064+0.09204479i,-0.09422418+0.2079209i,0.06791431+0.2153586i,0.1942353+0.1162704i,0.2259727-0.0425071i,0.1441051-0.1871423i,-0.01919732-0.2438969i,-0.1863383-0.1736088i,-0.2656305-5.252575e-05i},
    {-0.406464+0.5806926i,0.05924146+0.6985805i,0.4866058+0.496966i,0.6891935+0.07535474i,0.5823968-0.3792915i,0.2108622-0.6681609i,-0.2671686-0.6573128i,-0.6366277-0.3375221i,-0.7153262+0.1569804i,-0.4469058+0.5941089i,0.0531621+0.7506008i,0.5393876+0.5331316i,0.7592241+0.04199173i,0.5933081-0.4716831i,0.1275434-0.7400272i,-0.3916425-0.6271663i,-0.6946225-0.2028795i,-0.636104+0.3017946i,-0.2668502+0.6267004i,0.2063128+0.6220436i,0.5408806+0.3174093i,0.5865391-0.1101931i,0.3518746-0.4415513i,-0.0181652-0.5304533i,-0.3321243-0.3676922i,-0.4542972-0.06625015i,-0.1411808+0.3590659i,0.09197453+0.3393365i,0.2472064+0.2061721i,0.2979553+0.03437502i,0.2613727-0.1232855i,0.1600987-0.2432982i,0.005984284-0.3064508i,-0.180041-0.2791867i,-0.3396774-0.1324753i,-0.3838843+0.1122522i,-0.2479752+0.3575741i,0.04235688+0.4657678i,0.3553441+0.3457271i,0.5173579+0.02931616i,0.4216887-0.3280351i,0.1041983-0.5338001i,-0.2721214-0.4750898i,-0.5140845-0.1844191i,-0.5080842+0.187019i,-0.271338+0.4614035i,0.07603908+0.5245854i,0.3824976+0.3641477i,0.5286483+0.05357347i,0.4590352-0.2861543i,0.191598-0.5229138i,-0.1812841-0.5492285i},
    {-1.188101-0.5218496i,-1.206205+0.3630832i,-0.6642331+1.018736i,0.1347229+1.161896i,0.8058326+0.7825851i,1.075322+0.1026516i,0.8771056-0.5649377i,0.3357959-0.9574595i,-0.3139319-0.9442422i,-0.8170433-0.5482913i,-0.9769568+0.06970053i,-0.7235486+0.6590932i,-0.1546354+0.9665351i,0.4850619+0.8480324i,0.9053441+0.3511541i,0.9137447-0.2944518i,0.5169153-0.7896306i,-0.08725444-0.9192654i,-0.6214376-0.6523205i,-0.8691157-0.1336956i,-0.7587364+0.4090153i,-0.361319+0.7717519i,0.1655932+0.8362803i,0.6369225+0.5843707i,0.8825724+0.09308415i,0.7890178-0.473284i,-0.2870429-0.9614223i,-0.8616771-0.5976461i,-1.090497+0.08199703i,-0.8226116+0.7847878i,-0.1391581+1.16995i,0.6617573+1.022025i,1.19897+0.3728438i,1.193731-0.4971493i,0.6127638-1.181387i,-0.3005192-1.335867i,-1.123645-0.8490028i,-1.445025+0.08491254i,-1.068516+1.03233i,-0.1356537+1.515442i,0.9121397+1.256973i,1.539589+0.3489251i,1.401438-0.7650251i,0.5464758-1.510052i,-0.5907978-1.49304i,-1.422092-0.7244386i,-1.528762+0.388992i,-0.8826844+1.276016i,0.1612985+1.511734i,1.07848+1.022762i,1.449918+0.0863378i,1.145344-0.8422067i},
    {0.1185925+0.7770303i,0.585419+0.5297316i,0.7963108+0.03633504i,0.6411917-0.4891771i,0.1733718-0.7964343i,-0.3912061-0.7215447i,-0.769795-0.2880217i,-0.764879+0.2885637i,-0.3802191+0.7120264i,0.178736+0.7707616i,0.6235267+0.4523929i,0.7431951-0.06179104i,0.5071073-0.5094572i,0.05858539-0.688498i,-0.378299-0.5451677i,-0.6129301-0.1755077i,-0.5648688+0.2395375i,-0.2805713+0.5209242i,0.1013236+0.5626157i,0.4145248+0.3661588i,0.5346408+0.0310627i,0.4275166-0.2941724i,0.155432-0.4791272i,-0.1604618-0.4638337i,-0.3978876-0.2715648i,-0.4779123+0.01612969i,-0.1325808+0.4745367i,0.1853673+0.4761516i,0.4581293+0.275833i,0.5568035-0.07360626i,0.4015903-0.4305691i,0.02968298-0.6125944i,-0.3900248-0.498156i,-0.6335728-0.119712i,-0.5570782+0.3313238i,-0.196707+0.611181i,0.2478479+0.5754553i,0.5411911+0.265342i,0.5568206-0.1343946i,0.3326102-0.4258291i,0.009930109-0.5102261i,-0.2743009-0.4047825i,-0.4477257-0.1797895i,-0.4844357+0.1014268i,-0.3633925+0.3809932i,-0.07530984+0.56855i,0.3181113+0.5441745i,0.6483549+0.2394774i,0.7039827-0.2615307i,0.3790966-0.7110585i,-0.2078404-0.8268817i,-0.7429916-0.4887368i},
    {-0.1380941+0.08613065i,-0.07392138+0.1423025i,0.01336677+0.1692089i,0.118941+0.1446707i,0.2037857+0.04587309i,0.2051114-0.10697i,0.08865914-0.2364254i,-0.1037804-0.2504417i,-0.2623594-0.1146979i,-0.2783422+0.1059712i,-0.1255604+0.2784409i,0.1105319+0.2887677i,0.2834959+0.1235872i,0.2831757-0.115628i,0.1108847-0.2780193i,-0.1207811-0.2635489i,-0.2634274-0.08875619i,-0.2316024+0.1264716i,-0.05772384+0.2412164i,0.1333936+0.1884684i,0.2123825+0.01806489i,0.1349413-0.1417126i,-0.02941253-0.1773337i,-0.1506554-0.07214177i,-0.1363119+0.08272024i,-0.002275013+0.1586228i,0.1638045-0.07088678i,0.04090122-0.1923672i,-0.1420867-0.1650667i,-0.2399461+0.007640861i,-0.1627577+0.205313i,0.05039139+0.2779124i,0.2550159+0.159075i,0.3050293-0.0817911i,0.1577732-0.2874507i,-0.09714928-0.3225619i,-0.3017001-0.163215i,-0.3339327+0.0939947i,-0.1790111+0.3000022i,0.07300635+0.3436477i,0.287209+0.20666i,0.3557837-0.03817611i,0.2446458-0.2694794i,0.003924109-0.3725i,-0.2525584-0.2883323i,-0.3930548-0.0456226i,-0.3307636+0.2401457i,-0.07998682+0.4136715i,0.2328466+0.3641984i,0.4283442+0.1025056i,0.3819695-0.2280317i,0.1121308-0.4303792i},
    {-0.4013091-0.1088729i,-0.3003608+0.2232766i,-0.0006187892+0.336493i,0.2492287+0.1761522i,0.2640787-0.1014006i,0.05627433-0.2652508i,-0.1901628-0.1916307i,-0.2729892+0.04966328i,-0.1271529+0.2614682i,0.1342156+0.275923i,0.3138073+0.07780861i,0.2783017-0.1926179i,0.04901545-0.3477809i,-0.2227612-0.2841764i,-0.3653452-0.04401984i,-0.2967331+0.2248058i,-0.0638951+0.3691312i,0.2006681+0.317993i,0.3619984+0.1077958i,0.3488062-0.1535814i,0.1732683-0.3468396i,-0.0878282-0.3889774i,-0.3265375-0.2564716i,-0.4373538+0.008609879i,-0.3522735+0.303905i,-0.0780853+0.4917791i,0.5489373+0.1657816i,0.5551752-0.2610409i,0.2480931-0.6042217i,-0.2431896-0.6468935i,-0.6518268-0.3195615i,-0.7217613+0.2267748i,-0.3765852+0.6852276i,0.208828+0.773461i,0.6980944+0.4181701i,0.7982253-0.1849409i,0.4462103-0.6855242i,-0.1502057-0.7957285i,-0.6453146-0.4651073i,-0.7693905+0.1005533i,-0.480713+0.5789224i,0.03417102+0.7259098i,0.4917796+0.498794i,0.6740372+0.04739741i,0.523384-0.3927759i,0.1388266-0.6228227i,-0.2929343-0.5554593i,-0.5797364-0.2314592i,-0.5923185+0.2035293i,-0.3146022+0.5491214i,0.1340648+0.6278735i,0.5313722+0.3774118i},
    {-0.4788841+0.1993217i,-0.2322322+0.4517363i,0.1152804+0.489456i,0.4070859+0.293642i,0.5008326-0.05042646i,0.3384103-0.3751981i,-0.006792399-0.5059916i,-0.351232-0.3620827i,-0.4993886-0.01801982i,-0.3647716+0.3293903i,-0.02949195+0.4788994i,0.305269+0.3508618i,0.4466617+0.03395736i,0.3274216-0.2776694i,0.03622673-0.4085326i,-0.2492663-0.3018402i,-0.3723362-0.03785699i,-0.2794713+0.2259114i,-0.03663203+0.3454799i,0.2148048+0.2620542i,0.3327225+0.02741758i,0.2474248-0.2221454i,0.004093428-0.3348286i,-0.2510407-0.2305932i,-0.348539+0.03809375i,-0.2058061+0.3003698i,0.3649664+0.1688823i,0.3861243-0.1804134i,0.1190225-0.4370485i,-0.270945-0.3983789i,-0.5084034-0.05947734i,-0.4028585+0.3631899i,0.003149702+0.572591i,0.4482587+0.4014861i,0.6264373-0.06072448i,0.3989874-0.5195234i,-0.1059093-0.6703386i,-0.573994-0.4010328i,-0.7073156+0.1342122i,-0.412048+0.6124455i,0.1450784+0.7411827i,0.6383033+0.433455i,0.7745013-0.1416759i,0.4629548-0.6557118i,-0.129475-0.8070551i,-0.6674927-0.4951073i,-0.8354062+0.1141281i,-0.5230199+0.6737283i,0.09939281+0.8537129i,0.6714811+0.5405771i,0.8555554-0.08581818i,0.5444574-0.6557714i},
    {0.7108629+0.4011779i,0.840834-0.1728246i,0.5356106-0.7130867i,-0.07616355-0.9121553i,-0.6733997-0.6394054i,-0.9316826-0.031559i,-0.717093+0.5882472i,-0.1548343+0.9033083i,0.4604429+0.7753416i,0.83602+0.2942154i,0.8203567-0.2988326i,0.445343-0.7414368i,-0.1166115-0.8557931i,-0.6311346-0.5993545i,-0.8817368-0.07118826i,-0.7444925+0.5144914i,-0.2503205+0.8949485i,0.3975667+0.8683888i,0.8901694+0.4093646i,0.9603363-0.2831706i,0.5407307-0.8619716i,-0.1718921-1.012926i,-0.8065194-0.6405436i,-1.02269+0.06357501i,-0.707688+0.7226958i,-0.0413567+0.989745i,0.9167755+0.141196i,0.7458998-0.4795563i,0.2330611-0.8078609i,-0.3297959-0.7186533i,-0.6676539-0.3136664i,-0.6620165+0.1686461i,-0.3803513+0.5011956i,0.001331827+0.5783581i,0.3143511+0.4318695i,0.4720081+0.1672079i,0.4685506-0.1145528i,0.3316535-0.3496139i,0.08862492-0.4917083i,-0.2197111-0.4854386i,-0.5024858-0.2835147i,-0.6201789+0.09148665i,-0.4572758+0.500586i,-0.02696886+0.7258331i,0.4834295+0.5976117i,0.7917899+0.1303838i,0.6948948-0.4461808i,0.2174115-0.8087452i,-0.3828111-0.7440981i,-0.770915-0.290675i,-0.7459171+0.2880088i,-0.3556219+0.6779401i},
    {0.05235297-0.3942732i,-0.2336233-0.3597344i,-0.4405467-0.1244237i,-0.4347588+0.210941i,-0.1909914+0.4672346i,0.1763016+0.4916655i,0.4719125+0.2546937i,0.5323023-0.127173i,0.318617-0.4560973i,-0.06414006-0.5609323i,-0.4248928-0.384439i,-0.5823689-0.008538514i,-0.451013+0.3855597i,-0.08352116+0.5999856i,0.3454382+0.5138986i,0.6142557+0.1519844i,0.5660331-0.3098709i,0.2057594-0.6223124i,-0.2807846-0.5993699i,-0.6186939-0.2393459i,-0.6069893+0.2563863i,-0.2511788+0.597052i,0.2320682+0.5850294i,0.5522939+0.2437575i,0.5338404-0.2022294i,0.2226152-0.482478i,-0.3898652-0.1944751i,-0.3652585+0.1111324i,-0.1651922+0.280793i,0.05062068+0.2645899i,0.1644166+0.1381382i,0.1642388+0.01343199i,0.1135258-0.05071957i,0.07334685-0.07008988i,0.05158564-0.08884767i,0.01500185-0.1214643i,-0.06023837-0.136626i,-0.1521019-0.09083547i,-0.2019645+0.02426361i,-0.1586459+0.1628384i,-0.02048585+0.2481176i,0.1547506+0.2195308i,0.2772526+0.07253886i,0.273117-0.1315875i,0.127708-0.2915874i,-0.09822336-0.3169596i,-0.292097-0.1802023i,-0.3469+0.05895777i,-0.2242923+0.2779954i,0.01626544+0.3582582i,0.2471726+0.2559483i,0.3474392+0.02958297i},
    {0.05036617+0.1097863i,0.0875959+0.0572691i,0.09606446+0.009284659i,0.0934182-0.03543609i,0.07277768-0.08787227i,0.01215051-0.1344194i,-0.08680316-0.132605i,-0.1749383-0.04954698i,-0.1811932+0.09163389i,-0.0736239+0.2082073i,0.09861514+0.2124949i,0.2275494+0.08430409i,0.2232492-0.1024908i,0.08432894-0.2279666i,-0.0979619-0.213573i,-0.2073563-0.07830714i,-0.1867377+0.08117726i,-0.07133579+0.1670265i,0.05082467+0.1482211i,0.1113816+0.06760052i,0.1043239-0.008524747i,0.06934956-0.04689433i,0.04155661-0.06075179i,0.01932313-0.0765038i,-0.02154519-0.0937251i,-0.08695657-0.08093707i,-0.1334214+0.09740476i,-0.03811721+0.1817004i,0.1044043+0.1744681i,0.2094983+0.05996919i,0.2037597-0.1053039i,0.0786864-0.2243484i,-0.09878802-0.2222824i,-0.2267578-0.09562825i,-0.2314865+0.08491565i,-0.111352+0.2181596i,0.06472855+0.232608i,0.200178+0.125633i,0.2263717-0.03964198i,0.1378449-0.1741403i,-0.01089264-0.2131256i,-0.1409931-0.1474863i,-0.1932827-0.02072712i,-0.154592+0.1016091i,-0.05474669+0.167825i,0.05730632+0.1598237i,0.1386015+0.09056912i,0.1641701-0.010313i,0.1269024-0.1082337i,0.03608056-0.1683539i,-0.0796012-0.1613431i,-0.172177-0.07783116i},
    {0.3940354-0.2265837i,0.1041683-0.430968i,-0.2301021-0.3593686i,-0.3971114-0.08155949i,-0.3173189+0.2100853i,-0.07505912+0.3456452i,0.1676402+0.2803742i,0.2879703+0.0898184i,0.2585667-0.1101149i,0.1243921-0.2363147i,-0.04871759-0.2565872i,-0.2001135-0.1714385i,-0.2726975-0.00494716i,-0.2202233+0.1834549i,-0.04226723+0.299732i,0.1843823+0.2600532i,0.3277847+0.05984063i,0.2834875-0.1962077i,0.05984895-0.3476388i,-0.2103148-0.2882876i,-0.3537713-0.04855439i,-0.2775206+0.2194404i,-0.03352688+0.3459357i,0.2202801+0.2578709i,0.3288361+0.02062661i,0.2368269-0.2145234i,-0.207983-0.2197778i,-0.2970779-0.00464425i,-0.2080662+0.2081577i,0.006635241+0.2943061i,0.2211221+0.1986886i,0.3014433-0.0283939i,0.1857415-0.2488737i,-0.06471953-0.3135325i,-0.2881122-0.1630856i,-0.3228319+0.1151374i,-0.1272535+0.3309305i,0.1739024+0.3218088i,0.3672251+0.07952413i,0.3061976-0.231186i,0.02635378-0.3880296i,-0.2758325-0.2770158i,-0.3886346+0.02208175i,-0.2407752+0.2988055i,0.05482423+0.370405i,0.2961754+0.2077373i,0.340628-0.06360783i,0.1887355-0.2706182i,-0.04570985-0.3103771i,-0.230866-0.1915971i,-0.2910449+0.005187321i,-0.2183571+0.1892162i},
    {0.1483335+1.135576i,0.814018+0.773504i,1.100764+0.09161606i,0.9059121-0.6080568i,0.3265114-1.032069i,-0.387435-1.006207i,-0.930707-0.5420642i,-1.065224+0.1620358i,-0.7260863+0.796724i,-0.06074711+1.075451i,0.6302909+0.869935i,1.032796+0.2756428i,0.9690107-0.4332957i,0.478425-0.9376665i,-0.2106501-1.02229i,-0.7950422-0.6646215i,-1.031178-0.02918018i,-0.8285625+0.6135717i,-0.2746608+0.9981622i,0.4039955+0.963188i,0.925772+0.5125926i,1.060748-0.1774029i,0.7300354-0.816204i,0.05615707-1.114205i,-0.6716965-0.9161785i,-1.118869-0.2883404i,-0.512351+1.073709i,0.2926461+1.168619i,0.9818643+0.7221646i,1.230568-0.07114802i,0.9115604-0.8501408i,0.1586035-1.250557i,-0.6876364-1.073454i,-1.230002-0.3844966i,-1.199909+0.5039209i,-0.5943345+1.169643i,0.3073626+1.282953i,1.069377+0.7776399i,1.315999-0.1041343i,0.9271342-0.9290059i,0.1018015-1.295434i,-0.7496097-1.039436i,-1.221832-0.3077702i,-1.114753+0.53504i,-0.5108939+1.100329i,0.292932+1.155684i,0.9399695+0.7066016i,1.165513-0.03479274i,0.8877198-0.752155i,0.2249933-1.14658i,-0.5486158-1.044541i,-1.099266-0.4710386i},
    {-0.1789754+1.095619i,0.5823041+0.9731466i,1.096406+0.368701i,1.08857-0.445248i,0.534113-1.063746i,-0.3023786-1.159053i,-0.993103-0.669504i,-1.179406+0.1537514i,-0.7731006+0.8821615i,-0.001069552+1.149168i,0.7322628+0.8463594i,1.072634+0.1614179i,0.8925351-0.5491528i,0.324166-0.957891i,-0.3427676-0.9149685i,-0.815155-0.4830615i,-0.9156288+0.1260642i,-0.6290122+0.6548517i,-0.08682168+0.8943554i,0.4859821+0.7512884i,0.8490202+0.2826162i,0.8393301-0.3151798i,0.4506342-0.7765338i,-0.1466439-0.8846696i,-0.6743517-0.5837913i,-0.8824528-0.01715257i,-0.1743152+0.8321762i,0.382073+0.7351838i,0.7375029+0.3223874i,0.7548202-0.2005864i,0.4576287-0.6052963i,-0.006299189-0.7401168i,-0.4442235-0.5749491i,-0.6935175-0.1904582i,-0.6685033+0.263372i,-0.3792611+0.617172i,0.07125966+0.7327187i,0.5132257+0.5508758i,0.7633973+0.1245595i,0.6980284-0.3844568i,0.3173263-0.7585187i,-0.234925-0.8155306i,-0.7184919-0.5005842i,-0.8998674+0.07030246i,-0.6677101+0.6458033i,-0.1023189+0.9485356i,0.5442263+0.8117866i,0.9594956+0.2751466i,0.9259884-0.4179095i,0.4407286-0.9310328i,-0.2707034-1.004432i,-0.8621478-0.592975i},
    {-1.620047-0.1260677i,-1.30198+0.9135087i,-0.4181474+1.501647i,0.6160965+1.400199i,1.339262+0.681746i,1.443222-0.314043i,0.9032403-1.13602i,-0.01760148-1.424909i,-0.8950757-1.073403i,-1.34327-0.2657168i,-1.187977+0.6215817i,-0.52965+1.201709i,0.3243637+1.246796i,1.008825+0.7672839i,1.251861-0.0165079i,0.9696269-0.7768119i,0.2855147-1.205205i,-0.5189735-1.125375i,-1.107389-0.5640558i,-1.222155+0.2471931i,-0.8032111+0.9572918i,-0.02977703+1.24898i,0.7533461+0.9915569i,1.199183+0.3066389i,1.123828-0.4958343i,0.5803948-1.072858i,-0.8779477-0.8481529i,-1.228635-0.1548943i,-1.104713+0.6294741i,-0.5196517+1.214302i,0.3470358+1.340863i,1.164452+0.8822101i,1.543118-0.05120312i,1.217952-1.082238i,0.2401641-1.695179i,-0.966745-1.504192i,-1.780819-0.5146201i,-1.723878+0.8140066i,-0.7661002+1.78743i,0.6194884+1.868051i,1.7092+0.9939361i,1.936377-0.3812388i,1.200322-1.54895i,-0.1026613-1.935693i,-1.318066-1.38712i,-1.877041-0.206037i,-1.553091+1.034508i,-0.5282592+1.772163i,0.7194536+1.692471i,1.630515+0.8432442i,1.795369-0.3935606i,1.129483-1.457687i},
    {0.4440626+1.027584i,0.9701698+0.5613198i,1.126297-0.1330029i,0.8336771-0.8015394i,0.1768626-1.171576i,-0.5958781-1.060402i,-1.154328-0.4768429i,-1.231921+0.3530216i,-0.7619743+1.070444i,0.07497924+1.344919i,0.9224082+1.029106i,1.401333+0.2318432i,1.27447-0.719328i,0.5555652-1.406132i,-0.4753557-1.491683i,-1.364702-0.8793692i,-1.670965+0.2069872i,-1.183599+1.280765i,-0.06992154+1.799966i,1.155539+1.448853i,1.866018+0.3425188i,1.659181-0.988414i,0.6020388-1.85914i,-0.7788631-1.804447i,-1.774835-0.8433859i,-1.881229+0.5288546i,0.2448652+1.892044i,1.391763+1.259368i,1.843289+0.0613029i,1.426028-1.118131i,0.3732846-1.74265i,-0.8127782-1.55611i,-1.596866-0.6723539i,-1.640398+0.4930624i,-0.9404408+1.410601i,0.1733001+1.669733i,1.186733+1.163071i,1.637508+0.1363667i,1.331355-0.927873i,0.4295222-1.541919i,-0.6384711-1.442476i,-1.387219-0.7017709i,-1.498601+0.3266681i,-0.9485112+1.18348i,0.005105208+1.504662i,0.9449003+1.163094i,1.465791+0.3097306i,1.336115-0.6871254i,0.5995538-1.385314i,-0.4244137-1.456203i,-1.263976-0.8471617i,-1.512102+0.1675048i},
    {-0.4705988+1.060384i,0.3004152+1.133622i,0.9577408+0.6995365i,1.196796-0.06453772i,0.8914628-0.8169001i,0.1682643-1.205205i,-0.6414257-1.039091i,-1.157325-0.3906743i,-1.137311+0.4359437i,-0.5962901+1.054072i,0.2062151+1.183543i,0.8990908+0.7797071i,1.177877+0.04066405i,0.9363536-0.6989143i,0.2960365-1.122916i,-0.4628647-1.062134i,-1.023295-0.5495926i,-1.15303+0.2025938i,-0.789582+0.8849781i,-0.06874974+1.204845i,0.7144729+1.003437i,1.21327+0.3376417i,1.178804-0.5181639i,0.5914105-1.174339i,-0.30193-1.304854i,-1.085254-0.8193393i,-1.013421+0.945386i,-0.1690272+1.381065i,0.7572062+1.168612i,1.327646+0.4129703i,1.282568-0.5268693i,0.6541333-1.218182i,-0.264243-1.354965i,-1.061084-0.8846108i,-1.386621-0.01769005i,-1.095164+0.867105i,-0.3039784+1.378685i,0.6479064+1.275685i,1.332125+0.5791805i,1.416071-0.4147465i,0.8288883-1.24764i,-0.1775591-1.507325i,-1.125985-1.041011i,-1.542675-0.05545787i,-1.206613+0.9685956i,-0.2777641+1.518463i,0.7782754+1.320217i,1.43463+0.4840599i,1.379628-0.5597328i,0.669749-1.294734i,-0.3197941-1.385417i,-1.10553-0.8304967i},
    {0.5036572+1.181828i,1.17433+0.592816i,1.309871-0.3151745i,0.8097412-1.116241i,-0.1169015-1.404695i,-1.028222-1.004701i,-1.459525-0.0832741i,-1.16837+0.9107732i,-0.2794588+1.469016i,0.7644116+1.294441i,1.430651+0.467804i,1.380278-0.590829i,0.6457705-1.345795i,-0.3941344-1.426684i,-1.219992-0.8108803i,-1.436845+0.1816887i,-0.9594203+1.062344i,-0.03585429+1.414785i,0.8840673+1.085607i,1.363824+0.2454438i,1.181585-0.6966122i,0.4333216-1.285571i,-0.5098589-1.238373i,-1.179769-0.5870961i,-1.247552+0.3308867i,-0.6976615+1.045081i,0.8805557+0.7604514i,1.103907-0.009544749i,0.7757013-0.6873056i,0.1312018-0.9530975i,-0.4698569-0.7476862i,-0.7594945-0.2580698i,-0.6831905+0.2366941i,-0.3689398+0.5356154i,-0.0002144738+0.5896847i,0.2958959+0.4595407i,0.4737485+0.2268292i,0.5237905-0.05454301i,0.4290257-0.3401769i,0.1762611-0.5549414i,-0.1919661-0.5946274i,-0.5471767-0.3873786i,-0.7149549+0.03108432i,-0.5727969+0.4971654i,-0.1403263+0.7855295i,0.4050995+0.7289127i,0.8058389+0.3187965i,0.8534019-0.2749113i,0.4988707-0.7783635i,-0.1136396-0.9441615i,-0.7072738-0.6731974i,-0.9987361-0.06981731i},
    {0.2628061-0.4379961i,-0.05428546-0.4962994i,-0.338617-0.36403i,-0.4972017-0.09112252i,-0.4670745+0.235903i,-0.2334323+0.4959302i,0.1366776+0.5605239i,0.4873955+0.3612449i,0.6332531-0.04304188i,0.4676143-0.4645897i,0.04678803-0.6772661i,-0.4214-0.5506306i,-0.689471-0.1363263i,-0.6123552+0.35511i,-0.2281693+0.6718717i,0.267742+0.6565915i,0.6301996+0.3218271i,0.6863567-0.1658064i,0.412822-0.5715449i,-0.05857585-0.7020041i,-0.5018684-0.4933875i,-0.7006915-0.04449098i,-0.5545328+0.4242955i,-0.1362654+0.6773981i,0.3387946+0.5887497i,0.6271224+0.2135258i,0.2770572-0.5474524i,-0.1360222-0.566929i,-0.4405434-0.3302632i,-0.5184383+0.01752091i,-0.3768181+0.3137227i,-0.1074066+0.4557493i,0.1784093+0.4182352i,0.3875916+0.2296829i,0.4522775-0.04761786i,0.3373619-0.3198908i,0.06717851-0.4728503i,-0.254099-0.418316i,-0.4715069-0.1588151i,-0.4633469+0.1871673i,-0.225918+0.4401302i,0.1132029+0.4687163i,0.3739232+0.2726012i,0.4372492-0.02627422i,0.3064579-0.273704i,0.07657141-0.3776045i,-0.1466921-0.3354889i,-0.3018904-0.1931092i,-0.3649614+0.005447993i,-0.3153341+0.2223388i,-0.1347823+0.3952273i,0.1480579+0.4307233i},
    {0.3101633+0.1184643i,0.3026923-0.1372681i,0.1137039-0.3112881i,-0.1424897-0.2964282i,-0.3079913-0.1027122i,-0.2825576+0.1472434i,-0.08822924+0.2979661i,0.1479374+0.2623134i,0.2803656+0.07416196i,0.2387272-0.1416954i,0.0646996-0.256333i,-0.1272872-0.2161199i,-0.2290324-0.06323037i,-0.1991657+0.105707i,-0.07136439+0.2031174i,0.08019098+0.1917677i,0.1837439+0.0883605i,0.1960552-0.05562346i,0.1111512-0.1753744i,-0.03745783-0.2117932i,-0.1806945-0.1349908i,-0.2363817+0.03042926i,-0.154566+0.199939i,0.03740471+0.2654538i,0.2308114+0.1652712i,0.2939066-0.05868272i,-0.09192742-0.3170777i,-0.3092298-0.151239i,-0.3317462+0.1327375i,-0.1280878+0.3462824i,0.175671+0.3366994i,0.3761522+0.0986245i,0.3327488-0.2154263i,0.06744304-0.3966024i,-0.2478549-0.3222443i,-0.4072889-0.03888877i,-0.3082769+0.2705589i,-0.01621298+0.4093973i,0.2829712+0.2938336i,0.4049805+0.001143626i,0.2811537-0.2859817i,-0.006075091-0.3962446i,-0.2813033-0.2714413i,-0.3850099+0.006272948i,-0.2649576+0.2708263i,0.0007772286+0.3724857i,0.2561735+0.2613858i,0.3593673+0.009100469i,0.2602766-0.2385672i,0.02233871-0.3461413i,-0.2189835-0.2613775i,-0.3334144-0.0381794i},
    {-1.316072-0.2066664i,-1.141262+0.6306025i,-0.5109723+1.181689i,0.3178816+1.242718i,1.019232+0.7876878i,1.300652-0.01387319i,1.018481-0.8347898i,0.2660981-1.306013i,-0.6312529-1.187943i,-1.250806-0.5117411i,-1.286143+0.4094002i,-0.7180836+1.130702i,0.1699406+1.310023i,0.9470902+0.8843312i,1.263248+0.08422027i,1.011764-0.7078952i,0.3462969-1.15463i,-0.4268887-1.101431i,-0.9956391-0.6051388i,-1.152432+0.1216487i,-0.8461729+0.79779i,-0.1892437+1.161377i,0.5706974+1.053543i,1.123187+0.4889736i,1.212833-0.3213226i,0.7644708-1.032951i,-0.8882115-1.007118i,-1.350799-0.2253698i,-1.212141+0.6908886i,-0.5127768+1.325316i,0.4481695+1.377053i,1.242564+0.7993661i,1.49984-0.172055i,1.0737-1.110672i,0.1223261-1.577605i,-0.9383137-1.322087i,-1.606208-0.4191054i,-1.530488+0.7331215i,-0.7040208+1.581057i,0.5011542+1.68687i,1.498776+0.9660113i,1.783269-0.2474958i,1.19763-1.359122i,0.02234479-1.816895i,-1.166436-1.39427i,-1.789952-0.3008731i,-1.552624+0.930028i,-0.5776033+1.708265i,0.6632727+1.669049i,1.579229+0.8391307i,1.738559-0.3816148i,1.070431-1.409804i},
    {-0.7895855-0.5869937i,-0.9762963+0.02120732i,-0.762293+0.6165041i,-0.2275954+0.9694521i,0.430914+0.9263169i,0.9455094+0.4692897i,1.067251-0.2430726i,0.689196-0.9024057i,-0.06047626-1.173706i,-0.8370261-0.875592i,-1.236482-0.1120905i,-1.020521+0.7465978i,-0.2718456+1.249837i,0.6299848+1.119791i,1.212017+0.4169883i,1.172363-0.4885236i,0.5457593-1.125063i,-0.3262166-1.17944i,-0.9940736-0.6558889i,-1.143645+0.1493163i,-0.7445643+0.8262588i,-0.03448431+1.068495i,0.6300862+0.8088393i,0.9582967+0.2169461i,0.846252-0.4147338i,0.3899809-0.8183014i,-0.6549177-0.5459974i,-0.835923-0.03437833i,-0.6779191+0.4756943i,-0.2474999+0.7887522i,0.2889188+0.7790551i,0.7151574+0.4389572i,0.8430818-0.1028324i,0.5989224-0.6164132i,0.07535173-0.8643563i,-0.4934379-0.7193282i,-0.8386403-0.2403155i,-0.7949899+0.3469453i,-0.3890687+0.7641225i,0.1781135+0.8244526i,0.6424546+0.5207396i,0.8102443+0.0103903i,0.6357208-0.4794288i,0.2133652-0.7583532i,-0.2849714-0.7343881i,-0.6769707-0.4224195i,-0.815784+0.07228857i,-0.6260407+0.5747725i,-0.1437581+0.8767083i,0.4591726+0.810542i,0.9115646+0.3487305i,0.9617808-0.3350254i},
    {-0.8828529+0.1838123i,-0.5725235+0.6789266i,-0.02877326+0.8799418i,0.5235137+0.7026824i,0.8453168+0.2173282i,0.78754-0.3634697i,0.3738388-0.7720725i,-0.1982007-0.8192263i,-0.6558241-0.4958974i,-0.796189+0.02614624i,-0.5854404+0.496992i,-0.1526755+0.7230731i,0.3018035+0.6464229i,0.6090644+0.3347195i,0.6822771-0.08168449i,0.5122535-0.4652866i,0.148765-0.6940417i,-0.3021254-0.6742312i,-0.6797882-0.3745621i,-0.8084268+0.1273356i,-0.5830172+0.6355101i,-0.05451009+0.9041287i,0.5571181+0.765476i,0.9545124+0.2411592i,0.9176509-0.4428017i,0.4308321-0.9579203i,-0.9176603-0.6201656i,-1.128563+0.1204445i,-0.8027922+0.840444i,-0.06949107+1.187332i,0.7340494+0.9691719i,1.21252+0.262084i,1.107839-0.6050558i,0.4453256-1.199729i,-0.4574563-1.207714i,-1.143806-0.6103868i,-1.260728+0.2926313i,-0.7528672+1.041056i,0.1106687+1.263882i,0.891587+0.8725483i,1.220013+0.08747498i,0.9717672-0.700905i,0.297798-1.136981i,-0.4801283-1.053008i,-1.025495-0.5119185i,-1.116581+0.2446091i,-0.7171746+0.896272i,0.01129279+1.159254i,0.7574367+0.8982751i,1.174352+0.2044304i,1.040094-0.6129975i,0.3914464-1.153399i},
    {-0.5672483-0.5538371i,-0.7413126-0.07483742i,-0.5926103+0.3751618i,-0.2261548+0.6218366i,0.1858206+0.5975242i,0.4805789+0.3479972i,0.5645251-0.003930904i,0.436185-0.3182847i,0.1679109-0.4931337i,-0.1376316-0.4903797i,-0.3871631-0.3275733i,-0.5128799-0.05542697i,-0.4716234+0.2541808i,-0.2513748+0.5067302i,0.1038723+0.5941828i,0.473875+0.438113i,0.6869361+0.05414702i,0.6029748-0.4140778i,0.212332-0.740416i,-0.3250538-0.735174i,-0.7462305-0.3663405i,-0.8279143+0.2038279i,-0.5149205+0.6995366i,0.04887614+0.8794801i,0.6009386+0.6586072i,0.8929503+0.1376974i,0.3487555-0.874625i,-0.2800136-0.9302903i,-0.831676-0.5720761i,-1.050981+0.08442673i,-0.7918119+0.7697922i,-0.1147788+1.150982i,0.6915921+0.9911273i,1.219484+0.3055494i,1.15529-0.5963272i,0.4804458-1.24608i,-0.4809722-1.274336i,-1.223454-0.636977i,-1.344538+0.3423351i,-0.7764196+1.149553i,0.1794766+1.368292i,1.02854+0.9015756i,1.352496+0.004386904i,1.014255-0.8702222i,0.2011635-1.305979i,-0.6881023-1.113339i,-1.236803-0.3986342i,-1.194074+0.4966336i,-0.5824832+1.150266i,0.3084855+1.248821i,1.04819+0.7390055i,1.269006-0.1326121i},
    {-0.6920137+0.4882154i,-0.2371602+0.8321771i,0.3487609+0.8153337i,0.8077982+0.4213574i,0.9170783-0.1953069i,0.5957532-0.7599092i,-0.03675465-0.993103i,-0.6918667-0.7505253i,-1.038337-0.1175083i,-0.8753378+0.6061581i,-0.2591321+1.046874i,0.503644+0.9607859i,1.012853+0.3822674i,1.000157-0.3835615i,0.4844749-0.9320011i,-0.2443952-0.9909916i,-0.803396-0.5667326i,-0.9359139+0.08540648i,-0.6324701+0.630898i,-0.09164976+0.8424059i,0.42371+0.6858773i,0.7214703+0.281201i,0.7299796-0.1957617i,0.4734334-0.585483i,0.03606023-0.7650716i,-0.4457792-0.6550263i,-0.8109661+0.3106128i,-0.4444893+0.7926219i,0.1840329+0.9270352i,0.7711729+0.5957066i,0.9923613-0.06596405i,0.7034036-0.7164899i,0.04656818-1.001378i,-0.6241819-0.7684287i,-0.9547019-0.1574519i,-0.7958422+0.4943244i,-0.269344+0.8587201i,0.3321409+0.7927967i,0.7240493+0.3820014i,0.7662805-0.1474929i,0.4915667-0.5633073i,0.04666944-0.7213584i,-0.388821-0.5909873i,-0.6603581-0.2364565i,-0.6714011+0.2108595i,-0.4091966+0.5831321i,0.03678107+0.7240355i,0.4881859+0.555051i,0.7420407+0.1288246i,0.6677411-0.3742062i,0.2832384-0.7217409i,-0.2414388-0.7443504i},
    {0.3677099+0.4522596i,0.5387153+0.1035593i,0.458136-0.2487431i,0.1917387-0.4642331i,-0.1412096-0.4705679i,-0.405214-0.2698036i,-0.4828458+0.0573807i,-0.3246074+0.3624721i,0.004167839+0.4849418i,0.331126+0.3461615i,0.4667265+0.01821118i,0.3303133-0.302755i,0.01561599-0.4213125i,-0.2686093-0.2797753i,-0.3474657+0.002350142i,-0.203209+0.2228342i,0.0256188+0.2503287i,0.164677+0.1126825i,0.1402487-0.0468186i,0.02033481-0.09898539i,-0.06332025-0.030108i,-0.03487404+0.06468607i,0.06796608+0.07755164i,0.1380653-0.01696482i,0.09555519-0.1454611i,-0.0473961-0.2004249i,-0.2557683+0.05138672i,-0.1690142+0.2302964i,0.02915134+0.3088998i,0.2441536+0.2305861i,0.3627838+0.01441459i,0.3053512-0.2461505i,0.07173601-0.4167936i,-0.2400331-0.38586i,-0.4664638-0.1352324i,-0.4631954+0.2262702i,-0.1996947+0.5048105i,0.2020915+0.5296888i,0.5247241+0.2635289i,0.5811136-0.1629916i,0.3284517-0.5215607i,-0.1051226-0.6175824i,-0.4949865-0.3977896i,-0.6428475+0.02767513i,-0.4740336+0.4493938i,-0.06565991+0.6622652i,0.3927011+0.5565808i,0.6801676+0.1667451i,0.6405389-0.3339179i,0.2646416-0.6975994i,-0.2802949-0.7171148i,-0.711271-0.348363i},
    {-1.332229+0.3051167i,-0.7896822+1.125423i,0.1651614+1.365908i,1.030231+0.9044077i,1.361134-0.009662936i,1.002489-0.9010901i,0.1538648-1.323374i,-0.7483369-1.0813i,-1.257629-0.3149628i,-1.135838+0.5829269i,-0.4620645+1.167109i,0.4143489+1.159651i,1.052977+0.5847545i,1.146612-0.2492823i,0.6757457-0.91518i,-0.09137168-1.092953i,-0.7540411-0.7319704i,-0.9988541-0.05790181i,-0.7544773+0.5719803i,-0.1976438+0.8690398i,0.3747142+0.7472262i,0.7121693+0.3258953i,0.7152385-0.171442i,0.4385474-0.5391889i,0.02611653-0.6627571i,-0.3611776-0.5292534i,-0.5904171+0.1873639i,-0.3560569+0.5032631i,0.02392292+0.6149518i,0.3952996+0.470052i,0.5982361+0.1261115i,0.5443412-0.2674556i,0.2618689-0.5396144i,-0.1211342-0.5797832i,-0.4429292-0.3830047i,-0.5800505-0.03895789i,-0.4880316+0.3158896i,-0.2046197+0.5497837i,0.168453+0.5732505i,0.4928047+0.3651096i,0.6327072-0.01072165i,0.5090016-0.4110003i,0.1489896-0.6592516i,-0.3042559-0.6263938i,-0.6463897-0.3053134i,-0.7107939+0.1714564i,-0.4558786+0.5903425i,0.01219908+0.7600954i,0.4916282+0.6002777i,0.7763529+0.1713922i,0.7383536-0.355624i,0.3734182-0.7644526i},
    {0.04692384+0.2639025i,0.2100874+0.1929246i,0.3003817+0.02733889i,0.2698399-0.169392i,0.11829-0.3159905i,-0.1050593-0.3431638i,-0.3136902-0.22042i,-0.410122+0.02319521i,-0.3270692+0.2951652i,-0.07074034+0.4667469i,0.2609792+0.4318898i,0.5091514+0.1724605i,0.5298257-0.2113889i,0.2785874-0.5346628i,-0.1473834-0.6173307i,-0.542385-0.3858499i,-0.6918582+0.07145777i,-0.4901972+0.5329971i,-0.01225772+0.7509429i,0.5079076+0.5863115i,0.7913607+0.09862544i,0.6678467-0.4681417i,0.1826993-0.8088323i,-0.4134664-0.7284366i,-0.7985381-0.2610621i,-0.7632021+0.342188i,0.251828+0.7702551i,0.6807395+0.3995294i,0.7516279-0.140551i,0.4647761-0.5738174i,-0.008910576-0.7131982i,-0.4425239-0.5321096i,-0.6634868-0.1387003i,-0.6032975+0.2979581i,-0.2934821+0.6115797i,0.1537673+0.6766672i,0.56475+0.4428987i,0.7464326-0.02362834i,0.5725595-0.5265017i,0.08147392-0.8033015i,-0.495665-0.6688959i,-0.8363057-0.1554024i,-0.7219274+0.4668722i,-0.1978299+0.8354018i,0.4323202+0.7273523i,0.7941206+0.2137226i,0.6873636-0.3843208i,0.2114976-0.7115026i,-0.3178921-0.6099598i,-0.5927507-0.2003993i,-0.5069513+0.232627i,-0.1878626+0.4484078i},
    {-0.7802934+0.636767i,-0.2045386+1.060251i,0.5630961+0.9986771i,1.13353+0.4114124i,1.174995-0.4475665i,0.616517-1.145503i,-0.290354-1.30507i,-1.095578-0.8169988i,-1.388077+0.09467916i,-1.00975+0.9876989i,-0.1326288+1.425781i,0.8298748+1.190519i,1.421435+0.3811471i,1.353339-0.6331151i,0.6375404-1.378649i,-0.4099877-1.49049i,-1.30051-0.8868325i,-1.593099+0.1731063i,-1.11404+1.18919i,-0.06614458+1.652258i,1.046129+1.305845i,1.660435+0.2984148i,1.45198-0.8726643i,0.5166342-1.612845i,-0.6709157-1.546079i,-1.508457-0.7157586i,-0.8921947+1.350438i,0.1996918+1.572911i,1.145963+1.043133i,1.511585+0.05569506i,1.165991-0.9054829i,0.3114249-1.408351i,-0.6416581-1.258112i,-1.2707-0.5561577i,-1.316741+0.3681701i,-0.7782244+1.106443i,0.09863482+1.339252i,0.9232225+0.9665422i,1.323509+0.1542618i,1.111409-0.7282791i,0.3793655-1.268256i,-0.5283626-1.205097i,-1.173433-0.5674287i,-1.242247+0.3297129i,-0.7113387+1.040377i,0.1380229+1.220091i,0.8718967+0.8062797i,1.138583+0.04164071i,0.8498695-0.672282i,0.2049273-1.000484i,-0.4473001-0.8422568i,-0.8114015-0.3482379i},
    {-0.5000426-0.8940959i,-0.9684522-0.4215874i,-1.062424+0.2707064i,-0.691419+0.9083392i,0.03586557+1.187838i,0.8132826+0.9276918i,1.259736+0.1961402i,1.118821-0.6814585i,0.4198226-1.270198i,-0.5116269-1.257619i,-1.215551-0.6320328i,-1.341579+0.304663i,-0.8307897+1.097288i,0.06486735+1.372263i,0.9220927+1.013846i,1.354006+0.1993649i,1.177467-0.7009676i,0.4757614-1.292364i,-0.4476783-1.315841i,-1.192746-0.7492802i,-1.421329+0.1769242i,-1.003862+1.059618i,-0.09733349+1.485518i,0.8964339+1.224411i,1.500776+0.3630333i,1.398549-0.7062106i,-0.4924631-1.517764i,-1.367199-0.8322995i,-1.577787+0.2601079i,-1.022719+1.219313i,0.01598804+1.578254i,1.024663+1.177141i,1.521886+0.2311753i,1.291637-0.7926996i,0.4713973-1.413544i,-0.5346491-1.362924i,-1.259446-0.694412i,-1.388676+0.2623366i,-0.8907166+1.06675i,-0.0126577+1.368037i,0.8434801+1.052378i,1.302085+0.2793886i,1.173409-0.5986521i,0.5275518-1.194019i,-0.342339-1.24968i,-1.048937-0.7473302i,-1.278524+0.08545836i,-0.9293543+0.8732187i,-0.1608343+1.258281i,0.6737005+1.064994i,1.188061+0.3860843i,1.147051-0.4569087i},
    {0.03664693+0.9158104i,0.6163825+0.7153191i,0.9589729+0.174444i,0.8787809-0.4887449i,0.3731814-0.9650468i,-0.3441815-1.003095i,-0.9295626-0.5534825i,-1.082644+0.1840025i,-0.7114307+0.8510873i,0.01064528+1.11538i,0.7316073+0.8443551i,1.10216+0.1716423i,0.9499439-0.5761921i,0.3567334-1.045779i,-0.3921297-1.025732i,-0.9500792-0.5371604i,-1.069138+0.1878693i,-0.7050477+0.8194497i,-0.0278747+1.077992i,0.6588126+0.853108i,1.051318+0.2466127i,0.9753725-0.4739938i,0.460112-0.9900233i,-0.2721953-1.067449i,-0.8971757-0.6601226i,-1.126294+0.06222503i,-0.1457803+1.149688i,0.6376505+0.9851468i,1.135721+0.3412166i,1.092655-0.4829973i,0.5143002-1.082593i,-0.3188437-1.153185i,-0.9889442-0.6574345i,-1.161829+0.148886i,-0.7662286+0.8546764i,-0.02436491+1.1174i,0.6820392+0.8398212i,1.023132+0.1987511i,0.880363-0.4766006i,0.3712931-0.886566i,-0.2476895-0.8917799i,-0.7185543-0.5371058i,-0.8781779+0.00802887i,-0.6888441+0.5315602i,-0.227496+0.8423784i,0.3376653+0.816973i,0.7850453+0.4437232i,0.9109048-0.1467908i,0.6273277-0.7046917i,0.0344086-0.9607702i,-0.5985821-0.768647i,-0.9593766-0.202708i},
    {0.9600698+0.9360989i,1.297341+0.08375607i,1.009102-0.7495584i,0.2810809-1.1801i,-0.5179193-1.048485i,-1.026762-0.4645734i,-1.051031+0.2757927i,-0.6249548+0.8426266i,0.03303012+1.014519i,0.6332536+0.7546094i,0.9384114+0.2016188i,0.8480936-0.4047886i,0.4204717-0.8243116i,-0.1642763-0.9022265i,-0.6760545-0.6166821i,-0.9158358-0.08023019i,-0.7840062+0.4994244i,-0.3198611+0.8893321i,0.3016016+0.9167393i,0.8243088+0.5454146i,1.009907-0.090515i,0.7480187-0.7233261i,0.1257116-1.059681i,-0.5899346-0.9197963i,-1.063897-0.339092i,-1.05436+0.4288785i,0.246322+1.147026i,0.9375896+0.7264249i,1.194742-0.04990684i,0.8852515-0.8134637i,0.1515058-1.195828i,-0.6558675-1.011017i,-1.149703-0.3484516i,-1.096977+0.4714108i,-0.531747+1.056755i,0.2668757+1.137633i,0.9184818+0.6934373i,1.129559-0.04877932i,0.827562-0.7378756i,0.1767083-1.072144i,-0.5199364-0.9305272i,-0.9680427-0.4035037i,-1.000988+0.2721007i,-0.6251484+0.8231397i,0.004363789+1.039295i,0.6459762+0.8343744i,1.046686+0.2710603i,1.022933-0.4467428i,0.5405741-1.024494i,-0.2360511-1.181852i,-0.9736203-0.7904125i,-1.302139+0.02377007i},
    {-0.954693-0.6216511i,-1.114697+0.1626069i,-0.7177655+0.8378533i,0.002585765+1.071577i,0.6694717+0.7881832i,0.9787901+0.1739598i,0.8370348-0.4601295i,0.3604292-0.8474876i,-0.2238488-0.8664279i,-0.6889015-0.546886i,-0.8761172-0.02396672i,-0.7215586+0.512997i,-0.2683845+0.8640018i,0.3279134+0.8725443i,0.8271515+0.4962275i,0.9892765-0.1401065i,0.6966652-0.7629528i,0.04509995-1.06347i,-0.6700008-0.8612381i,-1.089486-0.2229296i,-0.9836067+0.5485218i,-0.3888482+1.064271i,0.4003217+1.059359i,0.9871442+0.5386743i,1.086098-0.2284504i,0.6690226-0.8597224i,-0.6861069-0.777814i,-0.9955648-0.1696117i,-0.8645233+0.4732909i,-0.3850536+0.8874627i,0.2315317+0.9299148i,0.7487703+0.601824i,0.9752205+0.02566024i,0.8100984-0.5907745i,0.2822122-1.000969i,-0.4251999-0.9977797i,-1.00587-0.5209711i,-1.151153+0.2622708i,-0.7258134+0.9862301i,0.1089735+1.256373i,0.9362407+0.8839636i,1.301585+0.03194897i,0.9879516-0.8492526i,0.1619066-1.279227i,-0.7197927-1.036667i,-1.187922-0.285218i,-1.035163+0.5458227i,-0.4069974+1.033388i,0.3305994+0.9931976i,0.8280367+0.5307328i,0.9228246-0.08355045i,0.6562333-0.5892596i},
    {0.3580926+0.06144992i,0.2927063-0.2055378i,0.06361985-0.3461336i,-0.1928057-0.288074i,-0.3344577-0.07272117i,-0.2893688+0.1770345i,-0.08715791+0.3263613i,0.1618329+0.2968879i,0.323916+0.1040241i,0.3092348-0.1504123i,0.1199349-0.3275813i,-0.14486-0.3238437i,-0.3363044-0.131895i,-0.3377647+0.1458111i,-0.1379493+0.3480282i,0.152568+0.3484506i,0.3604059+0.1374506i,0.3543085-0.1635721i,0.1309162-0.371471i,-0.1770246-0.3548747i,-0.3800495-0.1195823i,-0.3506106+0.191423i,-0.1048582+0.3858096i,0.2058344+0.3424489i,0.3889816+0.0878938i,0.3312967-0.2198388i,-0.2332121-0.3177023i,-0.3886182-0.04985273i,-0.3018135+0.2455171i,-0.02970374+0.3846663i,0.2558089+0.2836332i,0.3772449+0.009897657i,0.2634525-0.2626134i,-0.007979221-0.3656156i,-0.2642306-0.242263i,-0.3496496+0.02177116i,-0.2219462+0.259285i,0.0291675+0.3302734i,0.2473373+0.2051107i,0.3096158-0.02834217i,0.1945742-0.2293279i,-0.01861571-0.2907447i,-0.2076602-0.1926214i,-0.2770244+0.0009047404i,-0.2002651+0.1858402i,-0.02222804+0.2712581i,0.167727+0.2167596i,0.2748676+0.04699437i,0.2395568-0.1565898i,0.0691945-0.2873755i,-0.1542371-0.2647633i,-0.30637-0.08521605i},
    {-0.2934739-0.2245801i,-0.3743747+0.002988029i,-0.2962181+0.2362618i,-0.08719333+0.3727582i,0.1640909+0.3495624i,0.3480916+0.1739742i,0.384005-0.07945641i,0.2549077-0.3024524i,0.01382176-0.3994872i,-0.2389031-0.3269611i,-0.3960197-0.1111102i,-0.3867286+0.1607817i,-0.2076989+0.3734937i,0.07115846+0.4309603i,0.3318474+0.2995157i,0.4572234+0.02736648i,0.3835821-0.2715123i,0.1324826-0.4644552i,-0.1939499-0.4580661i,-0.4532046-0.2417069i,-0.5219359+0.1020519i,-0.3518507+0.4254583i,0.0002138911+0.5743589i,0.3840957+0.4586575i,0.6140856+0.1060033i,0.5568094-0.3321411i,-0.2720569-0.6403773i,-0.6465352-0.3078758i,-0.7036448+0.2053166i,-0.3935397+0.6334362i,0.132411+0.7420955i,0.5973552+0.4649355i,0.7532855-0.05330046i,0.5212407-0.5374275i,0.03182369-0.7373297i,-0.4550876-0.5630101i,-0.6968378-0.12172i,-0.5914067+0.3543433i,-0.2135093+0.6362993i,0.2414512+0.607342i,0.5610864+0.3025497i,0.6108193-0.1240439i,0.3828689-0.4763689i,-0.009928759-0.6007099i,-0.3862592-0.4480728i,-0.5750532-0.09411833i,-0.4924935+0.2934288i,-0.1832408+0.5317967i,0.19928+0.5122606i,0.4697403+0.2548501i,0.5059944-0.1045699i,0.3083864-0.3893776i},
    {-1.692488+0.126394i,-1.223524+1.129692i,-0.2578386+1.622122i,0.7933726+1.423171i,1.499913+0.6261744i,1.568322-0.4399803i,0.9581238-1.328021i,-0.0840627-1.646778i,-1.107907-1.236885i,-1.649608-0.2631196i,-1.450975+0.8418343i,-0.5931634+1.573085i,0.5345492+1.594677i,1.419667+0.8993139i,1.66733-0.1945556i,1.175021-1.197777i,0.1655178-1.671802i,-0.9204596-1.412841i,-1.612724-0.5296347i,-1.604125+0.6033454i,-0.8799917+1.495063i,0.2625095+1.739632i,1.323464+1.199131i,1.810884+0.08718367i,1.47194-1.102471i,0.43288-1.81182i,-1.740196-0.7636247i,-1.837074+0.5355642i,-1.069611+1.598289i,0.2068633+1.918543i,1.392671+1.341274i,1.930485+0.1359127i,1.568748-1.13317i,0.4779799-1.87354i,-0.8313793-1.742041i,-1.749241-0.8040293i,-1.851988+0.4992115i,-1.099993+1.560043i,0.1479777+1.891729i,1.310034+1.354548i,1.858239+0.2117815i,1.559916-1.006039i,0.5697514-1.753349i,-0.6586024-1.711735i,-1.583871-0.9149241i,-1.808124+0.2823635i,-1.234802+1.36069i,-0.1045232+1.848335i,1.097038+1.515211i,1.831539+0.4819504i,1.741015-0.8064347i,0.8301126-1.756241i},
    {-0.1052387+0.1086271i,0.0228637+0.1114768i,0.08341185+0.01908689i,0.03490866-0.06977332i,-0.06775781-0.06707861i,-0.1219321+0.03291459i,-0.06205785+0.149235i,0.0859898+0.1777624i,0.220969+0.07191835i,0.2376074-0.1194563i,0.1000818-0.2810387i,-0.1308712-0.3029646i,-0.3298967-0.1483471i,-0.3751503+0.1208186i,-0.2157419+0.3694716i,0.0926393+0.4538765i,0.4017807+0.2981214i,0.5362676-0.05136194i,0.388698-0.4275499i,-0.002186438-0.6167111i,-0.4453514-0.4793785i,-0.6876701-0.0509794i,-0.5625216+0.4515977i,-0.1064439+0.7412601i,0.4414442+0.6325794i,0.7711324+0.1648079i,0.228167-0.7740835i,-0.3557484-0.7268984i,-0.7508795-0.2987068i,-0.7550147+0.2784346i,-0.377167+0.7060244i,0.1829369+0.7753621i,0.6465304+0.4617049i,0.7909628-0.07696805i,0.547568-0.5800696i,0.03006876-0.8026954i,-0.5130795-0.6277252i,-0.8088543-0.1290308i,-0.6942931+0.4494058i,-0.2128722+0.8056828i,0.3898807+0.7403294i,0.7886955+0.2778257i,0.7614416-0.3329216i,0.3236037-0.7543426i,-0.2759008-0.7567138i,-0.7014539-0.3526122i,-0.7286783+0.2167875i,-0.3684849+0.6319801i,0.15549+0.6823692i,0.5507897+0.3744535i,0.6237887-0.09444585i,0.3721012-0.4645962i},
    {-0.533885+0.4274334i,-0.1364352+0.6417584i,0.2876572+0.5570737i,0.5461752+0.2370902i,0.540409-0.1500168i,0.3074812-0.4234382i,-0.01445351-0.4835252i,-0.2747562-0.3491008i,-0.3905696-0.1189185i,-0.3657215+0.1051194i,-0.2481258+0.2694637i,-0.07658931+0.3614901i,0.1302032+0.3683099i,0.3391481+0.2586385i,0.4717759+0.01727568i,0.4283814-0.2989926i,0.1650003-0.549174i,-0.2389424-0.5745224i,-0.5914934-0.3080507i,-0.6890483+0.1556971i,-0.4445313+0.5922686i,0.0466025+0.7682664i,0.5493159+0.5744957i,0.8126784+0.088413i,0.6982433-0.465454i,0.2455003-0.8257899i,-0.8122919-0.4166369i,-0.9199014+0.2070788i,-0.5905951+0.7762363i,0.05360417+1.007791i,0.7198095+0.7548748i,1.070387+0.1029952i,0.8980306-0.6430956i,0.2560809-1.100028i,-0.5448719-1.011699i,-1.0913-0.4021224i,-1.091736+0.4241274i,-0.5399041+1.042617i,0.2817419+1.138162i,0.956854+0.6690001i,1.154022-0.1217045i,0.7881206-0.8408095i,0.0485983-1.143583i,-0.7036974-0.8939627i,-1.110537-0.219178i,-0.9810104+0.5551364i,-0.3791087+1.056812i,0.4032902+1.042387i,0.9823912+0.5185459i,1.071489-0.253733i,0.6304621-0.8861567i,-0.1093628-1.063843i},
    {0.5313425-0.007002186i,0.3716407-0.3259988i,0.07225146-0.4513791i,-0.2077361-0.3669015i,-0.3589802-0.1526801i,-0.3551435+0.08351269i,-0.2300487+0.2607612i,-0.03840723+0.3375653i,0.1632368+0.2986638i,0.3140422+0.1492907i,0.3518815-0.07183224i,0.2411161-0.2830072i,0.009900022-0.3830741i,-0.2418385-0.3077957i,-0.3868771-0.08063233i,-0.3461389+0.1877046i,-0.1410668+0.3604163i,0.1186634+0.3562959i,0.3041828+0.1932326i,0.3415427-0.03471243i,0.2394614-0.2222868i,0.06152498-0.3074354i,-0.1219745-0.281321i,-0.2605312-0.1646999i,-0.3188006+0.0124865i,-0.2672938+0.2069878i,0.1513842+0.3607186i,0.3712213+0.1963824i,0.4367009-0.09604534i,0.281021-0.3779858i,-0.04101082-0.488624i,-0.3658083-0.3472422i,-0.5125163-0.01538499i,-0.3948426+0.3314301i,-0.07551891+0.5074841i,0.2736522+0.4258905i,0.4755353+0.1413681i,0.4436663-0.1937598i,0.2135923-0.4209023i,-0.09543611-0.4515476i,-0.3490853-0.2910399i,-0.4521371-0.01577176i,-0.3707645+0.2658869i,-0.1332546+0.4468216i,0.1766672+0.4484837i,0.435797+0.2501831i,0.5192893-0.08595002i,0.3601845-0.4184482i,0.002620752-0.5783738i,-0.3938783-0.4577421i,-0.6215794-0.08609178i,-0.5383189+0.3613749i},
    {0.6822965-0.4931397i,0.1779041-0.8053133i,-0.3879458-0.7022617i,-0.7286-0.2671352i,-0.701557+0.2592786i,-0.3590656+0.6245418i,0.1127627+0.6867768i,0.5033322+0.4527289i,0.6638232+0.04166139i,0.5432999-0.3765745i,0.1912055-0.6359982i,-0.2548221-0.6224428i,-0.6030535-0.3226018i,-0.6799077+0.1455236i,-0.4247122+0.5615197i,0.05196839+0.705938i,0.5062138+0.4906363i,0.6937808+0.02648984i,0.5187261-0.4324359i,0.09306954-0.6415427i,-0.3381355-0.5122559i,-0.5528318-0.1515514i,-0.4779085+0.2253387i,-0.2043066+0.4360024i,0.1003699+0.4235936i,0.3022527+0.2510081i,0.2884191-0.1631719i,0.1465446-0.2805971i,-0.02847956-0.3112842i,-0.1982719-0.2478674i,-0.3139832-0.0953992i,-0.3243039+0.1089736i,-0.2055801+0.2923704i,0.01167841+0.3728722i,0.2451828+0.3018456i,0.3942692+0.09368881i,0.3850714-0.1745639i,0.2050532-0.391679i,-0.08556252-0.4555821i,-0.3690782-0.3178483i,-0.512049-0.01518863i,-0.4256522+0.3296605i,-0.1211364+0.5513233i,0.2749363+0.52157i,0.5692456+0.2272297i,0.5998625-0.204797i,0.3306133-0.562114i,-0.1184847-0.6572328i,-0.5282522-0.4303705i,-0.6933069+0.01607425i,-0.5264355+0.4690763i,-0.1001193+0.7101247i},
    {-0.4312756+1.817382i,0.8803986+1.636756i,1.724692+0.6323407i,1.679887-0.6560348i,0.8100643-1.561509i,-0.3987221-1.658861i,-1.33346-0.9673729i,-1.582763+0.1128955i,-1.107126+1.053899i,-0.1907825+1.464631i,0.742377+1.229183i,1.317981+0.4953566i,1.328561-0.4215023i,0.7794563-1.153504i,-0.11302-1.395381i,-0.9769837-1.020715i,-1.416752-0.1657793i,-1.19982+0.7890507i,-0.4043218+1.380089i,0.5868476+1.304073i,1.276884+0.5990953i,1.329448-0.3670056i,0.752091-1.105786i,-0.1289407-1.280614i,-0.8740259-0.8679423i,-1.168985-0.1226397i,-0.3768667+1.009437i,0.2943526+1.00163i,0.8167368+0.6177921i,1.017782+0.01112003i,0.8271154-0.6027282i,0.2999242-0.9932858i,-0.3750416-0.9877316i,-0.9213431-0.5573462i,-1.087038+0.1375615i,-0.7748236+0.7971416i,-0.1077074+1.119045i,0.6203695+0.9492323i,1.084747+0.3581803i,1.080825-0.3965331i,0.6086087-0.990778i,-0.1366482-1.170697i,-0.8469372-0.8501726i,-1.218758-0.1445731i,-1.071102+0.6634749i,-0.431418+1.222941i,0.4490806+1.258632i,1.179894+0.7098495i,1.401598-0.2101924i,0.9692968-1.086846i,0.04825169-1.492773i,-0.9438803-1.203031i},
    {0.004463258+0.1503739i,0.07185376+0.1352975i,0.1432158+0.09129345i,0.1939686-0.004164081i,0.1731611-0.1366499i,0.05333225-0.240598i,-0.1270232-0.2380874i,-0.2715529-0.1015965i,-0.2851893+0.1116868i,-0.1419365+0.2854233i,0.0895022+0.3149945i,0.2826+0.1752645i,0.3286355-0.0607966i,0.2017908-0.2645705i,-0.02689948-0.3272878i,-0.2332495-0.221173i,-0.3120128-0.01047772i,-0.232964+0.1905963i,-0.04972902+0.2839791i,0.138625+0.237096i,0.2448784+0.08950396i,0.2341403-0.07972942i,0.1284769-0.1972669i,-0.01709799-0.2251842i,-0.1445881-0.1648717i,-0.2113404-0.04506567i,-0.1017429+0.1930725i,0.0393909+0.2181396i,0.1696338+0.1477908i,0.2268427+0.007129216i,0.1789916-0.138911i,0.0483372-0.217868i,-0.09784889-0.1931546i,-0.1883594-0.0858845i,-0.1908914+0.04342726i,-0.1230477+0.1380231i,-0.02605036+0.175743i,0.06986186+0.1636201i,0.1535178+0.1097468i,0.2104676+0.00983988i,0.2035754-0.1309489i,0.0923823-0.2641758i,-0.1140042-0.300279i,-0.3222236-0.1682156i,-0.390383+0.1063164i,-0.2288274+0.3789868i,0.1081896+0.4638402i,0.4266382+0.2684612i,0.5119713-0.1164829i,0.2852067-0.4567473i,-0.1254243-0.5292021i,-0.4621684-0.2811735i},
    {-0.09169428+0.4087445i,0.2305795+0.3933809i,0.4677439+0.1377098i,0.4575216-0.2319213i,0.1807695-0.4997973i,-0.2137536-0.4991322i,-0.500081-0.2230421i,-0.5181391+0.1716247i,-0.268252+0.4672742i,0.1032185+0.5178734i,0.4041805+0.3202656i,0.5041004-0.009580765i,0.3815137-0.3174364i,0.1043707-0.4834366i,-0.2163251-0.4517241i,-0.4615841-0.2302632i,-0.5273625+0.1109756i,-0.3575585+0.4418793i,0.0104177+0.6019794i,0.4245655+0.4753984i,0.6673921+0.07898741i,0.5745189-0.4069877i,0.1543323-0.7153794i,-0.3846294-0.6487265i,-0.7394165-0.2159936i,-0.6955715+0.3526635i,0.3075437+0.7160992i,0.70508+0.309672i,0.7138413-0.2481763i,0.3478993-0.6499819i,-0.1763642-0.6934212i,-0.57621-0.3823567i,-0.6592263+0.09645793i,-0.412062+0.4902623i,0.01439325+0.6145256i,0.3983951+0.4344051i,0.5612274+0.06353541i,0.4460574-0.3058195i,0.131779-0.500235i,-0.2164581-0.4440297i,-0.432164-0.1862149i,-0.4265106+0.1332007i,-0.2242867+0.3580867i,0.05843255+0.3932369i,0.2799936+0.244684i,0.3453345+0.005465522i,0.2468041-0.2007918i,0.05590868-0.2847699i,-0.1238516-0.2302914i,-0.2136836-0.09031728i,-0.1948971+0.05228702i,-0.1066898+0.1339113i},
    {-0.2370669+0.7960226i,0.3377185+0.757282i,0.7424639+0.3564105i,0.7904058-0.2016896i,0.4761061-0.6525848i,-0.04346845-0.8007187i,-0.5358697-0.5937049i,-0.7924755-0.1268025i,-0.7034525+0.4026522i,-0.2970443+0.7677318i,0.2621809+0.7972977i,0.7262337+0.4553971i,0.8666506-0.1214505i,0.5920579-0.6662986i,0.01496976-0.9043132i,-0.5862911-0.7003301i,-0.9059837-0.1442329i,-0.7767044+0.4861185i,-0.2640474+0.8709093i,0.3681879+0.8201296i,0.8015695+0.3715956i,0.8308885-0.2374832i,0.4630128-0.7026015i,-0.1007447-0.8095926i,-0.5794285-0.5336671i,-0.7567241-0.03493281i,-0.1635609+0.6728989i,0.279939+0.5966072i,0.5597262+0.2812286i,0.5858529-0.1116009i,0.3862213-0.4208699i,0.06373487-0.5498247i,-0.2628056-0.4782421i,-0.4940799-0.2403894i,-0.5570362+0.09483783i,-0.4104258+0.4254372i,-0.07181222+0.6209611i,0.3501563+0.5637332i,0.6660985+0.2257093i,0.6890917-0.272252i,0.3572527-0.6863365i,-0.1925285-0.7760302i,-0.6745266-0.4604626i,-0.8169783+0.10871i,-0.5339298+0.6244416i,0.01669295+0.8090602i,0.532958+0.5805876i,0.7549424+0.08742491i,0.6063219-0.4017708i,0.205157-0.6624088i,-0.2380554-0.6178023i,-0.5427188-0.33398i},
    {0.4787242+0.634404i,0.8302208+0.12137i,0.7067599-0.5196002i,0.1434557-0.896788i,-0.5393613-0.7591098i,-0.9306494-0.168964i,-0.7913148+0.5295355i,-0.2047224+0.9282476i,0.4845662+0.8078968i,0.8917766+0.257459i,0.8163806-0.4040187i,0.3310562-0.8287612i,-0.2935109-0.8246498i,-0.750138-0.4244601i,-0.8381541+0.1639966i,-0.5309726+0.6674019i,0.02954744+0.8578752i,0.58968+0.6392289i,0.8797265+0.09574473i,0.7356292-0.5216308i,0.2008411-0.8956074i,-0.4627964-0.8075258i,-0.8958001-0.2799069i,-0.8462235+0.408572i,-0.3329347+0.8719655i,0.3524464+0.8489078i,0.8189511-0.2887665i,0.3825448-0.7405851i,-0.2151359-0.7645599i,-0.6410274-0.3934334i,-0.6962345+0.1336913i,-0.401715+0.5317121i,0.05088056+0.6238641i,0.4244486+0.4077873i,0.5543605+0.02414567i,0.4083227-0.3294983i,0.08197442-0.4905184i,-0.2534828-0.3977984i,-0.4313622-0.115398i,-0.3707611+0.1985755i,-0.1211208+0.3737395i,0.1631251+0.3240198i,0.3145143+0.1001941i,0.2580112-0.1433828i,0.05711327-0.2525432i,-0.1356484-0.1768922i,-0.1897232+0.002036833i,-0.08736978+0.1380365i,0.07168391+0.1307536i,0.1512288-0.003277652i,0.08172798-0.1483493i,-0.0892512-0.1779614i},
    {0.8556781+0.1230295i,0.7571583-0.4025707i,0.3800749-0.7838485i,-0.1693979-0.8879528i,-0.7116165-0.6318629i,-1.006951-0.05176961i,-0.8559472+0.6383854i,-0.2490427+1.096974i,0.5578807+1.034555i,1.142231+0.4179597i,1.157229-0.4612701i,0.5601062-1.132006i,-0.3409091-1.221383i,-1.062852-0.6802108i,-1.230844+0.193518i,-0.7827978+0.9387895i,0.02184138+1.193097i,0.7696719+0.8695545i,1.116285+0.1656208i,0.9382517-0.568433i,0.3565762-1.00702i,-0.348221-0.9834752i,-0.8696515-0.5378227i,-0.9987737+0.1203606i,-0.6980238+0.7070907i,-0.1063032+0.9793323i,0.9241173+0.3246949i,0.9282335-0.3219776i,0.5279766-0.8366579i,-0.1141996-0.9931291i,-0.7241599-0.7080557i,-1.0236-0.0884572i,-0.8549693+0.5952814i,-0.2725144+1.017985i,0.4574195+0.9576377i,0.9727198+0.4260814i,1.005929-0.314565i,0.541708-0.8830559i,-0.1665933-0.9934342i,-0.7451543-0.6182158i,-0.9199859+0.01035702i,-0.6607668+0.5588742i,-0.157715+0.7929605i,0.3302224+0.6789941i,0.626702+0.3383787i,0.683674-0.07245205i,0.5268478-0.440009i,0.194822-0.6829363i,-0.2522534-0.7116316i,-0.6792168-0.4484989i,-0.8755217+0.0791875i,-0.6662055+0.6679755i},
};
# 2 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp" 2
# 1 "D:/Softwares/Xilinx/Vivado/Vivado/2019.1/msys64/mingw64/include/c++/6.2.0/math.h" 1 3
# 3 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp" 2

#ifndef HLS_FASTSIM
#ifndef HLS_FASTSIM
#include "apatb_DNN_u.h"
#endif
# 4 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
int main() {

 float nrm = 0;
 float phf = 0;
 float errNorm;

 for(int i=0; i<200; i++) {

  hls::stream<axis_data> LS_stream;
  hls::stream<axis_data> DNN_out;

  COMPLEXD DNNOut[52];
  COMPLEXD GoldRef[52];


  COMPLEXD lsOut[52];
  for(int j=0; j<52; j++) {
   COMPLEXD z_pre(preamble[i][j]);
   COMPLEXD z_train(train_sym[j]);
   lsOut[j] = z_pre/z_train;
  }


  for(int j=0; j<52; j++) {
   axis_data local_write;
   local_write.data = lsOut[j];
   local_write.last = (j==52 -1)?1:0;
   LS_stream.write(local_write);
  }



  
#ifndef HLS_FASTSIM
#define DNN_u AESL_WRAP_DNN_u
#endif
# 36 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
DNN_u(LS_stream, DNN_out);
#undef DNN_u
# 36 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"

# 52 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"
  for(int j=0; j<52; j++) {
   axis_data local_read = DNN_out.read();
   DNNOut[j] = local_read.data;

  } std::cout << std::endl;


  for(int j=0; j<52; j++) {
   COMPLEXD z(actin[i][j]);
   GoldRef[j] = z;
  }


  COMPLEXD diff;
  float d;
  for(int j=0; j<52; j++) {
   diff = DNNOut[j] - GoldRef[j];
   d = pow(norm(diff), 2);
   nrm += d;
   d = pow(norm(GoldRef[j]), 2);
   phf += d;
  }

 }

 nrm = sqrt(nrm)/200;
 phf = sqrt(phf)/200;
 errNorm = nrm/phf;

 printf("Normalized error: %lf\n", errNorm);

 if(errNorm > 1e-5) {
  printf("FAILED\n");
  return -1;
 }

 printf("SUCCESS\n");

 return 0;
}
#endif
# 91 "D:/IIIT-D/Channel_Estimation/HLS/dnn/dnn_tb.cpp"

